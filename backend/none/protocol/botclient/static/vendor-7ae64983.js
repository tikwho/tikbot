function makeMap(K, C) {
    const H = Object.create(null),
        W = K.split(",");
    for (let U = 0; U < W.length; U++) H[W[U]] = !0;
    return C ? U => !!H[U.toLowerCase()] : U => !!H[U]
}

function normalizeStyle(K) {
    if (isArray$4(K)) {
        const C = {};
        for (let H = 0; H < K.length; H++) {
            const W = K[H],
                U = isString$3(W) ? parseStringStyle(W) : normalizeStyle(W);
            if (U)
                for (const G in U) C[G] = U[G]
        }
        return C
    } else {
        if (isString$3(K)) return K;
        if (isObject$4(K)) return K
    }
}
const listDelimiterRE = /;(?![^(]*\))/g,
    propertyDelimiterRE = /:([^]+)/,
    styleCommentRE = /\/\*.*?\*\//gs;

function parseStringStyle(K) {
    const C = {};
    return K.replace(styleCommentRE, "").split(listDelimiterRE).forEach(H => {
        if (H) {
            const W = H.split(propertyDelimiterRE);
            W.length > 1 && (C[W[0].trim()] = W[1].trim())
        }
    }), C
}

function normalizeClass(K) {
    let C = "";
    if (isString$3(K)) C = K;
    else if (isArray$4(K))
        for (let H = 0; H < K.length; H++) {
            const W = normalizeClass(K[H]);
            W && (C += W + " ")
        } else if (isObject$4(K))
            for (const H in K) K[H] && (C += H + " ");
    return C.trim()
}
const specialBooleanAttrs = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
    isSpecialBooleanAttr = makeMap(specialBooleanAttrs);

function includeBooleanAttr(K) {
    return !!K || K === ""
}
const toDisplayString = K => isString$3(K) ? K : K == null ? "" : isArray$4(K) || isObject$4(K) && (K.toString ===
        objectToString$1 || !isFunction$3(K.toString)) ? JSON.stringify(K, replacer, 2) : String(K),
    replacer = (K, C) => C && C.__v_isRef ? replacer(K, C.value) : isMap$2(C) ? {
        [`Map(${C.size})`]: [...C.entries()].reduce((H, [W, U]) => (H[`${W} =>`] = U, H), {})
    } : isSet$2(C) ? {
        [`Set(${C.size})`]: [...C.values()]
    } : isObject$4(C) && !isArray$4(C) && !isPlainObject$1(C) ? String(C) : C,
    EMPTY_OBJ = {},
    EMPTY_ARR = [],
    NOOP = () => {},
    NO = () => !1,
    onRE$1 = /^on[^a-z]/,
    isOn$1 = K => onRE$1.test(K),
    isModelListener = K => K.startsWith("onUpdate:"),
    extend$1 = Object.assign,
    remove = (K, C) => {
        const H = K.indexOf(C);
        H > -1 && K.splice(H, 1)
    },
    hasOwnProperty$f = Object.prototype.hasOwnProperty,
    hasOwn$1 = (K, C) => hasOwnProperty$f.call(K, C),
    isArray$4 = Array.isArray,
    isMap$2 = K => toTypeString(K) === "[object Map]",
    isSet$2 = K => toTypeString(K) === "[object Set]",
    isFunction$3 = K => typeof K == "function",
    isString$3 = K => typeof K == "string",
    isSymbol$1 = K => typeof K == "symbol",
    isObject$4 = K => K !== null && typeof K == "object",
    isPromise = K => isObject$4(K) && isFunction$3(K.then) && isFunction$3(K.catch),
    objectToString$1 = Object.prototype.toString,
    toTypeString = K => objectToString$1.call(K),
    toRawType = K => toTypeString(K).slice(8, -1),
    isPlainObject$1 = K => toTypeString(K) === "[object Object]",
    isIntegerKey = K => isString$3(K) && K !== "NaN" && K[0] !== "-" && "" + parseInt(K, 10) === K,
    isReservedProp = makeMap(
        ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    ),
    cacheStringFunction$1 = K => {
        const C = Object.create(null);
        return H => C[H] || (C[H] = K(H))
    },
    camelizeRE$1 = /-(\w)/g,
    camelize$1 = cacheStringFunction$1(K => K.replace(camelizeRE$1, (C, H) => H ? H.toUpperCase() : "")),
    hyphenateRE$1 = /\B([A-Z])/g,
    hyphenate$1 = cacheStringFunction$1(K => K.replace(hyphenateRE$1, "-$1").toLowerCase()),
    capitalize = cacheStringFunction$1(K => K.charAt(0).toUpperCase() + K.slice(1)),
    toHandlerKey = cacheStringFunction$1(K => K ? `on${capitalize(K)}` : ""),
    hasChanged = (K, C) => !Object.is(K, C),
    invokeArrayFns = (K, C) => {
        for (let H = 0; H < K.length; H++) K[H](C)
    },
    def = (K, C, H) => {
        Object.defineProperty(K, C, {
            configurable: !0,
            enumerable: !1,
            value: H
        })
    },
    looseToNumber = K => {
        const C = parseFloat(K);
        return isNaN(C) ? K : C
    },
    toNumber$1 = K => {
        const C = isString$3(K) ? Number(K) : NaN;
        return isNaN(C) ? K : C
    };
let _globalThis;
const getGlobalThis = () => _globalThis || (_globalThis = typeof globalThis < "u" ? globalThis : typeof self < "u" ?
    self : typeof window < "u" ? window : typeof global < "u" ? global : {});
let activeEffectScope;
class EffectScope {
    constructor(C = !1) {
        this.detached = C, this._active = !0, this.effects = [], this.cleanups = [], this.parent =
            activeEffectScope, !C && activeEffectScope && (this.index = (activeEffectScope.scopes || (
                activeEffectScope.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    run(C) {
        if (this._active) {
            const H = activeEffectScope;
            try {
                return activeEffectScope = this, C()
            } finally {
                activeEffectScope = H
            }
        }
    }
    on() {
        activeEffectScope = this
    }
    off() {
        activeEffectScope = this.parent
    }
    stop(C) {
        if (this._active) {
            let H, W;
            for (H = 0, W = this.effects.length; H < W; H++) this.effects[H].stop();
            for (H = 0, W = this.cleanups.length; H < W; H++) this.cleanups[H]();
            if (this.scopes)
                for (H = 0, W = this.scopes.length; H < W; H++) this.scopes[H].stop(!0);
            if (!this.detached && this.parent && !C) {
                const U = this.parent.scopes.pop();
                U && U !== this && (this.parent.scopes[this.index] = U, U.index = this.index)
            }
            this.parent = void 0, this._active = !1
        }
    }
}

function recordEffectScope(K, C = activeEffectScope) {
    C && C.active && C.effects.push(K)
}

function getCurrentScope() {
    return activeEffectScope
}

function onScopeDispose(K) {
    activeEffectScope && activeEffectScope.cleanups.push(K)
}
const createDep = K => {
        const C = new Set(K);
        return C.w = 0, C.n = 0, C
    },
    wasTracked = K => (K.w & trackOpBit) > 0,
    newTracked = K => (K.n & trackOpBit) > 0,
    initDepMarkers = ({
        deps: K
    }) => {
        if (K.length)
            for (let C = 0; C < K.length; C++) K[C].w |= trackOpBit
    },
    finalizeDepMarkers = K => {
        const {
            deps: C
        } = K;
        if (C.length) {
            let H = 0;
            for (let W = 0; W < C.length; W++) {
                const U = C[W];
                wasTracked(U) && !newTracked(U) ? U.delete(K) : C[H++] = U, U.w &= ~trackOpBit, U.n &= ~trackOpBit
            }
            C.length = H
        }
    },
    targetMap = new WeakMap;
let effectTrackDepth = 0,
    trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol(""),
    MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
    constructor(C, H = null, W) {
        this.fn = C, this.scheduler = H, this.active = !0, this.deps = [], this.parent = void 0, recordEffectScope(
            this, W)
    }
    run() {
        if (!this.active) return this.fn();
        let C = activeEffect,
            H = shouldTrack;
        for (; C;) {
            if (C === this) return;
            C = C.parent
        }
        try {
            return this.parent = activeEffect, activeEffect = this, shouldTrack = !0, trackOpBit = 1 << ++
                effectTrackDepth, effectTrackDepth <= maxMarkerBits ? initDepMarkers(this) : cleanupEffect(this),
                this.fn()
        } finally {
            effectTrackDepth <= maxMarkerBits && finalizeDepMarkers(this), trackOpBit = 1 << --effectTrackDepth,
                activeEffect = this.parent, shouldTrack = H, this.parent = void 0, this.deferStop && this.stop()
        }
    }
    stop() {
        activeEffect === this ? this.deferStop = !0 : this.active && (cleanupEffect(this), this.onStop && this.onStop(),
            this.active = !1)
    }
}

function cleanupEffect(K) {
    const {
        deps: C
    } = K;
    if (C.length) {
        for (let H = 0; H < C.length; H++) C[H].delete(K);
        C.length = 0
    }
}
let shouldTrack = !0;
const trackStack = [];

function pauseTracking() {
    trackStack.push(shouldTrack), shouldTrack = !1
}

function resetTracking() {
    const K = trackStack.pop();
    shouldTrack = K === void 0 ? !0 : K
}

function track(K, C, H) {
    if (shouldTrack && activeEffect) {
        let W = targetMap.get(K);
        W || targetMap.set(K, W = new Map);
        let U = W.get(H);
        U || W.set(H, U = createDep()), trackEffects(U)
    }
}

function trackEffects(K, C) {
    let H = !1;
    effectTrackDepth <= maxMarkerBits ? newTracked(K) || (K.n |= trackOpBit, H = !wasTracked(K)) : H = !K.has(
        activeEffect), H && (K.add(activeEffect), activeEffect.deps.push(K))
}

function trigger$1(K, C, H, W, U, G) {
    const X = targetMap.get(K);
    if (!X) return;
    let Z = [];
    if (C === "clear") Z = [...X.values()];
    else if (H === "length" && isArray$4(K)) {
        const Q = Number(W);
        X.forEach((ee, ne) => {
            (ne === "length" || ne >= Q) && Z.push(ee)
        })
    } else switch (H !== void 0 && Z.push(X.get(H)), C) {
        case "add":
            isArray$4(K) ? isIntegerKey(H) && Z.push(X.get("length")) : (Z.push(X.get(ITERATE_KEY)), isMap$2(K) &&
                Z.push(X.get(MAP_KEY_ITERATE_KEY)));
            break;
        case "delete":
            isArray$4(K) || (Z.push(X.get(ITERATE_KEY)), isMap$2(K) && Z.push(X.get(MAP_KEY_ITERATE_KEY)));
            break;
        case "set":
            isMap$2(K) && Z.push(X.get(ITERATE_KEY));
            break
    }
    if (Z.length === 1) Z[0] && triggerEffects(Z[0]);
    else {
        const Q = [];
        for (const ee of Z) ee && Q.push(...ee);
        triggerEffects(createDep(Q))
    }
}

function triggerEffects(K, C) {
    const H = isArray$4(K) ? K : [...K];
    for (const W of H) W.computed && triggerEffect(W);
    for (const W of H) W.computed || triggerEffect(W)
}

function triggerEffect(K, C) {
    (K !== activeEffect || K.allowRecurse) && (K.scheduler ? K.scheduler() : K.run())
}

function getDepFromReactive(K, C) {
    var H;
    return (H = targetMap.get(K)) === null || H === void 0 ? void 0 : H.get(C)
}
const isNonTrackableKeys = makeMap("__proto__,__v_isRef,__isVue"),
    builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).filter(K => K !== "arguments" && K !== "caller").map(K =>
        Symbol[K]).filter(isSymbol$1)),
    get$1$1 = createGetter(),
    shallowGet = createGetter(!1, !0),
    readonlyGet = createGetter(!0),
    arrayInstrumentations = createArrayInstrumentations();

function createArrayInstrumentations() {
    const K = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(C => {
        K[C] = function (...H) {
            const W = toRaw(this);
            for (let G = 0, X = this.length; G < X; G++) track(W, "get", G + "");
            const U = W[C](...H);
            return U === -1 || U === !1 ? W[C](...H.map(toRaw)) : U
        }
    }), ["push", "pop", "shift", "unshift", "splice"].forEach(C => {
        K[C] = function (...H) {
            pauseTracking();
            const W = toRaw(this)[C].apply(this, H);
            return resetTracking(), W
        }
    }), K
}

function hasOwnProperty$e(K) {
    const C = toRaw(this);
    return track(C, "has", K), C.hasOwnProperty(K)
}

function createGetter(K = !1, C = !1) {
    return function (W, U, G) {
        if (U === "__v_isReactive") return !K;
        if (U === "__v_isReadonly") return K;
        if (U === "__v_isShallow") return C;
        if (U === "__v_raw" && G === (K ? C ? shallowReadonlyMap : readonlyMap : C ? shallowReactiveMap :
                reactiveMap).get(W)) return W;
        const X = isArray$4(W);
        if (!K) {
            if (X && hasOwn$1(arrayInstrumentations, U)) return Reflect.get(arrayInstrumentations, U, G);
            if (U === "hasOwnProperty") return hasOwnProperty$e
        }
        const Z = Reflect.get(W, U, G);
        return (isSymbol$1(U) ? builtInSymbols.has(U) : isNonTrackableKeys(U)) || (K || track(W, "get", U), C) ? Z :
            isRef(Z) ? X && isIntegerKey(U) ? Z : Z.value : isObject$4(Z) ? K ? readonly(Z) : reactive(Z) : Z
    }
}
const set$1$1 = createSetter(),
    shallowSet = createSetter(!0);

function createSetter(K = !1) {
    return function (H, W, U, G) {
        let X = H[W];
        if (isReadonly(X) && isRef(X) && !isRef(U)) return !1;
        if (!K && (!isShallow(U) && !isReadonly(U) && (X = toRaw(X), U = toRaw(U)), !isArray$4(H) && isRef(X) && !
                isRef(U))) return X.value = U, !0;
        const Z = isArray$4(H) && isIntegerKey(W) ? Number(W) < H.length : hasOwn$1(H, W),
            Q = Reflect.set(H, W, U, G);
        return H === toRaw(G) && (Z ? hasChanged(U, X) && trigger$1(H, "set", W, U) : trigger$1(H, "add", W, U)), Q
    }
}

function deleteProperty(K, C) {
    const H = hasOwn$1(K, C);
    K[C];
    const W = Reflect.deleteProperty(K, C);
    return W && H && trigger$1(K, "delete", C, void 0), W
}

function has$1(K, C) {
    const H = Reflect.has(K, C);
    return (!isSymbol$1(C) || !builtInSymbols.has(C)) && track(K, "has", C), H
}

function ownKeys$2(K) {
    return track(K, "iterate", isArray$4(K) ? "length" : ITERATE_KEY), Reflect.ownKeys(K)
}
const mutableHandlers = {
        get: get$1$1,
        set: set$1$1,
        deleteProperty,
        has: has$1,
        ownKeys: ownKeys$2
    },
    readonlyHandlers = {
        get: readonlyGet,
        set(K, C) {
            return !0
        },
        deleteProperty(K, C) {
            return !0
        }
    },
    shallowReactiveHandlers = extend$1({}, mutableHandlers, {
        get: shallowGet,
        set: shallowSet
    }),
    toShallow = K => K,
    getProto = K => Reflect.getPrototypeOf(K);

function get$5(K, C, H = !1, W = !1) {
    K = K.__v_raw;
    const U = toRaw(K),
        G = toRaw(C);
    H || (C !== G && track(U, "get", C), track(U, "get", G));
    const {
        has: X
    } = getProto(U), Z = W ? toShallow : H ? toReadonly : toReactive$1;
    if (X.call(U, C)) return Z(K.get(C));
    if (X.call(U, G)) return Z(K.get(G));
    K !== U && K.get(C)
}

function has(K, C = !1) {
    const H = this.__v_raw,
        W = toRaw(H),
        U = toRaw(K);
    return C || (K !== U && track(W, "has", K), track(W, "has", U)), K === U ? H.has(K) : H.has(K) || H.has(U)
}

function size(K, C = !1) {
    return K = K.__v_raw, !C && track(toRaw(K), "iterate", ITERATE_KEY), Reflect.get(K, "size", K)
}

function add$2(K) {
    K = toRaw(K);
    const C = toRaw(this);
    return getProto(C).has.call(C, K) || (C.add(K), trigger$1(C, "add", K, K)), this
}

function set$3(K, C) {
    C = toRaw(C);
    const H = toRaw(this),
        {
            has: W,
            get: U
        } = getProto(H);
    let G = W.call(H, K);
    G || (K = toRaw(K), G = W.call(H, K));
    const X = U.call(H, K);
    return H.set(K, C), G ? hasChanged(C, X) && trigger$1(H, "set", K, C) : trigger$1(H, "add", K, C), this
}

function deleteEntry(K) {
    const C = toRaw(this),
        {
            has: H,
            get: W
        } = getProto(C);
    let U = H.call(C, K);
    U || (K = toRaw(K), U = H.call(C, K)), W && W.call(C, K);
    const G = C.delete(K);
    return U && trigger$1(C, "delete", K, void 0), G
}

function clear() {
    const K = toRaw(this),
        C = K.size !== 0,
        H = K.clear();
    return C && trigger$1(K, "clear", void 0, void 0), H
}

function createForEach(K, C) {
    return function (W, U) {
        const G = this,
            X = G.__v_raw,
            Z = toRaw(X),
            Q = C ? toShallow : K ? toReadonly : toReactive$1;
        return !K && track(Z, "iterate", ITERATE_KEY), X.forEach((ee, ne) => W.call(U, Q(ee), Q(ne), G))
    }
}

function createIterableMethod(K, C, H) {
    return function (...W) {
        const U = this.__v_raw,
            G = toRaw(U),
            X = isMap$2(G),
            Z = K === "entries" || K === Symbol.iterator && X,
            Q = K === "keys" && X,
            ee = U[K](...W),
            ne = H ? toShallow : C ? toReadonly : toReactive$1;
        return !C && track(G, "iterate", Q ? MAP_KEY_ITERATE_KEY : ITERATE_KEY), {
            next() {
                const {
                    value: te,
                    done: re
                } = ee.next();
                return re ? {
                    value: te,
                    done: re
                } : {
                    value: Z ? [ne(te[0]), ne(te[1])] : ne(te),
                    done: re
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}

function createReadonlyMethod(K) {
    return function (...C) {
        return K === "delete" ? !1 : this
    }
}

function createInstrumentations() {
    const K = {
            get(G) {
                return get$5(this, G)
            },
            get size() {
                return size(this)
            },
            has,
            add: add$2,
            set: set$3,
            delete: deleteEntry,
            clear,
            forEach: createForEach(!1, !1)
        },
        C = {
            get(G) {
                return get$5(this, G, !1, !0)
            },
            get size() {
                return size(this)
            },
            has,
            add: add$2,
            set: set$3,
            delete: deleteEntry,
            clear,
            forEach: createForEach(!1, !0)
        },
        H = {
            get(G) {
                return get$5(this, G, !0)
            },
            get size() {
                return size(this, !0)
            },
            has(G) {
                return has.call(this, G, !0)
            },
            add: createReadonlyMethod("add"),
            set: createReadonlyMethod("set"),
            delete: createReadonlyMethod("delete"),
            clear: createReadonlyMethod("clear"),
            forEach: createForEach(!0, !1)
        },
        W = {
            get(G) {
                return get$5(this, G, !0, !0)
            },
            get size() {
                return size(this, !0)
            },
            has(G) {
                return has.call(this, G, !0)
            },
            add: createReadonlyMethod("add"),
            set: createReadonlyMethod("set"),
            delete: createReadonlyMethod("delete"),
            clear: createReadonlyMethod("clear"),
            forEach: createForEach(!0, !0)
        };
    return ["keys", "values", "entries", Symbol.iterator].forEach(G => {
        K[G] = createIterableMethod(G, !1, !1), H[G] = createIterableMethod(G, !0, !1), C[G] =
            createIterableMethod(G, !1, !0), W[G] = createIterableMethod(G, !0, !0)
    }), [K, H, C, W]
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] =
createInstrumentations();

function createInstrumentationGetter(K, C) {
    const H = C ? K ? shallowReadonlyInstrumentations : shallowInstrumentations : K ? readonlyInstrumentations :
        mutableInstrumentations;
    return (W, U, G) => U === "__v_isReactive" ? !K : U === "__v_isReadonly" ? K : U === "__v_raw" ? W : Reflect.get(
        hasOwn$1(H, U) && U in W ? H : W, U, G)
}
const mutableCollectionHandlers = {
        get: createInstrumentationGetter(!1, !1)
    },
    shallowCollectionHandlers = {
        get: createInstrumentationGetter(!1, !0)
    },
    readonlyCollectionHandlers = {
        get: createInstrumentationGetter(!0, !1)
    },
    reactiveMap = new WeakMap,
    shallowReactiveMap = new WeakMap,
    readonlyMap = new WeakMap,
    shallowReadonlyMap = new WeakMap;

function targetTypeMap(K) {
    switch (K) {
        case "Object":
        case "Array":
            return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2;
        default:
            return 0
    }
}

function getTargetType(K) {
    return K.__v_skip || !Object.isExtensible(K) ? 0 : targetTypeMap(toRawType(K))
}

function reactive(K) {
    return isReadonly(K) ? K : createReactiveObject(K, !1, mutableHandlers, mutableCollectionHandlers, reactiveMap)
}

function shallowReactive(K) {
    return createReactiveObject(K, !1, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap)
}

function readonly(K) {
    return createReactiveObject(K, !0, readonlyHandlers, readonlyCollectionHandlers, readonlyMap)
}

function createReactiveObject(K, C, H, W, U) {
    if (!isObject$4(K) || K.__v_raw && !(C && K.__v_isReactive)) return K;
    const G = U.get(K);
    if (G) return G;
    const X = getTargetType(K);
    if (X === 0) return K;
    const Z = new Proxy(K, X === 2 ? W : H);
    return U.set(K, Z), Z
}

function isReactive(K) {
    return isReadonly(K) ? isReactive(K.__v_raw) : !!(K && K.__v_isReactive)
}

function isReadonly(K) {
    return !!(K && K.__v_isReadonly)
}

function isShallow(K) {
    return !!(K && K.__v_isShallow)
}

function isProxy(K) {
    return isReactive(K) || isReadonly(K)
}

function toRaw(K) {
    const C = K && K.__v_raw;
    return C ? toRaw(C) : K
}

function markRaw(K) {
    return def(K, "__v_skip", !0), K
}
const toReactive$1 = K => isObject$4(K) ? reactive(K) : K,
    toReadonly = K => isObject$4(K) ? readonly(K) : K;

function trackRefValue(K) {
    shouldTrack && activeEffect && (K = toRaw(K), trackEffects(K.dep || (K.dep = createDep())))
}

function triggerRefValue(K, C) {
    K = toRaw(K);
    const H = K.dep;
    H && triggerEffects(H)
}

function isRef(K) {
    return !!(K && K.__v_isRef === !0)
}

function ref(K) {
    return createRef$1(K, !1)
}

function shallowRef(K) {
    return createRef$1(K, !0)
}

function createRef$1(K, C) {
    return isRef(K) ? K : new RefImpl(K, C)
}
class RefImpl {
    constructor(C, H) {
        this.__v_isShallow = H, this.dep = void 0, this.__v_isRef = !0, this._rawValue = H ? C : toRaw(C), this._value =
            H ? C : toReactive$1(C)
    }
    get value() {
        return trackRefValue(this), this._value
    }
    set value(C) {
        const H = this.__v_isShallow || isShallow(C) || isReadonly(C);
        C = H ? C : toRaw(C), hasChanged(C, this._rawValue) && (this._rawValue = C, this._value = H ? C :
            toReactive$1(C), triggerRefValue(this))
    }
}

function unref(K) {
    return isRef(K) ? K.value : K
}
const shallowUnwrapHandlers = {
    get: (K, C, H) => unref(Reflect.get(K, C, H)),
    set: (K, C, H, W) => {
        const U = K[C];
        return isRef(U) && !isRef(H) ? (U.value = H, !0) : Reflect.set(K, C, H, W)
    }
};

function proxyRefs(K) {
    return isReactive(K) ? K : new Proxy(K, shallowUnwrapHandlers)
}

function toRefs(K) {
    const C = isArray$4(K) ? new Array(K.length) : {};
    for (const H in K) C[H] = toRef(K, H);
    return C
}
class ObjectRefImpl {
    constructor(C, H, W) {
        this._object = C, this._key = H, this._defaultValue = W, this.__v_isRef = !0
    }
    get value() {
        const C = this._object[this._key];
        return C === void 0 ? this._defaultValue : C
    }
    set value(C) {
        this._object[this._key] = C
    }
    get dep() {
        return getDepFromReactive(toRaw(this._object), this._key)
    }
}

function toRef(K, C, H) {
    const W = K[C];
    return isRef(W) ? W : new ObjectRefImpl(K, C, H)
}
var _a$1;
class ComputedRefImpl {
    constructor(C, H, W, U) {
        this._setter = H, this.dep = void 0, this.__v_isRef = !0, this[_a$1] = !1, this._dirty = !0, this.effect =
            new ReactiveEffect(C, () => {
                this._dirty || (this._dirty = !0, triggerRefValue(this))
            }), this.effect.computed = this, this.effect.active = this._cacheable = !U, this.__v_isReadonly = W
    }
    get value() {
        const C = toRaw(this);
        return trackRefValue(C), (C._dirty || !C._cacheable) && (C._dirty = !1, C._value = C.effect.run()), C._value
    }
    set value(C) {
        this._setter(C)
    }
}
_a$1 = "__v_isReadonly";

function computed$1(K, C, H = !1) {
    let W, U;
    const G = isFunction$3(K);
    return G ? (W = K, U = NOOP) : (W = K.get, U = K.set), new ComputedRefImpl(W, U, G || !U, H)
}

function warn$1(K, ...C) {}

function callWithErrorHandling(K, C, H, W) {
    let U;
    try {
        U = W ? K(...W) : K()
    } catch (G) {
        handleError(G, C, H)
    }
    return U
}

function callWithAsyncErrorHandling(K, C, H, W) {
    if (isFunction$3(K)) {
        const G = callWithErrorHandling(K, C, H, W);
        return G && isPromise(G) && G.catch(X => {
            handleError(X, C, H)
        }), G
    }
    const U = [];
    for (let G = 0; G < K.length; G++) U.push(callWithAsyncErrorHandling(K[G], C, H, W));
    return U
}

function handleError(K, C, H, W = !0) {
    const U = C ? C.vnode : null;
    if (C) {
        let G = C.parent;
        const X = C.proxy,
            Z = H;
        for (; G;) {
            const ee = G.ec;
            if (ee) {
                for (let ne = 0; ne < ee.length; ne++)
                    if (ee[ne](K, X, Z) === !1) return
            }
            G = G.parent
        }
        const Q = C.appContext.config.errorHandler;
        if (Q) {
            callWithErrorHandling(Q, null, 10, [K, X, Z]);
            return
        }
    }
    logError(K, H, U, W)
}

function logError(K, C, H, W = !0) {
    console.error(K)
}
let isFlushing = !1,
    isFlushPending = !1;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null,
    postFlushIndex = 0;
const resolvedPromise = Promise.resolve();
let currentFlushPromise = null;

function nextTick(K) {
    const C = currentFlushPromise || resolvedPromise;
    return K ? C.then(this ? K.bind(this) : K) : C
}

function findInsertionIndex(K) {
    let C = flushIndex + 1,
        H = queue.length;
    for (; C < H;) {
        const W = C + H >>> 1;
        getId(queue[W]) < K ? C = W + 1 : H = W
    }
    return C
}

function queueJob(K) {
    (!queue.length || !queue.includes(K, isFlushing && K.allowRecurse ? flushIndex + 1 : flushIndex)) && (K.id == null ?
        queue.push(K) : queue.splice(findInsertionIndex(K.id), 0, K), queueFlush())
}

function queueFlush() {
    !isFlushing && !isFlushPending && (isFlushPending = !0, currentFlushPromise = resolvedPromise.then(flushJobs))
}

function invalidateJob(K) {
    const C = queue.indexOf(K);
    C > flushIndex && queue.splice(C, 1)
}

function queuePostFlushCb(K) {
    isArray$4(K) ? pendingPostFlushCbs.push(...K) : (!activePostFlushCbs || !activePostFlushCbs.includes(K, K.allowRecurse ?
        postFlushIndex + 1 : postFlushIndex)) && pendingPostFlushCbs.push(K), queueFlush()
}

function flushPreFlushCbs(K, C = isFlushing ? flushIndex + 1 : 0) {
    for (; C < queue.length; C++) {
        const H = queue[C];
        H && H.pre && (queue.splice(C, 1), C--, H())
    }
}

function flushPostFlushCbs(K) {
    if (pendingPostFlushCbs.length) {
        const C = [...new Set(pendingPostFlushCbs)];
        if (pendingPostFlushCbs.length = 0, activePostFlushCbs) {
            activePostFlushCbs.push(...C);
            return
        }
        for (activePostFlushCbs = C, activePostFlushCbs.sort((H, W) => getId(H) - getId(W)), postFlushIndex = 0; postFlushIndex <
            activePostFlushCbs.length; postFlushIndex++) activePostFlushCbs[postFlushIndex]();
        activePostFlushCbs = null, postFlushIndex = 0
    }
}
const getId = K => K.id == null ? 1 / 0 : K.id,
    comparator = (K, C) => {
        const H = getId(K) - getId(C);
        if (H === 0) {
            if (K.pre && !C.pre) return -1;
            if (C.pre && !K.pre) return 1
        }
        return H
    };

function flushJobs(K) {
    isFlushPending = !1, isFlushing = !0, queue.sort(comparator);
    const C = NOOP;
    try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
            const H = queue[flushIndex];
            H && H.active !== !1 && callWithErrorHandling(H, null, 14)
        }
    } finally {
        flushIndex = 0, queue.length = 0, flushPostFlushCbs(), isFlushing = !1, currentFlushPromise = null, (queue.length ||
            pendingPostFlushCbs.length) && flushJobs()
    }
}

function emit(K, C, ...H) {
    if (K.isUnmounted) return;
    const W = K.vnode.props || EMPTY_OBJ;
    let U = H;
    const G = C.startsWith("update:"),
        X = G && C.slice(7);
    if (X && X in W) {
        const ne = `${X==="modelValue"?"model":X}Modifiers`,
            {
                number: te,
                trim: re
            } = W[ne] || EMPTY_OBJ;
        re && (U = H.map(ae => isString$3(ae) ? ae.trim() : ae)), te && (U = H.map(looseToNumber))
    }
    let Z, Q = W[Z = toHandlerKey(C)] || W[Z = toHandlerKey(camelize$1(C))];
    !Q && G && (Q = W[Z = toHandlerKey(hyphenate$1(C))]), Q && callWithAsyncErrorHandling(Q, K, 6, U);
    const ee = W[Z + "Once"];
    if (ee) {
        if (!K.emitted) K.emitted = {};
        else if (K.emitted[Z]) return;
        K.emitted[Z] = !0, callWithAsyncErrorHandling(ee, K, 6, U)
    }
}

function normalizeEmitsOptions(K, C, H = !1) {
    const W = C.emitsCache,
        U = W.get(K);
    if (U !== void 0) return U;
    const G = K.emits;
    let X = {},
        Z = !1;
    if (!isFunction$3(K)) {
        const Q = ee => {
            const ne = normalizeEmitsOptions(ee, C, !0);
            ne && (Z = !0, extend$1(X, ne))
        };
        !H && C.mixins.length && C.mixins.forEach(Q), K.extends && Q(K.extends), K.mixins && K.mixins.forEach(Q)
    }
    return !G && !Z ? (isObject$4(K) && W.set(K, null), null) : (isArray$4(G) ? G.forEach(Q => X[Q] = null) : extend$1(
        X, G), isObject$4(K) && W.set(K, X), X)
}

function isEmitListener(K, C) {
    return !K || !isOn$1(C) ? !1 : (C = C.slice(2).replace(/Once$/, ""), hasOwn$1(K, C[0].toLowerCase() + C.slice(1)) ||
        hasOwn$1(K, hyphenate$1(C)) || hasOwn$1(K, C))
}
let currentRenderingInstance = null,
    currentScopeId = null;

function setCurrentRenderingInstance(K) {
    const C = currentRenderingInstance;
    return currentRenderingInstance = K, currentScopeId = K && K.type.__scopeId || null, C
}

function pushScopeId(K) {
    currentScopeId = K
}

function popScopeId() {
    currentScopeId = null
}

function withCtx(K, C = currentRenderingInstance, H) {
    if (!C || K._n) return K;
    const W = (...U) => {
        W._d && setBlockTracking(-1);
        const G = setCurrentRenderingInstance(C);
        let X;
        try {
            X = K(...U)
        } finally {
            setCurrentRenderingInstance(G), W._d && setBlockTracking(1)
        }
        return X
    };
    return W._n = !0, W._c = !0, W._d = !0, W
}

function markAttrsAccessed() {}

function renderComponentRoot(K) {
    const {
        type: C,
        vnode: H,
        proxy: W,
        withProxy: U,
        props: G,
        propsOptions: [X],
        slots: Z,
        attrs: Q,
        emit: ee,
        render: ne,
        renderCache: te,
        data: re,
        setupState: ae,
        ctx: oe,
        inheritAttrs: ie
    } = K;
    let ue, le;
    const se = setCurrentRenderingInstance(K);
    try {
        if (H.shapeFlag & 4) {
            const de = U || W;
            ue = normalizeVNode(ne.call(de, de, te, G, ae, re, oe)), le = Q
        } else {
            const de = C;
            ue = normalizeVNode(de.length > 1 ? de(G, {
                attrs: Q,
                slots: Z,
                emit: ee
            }) : de(G, null)), le = C.props ? Q : getFunctionalFallthrough(Q)
        }
    } catch (de) {
        blockStack.length = 0, handleError(de, K, 1), ue = createVNode(Comment$1)
    }
    let ce = ue;
    if (le && ie !== !1) {
        const de = Object.keys(le),
            {
                shapeFlag: ve
            } = ce;
        de.length && ve & 7 && (X && de.some(isModelListener) && (le = filterModelListeners(le, X)), ce = cloneVNode(ce,
            le))
    }
    return H.dirs && (ce = cloneVNode(ce), ce.dirs = ce.dirs ? ce.dirs.concat(H.dirs) : H.dirs), H.transition && (ce.transition =
        H.transition), ue = ce, setCurrentRenderingInstance(se), ue
}
const getFunctionalFallthrough = K => {
        let C;
        for (const H in K)(H === "class" || H === "style" || isOn$1(H)) && ((C || (C = {}))[H] = K[H]);
        return C
    },
    filterModelListeners = (K, C) => {
        const H = {};
        for (const W in K)(!isModelListener(W) || !(W.slice(9) in C)) && (H[W] = K[W]);
        return H
    };

function shouldUpdateComponent(K, C, H) {
    const {
        props: W,
        children: U,
        component: G
    } = K, {
        props: X,
        children: Z,
        patchFlag: Q
    } = C, ee = G.emitsOptions;
    if (C.dirs || C.transition) return !0;
    if (H && Q >= 0) {
        if (Q & 1024) return !0;
        if (Q & 16) return W ? hasPropsChanged(W, X, ee) : !!X;
        if (Q & 8) {
            const ne = C.dynamicProps;
            for (let te = 0; te < ne.length; te++) {
                const re = ne[te];
                if (X[re] !== W[re] && !isEmitListener(ee, re)) return !0
            }
        }
    } else return (U || Z) && (!Z || !Z.$stable) ? !0 : W === X ? !1 : W ? X ? hasPropsChanged(W, X, ee) : !0 : !!X;
    return !1
}

function hasPropsChanged(K, C, H) {
    const W = Object.keys(C);
    if (W.length !== Object.keys(K).length) return !0;
    for (let U = 0; U < W.length; U++) {
        const G = W[U];
        if (C[G] !== K[G] && !isEmitListener(H, G)) return !0
    }
    return !1
}

function updateHOCHostEl({
    vnode: K,
    parent: C
}, H) {
    for (; C && C.subTree === K;)(K = C.vnode).el = H, C = C.parent
}
const isSuspense = K => K.__isSuspense;

function queueEffectWithSuspense(K, C) {
    C && C.pendingBranch ? isArray$4(K) ? C.effects.push(...K) : C.effects.push(K) : queuePostFlushCb(K)
}

function provide(K, C) {
    if (currentInstance) {
        let H = currentInstance.provides;
        const W = currentInstance.parent && currentInstance.parent.provides;
        W === H && (H = currentInstance.provides = Object.create(W)), H[K] = C
    }
}

function inject(K, C, H = !1) {
    const W = currentInstance || currentRenderingInstance;
    if (W) {
        const U = W.parent == null ? W.vnode.appContext && W.vnode.appContext.provides : W.parent.provides;
        if (U && K in U) return U[K];
        if (arguments.length > 1) return H && isFunction$3(C) ? C.call(W.proxy) : C
    }
}

function watchEffect(K, C) {
    return doWatch(K, null, C)
}
const INITIAL_WATCHER_VALUE = {};

function watch(K, C, H) {
    return doWatch(K, C, H)
}

function doWatch(K, C, {
    immediate: H,
    deep: W,
    flush: U,
    onTrack: G,
    onTrigger: X
} = EMPTY_OBJ) {
    const Z = getCurrentScope() === (currentInstance == null ? void 0 : currentInstance.scope) ? currentInstance : null;
    let Q, ee = !1,
        ne = !1;
    if (isRef(K) ? (Q = () => K.value, ee = isShallow(K)) : isReactive(K) ? (Q = () => K, W = !0) : isArray$4(K) ? (ne = !
            0, ee = K.some(ce => isReactive(ce) || isShallow(ce)), Q = () => K.map(ce => {
                if (isRef(ce)) return ce.value;
                if (isReactive(ce)) return traverse(ce);
                if (isFunction$3(ce)) return callWithErrorHandling(ce, Z, 2)
            })) : isFunction$3(K) ? C ? Q = () => callWithErrorHandling(K, Z, 2) : Q = () => {
            if (!(Z && Z.isUnmounted)) return te && te(), callWithAsyncErrorHandling(K, Z, 3, [re])
        } : Q = NOOP, C && W) {
        const ce = Q;
        Q = () => traverse(ce())
    }
    let te, re = ce => {
            te = le.onStop = () => {
                callWithErrorHandling(ce, Z, 4)
            }
        },
        ae;
    if (isInSSRComponentSetup)
        if (re = NOOP, C ? H && callWithAsyncErrorHandling(C, Z, 3, [Q(), ne ? [] : void 0, re]) : Q(), U === "sync") {
            const ce = useSSRContext();
            ae = ce.__watcherHandles || (ce.__watcherHandles = [])
        } else return NOOP;
    let oe = ne ? new Array(K.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const ie = () => {
        if (le.active)
            if (C) {
                const ce = le.run();
                (W || ee || (ne ? ce.some((de, ve) => hasChanged(de, oe[ve])) : hasChanged(ce, oe))) && (te && te(),
                    callWithAsyncErrorHandling(C, Z, 3, [ce, oe === INITIAL_WATCHER_VALUE ? void 0 : ne && oe[0] ===
                        INITIAL_WATCHER_VALUE ? [] : oe, re]), oe = ce)
            } else le.run()
    };
    ie.allowRecurse = !!C;
    let ue;
    U === "sync" ? ue = ie : U === "post" ? ue = () => queuePostRenderEffect(ie, Z && Z.suspense) : (ie.pre = !0, Z &&
        (ie.id = Z.uid), ue = () => queueJob(ie));
    const le = new ReactiveEffect(Q, ue);
    C ? H ? ie() : oe = le.run() : U === "post" ? queuePostRenderEffect(le.run.bind(le), Z && Z.suspense) : le.run();
    const se = () => {
        le.stop(), Z && Z.scope && remove(Z.scope.effects, le)
    };
    return ae && ae.push(se), se
}

function instanceWatch(K, C, H) {
    const W = this.proxy,
        U = isString$3(K) ? K.includes(".") ? createPathGetter(W, K) : () => W[K] : K.bind(W, W);
    let G;
    isFunction$3(C) ? G = C : (G = C.handler, H = C);
    const X = currentInstance;
    setCurrentInstance(this);
    const Z = doWatch(U, G.bind(W), H);
    return X ? setCurrentInstance(X) : unsetCurrentInstance(), Z
}

function createPathGetter(K, C) {
    const H = C.split(".");
    return () => {
        let W = K;
        for (let U = 0; U < H.length && W; U++) W = W[H[U]];
        return W
    }
}

function traverse(K, C) {
    if (!isObject$4(K) || K.__v_skip || (C = C || new Set, C.has(K))) return K;
    if (C.add(K), isRef(K)) traverse(K.value, C);
    else if (isArray$4(K))
        for (let H = 0; H < K.length; H++) traverse(K[H], C);
    else if (isSet$2(K) || isMap$2(K)) K.forEach(H => {
        traverse(H, C)
    });
    else if (isPlainObject$1(K))
        for (const H in K) traverse(K[H], C);
    return K
}

function useTransitionState() {
    const K = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return onMounted(() => {
        K.isMounted = !0
    }), onBeforeUnmount(() => {
        K.isUnmounting = !0
    }), K
}
const TransitionHookValidator = [Function, Array],
    BaseTransitionImpl = {
        name: "BaseTransition",
        props: {
            mode: String,
            appear: Boolean,
            persisted: Boolean,
            onBeforeEnter: TransitionHookValidator,
            onEnter: TransitionHookValidator,
            onAfterEnter: TransitionHookValidator,
            onEnterCancelled: TransitionHookValidator,
            onBeforeLeave: TransitionHookValidator,
            onLeave: TransitionHookValidator,
            onAfterLeave: TransitionHookValidator,
            onLeaveCancelled: TransitionHookValidator,
            onBeforeAppear: TransitionHookValidator,
            onAppear: TransitionHookValidator,
            onAfterAppear: TransitionHookValidator,
            onAppearCancelled: TransitionHookValidator
        },
        setup(K, {
            slots: C
        }) {
            const H = getCurrentInstance(),
                W = useTransitionState();
            let U;
            return () => {
                const G = C.default && getTransitionRawChildren(C.default(), !0);
                if (!G || !G.length) return;
                let X = G[0];
                if (G.length > 1) {
                    for (const ie of G)
                        if (ie.type !== Comment$1) {
                            X = ie;
                            break
                        }
                }
                const Z = toRaw(K),
                    {
                        mode: Q
                    } = Z;
                if (W.isLeaving) return emptyPlaceholder(X);
                const ee = getKeepAliveChild(X);
                if (!ee) return emptyPlaceholder(X);
                const ne = resolveTransitionHooks(ee, Z, W, H);
                setTransitionHooks(ee, ne);
                const te = H.subTree,
                    re = te && getKeepAliveChild(te);
                let ae = !1;
                const {
                    getTransitionKey: oe
                } = ee.type;
                if (oe) {
                    const ie = oe();
                    U === void 0 ? U = ie : ie !== U && (U = ie, ae = !0)
                }
                if (re && re.type !== Comment$1 && (!isSameVNodeType(ee, re) || ae)) {
                    const ie = resolveTransitionHooks(re, Z, W, H);
                    if (setTransitionHooks(re, ie), Q === "out-in") return W.isLeaving = !0, ie.afterLeave = () => {
                        W.isLeaving = !1, H.update.active !== !1 && H.update()
                    }, emptyPlaceholder(X);
                    Q === "in-out" && ee.type !== Comment$1 && (ie.delayLeave = (ue, le, se) => {
                        const ce = getLeavingNodesForType(W, re);
                        ce[String(re.key)] = re, ue._leaveCb = () => {
                            le(), ue._leaveCb = void 0, delete ne.delayedLeave
                        }, ne.delayedLeave = se
                    })
                }
                return X
            }
        }
    },
    BaseTransition = BaseTransitionImpl;

function getLeavingNodesForType(K, C) {
    const {
        leavingVNodes: H
    } = K;
    let W = H.get(C.type);
    return W || (W = Object.create(null), H.set(C.type, W)), W
}

function resolveTransitionHooks(K, C, H, W) {
    const {
        appear: U,
        mode: G,
        persisted: X = !1,
        onBeforeEnter: Z,
        onEnter: Q,
        onAfterEnter: ee,
        onEnterCancelled: ne,
        onBeforeLeave: te,
        onLeave: re,
        onAfterLeave: ae,
        onLeaveCancelled: oe,
        onBeforeAppear: ie,
        onAppear: ue,
        onAfterAppear: le,
        onAppearCancelled: se
    } = C, ce = String(K.key), de = getLeavingNodesForType(H, K), ve = (me, he) => {
        me && callWithAsyncErrorHandling(me, W, 9, he)
    }, fe = (me, he) => {
        const Se = he[1];
        ve(me, he), isArray$4(me) ? me.every(_e => _e.length <= 1) && Se() : me.length <= 1 && Se()
    }, pe = {
        mode: G,
        persisted: X,
        beforeEnter(me) {
            let he = Z;
            if (!H.isMounted)
                if (U) he = ie || Z;
                else return;
            me._leaveCb && me._leaveCb(!0);
            const Se = de[ce];
            Se && isSameVNodeType(K, Se) && Se.el._leaveCb && Se.el._leaveCb(), ve(he, [me])
        },
        enter(me) {
            let he = Q,
                Se = ee,
                _e = ne;
            if (!H.isMounted)
                if (U) he = ue || Q, Se = le || ee, _e = se || ne;
                else return;
            let be = !1;
            const ge = me._enterCb = xe => {
                be || (be = !0, xe ? ve(_e, [me]) : ve(Se, [me]), pe.delayedLeave && pe.delayedLeave(), me._enterCb =
                    void 0)
            };
            he ? fe(he, [me, ge]) : ge()
        },
        leave(me, he) {
            const Se = String(K.key);
            if (me._enterCb && me._enterCb(!0), H.isUnmounting) return he();
            ve(te, [me]);
            let _e = !1;
            const be = me._leaveCb = ge => {
                _e || (_e = !0, he(), ge ? ve(oe, [me]) : ve(ae, [me]), me._leaveCb = void 0, de[Se] === K &&
                    delete de[Se])
            };
            de[Se] = K, re ? fe(re, [me, be]) : be()
        },
        clone(me) {
            return resolveTransitionHooks(me, C, H, W)
        }
    };
    return pe
}

function emptyPlaceholder(K) {
    if (isKeepAlive(K)) return K = cloneVNode(K), K.children = null, K
}

function getKeepAliveChild(K) {
    return isKeepAlive(K) ? K.children ? K.children[0] : void 0 : K
}

function setTransitionHooks(K, C) {
    K.shapeFlag & 6 && K.component ? setTransitionHooks(K.component.subTree, C) : K.shapeFlag & 128 ? (K.ssContent.transition =
        C.clone(K.ssContent), K.ssFallback.transition = C.clone(K.ssFallback)) : K.transition = C
}

function getTransitionRawChildren(K, C = !1, H) {
    let W = [],
        U = 0;
    for (let G = 0; G < K.length; G++) {
        let X = K[G];
        const Z = H == null ? X.key : String(H) + String(X.key != null ? X.key : G);
        X.type === Fragment ? (X.patchFlag & 128 && U++, W = W.concat(getTransitionRawChildren(X.children, C, Z))) : (C ||
            X.type !== Comment$1) && W.push(Z != null ? cloneVNode(X, {
            key: Z
        }) : X)
    }
    if (U > 1)
        for (let G = 0; G < W.length; G++) W[G].patchFlag = -2;
    return W
}

function defineComponent(K) {
    return isFunction$3(K) ? {
        setup: K,
        name: K.name
    } : K
}
const isAsyncWrapper = K => !!K.type.__asyncLoader,
    isKeepAlive = K => K.type.__isKeepAlive;

function onActivated(K, C) {
    registerKeepAliveHook(K, "a", C)
}

function onDeactivated(K, C) {
    registerKeepAliveHook(K, "da", C)
}

function registerKeepAliveHook(K, C, H = currentInstance) {
    const W = K.__wdc || (K.__wdc = () => {
        let U = H;
        for (; U;) {
            if (U.isDeactivated) return;
            U = U.parent
        }
        return K()
    });
    if (injectHook(C, W, H), H) {
        let U = H.parent;
        for (; U && U.parent;) isKeepAlive(U.parent.vnode) && injectToKeepAliveRoot(W, C, H, U), U = U.parent
    }
}

function injectToKeepAliveRoot(K, C, H, W) {
    const U = injectHook(C, K, W, !0);
    onUnmounted(() => {
        remove(W[C], U)
    }, H)
}

function injectHook(K, C, H = currentInstance, W = !1) {
    if (H) {
        const U = H[K] || (H[K] = []),
            G = C.__weh || (C.__weh = (...X) => {
                if (H.isUnmounted) return;
                pauseTracking(), setCurrentInstance(H);
                const Z = callWithAsyncErrorHandling(C, H, K, X);
                return unsetCurrentInstance(), resetTracking(), Z
            });
        return W ? U.unshift(G) : U.push(G), G
    }
}
const createHook = K => (C, H = currentInstance) => (!isInSSRComponentSetup || K === "sp") && injectHook(K, (...W) => C(
        ...W), H),
    onBeforeMount = createHook("bm"),
    onMounted = createHook("m"),
    onBeforeUpdate = createHook("bu"),
    onUpdated = createHook("u"),
    onBeforeUnmount = createHook("bum"),
    onUnmounted = createHook("um"),
    onServerPrefetch = createHook("sp"),
    onRenderTriggered = createHook("rtg"),
    onRenderTracked = createHook("rtc");

function onErrorCaptured(K, C = currentInstance) {
    injectHook("ec", K, C)
}

function withDirectives(K, C) {
    const H = currentRenderingInstance;
    if (H === null) return K;
    const W = getExposeProxy(H) || H.proxy,
        U = K.dirs || (K.dirs = []);
    for (let G = 0; G < C.length; G++) {
        let [X, Z, Q, ee = EMPTY_OBJ] = C[G];
        X && (isFunction$3(X) && (X = {
            mounted: X,
            updated: X
        }), X.deep && traverse(Z), U.push({
            dir: X,
            instance: W,
            value: Z,
            oldValue: void 0,
            arg: Q,
            modifiers: ee
        }))
    }
    return K
}

function invokeDirectiveHook(K, C, H, W) {
    const U = K.dirs,
        G = C && C.dirs;
    for (let X = 0; X < U.length; X++) {
        const Z = U[X];
        G && (Z.oldValue = G[X].value);
        let Q = Z.dir[W];
        Q && (pauseTracking(), callWithAsyncErrorHandling(Q, H, 8, [K.el, Z, K, C]), resetTracking())
    }
}
const COMPONENTS = "components",
    DIRECTIVES = "directives";

function resolveComponent(K, C) {
    return resolveAsset(COMPONENTS, K, !0, C) || K
}
const NULL_DYNAMIC_COMPONENT = Symbol();

function resolveDynamicComponent(K) {
    return isString$3(K) ? resolveAsset(COMPONENTS, K, !1) || K : K || NULL_DYNAMIC_COMPONENT
}

function resolveDirective(K) {
    return resolveAsset(DIRECTIVES, K)
}

function resolveAsset(K, C, H = !0, W = !1) {
    const U = currentRenderingInstance || currentInstance;
    if (U) {
        const G = U.type;
        if (K === COMPONENTS) {
            const Z = getComponentName(G, !1);
            if (Z && (Z === C || Z === camelize$1(C) || Z === capitalize(camelize$1(C)))) return G
        }
        const X = resolve(U[K] || G[K], C) || resolve(U.appContext[K], C);
        return !X && W ? G : X
    }
}

function resolve(K, C) {
    return K && (K[C] || K[camelize$1(C)] || K[capitalize(camelize$1(C))])
}

function renderList(K, C, H, W) {
    let U;
    const G = H && H[W];
    if (isArray$4(K) || isString$3(K)) {
        U = new Array(K.length);
        for (let X = 0, Z = K.length; X < Z; X++) U[X] = C(K[X], X, void 0, G && G[X])
    } else if (typeof K == "number") {
        U = new Array(K);
        for (let X = 0; X < K; X++) U[X] = C(X + 1, X, void 0, G && G[X])
    } else if (isObject$4(K))
        if (K[Symbol.iterator]) U = Array.from(K, (X, Z) => C(X, Z, void 0, G && G[Z]));
        else {
            const X = Object.keys(K);
            U = new Array(X.length);
            for (let Z = 0, Q = X.length; Z < Q; Z++) {
                const ee = X[Z];
                U[Z] = C(K[ee], ee, Z, G && G[Z])
            }
        }
    else U = [];
    return H && (H[W] = U), U
}

function renderSlot(K, C, H = {}, W, U) {
    if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) &&
        currentRenderingInstance.parent.isCE) return C !== "default" && (H.name = C), createVNode("slot", H, W && W());
    let G = K[C];
    G && G._c && (G._d = !1), openBlock();
    const X = G && ensureValidVNode(G(H)),
        Z = createBlock(Fragment, {
            key: H.key || X && X.key || `_${C}`
        }, X || (W ? W() : []), X && K._ === 1 ? 64 : -2);
    return !U && Z.scopeId && (Z.slotScopeIds = [Z.scopeId + "-s"]), G && G._c && (G._d = !0), Z
}

function ensureValidVNode(K) {
    return K.some(C => isVNode(C) ? !(C.type === Comment$1 || C.type === Fragment && !ensureValidVNode(C.children)) : !
        0) ? K : null
}
const getPublicInstance = K => K ? isStatefulComponent(K) ? getExposeProxy(K) || K.proxy : getPublicInstance(K.parent) :
    null,
    publicPropertiesMap = extend$1(Object.create(null), {
        $: K => K,
        $el: K => K.vnode.el,
        $data: K => K.data,
        $props: K => K.props,
        $attrs: K => K.attrs,
        $slots: K => K.slots,
        $refs: K => K.refs,
        $parent: K => getPublicInstance(K.parent),
        $root: K => getPublicInstance(K.root),
        $emit: K => K.emit,
        $options: K => resolveMergedOptions(K),
        $forceUpdate: K => K.f || (K.f = () => queueJob(K.update)),
        $nextTick: K => K.n || (K.n = nextTick.bind(K.proxy)),
        $watch: K => instanceWatch.bind(K)
    }),
    hasSetupBinding = (K, C) => K !== EMPTY_OBJ && !K.__isScriptSetup && hasOwn$1(K, C),
    PublicInstanceProxyHandlers = {
        get({
            _: K
        }, C) {
            const {
                ctx: H,
                setupState: W,
                data: U,
                props: G,
                accessCache: X,
                type: Z,
                appContext: Q
            } = K;
            let ee;
            if (C[0] !== "$") {
                const ae = X[C];
                if (ae !== void 0) switch (ae) {
                    case 1:
                        return W[C];
                    case 2:
                        return U[C];
                    case 4:
                        return H[C];
                    case 3:
                        return G[C]
                } else {
                    if (hasSetupBinding(W, C)) return X[C] = 1, W[C];
                    if (U !== EMPTY_OBJ && hasOwn$1(U, C)) return X[C] = 2, U[C];
                    if ((ee = K.propsOptions[0]) && hasOwn$1(ee, C)) return X[C] = 3, G[C];
                    if (H !== EMPTY_OBJ && hasOwn$1(H, C)) return X[C] = 4, H[C];
                    shouldCacheAccess && (X[C] = 0)
                }
            }
            const ne = publicPropertiesMap[C];
            let te, re;
            if (ne) return C === "$attrs" && track(K, "get", C), ne(K);
            if ((te = Z.__cssModules) && (te = te[C])) return te;
            if (H !== EMPTY_OBJ && hasOwn$1(H, C)) return X[C] = 4, H[C];
            if (re = Q.config.globalProperties, hasOwn$1(re, C)) return re[C]
        },
        set({
            _: K
        }, C, H) {
            const {
                data: W,
                setupState: U,
                ctx: G
            } = K;
            return hasSetupBinding(U, C) ? (U[C] = H, !0) : W !== EMPTY_OBJ && hasOwn$1(W, C) ? (W[C] = H, !0) :
                hasOwn$1(K.props, C) || C[0] === "$" && C.slice(1) in K ? !1 : (G[C] = H, !0)
        },
        has({
            _: {
                data: K,
                setupState: C,
                accessCache: H,
                ctx: W,
                appContext: U,
                propsOptions: G
            }
        }, X) {
            let Z;
            return !!H[X] || K !== EMPTY_OBJ && hasOwn$1(K, X) || hasSetupBinding(C, X) || (Z = G[0]) && hasOwn$1(Z, X) ||
                hasOwn$1(W, X) || hasOwn$1(publicPropertiesMap, X) || hasOwn$1(U.config.globalProperties, X)
        },
        defineProperty(K, C, H) {
            return H.get != null ? K._.accessCache[C] = 0 : hasOwn$1(H, "value") && this.set(K, C, H.value, null),
                Reflect.defineProperty(K, C, H)
        }
    };
let shouldCacheAccess = !0;

function applyOptions(K) {
    const C = resolveMergedOptions(K),
        H = K.proxy,
        W = K.ctx;
    shouldCacheAccess = !1, C.beforeCreate && callHook$1(C.beforeCreate, K, "bc");
    const {
        data: U,
        computed: G,
        methods: X,
        watch: Z,
        provide: Q,
        inject: ee,
        created: ne,
        beforeMount: te,
        mounted: re,
        beforeUpdate: ae,
        updated: oe,
        activated: ie,
        deactivated: ue,
        beforeDestroy: le,
        beforeUnmount: se,
        destroyed: ce,
        unmounted: de,
        render: ve,
        renderTracked: fe,
        renderTriggered: pe,
        errorCaptured: me,
        serverPrefetch: he,
        expose: Se,
        inheritAttrs: _e,
        components: be,
        directives: ge,
        filters: xe
    } = C;
    if (ee && resolveInjections(ee, W, null, K.appContext.config.unwrapInjectedRef), X)
        for (const ye in X) {
            const Ce = X[ye];
            isFunction$3(Ce) && (W[ye] = Ce.bind(H))
        }
    if (U) {
        const ye = U.call(H, H);
        isObject$4(ye) && (K.data = reactive(ye))
    }
    if (shouldCacheAccess = !0, G)
        for (const ye in G) {
            const Ce = G[ye],
                we = isFunction$3(Ce) ? Ce.bind(H, H) : isFunction$3(Ce.get) ? Ce.get.bind(H, H) : NOOP,
                Oe = !isFunction$3(Ce) && isFunction$3(Ce.set) ? Ce.set.bind(H) : NOOP,
                Ne = computed({
                    get: we,
                    set: Oe
                });
            Object.defineProperty(W, ye, {
                enumerable: !0,
                configurable: !0,
                get: () => Ne.value,
                set: Me => Ne.value = Me
            })
        }
    if (Z)
        for (const ye in Z) createWatcher(Z[ye], W, H, ye);
    if (Q) {
        const ye = isFunction$3(Q) ? Q.call(H) : Q;
        Reflect.ownKeys(ye).forEach(Ce => {
            provide(Ce, ye[Ce])
        })
    }
    ne && callHook$1(ne, K, "c");

    function $e(ye, Ce) {
        isArray$4(Ce) ? Ce.forEach(we => ye(we.bind(H))) : Ce && ye(Ce.bind(H))
    }
    if ($e(onBeforeMount, te), $e(onMounted, re), $e(onBeforeUpdate, ae), $e(onUpdated, oe), $e(onActivated, ie), $e(
            onDeactivated, ue), $e(onErrorCaptured, me), $e(onRenderTracked, fe), $e(onRenderTriggered, pe), $e(
            onBeforeUnmount, se), $e(onUnmounted, de), $e(onServerPrefetch, he), isArray$4(Se))
        if (Se.length) {
            const ye = K.exposed || (K.exposed = {});
            Se.forEach(Ce => {
                Object.defineProperty(ye, Ce, {
                    get: () => H[Ce],
                    set: we => H[Ce] = we
                })
            })
        } else K.exposed || (K.exposed = {});
    ve && K.render === NOOP && (K.render = ve), _e != null && (K.inheritAttrs = _e), be && (K.components = be), ge && (
        K.directives = ge)
}

function resolveInjections(K, C, H = NOOP, W = !1) {
    isArray$4(K) && (K = normalizeInject(K));
    for (const U in K) {
        const G = K[U];
        let X;
        isObject$4(G) ? "default" in G ? X = inject(G.from || U, G.default, !0) : X = inject(G.from || U) : X = inject(
            G), isRef(X) && W ? Object.defineProperty(C, U, {
            enumerable: !0,
            configurable: !0,
            get: () => X.value,
            set: Z => X.value = Z
        }) : C[U] = X
    }
}

function callHook$1(K, C, H) {
    callWithAsyncErrorHandling(isArray$4(K) ? K.map(W => W.bind(C.proxy)) : K.bind(C.proxy), C, H)
}

function createWatcher(K, C, H, W) {
    const U = W.includes(".") ? createPathGetter(H, W) : () => H[W];
    if (isString$3(K)) {
        const G = C[K];
        isFunction$3(G) && watch(U, G)
    } else if (isFunction$3(K)) watch(U, K.bind(H));
    else if (isObject$4(K))
        if (isArray$4(K)) K.forEach(G => createWatcher(G, C, H, W));
        else {
            const G = isFunction$3(K.handler) ? K.handler.bind(H) : C[K.handler];
            isFunction$3(G) && watch(U, G, K)
        }
}

function resolveMergedOptions(K) {
    const C = K.type,
        {
            mixins: H,
            extends: W
        } = C,
        {
            mixins: U,
            optionsCache: G,
            config: {
                optionMergeStrategies: X
            }
        } = K.appContext,
        Z = G.get(C);
    let Q;
    return Z ? Q = Z : !U.length && !H && !W ? Q = C : (Q = {}, U.length && U.forEach(ee => mergeOptions(Q, ee, X, !0)),
        mergeOptions(Q, C, X)), isObject$4(C) && G.set(C, Q), Q
}

function mergeOptions(K, C, H, W = !1) {
    const {
        mixins: U,
        extends: G
    } = C;
    G && mergeOptions(K, G, H, !0), U && U.forEach(X => mergeOptions(K, X, H, !0));
    for (const X in C)
        if (!(W && X === "expose")) {
            const Z = internalOptionMergeStrats[X] || H && H[X];
            K[X] = Z ? Z(K[X], C[X]) : C[X]
        } return K
}
const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeObjectOptions,
    emits: mergeObjectOptions,
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    watch: mergeWatchOptions,
    provide: mergeDataFn,
    inject: mergeInject
};

function mergeDataFn(K, C) {
    return C ? K ? function () {
        return extend$1(isFunction$3(K) ? K.call(this, this) : K, isFunction$3(C) ? C.call(this, this) : C)
    } : C : K
}

function mergeInject(K, C) {
    return mergeObjectOptions(normalizeInject(K), normalizeInject(C))
}

function normalizeInject(K) {
    if (isArray$4(K)) {
        const C = {};
        for (let H = 0; H < K.length; H++) C[K[H]] = K[H];
        return C
    }
    return K
}

function mergeAsArray(K, C) {
    return K ? [...new Set([].concat(K, C))] : C
}

function mergeObjectOptions(K, C) {
    return K ? extend$1(extend$1(Object.create(null), K), C) : C
}

function mergeWatchOptions(K, C) {
    if (!K) return C;
    if (!C) return K;
    const H = extend$1(Object.create(null), K);
    for (const W in C) H[W] = mergeAsArray(K[W], C[W]);
    return H
}

function initProps(K, C, H, W = !1) {
    const U = {},
        G = {};
    def(G, InternalObjectKey, 1), K.propsDefaults = Object.create(null), setFullProps(K, C, U, G);
    for (const X in K.propsOptions[0]) X in U || (U[X] = void 0);
    H ? K.props = W ? U : shallowReactive(U) : K.type.props ? K.props = U : K.props = G, K.attrs = G
}

function updateProps(K, C, H, W) {
    const {
        props: U,
        attrs: G,
        vnode: {
            patchFlag: X
        }
    } = K, Z = toRaw(U), [Q] = K.propsOptions;
    let ee = !1;
    if ((W || X > 0) && !(X & 16)) {
        if (X & 8) {
            const ne = K.vnode.dynamicProps;
            for (let te = 0; te < ne.length; te++) {
                let re = ne[te];
                if (isEmitListener(K.emitsOptions, re)) continue;
                const ae = C[re];
                if (Q)
                    if (hasOwn$1(G, re)) ae !== G[re] && (G[re] = ae, ee = !0);
                    else {
                        const oe = camelize$1(re);
                        U[oe] = resolvePropValue$1(Q, Z, oe, ae, K, !1)
                    }
                else ae !== G[re] && (G[re] = ae, ee = !0)
            }
        }
    } else {
        setFullProps(K, C, U, G) && (ee = !0);
        let ne;
        for (const te in Z)(!C || !hasOwn$1(C, te) && ((ne = hyphenate$1(te)) === te || !hasOwn$1(C, ne))) && (Q ? H &&
            (H[te] !== void 0 || H[ne] !== void 0) && (U[te] = resolvePropValue$1(Q, Z, te, void 0, K, !0)) :
            delete U[te]);
        if (G !== Z)
            for (const te in G)(!C || !hasOwn$1(C, te)) && (delete G[te], ee = !0)
    }
    ee && trigger$1(K, "set", "$attrs")
}

function setFullProps(K, C, H, W) {
    const [U, G] = K.propsOptions;
    let X = !1,
        Z;
    if (C)
        for (let Q in C) {
            if (isReservedProp(Q)) continue;
            const ee = C[Q];
            let ne;
            U && hasOwn$1(U, ne = camelize$1(Q)) ? !G || !G.includes(ne) ? H[ne] = ee : (Z || (Z = {}))[ne] = ee :
                isEmitListener(K.emitsOptions, Q) || (!(Q in W) || ee !== W[Q]) && (W[Q] = ee, X = !0)
        }
    if (G) {
        const Q = toRaw(H),
            ee = Z || EMPTY_OBJ;
        for (let ne = 0; ne < G.length; ne++) {
            const te = G[ne];
            H[te] = resolvePropValue$1(U, Q, te, ee[te], K, !hasOwn$1(ee, te))
        }
    }
    return X
}

function resolvePropValue$1(K, C, H, W, U, G) {
    const X = K[H];
    if (X != null) {
        const Z = hasOwn$1(X, "default");
        if (Z && W === void 0) {
            const Q = X.default;
            if (X.type !== Function && isFunction$3(Q)) {
                const {
                    propsDefaults: ee
                } = U;
                H in ee ? W = ee[H] : (setCurrentInstance(U), W = ee[H] = Q.call(null, C), unsetCurrentInstance())
            } else W = Q
        }
        X[0] && (G && !Z ? W = !1 : X[1] && (W === "" || W === hyphenate$1(H)) && (W = !0))
    }
    return W
}

function normalizePropsOptions(K, C, H = !1) {
    const W = C.propsCache,
        U = W.get(K);
    if (U) return U;
    const G = K.props,
        X = {},
        Z = [];
    let Q = !1;
    if (!isFunction$3(K)) {
        const ne = te => {
            Q = !0;
            const [re, ae] = normalizePropsOptions(te, C, !0);
            extend$1(X, re), ae && Z.push(...ae)
        };
        !H && C.mixins.length && C.mixins.forEach(ne), K.extends && ne(K.extends), K.mixins && K.mixins.forEach(ne)
    }
    if (!G && !Q) return isObject$4(K) && W.set(K, EMPTY_ARR), EMPTY_ARR;
    if (isArray$4(G))
        for (let ne = 0; ne < G.length; ne++) {
            const te = camelize$1(G[ne]);
            validatePropName(te) && (X[te] = EMPTY_OBJ)
        } else if (G)
            for (const ne in G) {
                const te = camelize$1(ne);
                if (validatePropName(te)) {
                    const re = G[ne],
                        ae = X[te] = isArray$4(re) || isFunction$3(re) ? {
                            type: re
                        } : Object.assign({}, re);
                    if (ae) {
                        const oe = getTypeIndex(Boolean, ae.type),
                            ie = getTypeIndex(String, ae.type);
                        ae[0] = oe > -1, ae[1] = ie < 0 || oe < ie, (oe > -1 || hasOwn$1(ae, "default")) && Z.push(te)
                    }
                }
            }
    const ee = [X, Z];
    return isObject$4(K) && W.set(K, ee), ee
}

function validatePropName(K) {
    return K[0] !== "$"
}

function getType(K) {
    const C = K && K.toString().match(/^\s*(function|class) (\w+)/);
    return C ? C[2] : K === null ? "null" : ""
}

function isSameType(K, C) {
    return getType(K) === getType(C)
}

function getTypeIndex(K, C) {
    return isArray$4(C) ? C.findIndex(H => isSameType(H, K)) : isFunction$3(C) && isSameType(C, K) ? 0 : -1
}
const isInternalKey = K => K[0] === "_" || K === "$stable",
    normalizeSlotValue = K => isArray$4(K) ? K.map(normalizeVNode) : [normalizeVNode(K)],
    normalizeSlot = (K, C, H) => {
        if (C._n) return C;
        const W = withCtx((...U) => normalizeSlotValue(C(...U)), H);
        return W._c = !1, W
    },
    normalizeObjectSlots = (K, C, H) => {
        const W = K._ctx;
        for (const U in K) {
            if (isInternalKey(U)) continue;
            const G = K[U];
            if (isFunction$3(G)) C[U] = normalizeSlot(U, G, W);
            else if (G != null) {
                const X = normalizeSlotValue(G);
                C[U] = () => X
            }
        }
    },
    normalizeVNodeSlots = (K, C) => {
        const H = normalizeSlotValue(C);
        K.slots.default = () => H
    },
    initSlots = (K, C) => {
        if (K.vnode.shapeFlag & 32) {
            const H = C._;
            H ? (K.slots = toRaw(C), def(C, "_", H)) : normalizeObjectSlots(C, K.slots = {})
        } else K.slots = {}, C && normalizeVNodeSlots(K, C);
        def(K.slots, InternalObjectKey, 1)
    },
    updateSlots = (K, C, H) => {
        const {
            vnode: W,
            slots: U
        } = K;
        let G = !0,
            X = EMPTY_OBJ;
        if (W.shapeFlag & 32) {
            const Z = C._;
            Z ? H && Z === 1 ? G = !1 : (extend$1(U, C), !H && Z === 1 && delete U._) : (G = !C.$stable,
                normalizeObjectSlots(C, U)), X = C
        } else C && (normalizeVNodeSlots(K, C), X = {
            default: 1
        });
        if (G)
            for (const Z in U) !isInternalKey(Z) && !(Z in X) && delete U[Z]
    };

function createAppContext() {
    return {
        app: null,
        config: {
            isNativeTag: NO,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let uid$1 = 0;

function createAppAPI(K, C) {
    return function (W, U = null) {
        isFunction$3(W) || (W = Object.assign({}, W)), U != null && !isObject$4(U) && (U = null);
        const G = createAppContext(),
            X = new Set;
        let Z = !1;
        const Q = G.app = {
            _uid: uid$1++,
            _component: W,
            _props: U,
            _container: null,
            _context: G,
            _instance: null,
            version: version$1,
            get config() {
                return G.config
            },
            set config(ee) {},
            use(ee, ...ne) {
                return X.has(ee) || (ee && isFunction$3(ee.install) ? (X.add(ee), ee.install(Q, ...ne)) :
                    isFunction$3(ee) && (X.add(ee), ee(Q, ...ne))), Q
            },
            mixin(ee) {
                return G.mixins.includes(ee) || G.mixins.push(ee), Q
            },
            component(ee, ne) {
                return ne ? (G.components[ee] = ne, Q) : G.components[ee]
            },
            directive(ee, ne) {
                return ne ? (G.directives[ee] = ne, Q) : G.directives[ee]
            },
            mount(ee, ne, te) {
                if (!Z) {
                    const re = createVNode(W, U);
                    return re.appContext = G, ne && C ? C(re, ee) : K(re, ee, te), Z = !0, Q._container = ee,
                        ee.__vue_app__ = Q, getExposeProxy(re.component) || re.component.proxy
                }
            },
            unmount() {
                Z && (K(null, Q._container), delete Q._container.__vue_app__)
            },
            provide(ee, ne) {
                return G.provides[ee] = ne, Q
            }
        };
        return Q
    }
}

function setRef(K, C, H, W, U = !1) {
    if (isArray$4(K)) {
        K.forEach((re, ae) => setRef(re, C && (isArray$4(C) ? C[ae] : C), H, W, U));
        return
    }
    if (isAsyncWrapper(W) && !U) return;
    const G = W.shapeFlag & 4 ? getExposeProxy(W.component) || W.component.proxy : W.el,
        X = U ? null : G,
        {
            i: Z,
            r: Q
        } = K,
        ee = C && C.r,
        ne = Z.refs === EMPTY_OBJ ? Z.refs = {} : Z.refs,
        te = Z.setupState;
    if (ee != null && ee !== Q && (isString$3(ee) ? (ne[ee] = null, hasOwn$1(te, ee) && (te[ee] = null)) : isRef(ee) &&
            (ee.value = null)), isFunction$3(Q)) callWithErrorHandling(Q, Z, 12, [X, ne]);
    else {
        const re = isString$3(Q),
            ae = isRef(Q);
        if (re || ae) {
            const oe = () => {
                if (K.f) {
                    const ie = re ? hasOwn$1(te, Q) ? te[Q] : ne[Q] : Q.value;
                    U ? isArray$4(ie) && remove(ie, G) : isArray$4(ie) ? ie.includes(G) || ie.push(G) : re ? (ne[Q] = [
                        G], hasOwn$1(te, Q) && (te[Q] = ne[Q])) : (Q.value = [G], K.k && (ne[K.k] = Q.value))
                } else re ? (ne[Q] = X, hasOwn$1(te, Q) && (te[Q] = X)) : ae && (Q.value = X, K.k && (ne[K.k] = X))
            };
            X ? (oe.id = -1, queuePostRenderEffect(oe, H)) : oe()
        }
    }
}
const queuePostRenderEffect = queueEffectWithSuspense;

function createRenderer(K) {
    return baseCreateRenderer(K)
}

function baseCreateRenderer(K, C) {
    const H = getGlobalThis();
    H.__VUE__ = !0;
    const {
        insert: W,
        remove: U,
        patchProp: G,
        createElement: X,
        createText: Z,
        createComment: Q,
        setText: ee,
        setElementText: ne,
        parentNode: te,
        nextSibling: re,
        setScopeId: ae = NOOP,
        insertStaticContent: oe
    } = K, ie = (Ie, Te, De, Ke = null, We = null, Ue = null, et = !1, Ye = null, ze = !!Te.dynamicChildren) => {
        if (Ie === Te) return;
        Ie && !isSameVNodeType(Ie, Te) && (Ke = Re(Ie), Me(Ie, We, Ue, !0), Ie = null), Te.patchFlag === -2 && (ze = !
            1, Te.dynamicChildren = null);
        const {
            type: Be,
            ref: Ge,
            shapeFlag: Xe
        } = Te;
        switch (Be) {
            case Text$2:
                ue(Ie, Te, De, Ke);
                break;
            case Comment$1:
                le(Ie, Te, De, Ke);
                break;
            case Static:
                Ie == null && se(Te, De, Ke, et);
                break;
            case Fragment:
                be(Ie, Te, De, Ke, We, Ue, et, Ye, ze);
                break;
            default:
                Xe & 1 ? ve(Ie, Te, De, Ke, We, Ue, et, Ye, ze) : Xe & 6 ? ge(Ie, Te, De, Ke, We, Ue, et, Ye, ze) :
                    (Xe & 64 || Xe & 128) && Be.process(Ie, Te, De, Ke, We, Ue, et, Ye, ze, je)
        }
        Ge != null && We && setRef(Ge, Ie && Ie.ref, Ue, Te || Ie, !Te)
    }, ue = (Ie, Te, De, Ke) => {
        if (Ie == null) W(Te.el = Z(Te.children), De, Ke);
        else {
            const We = Te.el = Ie.el;
            Te.children !== Ie.children && ee(We, Te.children)
        }
    }, le = (Ie, Te, De, Ke) => {
        Ie == null ? W(Te.el = Q(Te.children || ""), De, Ke) : Te.el = Ie.el
    }, se = (Ie, Te, De, Ke) => {
        [Ie.el, Ie.anchor] = oe(Ie.children, Te, De, Ke, Ie.el, Ie.anchor)
    }, ce = ({
        el: Ie,
        anchor: Te
    }, De, Ke) => {
        let We;
        for (; Ie && Ie !== Te;) We = re(Ie), W(Ie, De, Ke), Ie = We;
        W(Te, De, Ke)
    }, de = ({
        el: Ie,
        anchor: Te
    }) => {
        let De;
        for (; Ie && Ie !== Te;) De = re(Ie), U(Ie), Ie = De;
        U(Te)
    }, ve = (Ie, Te, De, Ke, We, Ue, et, Ye, ze) => {
        et = et || Te.type === "svg", Ie == null ? fe(Te, De, Ke, We, Ue, et, Ye, ze) : he(Ie, Te, We, Ue, et, Ye,
            ze)
    }, fe = (Ie, Te, De, Ke, We, Ue, et, Ye) => {
        let ze, Be;
        const {
            type: Ge,
            props: Xe,
            shapeFlag: nt,
            transition: it,
            dirs: ft
        } = Ie;
        if (ze = Ie.el = X(Ie.type, Ue, Xe && Xe.is, Xe), nt & 8 ? ne(ze, Ie.children) : nt & 16 && me(Ie.children,
                ze, null, Ke, We, Ue && Ge !== "foreignObject", et, Ye), ft && invokeDirectiveHook(Ie, null, Ke,
                "created"), pe(ze, Ie, Ie.scopeId, et, Ke), Xe) {
            for (const ot in Xe) ot !== "value" && !isReservedProp(ot) && G(ze, ot, null, Xe[ot], Ue, Ie.children,
                Ke, We, Ae);
            "value" in Xe && G(ze, "value", null, Xe.value), (Be = Xe.onVnodeBeforeMount) && invokeVNodeHook(Be, Ke,
                Ie)
        }
        ft && invokeDirectiveHook(Ie, null, Ke, "beforeMount");
        const pt = (!We || We && !We.pendingBranch) && it && !it.persisted;
        pt && it.beforeEnter(ze), W(ze, Te, De), ((Be = Xe && Xe.onVnodeMounted) || pt || ft) &&
            queuePostRenderEffect(() => {
                Be && invokeVNodeHook(Be, Ke, Ie), pt && it.enter(ze), ft && invokeDirectiveHook(Ie, null, Ke,
                    "mounted")
            }, We)
    }, pe = (Ie, Te, De, Ke, We) => {
        if (De && ae(Ie, De), Ke)
            for (let Ue = 0; Ue < Ke.length; Ue++) ae(Ie, Ke[Ue]);
        if (We) {
            let Ue = We.subTree;
            if (Te === Ue) {
                const et = We.vnode;
                pe(Ie, et, et.scopeId, et.slotScopeIds, We.parent)
            }
        }
    }, me = (Ie, Te, De, Ke, We, Ue, et, Ye, ze = 0) => {
        for (let Be = ze; Be < Ie.length; Be++) {
            const Ge = Ie[Be] = Ye ? cloneIfMounted(Ie[Be]) : normalizeVNode(Ie[Be]);
            ie(null, Ge, Te, De, Ke, We, Ue, et, Ye)
        }
    }, he = (Ie, Te, De, Ke, We, Ue, et) => {
        const Ye = Te.el = Ie.el;
        let {
            patchFlag: ze,
            dynamicChildren: Be,
            dirs: Ge
        } = Te;
        ze |= Ie.patchFlag & 16;
        const Xe = Ie.props || EMPTY_OBJ,
            nt = Te.props || EMPTY_OBJ;
        let it;
        De && toggleRecurse(De, !1), (it = nt.onVnodeBeforeUpdate) && invokeVNodeHook(it, De, Te, Ie), Ge &&
            invokeDirectiveHook(Te, Ie, De, "beforeUpdate"), De && toggleRecurse(De, !0);
        const ft = We && Te.type !== "foreignObject";
        if (Be ? Se(Ie.dynamicChildren, Be, Ye, De, Ke, ft, Ue) : et || Ce(Ie, Te, Ye, null, De, Ke, ft, Ue, !1),
            ze > 0) {
            if (ze & 16) _e(Ye, Te, Xe, nt, De, Ke, We);
            else if (ze & 2 && Xe.class !== nt.class && G(Ye, "class", null, nt.class, We), ze & 4 && G(Ye, "style",
                    Xe.style, nt.style, We), ze & 8) {
                const pt = Te.dynamicProps;
                for (let ot = 0; ot < pt.length; ot++) {
                    const Ze = pt[ot],
                        ut = Xe[Ze],
                        st = nt[Ze];
                    (st !== ut || Ze === "value") && G(Ye, Ze, ut, st, We, Ie.children, De, Ke, Ae)
                }
            }
            ze & 1 && Ie.children !== Te.children && ne(Ye, Te.children)
        } else !et && Be == null && _e(Ye, Te, Xe, nt, De, Ke, We);
        ((it = nt.onVnodeUpdated) || Ge) && queuePostRenderEffect(() => {
            it && invokeVNodeHook(it, De, Te, Ie), Ge && invokeDirectiveHook(Te, Ie, De, "updated")
        }, Ke)
    }, Se = (Ie, Te, De, Ke, We, Ue, et) => {
        for (let Ye = 0; Ye < Te.length; Ye++) {
            const ze = Ie[Ye],
                Be = Te[Ye],
                Ge = ze.el && (ze.type === Fragment || !isSameVNodeType(ze, Be) || ze.shapeFlag & 70) ? te(ze.el) :
                De;
            ie(ze, Be, Ge, null, Ke, We, Ue, et, !0)
        }
    }, _e = (Ie, Te, De, Ke, We, Ue, et) => {
        if (De !== Ke) {
            if (De !== EMPTY_OBJ)
                for (const Ye in De) !isReservedProp(Ye) && !(Ye in Ke) && G(Ie, Ye, De[Ye], null, et, Te.children,
                    We, Ue, Ae);
            for (const Ye in Ke) {
                if (isReservedProp(Ye)) continue;
                const ze = Ke[Ye],
                    Be = De[Ye];
                ze !== Be && Ye !== "value" && G(Ie, Ye, Be, ze, et, Te.children, We, Ue, Ae)
            }
            "value" in Ke && G(Ie, "value", De.value, Ke.value)
        }
    }, be = (Ie, Te, De, Ke, We, Ue, et, Ye, ze) => {
        const Be = Te.el = Ie ? Ie.el : Z(""),
            Ge = Te.anchor = Ie ? Ie.anchor : Z("");
        let {
            patchFlag: Xe,
            dynamicChildren: nt,
            slotScopeIds: it
        } = Te;
        it && (Ye = Ye ? Ye.concat(it) : it), Ie == null ? (W(Be, De, Ke), W(Ge, De, Ke), me(Te.children, De, Ge,
            We, Ue, et, Ye, ze)) : Xe > 0 && Xe & 64 && nt && Ie.dynamicChildren ? (Se(Ie.dynamicChildren, nt,
            De, We, Ue, et, Ye), (Te.key != null || We && Te === We.subTree) && traverseStaticChildren(Ie,
            Te, !0)) : Ce(Ie, Te, De, Ge, We, Ue, et, Ye, ze)
    }, ge = (Ie, Te, De, Ke, We, Ue, et, Ye, ze) => {
        Te.slotScopeIds = Ye, Ie == null ? Te.shapeFlag & 512 ? We.ctx.activate(Te, De, Ke, et, ze) : xe(Te, De, Ke,
            We, Ue, et, ze) : Pe(Ie, Te, ze)
    }, xe = (Ie, Te, De, Ke, We, Ue, et) => {
        const Ye = Ie.component = createComponentInstance(Ie, Ke, We);
        if (isKeepAlive(Ie) && (Ye.ctx.renderer = je), setupComponent(Ye), Ye.asyncDep) {
            if (We && We.registerDep(Ye, $e), !Ie.el) {
                const ze = Ye.subTree = createVNode(Comment$1);
                le(null, ze, Te, De)
            }
            return
        }
        $e(Ye, Ie, Te, De, We, Ue, et)
    }, Pe = (Ie, Te, De) => {
        const Ke = Te.component = Ie.component;
        if (shouldUpdateComponent(Ie, Te, De))
            if (Ke.asyncDep && !Ke.asyncResolved) {
                ye(Ke, Te, De);
                return
            } else Ke.next = Te, invalidateJob(Ke.update), Ke.update();
        else Te.el = Ie.el, Ke.vnode = Te
    }, $e = (Ie, Te, De, Ke, We, Ue, et) => {
        const Ye = () => {
                if (Ie.isMounted) {
                    let {
                        next: Ge,
                        bu: Xe,
                        u: nt,
                        parent: it,
                        vnode: ft
                    } = Ie, pt = Ge, ot;
                    toggleRecurse(Ie, !1), Ge ? (Ge.el = ft.el, ye(Ie, Ge, et)) : Ge = ft, Xe && invokeArrayFns(Xe),
                        (ot = Ge.props && Ge.props.onVnodeBeforeUpdate) && invokeVNodeHook(ot, it, Ge, ft),
                        toggleRecurse(Ie, !0);
                    const Ze = renderComponentRoot(Ie),
                        ut = Ie.subTree;
                    Ie.subTree = Ze, ie(ut, Ze, te(ut.el), Re(ut), Ie, We, Ue), Ge.el = Ze.el, pt === null &&
                        updateHOCHostEl(Ie, Ze.el), nt && queuePostRenderEffect(nt, We), (ot = Ge.props && Ge.props
                            .onVnodeUpdated) && queuePostRenderEffect(() => invokeVNodeHook(ot, it, Ge, ft), We)
                } else {
                    let Ge;
                    const {
                        el: Xe,
                        props: nt
                    } = Te, {
                        bm: it,
                        m: ft,
                        parent: pt
                    } = Ie, ot = isAsyncWrapper(Te);
                    if (toggleRecurse(Ie, !1), it && invokeArrayFns(it), !ot && (Ge = nt && nt.onVnodeBeforeMount) &&
                        invokeVNodeHook(Ge, pt, Te), toggleRecurse(Ie, !0), Xe && Le) {
                        const Ze = () => {
                            Ie.subTree = renderComponentRoot(Ie), Le(Xe, Ie.subTree, Ie, We, null)
                        };
                        ot ? Te.type.__asyncLoader().then(() => !Ie.isUnmounted && Ze()) : Ze()
                    } else {
                        const Ze = Ie.subTree = renderComponentRoot(Ie);
                        ie(null, Ze, De, Ke, Ie, We, Ue), Te.el = Ze.el
                    }
                    if (ft && queuePostRenderEffect(ft, We), !ot && (Ge = nt && nt.onVnodeMounted)) {
                        const Ze = Te;
                        queuePostRenderEffect(() => invokeVNodeHook(Ge, pt, Ze), We)
                    }(Te.shapeFlag & 256 || pt && isAsyncWrapper(pt.vnode) && pt.vnode.shapeFlag & 256) && Ie.a &&
                        queuePostRenderEffect(Ie.a, We), Ie.isMounted = !0, Te = De = Ke = null
                }
            },
            ze = Ie.effect = new ReactiveEffect(Ye, () => queueJob(Be), Ie.scope),
            Be = Ie.update = () => ze.run();
        Be.id = Ie.uid, toggleRecurse(Ie, !0), Be()
    }, ye = (Ie, Te, De) => {
        Te.component = Ie;
        const Ke = Ie.vnode.props;
        Ie.vnode = Te, Ie.next = null, updateProps(Ie, Te.props, Ke, De), updateSlots(Ie, Te.children, De),
            pauseTracking(), flushPreFlushCbs(), resetTracking()
    }, Ce = (Ie, Te, De, Ke, We, Ue, et, Ye, ze = !1) => {
        const Be = Ie && Ie.children,
            Ge = Ie ? Ie.shapeFlag : 0,
            Xe = Te.children,
            {
                patchFlag: nt,
                shapeFlag: it
            } = Te;
        if (nt > 0) {
            if (nt & 128) {
                Oe(Be, Xe, De, Ke, We, Ue, et, Ye, ze);
                return
            } else if (nt & 256) {
                we(Be, Xe, De, Ke, We, Ue, et, Ye, ze);
                return
            }
        }
        it & 8 ? (Ge & 16 && Ae(Be, We, Ue), Xe !== Be && ne(De, Xe)) : Ge & 16 ? it & 16 ? Oe(Be, Xe, De, Ke, We,
            Ue, et, Ye, ze) : Ae(Be, We, Ue, !0) : (Ge & 8 && ne(De, ""), it & 16 && me(Xe, De, Ke, We, Ue, et,
            Ye, ze))
    }, we = (Ie, Te, De, Ke, We, Ue, et, Ye, ze) => {
        Ie = Ie || EMPTY_ARR, Te = Te || EMPTY_ARR;
        const Be = Ie.length,
            Ge = Te.length,
            Xe = Math.min(Be, Ge);
        let nt;
        for (nt = 0; nt < Xe; nt++) {
            const it = Te[nt] = ze ? cloneIfMounted(Te[nt]) : normalizeVNode(Te[nt]);
            ie(Ie[nt], it, De, null, We, Ue, et, Ye, ze)
        }
        Be > Ge ? Ae(Ie, We, Ue, !0, !1, Xe) : me(Te, De, Ke, We, Ue, et, Ye, ze, Xe)
    }, Oe = (Ie, Te, De, Ke, We, Ue, et, Ye, ze) => {
        let Be = 0;
        const Ge = Te.length;
        let Xe = Ie.length - 1,
            nt = Ge - 1;
        for (; Be <= Xe && Be <= nt;) {
            const it = Ie[Be],
                ft = Te[Be] = ze ? cloneIfMounted(Te[Be]) : normalizeVNode(Te[Be]);
            if (isSameVNodeType(it, ft)) ie(it, ft, De, null, We, Ue, et, Ye, ze);
            else break;
            Be++
        }
        for (; Be <= Xe && Be <= nt;) {
            const it = Ie[Xe],
                ft = Te[nt] = ze ? cloneIfMounted(Te[nt]) : normalizeVNode(Te[nt]);
            if (isSameVNodeType(it, ft)) ie(it, ft, De, null, We, Ue, et, Ye, ze);
            else break;
            Xe--, nt--
        }
        if (Be > Xe) {
            if (Be <= nt) {
                const it = nt + 1,
                    ft = it < Ge ? Te[it].el : Ke;
                for (; Be <= nt;) ie(null, Te[Be] = ze ? cloneIfMounted(Te[Be]) : normalizeVNode(Te[Be]), De, ft,
                    We, Ue, et, Ye, ze), Be++
            }
        } else if (Be > nt)
            for (; Be <= Xe;) Me(Ie[Be], We, Ue, !0), Be++;
        else {
            const it = Be,
                ft = Be,
                pt = new Map;
            for (Be = ft; Be <= nt; Be++) {
                const Qe = Te[Be] = ze ? cloneIfMounted(Te[Be]) : normalizeVNode(Te[Be]);
                Qe.key != null && pt.set(Qe.key, Be)
            }
            let ot, Ze = 0;
            const ut = nt - ft + 1;
            let st = !1,
                rt = 0;
            const qe = new Array(ut);
            for (Be = 0; Be < ut; Be++) qe[Be] = 0;
            for (Be = it; Be <= Xe; Be++) {
                const Qe = Ie[Be];
                if (Ze >= ut) {
                    Me(Qe, We, Ue, !0);
                    continue
                }
                let lt;
                if (Qe.key != null) lt = pt.get(Qe.key);
                else
                    for (ot = ft; ot <= nt; ot++)
                        if (qe[ot - ft] === 0 && isSameVNodeType(Qe, Te[ot])) {
                            lt = ot;
                            break
                        } lt === void 0 ? Me(Qe, We, Ue, !0) : (qe[lt - ft] = Be + 1, lt >= rt ? rt = lt : st = !0,
                    ie(Qe, Te[lt], De, null, We, Ue, et, Ye, ze), Ze++)
            }
            const Je = st ? getSequence(qe) : EMPTY_ARR;
            for (ot = Je.length - 1, Be = ut - 1; Be >= 0; Be--) {
                const Qe = ft + Be,
                    lt = Te[Qe],
                    ct = Qe + 1 < Ge ? Te[Qe + 1].el : Ke;
                qe[Be] === 0 ? ie(null, lt, De, ct, We, Ue, et, Ye, ze) : st && (ot < 0 || Be !== Je[ot] ? Ne(lt,
                    De, ct, 2) : ot--)
            }
        }
    }, Ne = (Ie, Te, De, Ke, We = null) => {
        const {
            el: Ue,
            type: et,
            transition: Ye,
            children: ze,
            shapeFlag: Be
        } = Ie;
        if (Be & 6) {
            Ne(Ie.component.subTree, Te, De, Ke);
            return
        }
        if (Be & 128) {
            Ie.suspense.move(Te, De, Ke);
            return
        }
        if (Be & 64) {
            et.move(Ie, Te, De, je);
            return
        }
        if (et === Fragment) {
            W(Ue, Te, De);
            for (let Xe = 0; Xe < ze.length; Xe++) Ne(ze[Xe], Te, De, Ke);
            W(Ie.anchor, Te, De);
            return
        }
        if (et === Static) {
            ce(Ie, Te, De);
            return
        }
        if (Ke !== 2 && Be & 1 && Ye)
            if (Ke === 0) Ye.beforeEnter(Ue), W(Ue, Te, De), queuePostRenderEffect(() => Ye.enter(Ue), We);
            else {
                const {
                    leave: Xe,
                    delayLeave: nt,
                    afterLeave: it
                } = Ye, ft = () => W(Ue, Te, De), pt = () => {
                    Xe(Ue, () => {
                        ft(), it && it()
                    })
                };
                nt ? nt(Ue, ft, pt) : pt()
            }
        else W(Ue, Te, De)
    }, Me = (Ie, Te, De, Ke = !1, We = !1) => {
        const {
            type: Ue,
            props: et,
            ref: Ye,
            children: ze,
            dynamicChildren: Be,
            shapeFlag: Ge,
            patchFlag: Xe,
            dirs: nt
        } = Ie;
        if (Ye != null && setRef(Ye, null, De, Ie, !0), Ge & 256) {
            Te.ctx.deactivate(Ie);
            return
        }
        const it = Ge & 1 && nt,
            ft = !isAsyncWrapper(Ie);
        let pt;
        if (ft && (pt = et && et.onVnodeBeforeUnmount) && invokeVNodeHook(pt, Te, Ie), Ge & 6) Ee(Ie.component, De,
            Ke);
        else {
            if (Ge & 128) {
                Ie.suspense.unmount(De, Ke);
                return
            }
            it && invokeDirectiveHook(Ie, null, Te, "beforeUnmount"), Ge & 64 ? Ie.type.remove(Ie, Te, De, We, je,
                Ke) : Be && (Ue !== Fragment || Xe > 0 && Xe & 64) ? Ae(Be, Te, De, !1, !0) : (Ue === Fragment &&
                Xe & 384 || !We && Ge & 16) && Ae(ze, Te, De), Ke && Ve(Ie)
        }(ft && (pt = et && et.onVnodeUnmounted) || it) && queuePostRenderEffect(() => {
            pt && invokeVNodeHook(pt, Te, Ie), it && invokeDirectiveHook(Ie, null, Te, "unmounted")
        }, De)
    }, Ve = Ie => {
        const {
            type: Te,
            el: De,
            anchor: Ke,
            transition: We
        } = Ie;
        if (Te === Fragment) {
            ke(De, Ke);
            return
        }
        if (Te === Static) {
            de(Ie);
            return
        }
        const Ue = () => {
            U(De), We && !We.persisted && We.afterLeave && We.afterLeave()
        };
        if (Ie.shapeFlag & 1 && We && !We.persisted) {
            const {
                leave: et,
                delayLeave: Ye
            } = We, ze = () => et(De, Ue);
            Ye ? Ye(Ie.el, Ue, ze) : ze()
        } else Ue()
    }, ke = (Ie, Te) => {
        let De;
        for (; Ie !== Te;) De = re(Ie), U(Ie), Ie = De;
        U(Te)
    }, Ee = (Ie, Te, De) => {
        const {
            bum: Ke,
            scope: We,
            update: Ue,
            subTree: et,
            um: Ye
        } = Ie;
        Ke && invokeArrayFns(Ke), We.stop(), Ue && (Ue.active = !1, Me(et, Ie, Te, De)), Ye &&
            queuePostRenderEffect(Ye, Te), queuePostRenderEffect(() => {
                Ie.isUnmounted = !0
            }, Te), Te && Te.pendingBranch && !Te.isUnmounted && Ie.asyncDep && !Ie.asyncResolved && Ie.suspenseId ===
            Te.pendingId && (Te.deps--, Te.deps === 0 && Te.resolve())
    }, Ae = (Ie, Te, De, Ke = !1, We = !1, Ue = 0) => {
        for (let et = Ue; et < Ie.length; et++) Me(Ie[et], Te, De, Ke, We)
    }, Re = Ie => Ie.shapeFlag & 6 ? Re(Ie.component.subTree) : Ie.shapeFlag & 128 ? Ie.suspense.next() : re(Ie.anchor ||
        Ie.el), He = (Ie, Te, De) => {
        Ie == null ? Te._vnode && Me(Te._vnode, null, null, !0) : ie(Te._vnode || null, Ie, Te, null, null, null,
            De), flushPreFlushCbs(), flushPostFlushCbs(), Te._vnode = Ie
    }, je = {
        p: ie,
        um: Me,
        m: Ne,
        r: Ve,
        mt: xe,
        mc: me,
        pc: Ce,
        pbc: Se,
        n: Re,
        o: K
    };
    let Fe, Le;
    return C && ([Fe, Le] = C(je)), {
        render: He,
        hydrate: Fe,
        createApp: createAppAPI(He, Fe)
    }
}

function toggleRecurse({
    effect: K,
    update: C
}, H) {
    K.allowRecurse = C.allowRecurse = H
}

function traverseStaticChildren(K, C, H = !1) {
    const W = K.children,
        U = C.children;
    if (isArray$4(W) && isArray$4(U))
        for (let G = 0; G < W.length; G++) {
            const X = W[G];
            let Z = U[G];
            Z.shapeFlag & 1 && !Z.dynamicChildren && ((Z.patchFlag <= 0 || Z.patchFlag === 32) && (Z = U[G] =
                cloneIfMounted(U[G]), Z.el = X.el), H || traverseStaticChildren(X, Z)), Z.type === Text$2 && (Z.el =
                X.el)
        }
}

function getSequence(K) {
    const C = K.slice(),
        H = [0];
    let W, U, G, X, Z;
    const Q = K.length;
    for (W = 0; W < Q; W++) {
        const ee = K[W];
        if (ee !== 0) {
            if (U = H[H.length - 1], K[U] < ee) {
                C[W] = U, H.push(W);
                continue
            }
            for (G = 0, X = H.length - 1; G < X;) Z = G + X >> 1, K[H[Z]] < ee ? G = Z + 1 : X = Z;
            ee < K[H[G]] && (G > 0 && (C[W] = H[G - 1]), H[G] = W)
        }
    }
    for (G = H.length, X = H[G - 1]; G-- > 0;) H[G] = X, X = C[X];
    return H
}
const isTeleport = K => K.__isTeleport,
    isTeleportDisabled = K => K && (K.disabled || K.disabled === ""),
    isTargetSVG = K => typeof SVGElement < "u" && K instanceof SVGElement,
    resolveTarget = (K, C) => {
        const H = K && K.to;
        return isString$3(H) ? C ? C(H) : null : H
    },
    TeleportImpl = {
        __isTeleport: !0,
        process(K, C, H, W, U, G, X, Z, Q, ee) {
            const {
                mc: ne,
                pc: te,
                pbc: re,
                o: {
                    insert: ae,
                    querySelector: oe,
                    createText: ie,
                    createComment: ue
                }
            } = ee, le = isTeleportDisabled(C.props);
            let {
                shapeFlag: se,
                children: ce,
                dynamicChildren: de
            } = C;
            if (K == null) {
                const ve = C.el = ie(""),
                    fe = C.anchor = ie("");
                ae(ve, H, W), ae(fe, H, W);
                const pe = C.target = resolveTarget(C.props, oe),
                    me = C.targetAnchor = ie("");
                pe && (ae(me, pe), X = X || isTargetSVG(pe));
                const he = (Se, _e) => {
                    se & 16 && ne(ce, Se, _e, U, G, X, Z, Q)
                };
                le ? he(H, fe) : pe && he(pe, me)
            } else {
                C.el = K.el;
                const ve = C.anchor = K.anchor,
                    fe = C.target = K.target,
                    pe = C.targetAnchor = K.targetAnchor,
                    me = isTeleportDisabled(K.props),
                    he = me ? H : fe,
                    Se = me ? ve : pe;
                if (X = X || isTargetSVG(fe), de ? (re(K.dynamicChildren, de, he, U, G, X, Z), traverseStaticChildren(K,
                        C, !0)) : Q || te(K, C, he, Se, U, G, X, Z, !1), le) me || moveTeleport(C, H, ve, ee, 1);
                else if ((C.props && C.props.to) !== (K.props && K.props.to)) {
                    const _e = C.target = resolveTarget(C.props, oe);
                    _e && moveTeleport(C, _e, null, ee, 0)
                } else me && moveTeleport(C, fe, pe, ee, 1)
            }
            updateCssVars(C)
        },
        remove(K, C, H, W, {
            um: U,
            o: {
                remove: G
            }
        }, X) {
            const {
                shapeFlag: Z,
                children: Q,
                anchor: ee,
                targetAnchor: ne,
                target: te,
                props: re
            } = K;
            if (te && G(ne), (X || !isTeleportDisabled(re)) && (G(ee), Z & 16))
                for (let ae = 0; ae < Q.length; ae++) {
                    const oe = Q[ae];
                    U(oe, C, H, !0, !!oe.dynamicChildren)
                }
        },
        move: moveTeleport,
        hydrate: hydrateTeleport
    };

function moveTeleport(K, C, H, {
    o: {
        insert: W
    },
    m: U
}, G = 2) {
    G === 0 && W(K.targetAnchor, C, H);
    const {
        el: X,
        anchor: Z,
        shapeFlag: Q,
        children: ee,
        props: ne
    } = K, te = G === 2;
    if (te && W(X, C, H), (!te || isTeleportDisabled(ne)) && Q & 16)
        for (let re = 0; re < ee.length; re++) U(ee[re], C, H, 2);
    te && W(Z, C, H)
}

function hydrateTeleport(K, C, H, W, U, G, {
    o: {
        nextSibling: X,
        parentNode: Z,
        querySelector: Q
    }
}, ee) {
    const ne = C.target = resolveTarget(C.props, Q);
    if (ne) {
        const te = ne._lpa || ne.firstChild;
        if (C.shapeFlag & 16)
            if (isTeleportDisabled(C.props)) C.anchor = ee(X(K), C, Z(K), H, W, U, G), C.targetAnchor = te;
            else {
                C.anchor = X(K);
                let re = te;
                for (; re;)
                    if (re = X(re), re && re.nodeType === 8 && re.data === "teleport anchor") {
                        C.targetAnchor = re, ne._lpa = C.targetAnchor && X(C.targetAnchor);
                        break
                    } ee(te, C, ne, H, W, U, G)
            } updateCssVars(C)
    }
    return C.anchor && X(C.anchor)
}
const Teleport = TeleportImpl;

function updateCssVars(K) {
    const C = K.ctx;
    if (C && C.ut) {
        let H = K.children[0].el;
        for (; H !== K.targetAnchor;) H.nodeType === 1 && H.setAttribute("data-v-owner", C.uid), H = H.nextSibling;
        C.ut()
    }
}
const Fragment = Symbol(void 0),
    Text$2 = Symbol(void 0),
    Comment$1 = Symbol(void 0),
    Static = Symbol(void 0),
    blockStack = [];
let currentBlock = null;

function openBlock(K = !1) {
    blockStack.push(currentBlock = K ? null : [])
}

function closeBlock() {
    blockStack.pop(), currentBlock = blockStack[blockStack.length - 1] || null
}
let isBlockTreeEnabled = 1;

function setBlockTracking(K) {
    isBlockTreeEnabled += K
}

function setupBlock(K) {
    return K.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null, closeBlock(),
        isBlockTreeEnabled > 0 && currentBlock && currentBlock.push(K), K
}

function createElementBlock(K, C, H, W, U, G) {
    return setupBlock(createBaseVNode(K, C, H, W, U, G, !0))
}

function createBlock(K, C, H, W, U) {
    return setupBlock(createVNode(K, C, H, W, U, !0))
}

function isVNode(K) {
    return K ? K.__v_isVNode === !0 : !1
}

function isSameVNodeType(K, C) {
    return K.type === C.type && K.key === C.key
}
const InternalObjectKey = "__vInternal",
    normalizeKey = ({
        key: K
    }) => K || null,
    normalizeRef = ({
        ref: K,
        ref_key: C,
        ref_for: H
    }) => K != null ? isString$3(K) || isRef(K) || isFunction$3(K) ? {
        i: currentRenderingInstance,
        r: K,
        k: C,
        f: !!H
    } : K : null;

function createBaseVNode(K, C = null, H = null, W = 0, U = null, G = K === Fragment ? 0 : 1, X = !1, Z = !1) {
    const Q = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: K,
        props: C,
        key: C && normalizeKey(C),
        ref: C && normalizeRef(C),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children: H,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: G,
        patchFlag: W,
        dynamicProps: U,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
    };
    return Z ? (normalizeChildren(Q, H), G & 128 && K.normalize(Q)) : H && (Q.shapeFlag |= isString$3(H) ? 8 : 16),
        isBlockTreeEnabled > 0 && !X && currentBlock && (Q.patchFlag > 0 || G & 6) && Q.patchFlag !== 32 &&
        currentBlock.push(Q), Q
}
const createVNode = _createVNode;

function _createVNode(K, C = null, H = null, W = 0, U = null, G = !1) {
    if ((!K || K === NULL_DYNAMIC_COMPONENT) && (K = Comment$1), isVNode(K)) {
        const Z = cloneVNode(K, C, !0);
        return H && normalizeChildren(Z, H), isBlockTreeEnabled > 0 && !G && currentBlock && (Z.shapeFlag & 6 ?
            currentBlock[currentBlock.indexOf(K)] = Z : currentBlock.push(Z)), Z.patchFlag |= -2, Z
    }
    if (isClassComponent(K) && (K = K.__vccOpts), C) {
        C = guardReactiveProps(C);
        let {
            class: Z,
            style: Q
        } = C;
        Z && !isString$3(Z) && (C.class = normalizeClass(Z)), isObject$4(Q) && (isProxy(Q) && !isArray$4(Q) && (Q =
            extend$1({}, Q)), C.style = normalizeStyle(Q))
    }
    const X = isString$3(K) ? 1 : isSuspense(K) ? 128 : isTeleport(K) ? 64 : isObject$4(K) ? 4 : isFunction$3(K) ? 2 :
        0;
    return createBaseVNode(K, C, H, W, U, X, G, !0)
}

function guardReactiveProps(K) {
    return K ? isProxy(K) || InternalObjectKey in K ? extend$1({}, K) : K : null
}

function cloneVNode(K, C, H = !1) {
    const {
        props: W,
        ref: U,
        patchFlag: G,
        children: X
    } = K, Z = C ? mergeProps(W || {}, C) : W;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: K.type,
        props: Z,
        key: Z && normalizeKey(Z),
        ref: C && C.ref ? H && U ? isArray$4(U) ? U.concat(normalizeRef(C)) : [U, normalizeRef(C)] : normalizeRef(C) : U,
        scopeId: K.scopeId,
        slotScopeIds: K.slotScopeIds,
        children: X,
        target: K.target,
        targetAnchor: K.targetAnchor,
        staticCount: K.staticCount,
        shapeFlag: K.shapeFlag,
        patchFlag: C && K.type !== Fragment ? G === -1 ? 16 : G | 16 : G,
        dynamicProps: K.dynamicProps,
        dynamicChildren: K.dynamicChildren,
        appContext: K.appContext,
        dirs: K.dirs,
        transition: K.transition,
        component: K.component,
        suspense: K.suspense,
        ssContent: K.ssContent && cloneVNode(K.ssContent),
        ssFallback: K.ssFallback && cloneVNode(K.ssFallback),
        el: K.el,
        anchor: K.anchor,
        ctx: K.ctx,
        ce: K.ce
    }
}

function createTextVNode(K = " ", C = 0) {
    return createVNode(Text$2, null, K, C)
}

function createCommentVNode(K = "", C = !1) {
    return C ? (openBlock(), createBlock(Comment$1, null, K)) : createVNode(Comment$1, null, K)
}

function normalizeVNode(K) {
    return K == null || typeof K == "boolean" ? createVNode(Comment$1) : isArray$4(K) ? createVNode(Fragment, null, K.slice()) :
        typeof K == "object" ? cloneIfMounted(K) : createVNode(Text$2, null, String(K))
}

function cloneIfMounted(K) {
    return K.el === null && K.patchFlag !== -1 || K.memo ? K : cloneVNode(K)
}

function normalizeChildren(K, C) {
    let H = 0;
    const {
        shapeFlag: W
    } = K;
    if (C == null) C = null;
    else if (isArray$4(C)) H = 16;
    else if (typeof C == "object")
        if (W & 65) {
            const U = C.default;
            U && (U._c && (U._d = !1), normalizeChildren(K, U()), U._c && (U._d = !0));
            return
        } else {
            H = 32;
            const U = C._;
            !U && !(InternalObjectKey in C) ? C._ctx = currentRenderingInstance : U === 3 && currentRenderingInstance &&
                (currentRenderingInstance.slots._ === 1 ? C._ = 1 : (C._ = 2, K.patchFlag |= 1024))
        }
    else isFunction$3(C) ? (C = {
        default: C,
        _ctx: currentRenderingInstance
    }, H = 32) : (C = String(C), W & 64 ? (H = 16, C = [createTextVNode(C)]) : H = 8);
    K.children = C, K.shapeFlag |= H
}

function mergeProps(...K) {
    const C = {};
    for (let H = 0; H < K.length; H++) {
        const W = K[H];
        for (const U in W)
            if (U === "class") C.class !== W.class && (C.class = normalizeClass([C.class, W.class]));
            else if (U === "style") C.style = normalizeStyle([C.style, W.style]);
        else if (isOn$1(U)) {
            const G = C[U],
                X = W[U];
            X && G !== X && !(isArray$4(G) && G.includes(X)) && (C[U] = G ? [].concat(G, X) : X)
        } else U !== "" && (C[U] = W[U])
    }
    return C
}

function invokeVNodeHook(K, C, H, W = null) {
    callWithAsyncErrorHandling(K, C, 7, [H, W])
}
const emptyAppContext = createAppContext();
let uid$2 = 0;

function createComponentInstance(K, C, H) {
    const W = K.type,
        U = (C ? C.appContext : K.appContext) || emptyAppContext,
        G = {
            uid: uid$2++,
            vnode: K,
            type: W,
            parent: C,
            appContext: U,
            root: null,
            next: null,
            subTree: null,
            effect: null,
            update: null,
            scope: new EffectScope(!0),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: C ? C.provides : Object.create(U.provides),
            accessCache: null,
            renderCache: [],
            components: null,
            directives: null,
            propsOptions: normalizePropsOptions(W, U),
            emitsOptions: normalizeEmitsOptions(W, U),
            emit: null,
            emitted: null,
            propsDefaults: EMPTY_OBJ,
            inheritAttrs: W.inheritAttrs,
            ctx: EMPTY_OBJ,
            data: EMPTY_OBJ,
            props: EMPTY_OBJ,
            attrs: EMPTY_OBJ,
            slots: EMPTY_OBJ,
            refs: EMPTY_OBJ,
            setupState: EMPTY_OBJ,
            setupContext: null,
            suspense: H,
            suspenseId: H ? H.pendingId : 0,
            asyncDep: null,
            asyncResolved: !1,
            isMounted: !1,
            isUnmounted: !1,
            isDeactivated: !1,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null
        };
    return G.ctx = {
        _: G
    }, G.root = C ? C.root : G, G.emit = emit.bind(null, G), K.ce && K.ce(G), G
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance,
    setCurrentInstance = K => {
        currentInstance = K, K.scope.on()
    },
    unsetCurrentInstance = () => {
        currentInstance && currentInstance.scope.off(), currentInstance = null
    };

function isStatefulComponent(K) {
    return K.vnode.shapeFlag & 4
}
let isInSSRComponentSetup = !1;

function setupComponent(K, C = !1) {
    isInSSRComponentSetup = C;
    const {
        props: H,
        children: W
    } = K.vnode, U = isStatefulComponent(K);
    initProps(K, H, U, C), initSlots(K, W);
    const G = U ? setupStatefulComponent(K, C) : void 0;
    return isInSSRComponentSetup = !1, G
}

function setupStatefulComponent(K, C) {
    const H = K.type;
    K.accessCache = Object.create(null), K.proxy = markRaw(new Proxy(K.ctx, PublicInstanceProxyHandlers));
    const {
        setup: W
    } = H;
    if (W) {
        const U = K.setupContext = W.length > 1 ? createSetupContext(K) : null;
        setCurrentInstance(K), pauseTracking();
        const G = callWithErrorHandling(W, K, 0, [K.props, U]);
        if (resetTracking(), unsetCurrentInstance(), isPromise(G)) {
            if (G.then(unsetCurrentInstance, unsetCurrentInstance), C) return G.then(X => {
                handleSetupResult(K, X, C)
            }).catch(X => {
                handleError(X, K, 0)
            });
            K.asyncDep = G
        } else handleSetupResult(K, G, C)
    } else finishComponentSetup(K, C)
}

function handleSetupResult(K, C, H) {
    isFunction$3(C) ? K.type.__ssrInlineRender ? K.ssrRender = C : K.render = C : isObject$4(C) && (K.setupState =
        proxyRefs(C)), finishComponentSetup(K, H)
}
let compile;

function finishComponentSetup(K, C, H) {
    const W = K.type;
    if (!K.render) {
        if (!C && compile && !W.render) {
            const U = W.template || resolveMergedOptions(K).template;
            if (U) {
                const {
                    isCustomElement: G,
                    compilerOptions: X
                } = K.appContext.config, {
                    delimiters: Z,
                    compilerOptions: Q
                } = W, ee = extend$1(extend$1({
                    isCustomElement: G,
                    delimiters: Z
                }, X), Q);
                W.render = compile(U, ee)
            }
        }
        K.render = W.render || NOOP
    }
    setCurrentInstance(K), pauseTracking(), applyOptions(K), resetTracking(), unsetCurrentInstance()
}

function createAttrsProxy(K) {
    return new Proxy(K.attrs, {
        get(C, H) {
            return track(K, "get", "$attrs"), C[H]
        }
    })
}

function createSetupContext(K) {
    const C = W => {
        K.exposed = W || {}
    };
    let H;
    return {
        get attrs() {
            return H || (H = createAttrsProxy(K))
        },
        slots: K.slots,
        emit: K.emit,
        expose: C
    }
}

function getExposeProxy(K) {
    if (K.exposed) return K.exposeProxy || (K.exposeProxy = new Proxy(proxyRefs(markRaw(K.exposed)), {
        get(C, H) {
            if (H in C) return C[H];
            if (H in publicPropertiesMap) return publicPropertiesMap[H](K)
        },
        has(C, H) {
            return H in C || H in publicPropertiesMap
        }
    }))
}

function getComponentName(K, C = !0) {
    return isFunction$3(K) ? K.displayName || K.name : K.name || C && K.__name
}

function isClassComponent(K) {
    return isFunction$3(K) && "__vccOpts" in K
}
const computed = (K, C) => computed$1(K, C, isInSSRComponentSetup);

function useAttrs() {
    return getContext().attrs
}

function getContext() {
    const K = getCurrentInstance();
    return K.setupContext || (K.setupContext = createSetupContext(K))
}

function h$1(K, C, H) {
    const W = arguments.length;
    return W === 2 ? isObject$4(C) && !isArray$4(C) ? isVNode(C) ? createVNode(K, null, [C]) : createVNode(K, C) :
        createVNode(K, null, C) : (W > 3 ? H = Array.prototype.slice.call(arguments, 2) : W === 3 && isVNode(H) && (H = [
            H]), createVNode(K, C, H))
}
const ssrContextKey = Symbol(""),
    useSSRContext = () => inject(ssrContextKey),
    version$1 = "3.2.47",
    svgNS = "http://www.w3.org/2000/svg",
    doc = typeof document < "u" ? document : null,
    templateContainer = doc && doc.createElement("template"),
    nodeOps = {
        insert: (K, C, H) => {
            C.insertBefore(K, H || null)
        },
        remove: K => {
            const C = K.parentNode;
            C && C.removeChild(K)
        },
        createElement: (K, C, H, W) => {
            const U = C ? doc.createElementNS(svgNS, K) : doc.createElement(K, H ? {
                is: H
            } : void 0);
            return K === "select" && W && W.multiple != null && U.setAttribute("multiple", W.multiple), U
        },
        createText: K => doc.createTextNode(K),
        createComment: K => doc.createComment(K),
        setText: (K, C) => {
            K.nodeValue = C
        },
        setElementText: (K, C) => {
            K.textContent = C
        },
        parentNode: K => K.parentNode,
        nextSibling: K => K.nextSibling,
        querySelector: K => doc.querySelector(K),
        setScopeId(K, C) {
            K.setAttribute(C, "")
        },
        insertStaticContent(K, C, H, W, U, G) {
            const X = H ? H.previousSibling : C.lastChild;
            if (U && (U === G || U.nextSibling))
                for (; C.insertBefore(U.cloneNode(!0), H), !(U === G || !(U = U.nextSibling)););
            else {
                templateContainer.innerHTML = W ? `<svg>${K}</svg>` : K;
                const Z = templateContainer.content;
                if (W) {
                    const Q = Z.firstChild;
                    for (; Q.firstChild;) Z.appendChild(Q.firstChild);
                    Z.removeChild(Q)
                }
                C.insertBefore(Z, H)
            }
            return [X ? X.nextSibling : C.firstChild, H ? H.previousSibling : C.lastChild]
        }
    };

function patchClass(K, C, H) {
    const W = K._vtc;
    W && (C = (C ? [C, ...W] : [...W]).join(" ")), C == null ? K.removeAttribute("class") : H ? K.setAttribute("class",
        C) : K.className = C
}

function patchStyle(K, C, H) {
    const W = K.style,
        U = isString$3(H);
    if (H && !U) {
        if (C && !isString$3(C))
            for (const G in C) H[G] == null && setStyle$1(W, G, "");
        for (const G in H) setStyle$1(W, G, H[G])
    } else {
        const G = W.display;
        U ? C !== H && (W.cssText = H) : C && K.removeAttribute("style"), "_vod" in K && (W.display = G)
    }
}
const importantRE = /\s*!important$/;

function setStyle$1(K, C, H) {
    if (isArray$4(H)) H.forEach(W => setStyle$1(K, C, W));
    else if (H == null && (H = ""), C.startsWith("--")) K.setProperty(C, H);
    else {
        const W = autoPrefix(K, C);
        importantRE.test(H) ? K.setProperty(hyphenate$1(W), H.replace(importantRE, ""), "important") : K[W] = H
    }
}
const prefixes = ["Webkit", "Moz", "ms"],
    prefixCache = {};

function autoPrefix(K, C) {
    const H = prefixCache[C];
    if (H) return H;
    let W = camelize$1(C);
    if (W !== "filter" && W in K) return prefixCache[C] = W;
    W = capitalize(W);
    for (let U = 0; U < prefixes.length; U++) {
        const G = prefixes[U] + W;
        if (G in K) return prefixCache[C] = G
    }
    return C
}
const xlinkNS = "http://www.w3.org/1999/xlink";

function patchAttr(K, C, H, W, U) {
    if (W && C.startsWith("xlink:")) H == null ? K.removeAttributeNS(xlinkNS, C.slice(6, C.length)) : K.setAttributeNS(
        xlinkNS, C, H);
    else {
        const G = isSpecialBooleanAttr(C);
        H == null || G && !includeBooleanAttr(H) ? K.removeAttribute(C) : K.setAttribute(C, G ? "" : H)
    }
}

function patchDOMProp(K, C, H, W, U, G, X) {
    if (C === "innerHTML" || C === "textContent") {
        W && X(W, U, G), K[C] = H || "";
        return
    }
    if (C === "value" && K.tagName !== "PROGRESS" && !K.tagName.includes("-")) {
        K._value = H;
        const Q = H || "";
        (K.value !== Q || K.tagName === "OPTION") && (K.value = Q), H == null && K.removeAttribute(C);
        return
    }
    let Z = !1;
    if (H === "" || H == null) {
        const Q = typeof K[C];
        Q === "boolean" ? H = includeBooleanAttr(H) : H == null && Q === "string" ? (H = "", Z = !0) : Q === "number" &&
            (H = 0, Z = !0)
    }
    try {
        K[C] = H
    } catch {}
    Z && K.removeAttribute(C)
}

function addEventListener$3(K, C, H, W) {
    K.addEventListener(C, H, W)
}

function removeEventListener$2(K, C, H, W) {
    K.removeEventListener(C, H, W)
}

function patchEvent(K, C, H, W, U = null) {
    const G = K._vei || (K._vei = {}),
        X = G[C];
    if (W && X) X.value = W;
    else {
        const [Z, Q] = parseName(C);
        if (W) {
            const ee = G[C] = createInvoker(W, U);
            addEventListener$3(K, Z, ee, Q)
        } else X && (removeEventListener$2(K, Z, X, Q), G[C] = void 0)
    }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;

function parseName(K) {
    let C;
    if (optionsModifierRE.test(K)) {
        C = {};
        let W;
        for (; W = K.match(optionsModifierRE);) K = K.slice(0, K.length - W[0].length), C[W[0].toLowerCase()] = !0
    }
    return [K[2] === ":" ? K.slice(3) : hyphenate$1(K.slice(2)), C]
}
let cachedNow = 0;
const p = Promise.resolve(),
    getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());

function createInvoker(K, C) {
    const H = W => {
        if (!W._vts) W._vts = Date.now();
        else if (W._vts <= H.attached) return;
        callWithAsyncErrorHandling(patchStopImmediatePropagation(W, H.value), C, 5, [W])
    };
    return H.value = K, H.attached = getNow(), H
}

function patchStopImmediatePropagation(K, C) {
    if (isArray$4(C)) {
        const H = K.stopImmediatePropagation;
        return K.stopImmediatePropagation = () => {
            H.call(K), K._stopped = !0
        }, C.map(W => U => !U._stopped && W && W(U))
    } else return C
}
const nativeOnRE = /^on[a-z]/,
    patchProp = (K, C, H, W, U = !1, G, X, Z, Q) => {
        C === "class" ? patchClass(K, W, U) : C === "style" ? patchStyle(K, H, W) : isOn$1(C) ? isModelListener(C) ||
            patchEvent(K, C, H, W, X) : (C[0] === "." ? (C = C.slice(1), !0) : C[0] === "^" ? (C = C.slice(1), !1) :
                shouldSetAsProp(K, C, W, U)) ? patchDOMProp(K, C, W, G, X, Z, Q) : (C === "true-value" ? K._trueValue =
                W : C === "false-value" && (K._falseValue = W), patchAttr(K, C, W, U))
    };

function shouldSetAsProp(K, C, H, W) {
    return W ? !!(C === "innerHTML" || C === "textContent" || C in K && nativeOnRE.test(C) && isFunction$3(H)) : C ===
        "spellcheck" || C === "draggable" || C === "translate" || C === "form" || C === "list" && K.tagName === "INPUT" ||
        C === "type" && K.tagName === "TEXTAREA" || nativeOnRE.test(C) && isString$3(H) ? !1 : C in K
}
const TRANSITION = "transition",
    ANIMATION = "animation",
    Transition = (K, {
        slots: C
    }) => h$1(BaseTransition, resolveTransitionProps(K), C);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
        name: String,
        type: String,
        css: {
            type: Boolean,
            default: !0
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
    },
    TransitionPropsValidators = Transition.props = extend$1({}, BaseTransition.props, DOMTransitionPropsValidators),
    callHook = (K, C = []) => {
        isArray$4(K) ? K.forEach(H => H(...C)) : K && K(...C)
    },
    hasExplicitCallback = K => K ? isArray$4(K) ? K.some(C => C.length > 1) : K.length > 1 : !1;

function resolveTransitionProps(K) {
    const C = {};
    for (const be in K) be in DOMTransitionPropsValidators || (C[be] = K[be]);
    if (K.css === !1) return C;
    const {
        name: H = "v",
        type: W,
        duration: U,
        enterFromClass: G = `${H}-enter-from`,
        enterActiveClass: X = `${H}-enter-active`,
        enterToClass: Z = `${H}-enter-to`,
        appearFromClass: Q = G,
        appearActiveClass: ee = X,
        appearToClass: ne = Z,
        leaveFromClass: te = `${H}-leave-from`,
        leaveActiveClass: re = `${H}-leave-active`,
        leaveToClass: ae = `${H}-leave-to`
    } = K, oe = normalizeDuration(U), ie = oe && oe[0], ue = oe && oe[1], {
        onBeforeEnter: le,
        onEnter: se,
        onEnterCancelled: ce,
        onLeave: de,
        onLeaveCancelled: ve,
        onBeforeAppear: fe = le,
        onAppear: pe = se,
        onAppearCancelled: me = ce
    } = C, he = (be, ge, xe) => {
        removeTransitionClass(be, ge ? ne : Z), removeTransitionClass(be, ge ? ee : X), xe && xe()
    }, Se = (be, ge) => {
        be._isLeaving = !1, removeTransitionClass(be, te), removeTransitionClass(be, ae), removeTransitionClass(be,
            re), ge && ge()
    }, _e = be => (ge, xe) => {
        const Pe = be ? pe : se,
            $e = () => he(ge, be, xe);
        callHook(Pe, [ge, $e]), nextFrame(() => {
            removeTransitionClass(ge, be ? Q : G), addTransitionClass(ge, be ? ne : Z), hasExplicitCallback(
                Pe) || whenTransitionEnds(ge, W, ie, $e)
        })
    };
    return extend$1(C, {
        onBeforeEnter(be) {
            callHook(le, [be]), addTransitionClass(be, G), addTransitionClass(be, X)
        },
        onBeforeAppear(be) {
            callHook(fe, [be]), addTransitionClass(be, Q), addTransitionClass(be, ee)
        },
        onEnter: _e(!1),
        onAppear: _e(!0),
        onLeave(be, ge) {
            be._isLeaving = !0;
            const xe = () => Se(be, ge);
            addTransitionClass(be, te), forceReflow(), addTransitionClass(be, re), nextFrame(() => {
                be._isLeaving && (removeTransitionClass(be, te), addTransitionClass(be, ae),
                    hasExplicitCallback(de) || whenTransitionEnds(be, W, ue, xe))
            }), callHook(de, [be, xe])
        },
        onEnterCancelled(be) {
            he(be, !1), callHook(ce, [be])
        },
        onAppearCancelled(be) {
            he(be, !0), callHook(me, [be])
        },
        onLeaveCancelled(be) {
            Se(be), callHook(ve, [be])
        }
    })
}

function normalizeDuration(K) {
    if (K == null) return null;
    if (isObject$4(K)) return [NumberOf(K.enter), NumberOf(K.leave)]; {
        const C = NumberOf(K);
        return [C, C]
    }
}

function NumberOf(K) {
    return toNumber$1(K)
}

function addTransitionClass(K, C) {
    C.split(/\s+/).forEach(H => H && K.classList.add(H)), (K._vtc || (K._vtc = new Set)).add(C)
}

function removeTransitionClass(K, C) {
    C.split(/\s+/).forEach(W => W && K.classList.remove(W));
    const {
        _vtc: H
    } = K;
    H && (H.delete(C), H.size || (K._vtc = void 0))
}

function nextFrame(K) {
    requestAnimationFrame(() => {
        requestAnimationFrame(K)
    })
}
let endId = 0;

function whenTransitionEnds(K, C, H, W) {
    const U = K._endId = ++endId,
        G = () => {
            U === K._endId && W()
        };
    if (H) return setTimeout(G, H);
    const {
        type: X,
        timeout: Z,
        propCount: Q
    } = getTransitionInfo(K, C);
    if (!X) return W();
    const ee = X + "end";
    let ne = 0;
    const te = () => {
            K.removeEventListener(ee, re), G()
        },
        re = ae => {
            ae.target === K && ++ne >= Q && te()
        };
    setTimeout(() => {
        ne < Q && te()
    }, Z + 1), K.addEventListener(ee, re)
}

function getTransitionInfo(K, C) {
    const H = window.getComputedStyle(K),
        W = oe => (H[oe] || "").split(", "),
        U = W(`${TRANSITION}Delay`),
        G = W(`${TRANSITION}Duration`),
        X = getTimeout(U, G),
        Z = W(`${ANIMATION}Delay`),
        Q = W(`${ANIMATION}Duration`),
        ee = getTimeout(Z, Q);
    let ne = null,
        te = 0,
        re = 0;
    C === TRANSITION ? X > 0 && (ne = TRANSITION, te = X, re = G.length) : C === ANIMATION ? ee > 0 && (ne = ANIMATION,
        te = ee, re = Q.length) : (te = Math.max(X, ee), ne = te > 0 ? X > ee ? TRANSITION : ANIMATION : null, re =
        ne ? ne === TRANSITION ? G.length : Q.length : 0);
    const ae = ne === TRANSITION && /\b(transform|all)(,|$)/.test(W(`${TRANSITION}Property`).toString());
    return {
        type: ne,
        timeout: te,
        propCount: re,
        hasTransform: ae
    }
}

function getTimeout(K, C) {
    for (; K.length < C.length;) K = K.concat(K);
    return Math.max(...C.map((H, W) => toMs(H) + toMs(K[W])))
}

function toMs(K) {
    return Number(K.slice(0, -1).replace(",", ".")) * 1e3
}

function forceReflow() {
    return document.body.offsetHeight
}
const positionMap = new WeakMap,
    newPositionMap = new WeakMap,
    TransitionGroupImpl = {
        name: "TransitionGroup",
        props: extend$1({}, TransitionPropsValidators, {
            tag: String,
            moveClass: String
        }),
        setup(K, {
            slots: C
        }) {
            const H = getCurrentInstance(),
                W = useTransitionState();
            let U, G;
            return onUpdated(() => {
                if (!U.length) return;
                const X = K.moveClass || `${K.name||"v"}-move`;
                if (!hasCSSTransform(U[0].el, H.vnode.el, X)) return;
                U.forEach(callPendingCbs), U.forEach(recordPosition);
                const Z = U.filter(applyTranslation);
                forceReflow(), Z.forEach(Q => {
                    const ee = Q.el,
                        ne = ee.style;
                    addTransitionClass(ee, X), ne.transform = ne.webkitTransform = ne.transitionDuration =
                        "";
                    const te = ee._moveCb = re => {
                        re && re.target !== ee || (!re || /transform$/.test(re.propertyName)) && (
                            ee.removeEventListener("transitionend", te), ee._moveCb = null,
                            removeTransitionClass(ee, X))
                    };
                    ee.addEventListener("transitionend", te)
                })
            }), () => {
                const X = toRaw(K),
                    Z = resolveTransitionProps(X);
                let Q = X.tag || Fragment;
                U = G, G = C.default ? getTransitionRawChildren(C.default()) : [];
                for (let ee = 0; ee < G.length; ee++) {
                    const ne = G[ee];
                    ne.key != null && setTransitionHooks(ne, resolveTransitionHooks(ne, Z, W, H))
                }
                if (U)
                    for (let ee = 0; ee < U.length; ee++) {
                        const ne = U[ee];
                        setTransitionHooks(ne, resolveTransitionHooks(ne, Z, W, H)), positionMap.set(ne, ne.el.getBoundingClientRect())
                    }
                return createVNode(Q, null, G)
            }
        }
    },
    removeMode = K => delete K.mode;
TransitionGroupImpl.props;
const TransitionGroup = TransitionGroupImpl;

function callPendingCbs(K) {
    const C = K.el;
    C._moveCb && C._moveCb(), C._enterCb && C._enterCb()
}

function recordPosition(K) {
    newPositionMap.set(K, K.el.getBoundingClientRect())
}

function applyTranslation(K) {
    const C = positionMap.get(K),
        H = newPositionMap.get(K),
        W = C.left - H.left,
        U = C.top - H.top;
    if (W || U) {
        const G = K.el.style;
        return G.transform = G.webkitTransform = `translate(${W}px,${U}px)`, G.transitionDuration = "0s", K
    }
}

function hasCSSTransform(K, C, H) {
    const W = K.cloneNode();
    K._vtc && K._vtc.forEach(X => {
        X.split(/\s+/).forEach(Z => Z && W.classList.remove(Z))
    }), H.split(/\s+/).forEach(X => X && W.classList.add(X)), W.style.display = "none";
    const U = C.nodeType === 1 ? C : C.parentNode;
    U.appendChild(W);
    const {
        hasTransform: G
    } = getTransitionInfo(W);
    return U.removeChild(W), G
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"],
    modifierGuards = {
        stop: K => K.stopPropagation(),
        prevent: K => K.preventDefault(),
        self: K => K.target !== K.currentTarget,
        ctrl: K => !K.ctrlKey,
        shift: K => !K.shiftKey,
        alt: K => !K.altKey,
        meta: K => !K.metaKey,
        left: K => "button" in K && K.button !== 0,
        middle: K => "button" in K && K.button !== 1,
        right: K => "button" in K && K.button !== 2,
        exact: (K, C) => systemModifiers.some(H => K[`${H}Key`] && !C.includes(H))
    },
    withModifiers = (K, C) => (H, ...W) => {
        for (let U = 0; U < C.length; U++) {
            const G = modifierGuards[C[U]];
            if (G && G(H, C)) return
        }
        return K(H, ...W)
    },
    vShow = {
        beforeMount(K, {
            value: C
        }, {
            transition: H
        }) {
            K._vod = K.style.display === "none" ? "" : K.style.display, H && C ? H.beforeEnter(K) : setDisplay(K, C)
        },
        mounted(K, {
            value: C
        }, {
            transition: H
        }) {
            H && C && H.enter(K)
        },
        updated(K, {
            value: C,
            oldValue: H
        }, {
            transition: W
        }) {
            !C != !H && (W ? C ? (W.beforeEnter(K), setDisplay(K, !0), W.enter(K)) : W.leave(K, () => {
                setDisplay(K, !1)
            }) : setDisplay(K, C))
        },
        beforeUnmount(K, {
            value: C
        }) {
            setDisplay(K, C)
        }
    };

function setDisplay(K, C) {
    K.style.display = C ? K._vod : "none"
}
const rendererOptions = extend$1({
    patchProp
}, nodeOps);
let renderer;

function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions))
}
const render = (...K) => {
        ensureRenderer().render(...K)
    },
    createApp = (...K) => {
        const C = ensureRenderer().createApp(...K),
            {
                mount: H
            } = C;
        return C.mount = W => {
            const U = normalizeContainer(W);
            if (!U) return;
            const G = C._component;
            !isFunction$3(G) && !G.render && !G.template && (G.template = U.innerHTML), U.innerHTML = "";
            const X = H(U, !1, U instanceof SVGElement);
            return U instanceof Element && (U.removeAttribute("v-cloak"), U.setAttribute("data-v-app", "")), X
        }, C
    };

function normalizeContainer(K) {
    return isString$3(K) ? document.querySelector(K) : K
}

function _typeof$2(K) {
    return _typeof$2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (C) {
        return typeof C
    } : function (C) {
        return C && typeof Symbol == "function" && C.constructor === Symbol && C !== Symbol.prototype ? "symbol" :
            typeof C
    }, _typeof$2(K)
}

function _toPrimitive(K, C) {
    if (_typeof$2(K) !== "object" || K === null) return K;
    var H = K[Symbol.toPrimitive];
    if (H !== void 0) {
        var W = H.call(K, C || "default");
        if (_typeof$2(W) !== "object") return W;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (C === "string" ? String : Number)(K)
}

function _toPropertyKey(K) {
    var C = _toPrimitive(K, "string");
    return _typeof$2(C) === "symbol" ? C : String(C)
}

function _defineProperty$V(K, C, H) {
    return C = _toPropertyKey(C), C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}

function ownKeys$1(K, C) {
    var H = Object.keys(K);
    if (Object.getOwnPropertySymbols) {
        var W = Object.getOwnPropertySymbols(K);
        C && (W = W.filter(function (U) {
            return Object.getOwnPropertyDescriptor(K, U).enumerable
        })), H.push.apply(H, W)
    }
    return H
}

function _objectSpread2$1(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? arguments[C] : {};
        C % 2 ? ownKeys$1(Object(H), !0).forEach(function (W) {
                _defineProperty$V(K, W, H[W])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(K, Object.getOwnPropertyDescriptors(H)) :
            ownKeys$1(Object(H)).forEach(function (W) {
                Object.defineProperty(K, W, Object.getOwnPropertyDescriptor(H, W))
            })
    }
    return K
}

function _extends$1() {
    return _extends$1 = Object.assign ? Object.assign.bind() : function (K) {
        for (var C = 1; C < arguments.length; C++) {
            var H = arguments[C];
            for (var W in H) Object.prototype.hasOwnProperty.call(H, W) && (K[W] = H[W])
        }
        return K
    }, _extends$1.apply(this, arguments)
}
var isFunction$2 = function (C) {
        return typeof C == "function"
    },
    isArray$3 = Array.isArray,
    isString$2 = function (C) {
        return typeof C == "string"
    },
    isObject$3 = function (C) {
        return C !== null && _typeof$2(C) === "object"
    },
    onRE = /^on[^a-z]/,
    isOn = function (C) {
        return onRE.test(C)
    },
    cacheStringFunction = function (C) {
        var H = Object.create(null);
        return function (W) {
            var U = H[W];
            return U || (H[W] = C(W))
        }
    },
    camelizeRE = /-(\w)/g,
    camelize = cacheStringFunction(function (K) {
        return K.replace(camelizeRE, function (C, H) {
            return H ? H.toUpperCase() : ""
        })
    }),
    hyphenateRE = /\B([A-Z])/g,
    hyphenate = cacheStringFunction(function (K) {
        return K.replace(hyphenateRE, "-$1").toLowerCase()
    }),
    hasOwnProperty$d = Object.prototype.hasOwnProperty,
    hasOwn = function (C, H) {
        return hasOwnProperty$d.call(C, H)
    };

function resolvePropValue(K, C, H, W) {
    var U = K[H];
    if (U != null) {
        var G = hasOwn(U, "default");
        if (G && W === void 0) {
            var X = U.default;
            W = U.type !== Function && isFunction$2(X) ? X() : X
        }
        U.type === Boolean && (!hasOwn(C, H) && !G ? W = !1 : W === "" && (W = !0))
    }
    return W
}

function getDataAndAriaProps(K) {
    return Object.keys(K).reduce(function (C, H) {
        return (H.substr(0, 5) === "data-" || H.substr(0, 5) === "aria-") && (C[H] = K[H]), C
    }, {})
}

function toPx(K) {
    return typeof K == "number" ? "".concat(K, "px") : K
}

function renderHelper(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        H = arguments.length > 2 ? arguments[2] : void 0;
    return typeof K == "function" ? K(C) : K || H
}

function classNames() {
    for (var K = [], C = 0; C < arguments.length; C++) {
        var H = C < 0 || arguments.length <= C ? void 0 : arguments[C];
        if (H) {
            if (isString$2(H)) K.push(H);
            else if (isArray$3(H))
                for (var W = 0; W < H.length; W++) {
                    var U = classNames(H[W]);
                    U && K.push(U)
                } else if (isObject$3(H))
                    for (var G in H) H[G] && K.push(G)
        }
    }
    return K.join(" ")
}
var MapShim = function () {
        if (typeof Map < "u") return Map;

        function K(C, H) {
            var W = -1;
            return C.some(function (U, G) {
                return U[0] === H ? (W = G, !0) : !1
            }), W
        }
        return function () {
            function C() {
                this.__entries__ = []
            }
            return Object.defineProperty(C.prototype, "size", {
                get: function () {
                    return this.__entries__.length
                },
                enumerable: !0,
                configurable: !0
            }), C.prototype.get = function (H) {
                var W = K(this.__entries__, H),
                    U = this.__entries__[W];
                return U && U[1]
            }, C.prototype.set = function (H, W) {
                var U = K(this.__entries__, H);
                ~U ? this.__entries__[U][1] = W : this.__entries__.push([H, W])
            }, C.prototype.delete = function (H) {
                var W = this.__entries__,
                    U = K(W, H);
                ~U && W.splice(U, 1)
            }, C.prototype.has = function (H) {
                return !!~K(this.__entries__, H)
            }, C.prototype.clear = function () {
                this.__entries__.splice(0)
            }, C.prototype.forEach = function (H, W) {
                W === void 0 && (W = null);
                for (var U = 0, G = this.__entries__; U < G.length; U++) {
                    var X = G[U];
                    H.call(W, X[1], X[0])
                }
            }, C
        }()
    }(),
    isBrowser = typeof window < "u" && typeof document < "u" && window.document === document,
    global$1 = function () {
        return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self :
            typeof window < "u" && window.Math === Math ? window : Function("return this")()
    }(),
    requestAnimationFrame$1 = function () {
        return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(global$1) : function (K) {
            return setTimeout(function () {
                return K(Date.now())
            }, 1e3 / 60)
        }
    }(),
    trailingTimeout = 2;

function throttle(K, C) {
    var H = !1,
        W = !1,
        U = 0;

    function G() {
        H && (H = !1, K()), W && Z()
    }

    function X() {
        requestAnimationFrame$1(G)
    }

    function Z() {
        var Q = Date.now();
        if (H) {
            if (Q - U < trailingTimeout) return;
            W = !0
        } else H = !0, W = !1, setTimeout(X, C);
        U = Q
    }
    return Z
}
var REFRESH_DELAY = 20,
    transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"],
    mutationObserverSupported = typeof MutationObserver < "u",
    ResizeObserverController = function () {
        function K() {
            this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [],
                this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = throttle(this.refresh.bind(
                    this), REFRESH_DELAY)
        }
        return K.prototype.addObserver = function (C) {
            ~this.observers_.indexOf(C) || this.observers_.push(C), this.connected_ || this.connect_()
        }, K.prototype.removeObserver = function (C) {
            var H = this.observers_,
                W = H.indexOf(C);
            ~W && H.splice(W, 1), !H.length && this.connected_ && this.disconnect_()
        }, K.prototype.refresh = function () {
            var C = this.updateObservers_();
            C && this.refresh()
        }, K.prototype.updateObservers_ = function () {
            var C = this.observers_.filter(function (H) {
                return H.gatherActive(), H.hasActive()
            });
            return C.forEach(function (H) {
                return H.broadcastActive()
            }), C.length > 0
        }, K.prototype.connect_ = function () {
            !isBrowser || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_),
                window.addEventListener("resize", this.refresh), mutationObserverSupported ? (this.mutationsObserver_ =
                    new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
                        attributes: !0,
                        childList: !0,
                        characterData: !0,
                        subtree: !0
                    })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !
                    0), this.connected_ = !0)
        }, K.prototype.disconnect_ = function () {
            !isBrowser || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_),
                window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_
                .disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified",
                    this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !
                1)
        }, K.prototype.onTransitionEnd_ = function (C) {
            var H = C.propertyName,
                W = H === void 0 ? "" : H,
                U = transitionKeys.some(function (G) {
                    return !!~W.indexOf(G)
                });
            U && this.refresh()
        }, K.getInstance = function () {
            return this.instance_ || (this.instance_ = new K), this.instance_
        }, K.instance_ = null, K
    }(),
    defineConfigurable = function (K, C) {
        for (var H = 0, W = Object.keys(C); H < W.length; H++) {
            var U = W[H];
            Object.defineProperty(K, U, {
                value: C[U],
                enumerable: !1,
                writable: !1,
                configurable: !0
            })
        }
        return K
    },
    getWindowOf = function (K) {
        var C = K && K.ownerDocument && K.ownerDocument.defaultView;
        return C || global$1
    },
    emptyRect = createRectInit(0, 0, 0, 0);

function toFloat(K) {
    return parseFloat(K) || 0
}

function getBordersSize(K) {
    for (var C = [], H = 1; H < arguments.length; H++) C[H - 1] = arguments[H];
    return C.reduce(function (W, U) {
        var G = K["border-" + U + "-width"];
        return W + toFloat(G)
    }, 0)
}

function getPaddings(K) {
    for (var C = ["top", "right", "bottom", "left"], H = {}, W = 0, U = C; W < U.length; W++) {
        var G = U[W],
            X = K["padding-" + G];
        H[G] = toFloat(X)
    }
    return H
}

function getSVGContentRect(K) {
    var C = K.getBBox();
    return createRectInit(0, 0, C.width, C.height)
}

function getHTMLElementContentRect(K) {
    var C = K.clientWidth,
        H = K.clientHeight;
    if (!C && !H) return emptyRect;
    var W = getWindowOf(K).getComputedStyle(K),
        U = getPaddings(W),
        G = U.left + U.right,
        X = U.top + U.bottom,
        Z = toFloat(W.width),
        Q = toFloat(W.height);
    if (W.boxSizing === "border-box" && (Math.round(Z + G) !== C && (Z -= getBordersSize(W, "left", "right") + G), Math
            .round(Q + X) !== H && (Q -= getBordersSize(W, "top", "bottom") + X)), !isDocumentElement(K)) {
        var ee = Math.round(Z + G) - C,
            ne = Math.round(Q + X) - H;
        Math.abs(ee) !== 1 && (Z -= ee), Math.abs(ne) !== 1 && (Q -= ne)
    }
    return createRectInit(U.left, U.top, Z, Q)
}
var isSVGGraphicsElement = function () {
    return typeof SVGGraphicsElement < "u" ? function (K) {
        return K instanceof getWindowOf(K).SVGGraphicsElement
    } : function (K) {
        return K instanceof getWindowOf(K).SVGElement && typeof K.getBBox == "function"
    }
}();

function isDocumentElement(K) {
    return K === getWindowOf(K).document.documentElement
}

function getContentRect(K) {
    return isBrowser ? isSVGGraphicsElement(K) ? getSVGContentRect(K) : getHTMLElementContentRect(K) : emptyRect
}

function createReadOnlyRect(K) {
    var C = K.x,
        H = K.y,
        W = K.width,
        U = K.height,
        G = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object,
        X = Object.create(G.prototype);
    return defineConfigurable(X, {
        x: C,
        y: H,
        width: W,
        height: U,
        top: H,
        right: C + W,
        bottom: U + H,
        left: C
    }), X
}

function createRectInit(K, C, H, W) {
    return {
        x: K,
        y: C,
        width: H,
        height: W
    }
}
var ResizeObservation = function () {
        function K(C) {
            this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = createRectInit(0, 0, 0, 0), this.target =
                C
        }
        return K.prototype.isActive = function () {
            var C = getContentRect(this.target);
            return this.contentRect_ = C, C.width !== this.broadcastWidth || C.height !== this.broadcastHeight
        }, K.prototype.broadcastRect = function () {
            var C = this.contentRect_;
            return this.broadcastWidth = C.width, this.broadcastHeight = C.height, C
        }, K
    }(),
    ResizeObserverEntry = function () {
        function K(C, H) {
            var W = createReadOnlyRect(H);
            defineConfigurable(this, {
                target: C,
                contentRect: W
            })
        }
        return K
    }(),
    ResizeObserverSPI = function () {
        function K(C, H, W) {
            if (this.activeObservations_ = [], this.observations_ = new MapShim, typeof C != "function") throw new TypeError(
                "The callback provided as parameter 1 is not a function.");
            this.callback_ = C, this.controller_ = H, this.callbackCtx_ = W
        }
        return K.prototype.observe = function (C) {
            if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
            if (!(typeof Element > "u" || !(Element instanceof Object))) {
                if (!(C instanceof getWindowOf(C).Element)) throw new TypeError(
                    'parameter 1 is not of type "Element".');
                var H = this.observations_;
                H.has(C) || (H.set(C, new ResizeObservation(C)), this.controller_.addObserver(this), this.controller_
                    .refresh())
            }
        }, K.prototype.unobserve = function (C) {
            if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
            if (!(typeof Element > "u" || !(Element instanceof Object))) {
                if (!(C instanceof getWindowOf(C).Element)) throw new TypeError(
                    'parameter 1 is not of type "Element".');
                var H = this.observations_;
                H.has(C) && (H.delete(C), H.size || this.controller_.removeObserver(this))
            }
        }, K.prototype.disconnect = function () {
            this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this)
        }, K.prototype.gatherActive = function () {
            var C = this;
            this.clearActive(), this.observations_.forEach(function (H) {
                H.isActive() && C.activeObservations_.push(H)
            })
        }, K.prototype.broadcastActive = function () {
            if (this.hasActive()) {
                var C = this.callbackCtx_,
                    H = this.activeObservations_.map(function (W) {
                        return new ResizeObserverEntry(W.target, W.broadcastRect())
                    });
                this.callback_.call(C, H, C), this.clearActive()
            }
        }, K.prototype.clearActive = function () {
            this.activeObservations_.splice(0)
        }, K.prototype.hasActive = function () {
            return this.activeObservations_.length > 0
        }, K
    }(),
    observers = typeof WeakMap < "u" ? new WeakMap : new MapShim,
    ResizeObserver$2 = function () {
        function K(C) {
            if (!(this instanceof K)) throw new TypeError("Cannot call a class as a function.");
            if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
            var H = ResizeObserverController.getInstance(),
                W = new ResizeObserverSPI(C, H, this);
            observers.set(this, W)
        }
        return K
    }();
["observe", "unobserve", "disconnect"].forEach(function (K) {
    ResizeObserver$2.prototype[K] = function () {
        var C;
        return (C = observers.get(this))[K].apply(C, arguments)
    }
});
var index$n = function () {
    return typeof global$1.ResizeObserver < "u" ? global$1.ResizeObserver : ResizeObserver$2
}();
const ResizeObserver$3 = index$n;

function _arrayWithHoles$2(K) {
    if (Array.isArray(K)) return K
}

function _iterableToArrayLimit$2(K, C) {
    var H = K == null ? null : typeof Symbol < "u" && K[Symbol.iterator] || K["@@iterator"];
    if (H != null) {
        var W, U, G, X, Z = [],
            Q = !0,
            ee = !1;
        try {
            if (G = (H = H.call(K)).next, C === 0) {
                if (Object(H) !== H) return;
                Q = !1
            } else
                for (; !(Q = (W = G.call(H)).done) && (Z.push(W.value), Z.length !== C); Q = !0);
        } catch (ne) {
            ee = !0, U = ne
        } finally {
            try {
                if (!Q && H.return != null && (X = H.return(), Object(X) !== X)) return
            } finally {
                if (ee) throw U
            }
        }
        return Z
    }
}

function _arrayLikeToArray$2(K, C) {
    (C == null || C > K.length) && (C = K.length);
    for (var H = 0, W = new Array(C); H < C; H++) W[H] = K[H];
    return W
}

function _unsupportedIterableToArray$2(K, C) {
    if (K) {
        if (typeof K == "string") return _arrayLikeToArray$2(K, C);
        var H = Object.prototype.toString.call(K).slice(8, -1);
        if (H === "Object" && K.constructor && (H = K.constructor.name), H === "Map" || H === "Set") return Array.from(
            K);
        if (H === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(H)) return _arrayLikeToArray$2(K, C)
    }
}

function _nonIterableRest$2() {
    throw new TypeError(
        `Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`
    )
}

function _slicedToArray$2(K, C) {
    return _arrayWithHoles$2(K) || _iterableToArrayLimit$2(K, C) || _unsupportedIterableToArray$2(K, C) ||
        _nonIterableRest$2()
}

function _arrayWithoutHoles(K) {
    if (Array.isArray(K)) return _arrayLikeToArray$2(K)
}

function _iterableToArray(K) {
    if (typeof Symbol < "u" && K[Symbol.iterator] != null || K["@@iterator"] != null) return Array.from(K)
}

function _nonIterableSpread() {
    throw new TypeError(
        `Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`
    )
}

function _toConsumableArray(K) {
    return _arrayWithoutHoles(K) || _iterableToArray(K) || _unsupportedIterableToArray$2(K) || _nonIterableSpread()
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
const freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self,
    root$1 = freeGlobal$1 || freeSelf || Function("return this")();
const root$2 = root$1;
var Symbol$1 = root$2.Symbol;
const Symbol$2 = Symbol$1;
var objectProto$f = Object.prototype,
    hasOwnProperty$c = objectProto$f.hasOwnProperty,
    nativeObjectToString$1 = objectProto$f.toString,
    symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;

function getRawTag(K) {
    var C = hasOwnProperty$c.call(K, symToStringTag$1),
        H = K[symToStringTag$1];
    try {
        K[symToStringTag$1] = void 0;
        var W = !0
    } catch {}
    var U = nativeObjectToString$1.call(K);
    return W && (C ? K[symToStringTag$1] = H : delete K[symToStringTag$1]), U
}
var objectProto$e = Object.prototype,
    nativeObjectToString = objectProto$e.toString;

function objectToString(K) {
    return nativeObjectToString.call(K)
}
var nullTag = "[object Null]",
    undefinedTag = "[object Undefined]",
    symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;

function baseGetTag(K) {
    return K == null ? K === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(K) ?
        getRawTag(K) : objectToString(K)
}

function overArg(K, C) {
    return function (H) {
        return K(C(H))
    }
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
const getPrototype$1 = getPrototype;

function isObjectLike(K) {
    return K != null && typeof K == "object"
}
var objectTag$4 = "[object Object]",
    funcProto$2 = Function.prototype,
    objectProto$d = Object.prototype,
    funcToString$2 = funcProto$2.toString,
    hasOwnProperty$b = objectProto$d.hasOwnProperty,
    objectCtorString = funcToString$2.call(Object);

function isPlainObject(K) {
    if (!isObjectLike(K) || baseGetTag(K) != objectTag$4) return !1;
    var C = getPrototype$1(K);
    if (C === null) return !0;
    var H = hasOwnProperty$b.call(C, "constructor") && C.constructor;
    return typeof H == "function" && H instanceof H && funcToString$2.call(H) == objectCtorString
}
var isValid$4 = function (C) {
    return C != null && C !== ""
};
const isValid$5 = isValid$4;
var initDefaultProps = function (C, H) {
    var W = _objectSpread2$1({}, C);
    return Object.keys(H).forEach(function (U) {
        var G = W[U];
        if (G) G.type || G.default ? G.default = H[U] : G.def ? G.def(H[U]) : W[U] = {
            type: G,
            default: H[U]
        };
        else throw new Error("not have ".concat(U, " prop"))
    }), W
};
const initDefaultProps$1 = initDefaultProps;
var splitAttrs = function (C) {
        for (var H = Object.keys(C), W = {}, U = {}, G = {}, X = 0, Z = H.length; X < Z; X++) {
            var Q = H[X];
            isOn(Q) ? (W[Q[2].toLowerCase() + Q.slice(3)] = C[Q], U[Q] = C[Q]) : G[Q] = C[Q]
        }
        return {
            onEvents: U,
            events: W,
            extraAttrs: G
        }
    },
    parseStyleText = function () {
        var C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "",
            H = arguments.length > 1 ? arguments[1] : void 0,
            W = {},
            U = /;(?![^(]*\))/g,
            G = /:(.+)/;
        return _typeof$2(C) === "object" ? C : (C.split(U).forEach(function (X) {
            if (X) {
                var Z = X.split(G);
                if (Z.length > 1) {
                    var Q = H ? camelize(Z[0].trim()) : Z[0].trim();
                    W[Q] = Z[1].trim()
                }
            }
        }), W)
    },
    hasProp = function (C, H) {
        return C[H] !== void 0
    },
    flattenChildren = function K() {
        var C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
            H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0,
            W = Array.isArray(C) ? C : [C],
            U = [];
        return W.forEach(function (G) {
            Array.isArray(G) ? U.push.apply(U, _toConsumableArray(K(G, H))) : G && G.type === Fragment ? U.push
                .apply(U, _toConsumableArray(K(G.children, H))) : G && isVNode(G) ? H && !isEmptyElement(G) ? U
                .push(G) : H || U.push(G) : isValid$5(G) && U.push(G)
        }), U
    },
    getSlot = function (C) {
        var H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default",
            W = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (isVNode(C)) return C.type === Fragment ? H === "default" ? flattenChildren(C.children) : [] : C.children &&
            C.children[H] ? flattenChildren(C.children[H](W)) : [];
        var U = C.$slots[H] && C.$slots[H](W);
        return flattenChildren(U)
    },
    findDOMNode = function (C) {
        for (var H, W = (C == null || (H = C.vnode) === null || H === void 0 ? void 0 : H.el) || C && (C.$el || C); W &&
            !W.tagName;) W = W.nextSibling;
        return W
    },
    getOptionProps = function (C) {
        var H = {};
        if (C.$ && C.$.vnode) {
            var W = C.$.vnode.props || {};
            Object.keys(C.$props).forEach(function (Z) {
                var Q = C.$props[Z],
                    ee = hyphenate(Z);
                (Q !== void 0 || ee in W) && (H[Z] = Q)
            })
        } else if (isVNode(C) && _typeof$2(C.type) === "object") {
            var U = C.props || {},
                G = {};
            Object.keys(U).forEach(function (Z) {
                G[camelize(Z)] = U[Z]
            });
            var X = C.type.props || {};
            Object.keys(X).forEach(function (Z) {
                var Q = resolvePropValue(X, G, Z, G[Z]);
                (Q !== void 0 || Z in G) && (H[Z] = Q)
            })
        }
        return H
    },
    getComponent = function (C) {
        var H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default",
            W = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : C,
            U = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0,
            G = void 0;
        if (C.$) {
            var X = C[H];
            if (X !== void 0) return typeof X == "function" && U ? X(W) : X;
            G = C.$slots[H], G = U && G ? G(W) : G
        } else if (isVNode(C)) {
            var Z = C.props && C.props[H];
            if (Z !== void 0 && C.props !== null) return typeof Z == "function" && U ? Z(W) : Z;
            C.type === Fragment ? G = C.children : C.children && C.children[H] && (G = C.children[H], G = U && G ? G(W) :
                G)
        }
        return Array.isArray(G) && (G = flattenChildren(G), G = G.length === 1 ? G[0] : G, G = G.length === 0 ? void 0 :
            G), G
    };

function getEvents() {
    var K = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
        C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0,
        H = {};
    return K.$ ? H = _objectSpread2$1(_objectSpread2$1({}, H), K.$attrs) : H = _objectSpread2$1(_objectSpread2$1({}, H),
        K.props), splitAttrs(H)[C ? "onEvents" : "events"]
}

function getClass(K) {
    var C = (isVNode(K) ? K.props : K.$attrs) || {},
        H = C.class || {},
        W = {};
    return typeof H == "string" ? H.split(" ").forEach(function (U) {
        W[U.trim()] = !0
    }) : Array.isArray(H) ? classNames(H).split(" ").forEach(function (U) {
        W[U.trim()] = !0
    }) : W = _objectSpread2$1(_objectSpread2$1({}, W), H), W
}

function getStyle(K, C) {
    var H = (isVNode(K) ? K.props : K.$attrs) || {},
        W = H.style || {};
    if (typeof W == "string") W = parseStyleText(W, C);
    else if (C && W) {
        var U = {};
        return Object.keys(W).forEach(function (G) {
            return U[camelize(G)] = W[G]
        }), U
    }
    return W
}

function isEmptyContent(K) {
    return K == null || K === "" || Array.isArray(K) && K.length === 0
}

function isEmptyElement(K) {
    return K && (K.type === Comment$1 || K.type === Fragment && K.children.length === 0 || K.type === Text$2 && K.children
        .trim() === "")
}

function isStringElement(K) {
    return K && K.type === Text$2
}

function filterEmpty() {
    var K = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
        C = [];
    return K.forEach(function (H) {
        Array.isArray(H) ? C.push.apply(C, _toConsumableArray(H)) : (H == null ? void 0 : H.type) === Fragment ?
            C.push.apply(C, _toConsumableArray(filterEmpty(H.children))) : C.push(H)
    }), C.filter(function (H) {
        return !isEmptyElement(H)
    })
}

function filterEmptyWithUndefined(K) {
    if (K) {
        var C = filterEmpty(K);
        return C.length ? C : void 0
    } else return K
}

function isValidElement(K) {
    return Array.isArray(K) && K.length === 1 && (K = K[0]), K && K.__v_isVNode && _typeof$2(K.type) !== "symbol"
}

function getPropsSlot(K, C) {
    var H, W, U = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "default";
    return (H = C[U]) !== null && H !== void 0 ? H : (W = K[U]) === null || W === void 0 ? void 0 : W.call(K)
}
const ResizeObserver$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ResizeObserver",
    props: {
        disabled: Boolean,
        onResize: Function
    },
    emits: ["resize"],
    setup: function (C, H) {
        var W = H.slots,
            U = reactive({
                width: 0,
                height: 0,
                offsetHeight: 0,
                offsetWidth: 0
            }),
            G = null,
            X = null,
            Z = function () {
                X && (X.disconnect(), X = null)
            },
            Q = function (re) {
                var ae = C.onResize,
                    oe = re[0].target,
                    ie = oe.getBoundingClientRect(),
                    ue = ie.width,
                    le = ie.height,
                    se = oe.offsetWidth,
                    ce = oe.offsetHeight,
                    de = Math.floor(ue),
                    ve = Math.floor(le);
                if (U.width !== de || U.height !== ve || U.offsetWidth !== se || U.offsetHeight !== ce) {
                    var fe = {
                        width: de,
                        height: ve,
                        offsetWidth: se,
                        offsetHeight: ce
                    };
                    _extends$1(U, fe), ae && Promise.resolve().then(function () {
                        ae(_objectSpread2$1(_objectSpread2$1({}, fe), {}, {
                            offsetWidth: se,
                            offsetHeight: ce
                        }), oe)
                    })
                }
            },
            ee = getCurrentInstance(),
            ne = function () {
                var re = C.disabled;
                if (re) {
                    Z();
                    return
                }
                var ae = findDOMNode(ee),
                    oe = ae !== G;
                oe && (Z(), G = ae), !X && ae && (X = new ResizeObserver$3(Q), X.observe(ae))
            };
        return onMounted(function () {
                ne()
            }), onUpdated(function () {
                ne()
            }), onUnmounted(function () {
                Z()
            }), watch(function () {
                return C.disabled
            }, function () {
                ne()
            }, {
                flush: "post"
            }),
            function () {
                var te;
                return (te = W.default) === null || te === void 0 ? void 0 : te.call(W)[0]
            }
    }
});
var raf$1 = function (C) {
        return setTimeout(C, 16)
    },
    caf = function (C) {
        return clearTimeout(C)
    };
typeof window < "u" && "requestAnimationFrame" in window && (raf$1 = function (C) {
    return window.requestAnimationFrame(C)
}, caf = function (C) {
    return window.cancelAnimationFrame(C)
});
var rafUUID = 0,
    rafIds = new Map;

function cleanup(K) {
    rafIds.delete(K)
}

function wrapperRaf(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    rafUUID += 1;
    var H = rafUUID;

    function W(U) {
        if (U === 0) cleanup(H), K();
        else {
            var G = raf$1(function () {
                W(U - 1)
            });
            rafIds.set(H, G)
        }
    }
    return W(C), H
}
wrapperRaf.cancel = function (K) {
    var C = rafIds.get(K);
    return cleanup(C), caf(C)
};

function throttleByAnimationFrame(K) {
    var C, H = function (G) {
            return function () {
                C = null, K.apply(void 0, _toConsumableArray(G))
            }
        },
        W = function () {
            if (C == null) {
                for (var G = arguments.length, X = new Array(G), Z = 0; Z < G; Z++) X[Z] = arguments[Z];
                C = wrapperRaf(H(X))
            }
        };
    return W.cancel = function () {
        return wrapperRaf.cancel(C)
    }, W
}
var tuple$1 = function () {
        for (var C = arguments.length, H = new Array(C), W = 0; W < C; W++) H[W] = arguments[W];
        return H
    },
    tupleNum = function () {
        for (var C = arguments.length, H = new Array(C), W = 0; W < C; W++) H[W] = arguments[W];
        return H
    },
    withInstall = function (C) {
        var H = C;
        return H.install = function (W) {
            W.component(H.displayName || H.name, C)
        }, C
    },
    supportsPassive = !1;
try {
    var opts = Object.defineProperty({}, "passive", {
        get: function () {
            supportsPassive = !0
        }
    });
    window.addEventListener("testPassive", null, opts), window.removeEventListener("testPassive", null, opts)
} catch {}
const supportsPassive$1 = supportsPassive;

function addEventListenerWrap(K, C, H, W) {
    if (K && K.addEventListener) {
        var U = W;
        U === void 0 && supportsPassive$1 && (C === "touchstart" || C === "touchmove" || C === "wheel") && (U = {
            passive: !1
        }), K.addEventListener(C, H, U)
    }
    return {
        remove: function () {
            K && K.removeEventListener && K.removeEventListener(C, H)
        }
    }
}

function getTargetRect(K) {
    return K !== window ? K.getBoundingClientRect() : {
        top: 0,
        bottom: window.innerHeight
    }
}

function getFixedTop(K, C, H) {
    if (H !== void 0 && C.top > K.top - H) return "".concat(H + C.top, "px")
}

function getFixedBottom(K, C, H) {
    if (H !== void 0 && C.bottom < K.bottom + H) {
        var W = window.innerHeight - C.bottom;
        return "".concat(H + W, "px")
    }
}
var TRIGGER_EVENTS = ["resize", "scroll", "touchstart", "touchmove", "touchend", "pageshow", "load"],
    observerEntities = [];

function addObserveTarget(K, C) {
    if (K) {
        var H = observerEntities.find(function (W) {
            return W.target === K
        });
        H ? H.affixList.push(C) : (H = {
            target: K,
            affixList: [C],
            eventHandlers: {}
        }, observerEntities.push(H), TRIGGER_EVENTS.forEach(function (W) {
            H.eventHandlers[W] = addEventListenerWrap(K, W, function () {
                H.affixList.forEach(function (U) {
                    var G = U.exposed.lazyUpdatePosition;
                    G()
                }, (W === "touchstart" || W === "touchmove") && supportsPassive$1 ? {
                    passive: !0
                } : !1)
            })
        }))
    }
}

function removeObserveTarget(K) {
    var C = observerEntities.find(function (H) {
        var W = H.affixList.some(function (U) {
            return U === K
        });
        return W && (H.affixList = H.affixList.filter(function (U) {
            return U !== K
        })), W
    });
    C && C.affixList.length === 0 && (observerEntities = observerEntities.filter(function (H) {
        return H !== C
    }), TRIGGER_EVENTS.forEach(function (H) {
        var W = C.eventHandlers[H];
        W && W.remove && W.remove()
    }))
}

function _objectWithoutPropertiesLoose$2(K, C) {
    if (K == null) return {};
    var H = {},
        W = Object.keys(K),
        U, G;
    for (G = 0; G < W.length; G++) U = W[G], !(C.indexOf(U) >= 0) && (H[U] = K[U]);
    return H
}

function _objectWithoutProperties$2(K, C) {
    if (K == null) return {};
    var H = _objectWithoutPropertiesLoose$2(K, C),
        W, U;
    if (Object.getOwnPropertySymbols) {
        var G = Object.getOwnPropertySymbols(K);
        for (U = 0; U < G.length; U++) W = G[U], !(C.indexOf(W) >= 0) && Object.prototype.propertyIsEnumerable.call(K,
            W) && (H[W] = K[W])
    }
    return H
}
const enUS$1 = {
    items_per_page: "/ page",
    jump_to: "Go to",
    jump_to_confirm: "confirm",
    page: "",
    prev_page: "Previous Page",
    next_page: "Next Page",
    prev_5: "Previous 5 Pages",
    next_5: "Next 5 Pages",
    prev_3: "Previous 3 Pages",
    next_3: "Next 3 Pages"
};
var locale$3 = {
    locale: "en_US",
    today: "Today",
    now: "Now",
    backToToday: "Back to today",
    ok: "Ok",
    clear: "Clear",
    month: "Month",
    year: "Year",
    timeSelect: "select time",
    dateSelect: "select date",
    weekSelect: "Choose a week",
    monthSelect: "Choose a month",
    yearSelect: "Choose a year",
    decadeSelect: "Choose a decade",
    yearFormat: "YYYY",
    dateFormat: "M/D/YYYY",
    dayFormat: "D",
    dateTimeFormat: "M/D/YYYY HH:mm:ss",
    monthBeforeYear: !0,
    previousMonth: "Previous month (PageUp)",
    nextMonth: "Next month (PageDown)",
    previousYear: "Last year (Control + left)",
    nextYear: "Next year (Control + right)",
    previousDecade: "Last decade",
    nextDecade: "Next decade",
    previousCentury: "Last century",
    nextCentury: "Next century"
};
const CalendarLocale = locale$3;
var locale$2 = {
    placeholder: "Select time",
    rangePlaceholder: ["Start time", "End time"]
};
const TimePicker$3 = locale$2;
var locale$1 = {
    lang: _objectSpread2$1({
        placeholder: "Select date",
        yearPlaceholder: "Select year",
        quarterPlaceholder: "Select quarter",
        monthPlaceholder: "Select month",
        weekPlaceholder: "Select week",
        rangePlaceholder: ["Start date", "End date"],
        rangeYearPlaceholder: ["Start year", "End year"],
        rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
        rangeMonthPlaceholder: ["Start month", "End month"],
        rangeWeekPlaceholder: ["Start week", "End week"]
    }, CalendarLocale),
    timePickerLocale: _objectSpread2$1({}, TimePicker$3)
};
const enUS = locale$1;
var typeTemplate$1 = "${label} is not a valid ${type}",
    localeValues = {
        locale: "en",
        Pagination: enUS$1,
        DatePicker: enUS,
        TimePicker: TimePicker$3,
        Calendar: enUS,
        global: {
            placeholder: "Please select"
        },
        Table: {
            filterTitle: "Filter menu",
            filterConfirm: "OK",
            filterReset: "Reset",
            filterEmptyText: "No filters",
            filterCheckall: "Select all items",
            filterSearchPlaceholder: "Search in filters",
            emptyText: "No data",
            selectAll: "Select current page",
            selectInvert: "Invert current page",
            selectNone: "Clear all data",
            selectionAll: "Select all data",
            sortTitle: "Sort",
            expand: "Expand row",
            collapse: "Collapse row",
            triggerDesc: "Click to sort descending",
            triggerAsc: "Click to sort ascending",
            cancelSort: "Click to cancel sorting"
        },
        Modal: {
            okText: "OK",
            cancelText: "Cancel",
            justOkText: "OK"
        },
        Popconfirm: {
            okText: "OK",
            cancelText: "Cancel"
        },
        Transfer: {
            titles: ["", ""],
            searchPlaceholder: "Search here",
            itemUnit: "item",
            itemsUnit: "items",
            remove: "Remove",
            selectCurrent: "Select current page",
            removeCurrent: "Remove current page",
            selectAll: "Select all data",
            removeAll: "Remove all data",
            selectInvert: "Invert current page"
        },
        Upload: {
            uploading: "Uploading...",
            removeFile: "Remove file",
            uploadError: "Upload error",
            previewFile: "Preview file",
            downloadFile: "Download file"
        },
        Empty: {
            description: "No Data"
        },
        Icon: {
            icon: "icon"
        },
        Text: {
            edit: "Edit",
            copy: "Copy",
            copied: "Copied",
            expand: "Expand"
        },
        PageHeader: {
            back: "Back"
        },
        Form: {
            optional: "(optional)",
            defaultValidateMessages: {
                default: "Field validation error for ${label}",
                required: "Please enter ${label}",
                enum: "${label} must be one of [${enum}]",
                whitespace: "${label} cannot be a blank character",
                date: {
                    format: "${label} date format is invalid",
                    parse: "${label} cannot be converted to a date",
                    invalid: "${label} is an invalid date"
                },
                types: {
                    string: typeTemplate$1,
                    method: typeTemplate$1,
                    array: typeTemplate$1,
                    object: typeTemplate$1,
                    number: typeTemplate$1,
                    date: typeTemplate$1,
                    boolean: typeTemplate$1,
                    integer: typeTemplate$1,
                    float: typeTemplate$1,
                    regexp: typeTemplate$1,
                    email: typeTemplate$1,
                    url: typeTemplate$1,
                    hex: typeTemplate$1
                },
                string: {
                    len: "${label} must be ${len} characters",
                    min: "${label} must be at least ${min} characters",
                    max: "${label} must be up to ${max} characters",
                    range: "${label} must be between ${min}-${max} characters"
                },
                number: {
                    len: "${label} must be equal to ${len}",
                    min: "${label} must be minimum ${min}",
                    max: "${label} must be maximum ${max}",
                    range: "${label} must be between ${min}-${max}"
                },
                array: {
                    len: "Must be ${len} ${label}",
                    min: "At least ${min} ${label}",
                    max: "At most ${max} ${label}",
                    range: "The amount of ${label} must be between ${min}-${max}"
                },
                pattern: {
                    mismatch: "${label} does not match the pattern ${pattern}"
                }
            }
        },
        Image: {
            preview: "Preview"
        }
    };
const defaultLocale = localeValues,
    LocaleReceiver = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "LocaleReceiver",
        props: {
            componentName: String,
            defaultLocale: {
                type: [Object, Function]
            },
            children: {
                type: Function
            }
        },
        setup: function (C, H) {
            var W = H.slots,
                U = inject("localeData", {}),
                G = computed(function () {
                    var Z = C.componentName,
                        Q = Z === void 0 ? "global" : Z,
                        ee = C.defaultLocale,
                        ne = ee || defaultLocale[Q || "global"],
                        te = U.antLocale,
                        re = Q && te ? te[Q] : {};
                    return _objectSpread2$1(_objectSpread2$1({}, typeof ne == "function" ? ne() : ne), re ||
                        {})
                }),
                X = computed(function () {
                    var Z = U.antLocale,
                        Q = Z && Z.locale;
                    return Z && Z.exist && !Q ? defaultLocale.locale : Q
                });
            return function () {
                var Z = C.children || W.default,
                    Q = U.antLocale;
                return Z == null ? void 0 : Z(G.value, X.value, Q)
            }
        }
    });

function useLocaleReceiver(K, C, H) {
    var W = inject("localeData", {}),
        U = computed(function () {
            var G = W.antLocale,
                X = unref(C) || defaultLocale[K || "global"],
                Z = K && G ? G[K] : {};
            return _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, typeof X == "function" ? X() : X), Z || {}),
                unref(H) || {})
        });
    return [U]
}
var Empty$2 = function () {
    var C = useConfigInject("empty", {}),
        H = C.getPrefixCls,
        W = H("empty-img-default");
    return createVNode("svg", {
        class: W,
        width: "184",
        height: "152",
        viewBox: "0 0 184 152"
    }, [createVNode("g", {
        fill: "none",
        "fill-rule": "evenodd"
    }, [createVNode("g", {
        transform: "translate(24 31.67)"
    }, [createVNode("ellipse", {
        class: "".concat(W, "-ellipse"),
        cx: "67.797",
        cy: "106.89",
        rx: "67.797",
        ry: "12.668"
    }, null), createVNode("path", {
        class: "".concat(W, "-path-1"),
        d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z"
    }, null), createVNode("path", {
        class: "".concat(W, "-path-2"),
        d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
        transform: "translate(13.56)"
    }, null), createVNode("path", {
        class: "".concat(W, "-path-3"),
        d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z"
    }, null), createVNode("path", {
        class: "".concat(W, "-path-4"),
        d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z"
    }, null)]), createVNode("path", {
        class: "".concat(W, "-path-5"),
        d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z"
    }, null), createVNode("g", {
        class: "".concat(W, "-g"),
        transform: "translate(149.65 15.383)"
    }, [createVNode("ellipse", {
        cx: "20.654",
        cy: "3.167",
        rx: "2.849",
        ry: "2.815"
    }, null), createVNode("path", {
        d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
    }, null)])])])
};
Empty$2.PRESENTED_IMAGE_DEFAULT = !0;
const DefaultEmptyImg = Empty$2;
var Simple = function () {
    var C = useConfigInject("empty", {}),
        H = C.getPrefixCls,
        W = H("empty-img-simple");
    return createVNode("svg", {
        class: W,
        width: "64",
        height: "41",
        viewBox: "0 0 64 41"
    }, [createVNode("g", {
        transform: "translate(0 1)",
        fill: "none",
        "fill-rule": "evenodd"
    }, [createVNode("ellipse", {
        class: "".concat(W, "-ellipse"),
        fill: "#F5F5F5",
        cx: "32",
        cy: "33",
        rx: "32",
        ry: "7"
    }, null), createVNode("g", {
        class: "".concat(W, "-g"),
        "fill-rule": "nonzero",
        stroke: "#D9D9D9"
    }, [createVNode("path", {
        d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
    }, null), createVNode("path", {
        d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
        fill: "#FAFAFA",
        class: "".concat(W, "-path")
    }, null)])])])
};
Simple.PRESENTED_IMAGE_SIMPLE = !0;
const SimpleEmptyImg = Simple;

function e$1(K, C) {
    for (var H = 0; H < C.length; H++) {
        var W = C[H];
        W.enumerable = W.enumerable || !1, W.configurable = !0, "value" in W && (W.writable = !0), Object.defineProperty(
            K, W.key, W)
    }
}

function t$1(K, C, H) {
    return C && e$1(K.prototype, C), H && e$1(K, H), K
}

function n$1() {
    return (n$1 = Object.assign || function (K) {
        for (var C = 1; C < arguments.length; C++) {
            var H = arguments[C];
            for (var W in H) Object.prototype.hasOwnProperty.call(H, W) && (K[W] = H[W])
        }
        return K
    }).apply(this, arguments)
}

function r$1(K, C) {
    K.prototype = Object.create(C.prototype), K.prototype.constructor = K, K.__proto__ = C
}

function i$1(K, C) {
    if (K == null) return {};
    var H, W, U = {},
        G = Object.keys(K);
    for (W = 0; W < G.length; W++) C.indexOf(H = G[W]) >= 0 || (U[H] = K[H]);
    return U
}

function o(K) {
    return ((C = K) != null && typeof C == "object" && Array.isArray(C) === !1) == 1 && Object.prototype.toString.call(
        K) === "[object Object]";
    var C
}
var u = Object.prototype,
    a = u.toString,
    f = u.hasOwnProperty,
    c = /^\s*function (\w+)/;

function l(K) {
    var C, H = (C = K == null ? void 0 : K.type) !== null && C !== void 0 ? C : K;
    if (H) {
        var W = H.toString().match(c);
        return W ? W[1] : ""
    }
    return ""
}
var s = function (K) {
        var C, H;
        return o(K) !== !1 && typeof (C = K.constructor) == "function" && o(H = C.prototype) !== !1 && H.hasOwnProperty(
            "isPrototypeOf") !== !1
    },
    v = function (K) {
        return K
    },
    y = v,
    d = function (K, C) {
        return f.call(K, C)
    },
    h = Number.isInteger || function (K) {
        return typeof K == "number" && isFinite(K) && Math.floor(K) === K
    },
    b = Array.isArray || function (K) {
        return a.call(K) === "[object Array]"
    },
    O = function (K) {
        return a.call(K) === "[object Function]"
    },
    g = function (K) {
        return s(K) && d(K, "_vueTypes_name")
    },
    m = function (K) {
        return s(K) && (d(K, "type") || ["_vueTypes_name", "validator", "default", "required"].some(function (C) {
            return d(K, C)
        }))
    };

function j(K, C) {
    return Object.defineProperty(K.bind(C), "__original", {
        value: K
    })
}

function _(K, C, H) {
    var W;
    H === void 0 && (H = !1);
    var U = !0,
        G = "";
    W = s(K) ? K : {
        type: K
    };
    var X = g(W) ? W._vueTypes_name + " - " : "";
    if (m(W) && W.type !== null) {
        if (W.type === void 0 || W.type === !0 || !W.required && C === void 0) return U;
        b(W.type) ? (U = W.type.some(function (te) {
                return _(te, C, !0) === !0
            }), G = W.type.map(function (te) {
                return l(te)
            }).join(" or ")) : U = (G = l(W)) === "Array" ? b(C) : G === "Object" ? s(C) : G === "String" || G ===
            "Number" || G === "Boolean" || G === "Function" ? function (te) {
                if (te == null) return "";
                var re = te.constructor.toString().match(c);
                return re ? re[1] : ""
            }(C) === G : C instanceof W.type
    }
    if (!U) {
        var Z = X + 'value "' + C + '" should be of type "' + G + '"';
        return H === !1 ? (y(Z), !1) : Z
    }
    if (d(W, "validator") && O(W.validator)) {
        var Q = y,
            ee = [];
        if (y = function (te) {
                ee.push(te)
            }, U = W.validator(C), y = Q, !U) {
            var ne = (ee.length > 1 ? "* " : "") + ee.join(`
* `);
            return ee.length = 0, H === !1 ? (y(ne), U) : ne
        }
    }
    return U
}

function T(K, C) {
    var H = Object.defineProperties(C, {
            _vueTypes_name: {
                value: K,
                writable: !0
            },
            isRequired: {
                get: function () {
                    return this.required = !0, this
                }
            },
            def: {
                value: function (U) {
                    return U !== void 0 || this.default ? O(U) || _(this, U, !0) === !0 ? (this.default = b(U) ?
                        function () {
                            return [].concat(U)
                        } : s(U) ? function () {
                            return Object.assign({}, U)
                        } : U, this) : (y(this._vueTypes_name + ' - invalid default value: "' + U + '"'),
                        this) : this
                }
            }
        }),
        W = H.validator;
    return O(W) && (H.validator = j(W, H)), H
}

function w(K, C) {
    var H = T(K, C);
    return Object.defineProperty(H, "validate", {
        value: function (W) {
            return O(this.validator) && y(this._vueTypes_name +
                ` - calling .validate() will overwrite the current custom validator function. Validator info:
` +
                JSON.stringify(this)), this.validator = j(W, this), this
        }
    })
}

function k(K, C, H) {
    var W, U, G = (W = C, U = {}, Object.getOwnPropertyNames(W).forEach(function (te) {
        U[te] = Object.getOwnPropertyDescriptor(W, te)
    }), Object.defineProperties({}, U));
    if (G._vueTypes_name = K, !s(H)) return G;
    var X, Z, Q = H.validator,
        ee = i$1(H, ["validator"]);
    if (O(Q)) {
        var ne = G.validator;
        ne && (ne = (Z = (X = ne).__original) !== null && Z !== void 0 ? Z : X), G.validator = j(ne ? function (te) {
            return ne.call(this, te) && Q.call(this, te)
        } : Q, G)
    }
    return Object.assign(G, ee)
}

function P(K) {
    return K.replace(/^(?!\s*$)/gm, "  ")
}
var x = function () {
        return w("any", {})
    },
    A = function () {
        return w("function", {
            type: Function
        })
    },
    E = function () {
        return w("boolean", {
            type: Boolean
        })
    },
    N = function () {
        return w("string", {
            type: String
        })
    },
    q = function () {
        return w("number", {
            type: Number
        })
    },
    S = function () {
        return w("array", {
            type: Array
        })
    },
    V = function () {
        return w("object", {
            type: Object
        })
    },
    F = function () {
        return T("integer", {
            type: Number,
            validator: function (K) {
                return h(K)
            }
        })
    },
    D = function () {
        return T("symbol", {
            validator: function (K) {
                return typeof K == "symbol"
            }
        })
    };

function L(K, C) {
    if (C === void 0 && (C = "custom validation failed"), typeof K != "function") throw new TypeError(
        "[VueTypes error]: You must provide a function as argument");
    return T(K.name || "<<anonymous function>>", {
        validator: function (H) {
            var W = K(H);
            return W || y(this._vueTypes_name + " - " + C), W
        }
    })
}

function Y(K) {
    if (!b(K)) throw new TypeError("[VueTypes error]: You must provide an array as argument.");
    var C = 'oneOf - value should be one of "' + K.join('", "') + '".',
        H = K.reduce(function (W, U) {
            if (U != null) {
                var G = U.constructor;
                W.indexOf(G) === -1 && W.push(G)
            }
            return W
        }, []);
    return T("oneOf", {
        type: H.length > 0 ? H : void 0,
        validator: function (W) {
            var U = K.indexOf(W) !== -1;
            return U || y(C), U
        }
    })
}

function B(K) {
    if (!b(K)) throw new TypeError("[VueTypes error]: You must provide an array as argument");
    for (var C = !1, H = [], W = 0; W < K.length; W += 1) {
        var U = K[W];
        if (m(U)) {
            if (g(U) && U._vueTypes_name === "oneOf") {
                H = H.concat(U.type);
                continue
            }
            if (O(U.validator) && (C = !0), U.type !== !0 && U.type) {
                H = H.concat(U.type);
                continue
            }
        }
        H.push(U)
    }
    return H = H.filter(function (G, X) {
        return H.indexOf(G) === X
    }), T("oneOfType", C ? {
        type: H,
        validator: function (G) {
            var X = [],
                Z = K.some(function (Q) {
                    var ee = _(g(Q) && Q._vueTypes_name === "oneOf" ? Q.type || null : Q, G, !0);
                    return typeof ee == "string" && X.push(ee), ee === !0
                });
            return Z || y("oneOfType - provided value does not match any of the " + X.length +
                ` passed-in validators:
` + P(X.join(`
`))), Z
        }
    } : {
        type: H
    })
}

function I(K) {
    return T("arrayOf", {
        type: Array,
        validator: function (C) {
            var H, W = C.every(function (U) {
                return (H = _(K, U, !0)) === !0
            });
            return W || y(`arrayOf - value validation error:
` + P(H)), W
        }
    })
}

function J(K) {
    return T("instanceOf", {
        type: K
    })
}

function M(K) {
    return T("objectOf", {
        type: Object,
        validator: function (C) {
            var H, W = Object.keys(C).every(function (U) {
                return (H = _(K, C[U], !0)) === !0
            });
            return W || y(`objectOf - value validation error:
` + P(H)), W
        }
    })
}

function R(K) {
    var C = Object.keys(K),
        H = C.filter(function (U) {
            var G;
            return !!(!((G = K[U]) === null || G === void 0) && G.required)
        }),
        W = T("shape", {
            type: Object,
            validator: function (U) {
                var G = this;
                if (!s(U)) return !1;
                var X = Object.keys(U);
                if (H.length > 0 && H.some(function (Q) {
                        return X.indexOf(Q) === -1
                    })) {
                    var Z = H.filter(function (Q) {
                        return X.indexOf(Q) === -1
                    });
                    return y(Z.length === 1 ? 'shape - required property "' + Z[0] + '" is not defined.' :
                        'shape - required properties "' + Z.join('", "') + '" are not defined.'), !1
                }
                return X.every(function (Q) {
                    if (C.indexOf(Q) === -1) return G._vueTypes_isLoose === !0 || (y(
                        'shape - shape definition does not include a "' + Q +
                        '" property. Allowed keys: "' + C.join('", "') + '".'), !1);
                    var ee = _(K[Q], U[Q], !0);
                    return typeof ee == "string" && y('shape - "' + Q +
                        `" property validation error:
 ` + P(ee)), ee === !0
                })
            }
        });
    return Object.defineProperty(W, "_vueTypes_isLoose", {
        writable: !0,
        value: !1
    }), Object.defineProperty(W, "loose", {
        get: function () {
            return this._vueTypes_isLoose = !0, this
        }
    }), W
}
var $ = function () {
    function K() {}
    return K.extend = function (C) {
        var H = this;
        if (b(C)) return C.forEach(function (te) {
            return H.extend(te)
        }), this;
        var W = C.name,
            U = C.validate,
            G = U !== void 0 && U,
            X = C.getter,
            Z = X !== void 0 && X,
            Q = i$1(C, ["name", "validate", "getter"]);
        if (d(this, W)) throw new TypeError('[VueTypes error]: Type "' + W + '" already defined');
        var ee, ne = Q.type;
        return g(ne) ? (delete Q.type, Object.defineProperty(this, W, Z ? {
            get: function () {
                return k(W, ne, Q)
            }
        } : {
            value: function () {
                var te, re = k(W, ne, Q);
                return re.validator && (re.validator = (te = re.validator).bind.apply(te, [re].concat(
                    [].slice.call(arguments)))), re
            }
        })) : (ee = Z ? {
            get: function () {
                var te = Object.assign({}, Q);
                return G ? w(W, te) : T(W, te)
            },
            enumerable: !0
        } : {
            value: function () {
                var te, re, ae = Object.assign({}, Q);
                return te = G ? w(W, ae) : T(W, ae), ae.validator && (te.validator = (re = ae.validator)
                    .bind.apply(re, [te].concat([].slice.call(arguments)))), te
            },
            enumerable: !0
        }, Object.defineProperty(this, W, ee))
    }, t$1(K, null, [{
        key: "any",
        get: function () {
            return x()
        }
    }, {
        key: "func",
        get: function () {
            return A().def(this.defaults.func)
        }
    }, {
        key: "bool",
        get: function () {
            return E().def(this.defaults.bool)
        }
    }, {
        key: "string",
        get: function () {
            return N().def(this.defaults.string)
        }
    }, {
        key: "number",
        get: function () {
            return q().def(this.defaults.number)
        }
    }, {
        key: "array",
        get: function () {
            return S().def(this.defaults.array)
        }
    }, {
        key: "object",
        get: function () {
            return V().def(this.defaults.object)
        }
    }, {
        key: "integer",
        get: function () {
            return F().def(this.defaults.integer)
        }
    }, {
        key: "symbol",
        get: function () {
            return D()
        }
    }]), K
}();

function z(K) {
    var C;
    return K === void 0 && (K = {
        func: function () {},
        bool: !0,
        string: "",
        number: 0,
        array: function () {
            return []
        },
        object: function () {
            return {}
        },
        integer: 0
    }), (C = function (H) {
        function W() {
            return H.apply(this, arguments) || this
        }
        return r$1(W, H), t$1(W, null, [{
            key: "sensibleDefaults",
            get: function () {
                return n$1({}, this.defaults)
            },
            set: function (U) {
                this.defaults = U !== !1 ? n$1({}, U !== !0 ? U : K) : {}
            }
        }]), W
    }($)).defaults = n$1({}, K), C
}
$.defaults = {}, $.custom = L, $.oneOf = Y, $.instanceOf = J, $.oneOfType = B, $.arrayOf = I, $.objectOf = M, $.shape =
    R, $.utils = {
        validate: function (K, C) {
            return _(C, K, !0) === !0
        },
        toType: function (K, C, H) {
            return H === void 0 && (H = !1), H ? w(K, C) : T(K, C)
        }
    };
(function (K) {
    function C() {
        return K.apply(this, arguments) || this
    }
    return r$1(C, K), C
})(z());
var PropTypes = z({
    func: void 0,
    bool: void 0,
    string: void 0,
    number: void 0,
    array: void 0,
    object: void 0,
    integer: void 0
});
PropTypes.extend([{
    name: "looseBool",
    getter: !0,
    type: Boolean,
    default: void 0
}, {
    name: "style",
    getter: !0,
    type: [String, Object],
    default: void 0
}, {
    name: "VueNode",
    getter: !0,
    type: null
}]);

function withUndefined(K) {
    return K.default = void 0, K
}
const PropTypes$1 = PropTypes;
var _excluded$12 = ["image", "description", "imageStyle", "class"],
    defaultEmptyImg = createVNode(DefaultEmptyImg, null, null),
    simpleEmptyImg = createVNode(SimpleEmptyImg, null, null),
    Empty = function (C, H) {
        var W, U = H.slots,
            G = U === void 0 ? {} : U,
            X = H.attrs,
            Z = useConfigInject("empty", C),
            Q = Z.direction,
            ee = Z.prefixCls,
            ne = ee.value,
            te = _objectSpread2$1(_objectSpread2$1({}, C), X),
            re = te.image,
            ae = re === void 0 ? defaultEmptyImg : re,
            oe = te.description,
            ie = oe === void 0 ? ((W = G.description) === null || W === void 0 ? void 0 : W.call(G)) || void 0 : oe,
            ue = te.imageStyle,
            le = te.class,
            se = le === void 0 ? "" : le,
            ce = _objectWithoutProperties$2(te, _excluded$12);
        return createVNode(LocaleReceiver, {
            componentName: "Empty",
            children: function (ve) {
                var fe, pe = typeof ie < "u" ? ie : ve.description,
                    me = typeof pe == "string" ? pe : "empty",
                    he = null;
                return typeof ae == "string" ? he = createVNode("img", {
                    alt: me,
                    src: ae
                }, null) : he = ae, createVNode("div", _objectSpread2$1({
                    class: classNames(ne, se, (fe = {}, _defineProperty$V(fe, "".concat(ne,
                        "-normal"), ae === simpleEmptyImg), _defineProperty$V(fe,
                        "".concat(ne, "-rtl"), Q.value === "rtl"), fe))
                }, ce), [createVNode("div", {
                    class: "".concat(ne, "-image"),
                    style: ue
                }, [he]), pe && createVNode("p", {
                    class: "".concat(ne, "-description")
                }, [pe]), G.default && createVNode("div", {
                    class: "".concat(ne, "-footer")
                }, [filterEmpty(G.default())])])
            }
        }, null)
    };
Empty.displayName = "AEmpty";
Empty.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
Empty.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
Empty.inheritAttrs = !1;
Empty.props = {
    prefixCls: String,
    image: PropTypes$1.any,
    description: PropTypes$1.any,
    imageStyle: {
        type: Object,
        default: void 0
    }
};
const Empty$1 = withInstall(Empty);
var RenderEmpty = function (C) {
    var H = useConfigInject("empty", C),
        W = H.prefixCls,
        U = function (X) {
            switch (X) {
                case "Table":
                case "List":
                    return createVNode(Empty$1, {
                        image: Empty$1.PRESENTED_IMAGE_SIMPLE
                    }, null);
                case "Select":
                case "TreeSelect":
                case "Cascader":
                case "Transfer":
                case "Mentions":
                    return createVNode(Empty$1, {
                        image: Empty$1.PRESENTED_IMAGE_SIMPLE,
                        class: "".concat(W.value, "-small")
                    }, null);
                default:
                    return createVNode(Empty$1, null, null)
            }
        };
    return U(C.componentName)
};

function renderEmpty(K) {
    return createVNode(RenderEmpty, {
        componentName: K
    }, null)
}
var warned = {};

function warning$3(K, C) {}

function note(K, C) {}

function call(K, C, H) {
    !C && !warned[H] && (K(!1, H), warned[H] = !0)
}

function warningOnce(K, C) {
    call(warning$3, K, C)
}

function noteOnce(K, C) {
    call(note, K, C)
}
const warning$2 = function (K, C) {
    var H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    warningOnce(K, "[antdv: ".concat(C, "] ").concat(H))
};
var ANT_MARK = "internalMark",
    LocaleProvider = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ALocaleProvider",
        props: {
            locale: {
                type: Object
            },
            ANT_MARK__: String
        },
        setup: function (C, H) {
            var W = H.slots;
            warning$2(C.ANT_MARK__ === ANT_MARK, "LocaleProvider",
                "`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead");
            var U = reactive({
                antLocale: _objectSpread2$1(_objectSpread2$1({}, C.locale), {}, {
                    exist: !0
                }),
                ANT_MARK__: ANT_MARK
            });
            return provide("localeData", U), watch(function () {
                    return C.locale
                }, function () {
                    U.antLocale = _objectSpread2$1(_objectSpread2$1({}, C.locale), {}, {
                        exist: !0
                    })
                }, {
                    immediate: !0
                }),
                function () {
                    var G;
                    return (G = W.default) === null || G === void 0 ? void 0 : G.call(W)
                }
        }
    });
LocaleProvider.install = function (K) {
    return K.component(LocaleProvider.name, LocaleProvider), K
};
const LocaleProvider$1 = withInstall(LocaleProvider);
tuple$1("bottomLeft", "bottomRight", "topLeft", "topRight");
var getTransitionDirection = function (C) {
        return C !== void 0 && (C === "topLeft" || C === "topRight") ? "slide-down" : "slide-up"
    },
    getTransitionProps = function (C) {
        var H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            W = _objectSpread2$1(C ? {
                name: C,
                appear: !0,
                enterFromClass: "".concat(C, "-enter ").concat(C, "-enter-prepare"),
                enterActiveClass: "".concat(C, "-enter ").concat(C, "-enter-prepare"),
                enterToClass: "".concat(C, "-enter ").concat(C, "-enter-active"),
                leaveFromClass: " ".concat(C, "-leave"),
                leaveActiveClass: "".concat(C, "-leave ").concat(C, "-leave-active"),
                leaveToClass: "".concat(C, "-leave ").concat(C, "-leave-active")
            } : {
                css: !1
            }, H);
        return W
    },
    getTransitionGroupProps = function (C) {
        var H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            W = _objectSpread2$1(C ? {
                name: C,
                appear: !0,
                appearActiveClass: "".concat(C),
                appearToClass: "".concat(C, "-appear ").concat(C, "-appear-active"),
                enterFromClass: "".concat(C, "-appear ").concat(C, "-enter ").concat(C, "-appear-prepare ").concat(
                    C, "-enter-prepare"),
                enterActiveClass: "".concat(C),
                enterToClass: "".concat(C, "-enter ").concat(C, "-appear ").concat(C, "-appear-active ").concat(C,
                    "-enter-active"),
                leaveActiveClass: "".concat(C, " ").concat(C, "-leave"),
                leaveToClass: "".concat(C, "-leave-active")
            } : {
                css: !1
            }, H);
        return W
    },
    getTransitionName$2 = function (C, H, W) {
        return W !== void 0 ? W : "".concat(C, "-").concat(H)
    };
const Notice = defineComponent({
    name: "Notice",
    inheritAttrs: !1,
    props: ["prefixCls", "duration", "updateMark", "noticeKey", "closeIcon", "closable", "props", "onClick",
        "onClose", "holder", "visible"],
    setup: function (C, H) {
        var W = H.attrs,
            U = H.slots,
            G, X = !1,
            Z = computed(function () {
                return C.duration === void 0 ? 4.5 : C.duration
            }),
            Q = function () {
                Z.value && !X && (G = setTimeout(function () {
                    ne()
                }, Z.value * 1e3))
            },
            ee = function () {
                G && (clearTimeout(G), G = null)
            },
            ne = function (ae) {
                ae && ae.stopPropagation(), ee();
                var oe = C.onClose,
                    ie = C.noticeKey;
                oe && oe(ie)
            },
            te = function () {
                ee(), Q()
            };
        return onMounted(function () {
                Q()
            }), onUnmounted(function () {
                X = !0, ee()
            }), watch([Z, function () {
                return C.updateMark
            }, function () {
                return C.visible
            }], function (re, ae) {
                var oe = _slicedToArray$2(re, 3),
                    ie = oe[0],
                    ue = oe[1],
                    le = oe[2],
                    se = _slicedToArray$2(ae, 3),
                    ce = se[0],
                    de = se[1],
                    ve = se[2];
                (ie !== ce || ue !== de || le !== ve && ve) && te()
            }, {
                flush: "post"
            }),
            function () {
                var re, ae, oe = C.prefixCls,
                    ie = C.closable,
                    ue = C.closeIcon,
                    le = ue === void 0 ? (re = U.closeIcon) === null || re === void 0 ? void 0 : re.call(U) :
                    ue,
                    se = C.onClick,
                    ce = C.holder,
                    de = W.class,
                    ve = W.style,
                    fe = "".concat(oe, "-notice"),
                    pe = Object.keys(W).reduce(function (he, Se) {
                        return (Se.substr(0, 5) === "data-" || Se.substr(0, 5) === "aria-" || Se ===
                            "role") && (he[Se] = W[Se]), he
                    }, {}),
                    me = createVNode("div", _objectSpread2$1({
                        class: classNames(fe, de, _defineProperty$V({}, "".concat(fe, "-closable"),
                            ie)),
                        style: ve,
                        onMouseenter: ee,
                        onMouseleave: Q,
                        onClick: se
                    }, pe), [createVNode("div", {
                            class: "".concat(fe, "-content")
                        }, [(ae = U.default) === null || ae === void 0 ? void 0 : ae.call(U)]), ie ?
                        createVNode("a", {
                            tabindex: 0,
                            onClick: ne,
                            class: "".concat(fe, "-close")
                        }, [le || createVNode("span", {
                            class: "".concat(fe, "-close-x")
                        }, null)]) : null]);
                return ce ? createVNode(Teleport, {
                    to: ce
                }, {
                    default: function () {
                        return me
                    }
                }) : me
            }
    }
});
var _excluded$11 = ["name", "getContainer", "appContext", "prefixCls", "rootPrefixCls", "transitionName",
        "hasTransitionName"],
    seed = 0,
    now$4 = Date.now();

function getUuid() {
    var K = seed;
    return seed += 1, "rcNotification_".concat(now$4, "_").concat(K)
}
var Notification = defineComponent({
    name: "Notification",
    inheritAttrs: !1,
    props: ["prefixCls", "transitionName", "animation", "maxCount", "closeIcon"],
    setup: function (C, H) {
        var W = H.attrs,
            U = H.expose,
            G = H.slots,
            X = new Map,
            Z = ref([]),
            Q = computed(function () {
                var te = C.prefixCls,
                    re = C.animation,
                    ae = re === void 0 ? "fade" : re,
                    oe = C.transitionName;
                return !oe && ae && (oe = "".concat(te, "-").concat(ae)), getTransitionGroupProps(oe)
            }),
            ee = function (re, ae) {
                var oe = re.key || getUuid(),
                    ie = _objectSpread2$1(_objectSpread2$1({}, re), {}, {
                        key: oe
                    }),
                    ue = C.maxCount,
                    le = Z.value.map(function (ce) {
                        return ce.notice.key
                    }).indexOf(oe),
                    se = Z.value.concat();
                le !== -1 ? se.splice(le, 1, {
                    notice: ie,
                    holderCallback: ae
                }) : (ue && Z.value.length >= ue && (ie.key = se[0].notice.key, ie.updateMark = getUuid(),
                    ie.userPassKey = oe, se.shift()), se.push({
                    notice: ie,
                    holderCallback: ae
                })), Z.value = se
            },
            ne = function (re) {
                Z.value = Z.value.filter(function (ae) {
                    var oe = ae.notice,
                        ie = oe.key,
                        ue = oe.userPassKey,
                        le = ue || ie;
                    return le !== re
                })
            };
        return U({
                add: ee,
                remove: ne,
                notices: Z
            }),
            function () {
                var te, re, ae = C.prefixCls,
                    oe = C.closeIcon,
                    ie = oe === void 0 ? (te = G.closeIcon) === null || te === void 0 ? void 0 : te.call(G, {
                        prefixCls: ae
                    }) : oe,
                    ue = Z.value.map(function (se, ce) {
                        var de = se.notice,
                            ve = se.holderCallback,
                            fe = ce === Z.value.length - 1 ? de.updateMark : void 0,
                            pe = de.key,
                            me = de.userPassKey,
                            he = de.content,
                            Se = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                                prefixCls: ae,
                                closeIcon: typeof ie == "function" ? ie({
                                    prefixCls: ae
                                }) : ie
                            }, de), de.props), {}, {
                                key: pe,
                                noticeKey: me || pe,
                                updateMark: fe,
                                onClose: function (be) {
                                    var ge;
                                    ne(be), (ge = de.onClose) === null || ge === void 0 || ge.call(
                                        de)
                                },
                                onClick: de.onClick
                            });
                        return ve ? createVNode("div", {
                            key: pe,
                            class: "".concat(ae, "-hook-holder"),
                            ref: function (be) {
                                typeof pe > "u" || (be ? (X.set(pe, be), ve(be, Se)) : X.delete(
                                    pe))
                            }
                        }, null) : createVNode(Notice, Se, {
                            default: function () {
                                return [typeof he == "function" ? he({
                                    prefixCls: ae
                                }) : he]
                            }
                        })
                    }),
                    le = (re = {}, _defineProperty$V(re, ae, 1), _defineProperty$V(re, W.class, !!W.class),
                        re);
                return createVNode("div", {
                    class: le,
                    style: W.style || {
                        top: "65px",
                        left: "50%"
                    }
                }, [createVNode(TransitionGroup, _objectSpread2$1({
                    tag: "div"
                }, Q.value), {
                    default: function () {
                        return [ue]
                    }
                })])
            }
    }
});
Notification.newInstance = function (C, H) {
    var W = C || {},
        U = W.name,
        G = U === void 0 ? "notification" : U,
        X = W.getContainer,
        Z = W.appContext,
        Q = W.prefixCls,
        ee = W.rootPrefixCls,
        ne = W.transitionName,
        te = W.hasTransitionName,
        re = _objectWithoutProperties$2(W, _excluded$11),
        ae = document.createElement("div");
    if (X) {
        var oe = X();
        oe.appendChild(ae)
    } else document.body.appendChild(ae);
    var ie = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "NotificationWrapper",
            setup: function (se, ce) {
                var de = ce.attrs,
                    ve = ref();
                return onMounted(function () {
                        H({
                            notice: function (pe) {
                                var me;
                                (me = ve.value) === null || me === void 0 || me.add(pe)
                            },
                            removeNotice: function (pe) {
                                var me;
                                (me = ve.value) === null || me === void 0 || me.remove(pe)
                            },
                            destroy: function () {
                                render(null, ae), ae.parentNode && ae.parentNode.removeChild(
                                    ae)
                            },
                            component: ve
                        })
                    }),
                    function () {
                        var fe = globalConfigForApi,
                            pe = fe.getPrefixCls(G, Q),
                            me = fe.getRootPrefixCls(ee, pe),
                            he = te ? ne : "".concat(me, "-").concat(ne);
                        return createVNode(ConfigProvider$1, _objectSpread2$1(_objectSpread2$1({}, fe), {}, {
                            notUpdateGlobalConfig: !0,
                            prefixCls: me
                        }), {
                            default: function () {
                                return [createVNode(Notification, _objectSpread2$1(
                                    _objectSpread2$1({
                                        ref: ve
                                    }, de), {}, {
                                        prefixCls: pe,
                                        transitionName: he
                                    }), null)]
                            }
                        })
                    }
            }
        }),
        ue = createVNode(ie, re);
    ue.appContext = Z || ue.appContext, render(ue, ae)
};
const Notification$1 = Notification;
var LoadingOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "0 0 1024 1024",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z"
            }
        }]
    },
    name: "loading",
    theme: "outlined"
};
const LoadingOutlinedSvg = LoadingOutlined$2;

function bound01(K, C) {
    isOnePointZero(K) && (K = "100%");
    var H = isPercentage(K);
    return K = C === 360 ? K : Math.min(C, Math.max(0, parseFloat(K))), H && (K = parseInt(String(K * C), 10) / 100),
        Math.abs(K - C) < 1e-6 ? 1 : (C === 360 ? K = (K < 0 ? K % C + C : K % C) / parseFloat(String(C)) : K = K % C /
            parseFloat(String(C)), K)
}

function clamp01(K) {
    return Math.min(1, Math.max(0, K))
}

function isOnePointZero(K) {
    return typeof K == "string" && K.indexOf(".") !== -1 && parseFloat(K) === 1
}

function isPercentage(K) {
    return typeof K == "string" && K.indexOf("%") !== -1
}

function boundAlpha(K) {
    return K = parseFloat(K), (isNaN(K) || K < 0 || K > 1) && (K = 1), K
}

function convertToPercentage(K) {
    return K <= 1 ? "".concat(Number(K) * 100, "%") : K
}

function pad2(K) {
    return K.length === 1 ? "0" + K : String(K)
}

function rgbToRgb(K, C, H) {
    return {
        r: bound01(K, 255) * 255,
        g: bound01(C, 255) * 255,
        b: bound01(H, 255) * 255
    }
}

function rgbToHsl(K, C, H) {
    K = bound01(K, 255), C = bound01(C, 255), H = bound01(H, 255);
    var W = Math.max(K, C, H),
        U = Math.min(K, C, H),
        G = 0,
        X = 0,
        Z = (W + U) / 2;
    if (W === U) X = 0, G = 0;
    else {
        var Q = W - U;
        switch (X = Z > .5 ? Q / (2 - W - U) : Q / (W + U), W) {
            case K:
                G = (C - H) / Q + (C < H ? 6 : 0);
                break;
            case C:
                G = (H - K) / Q + 2;
                break;
            case H:
                G = (K - C) / Q + 4;
                break
        }
        G /= 6
    }
    return {
        h: G,
        s: X,
        l: Z
    }
}

function hue2rgb(K, C, H) {
    return H < 0 && (H += 1), H > 1 && (H -= 1), H < 1 / 6 ? K + (C - K) * (6 * H) : H < 1 / 2 ? C : H < 2 / 3 ? K + (C -
        K) * (2 / 3 - H) * 6 : K
}

function hslToRgb(K, C, H) {
    var W, U, G;
    if (K = bound01(K, 360), C = bound01(C, 100), H = bound01(H, 100), C === 0) U = H, G = H, W = H;
    else {
        var X = H < .5 ? H * (1 + C) : H + C - H * C,
            Z = 2 * H - X;
        W = hue2rgb(Z, X, K + 1 / 3), U = hue2rgb(Z, X, K), G = hue2rgb(Z, X, K - 1 / 3)
    }
    return {
        r: W * 255,
        g: U * 255,
        b: G * 255
    }
}

function rgbToHsv(K, C, H) {
    K = bound01(K, 255), C = bound01(C, 255), H = bound01(H, 255);
    var W = Math.max(K, C, H),
        U = Math.min(K, C, H),
        G = 0,
        X = W,
        Z = W - U,
        Q = W === 0 ? 0 : Z / W;
    if (W === U) G = 0;
    else {
        switch (W) {
            case K:
                G = (C - H) / Z + (C < H ? 6 : 0);
                break;
            case C:
                G = (H - K) / Z + 2;
                break;
            case H:
                G = (K - C) / Z + 4;
                break
        }
        G /= 6
    }
    return {
        h: G,
        s: Q,
        v: X
    }
}

function hsvToRgb(K, C, H) {
    K = bound01(K, 360) * 6, C = bound01(C, 100), H = bound01(H, 100);
    var W = Math.floor(K),
        U = K - W,
        G = H * (1 - C),
        X = H * (1 - U * C),
        Z = H * (1 - (1 - U) * C),
        Q = W % 6,
        ee = [H, X, G, G, Z, H][Q],
        ne = [Z, H, H, X, G, G][Q],
        te = [G, G, Z, H, H, X][Q];
    return {
        r: ee * 255,
        g: ne * 255,
        b: te * 255
    }
}

function rgbToHex(K, C, H, W) {
    var U = [pad2(Math.round(K).toString(16)), pad2(Math.round(C).toString(16)), pad2(Math.round(H).toString(16))];
    return W && U[0].startsWith(U[0].charAt(1)) && U[1].startsWith(U[1].charAt(1)) && U[2].startsWith(U[2].charAt(1)) ?
        U[0].charAt(0) + U[1].charAt(0) + U[2].charAt(0) : U.join("")
}

function rgbaToHex(K, C, H, W, U) {
    var G = [pad2(Math.round(K).toString(16)), pad2(Math.round(C).toString(16)), pad2(Math.round(H).toString(16)), pad2(
        convertDecimalToHex(W))];
    return U && G[0].startsWith(G[0].charAt(1)) && G[1].startsWith(G[1].charAt(1)) && G[2].startsWith(G[2].charAt(1)) &&
        G[3].startsWith(G[3].charAt(1)) ? G[0].charAt(0) + G[1].charAt(0) + G[2].charAt(0) + G[3].charAt(0) : G.join("")
}

function convertDecimalToHex(K) {
    return Math.round(parseFloat(K) * 255).toString(16)
}

function convertHexToDecimal(K) {
    return parseIntFromHex(K) / 255
}

function parseIntFromHex(K) {
    return parseInt(K, 16)
}

function numberInputToObject(K) {
    return {
        r: K >> 16,
        g: (K & 65280) >> 8,
        b: K & 255
    }
}
var names = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    goldenrod: "#daa520",
    gold: "#ffd700",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavenderblush: "#fff0f5",
    lavender: "#e6e6fa",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
};

function inputToRGB(K) {
    var C = {
            r: 0,
            g: 0,
            b: 0
        },
        H = 1,
        W = null,
        U = null,
        G = null,
        X = !1,
        Z = !1;
    return typeof K == "string" && (K = stringInputToObject(K)), typeof K == "object" && (isValidCSSUnit(K.r) &&
        isValidCSSUnit(K.g) && isValidCSSUnit(K.b) ? (C = rgbToRgb(K.r, K.g, K.b), X = !0, Z = String(K.r).substr(-
            1) === "%" ? "prgb" : "rgb") : isValidCSSUnit(K.h) && isValidCSSUnit(K.s) && isValidCSSUnit(K.v) ? (W =
            convertToPercentage(K.s), U = convertToPercentage(K.v), C = hsvToRgb(K.h, W, U), X = !0, Z = "hsv") :
        isValidCSSUnit(K.h) && isValidCSSUnit(K.s) && isValidCSSUnit(K.l) && (W = convertToPercentage(K.s), G =
            convertToPercentage(K.l), C = hslToRgb(K.h, W, G), X = !0, Z = "hsl"), Object.prototype.hasOwnProperty.call(
            K, "a") && (H = K.a)), H = boundAlpha(H), {
        ok: X,
        format: K.format || Z,
        r: Math.min(255, Math.max(C.r, 0)),
        g: Math.min(255, Math.max(C.g, 0)),
        b: Math.min(255, Math.max(C.b, 0)),
        a: H
    }
}
var CSS_INTEGER = "[-\\+]?\\d+%?",
    CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?",
    CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")"),
    PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT,
        ")\\s*\\)?"),
    PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT,
        ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?"),
    matchers = {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };

function stringInputToObject(K) {
    if (K = K.trim().toLowerCase(), K.length === 0) return !1;
    var C = !1;
    if (names[K]) K = names[K], C = !0;
    else if (K === "transparent") return {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
        format: "name"
    };
    var H = matchers.rgb.exec(K);
    return H ? {
        r: H[1],
        g: H[2],
        b: H[3]
    } : (H = matchers.rgba.exec(K), H ? {
        r: H[1],
        g: H[2],
        b: H[3],
        a: H[4]
    } : (H = matchers.hsl.exec(K), H ? {
        h: H[1],
        s: H[2],
        l: H[3]
    } : (H = matchers.hsla.exec(K), H ? {
        h: H[1],
        s: H[2],
        l: H[3],
        a: H[4]
    } : (H = matchers.hsv.exec(K), H ? {
        h: H[1],
        s: H[2],
        v: H[3]
    } : (H = matchers.hsva.exec(K), H ? {
        h: H[1],
        s: H[2],
        v: H[3],
        a: H[4]
    } : (H = matchers.hex8.exec(K), H ? {
        r: parseIntFromHex(H[1]),
        g: parseIntFromHex(H[2]),
        b: parseIntFromHex(H[3]),
        a: convertHexToDecimal(H[4]),
        format: C ? "name" : "hex8"
    } : (H = matchers.hex6.exec(K), H ? {
        r: parseIntFromHex(H[1]),
        g: parseIntFromHex(H[2]),
        b: parseIntFromHex(H[3]),
        format: C ? "name" : "hex"
    } : (H = matchers.hex4.exec(K), H ? {
        r: parseIntFromHex(H[1] + H[1]),
        g: parseIntFromHex(H[2] + H[2]),
        b: parseIntFromHex(H[3] + H[3]),
        a: convertHexToDecimal(H[4] + H[4]),
        format: C ? "name" : "hex8"
    } : (H = matchers.hex3.exec(K), H ? {
        r: parseIntFromHex(H[1] + H[1]),
        g: parseIntFromHex(H[2] + H[2]),
        b: parseIntFromHex(H[3] + H[3]),
        format: C ? "name" : "hex"
    } : !1)))))))))
}

function isValidCSSUnit(K) {
    return !!matchers.CSS_UNIT.exec(String(K))
}
var TinyColor = function () {
        function K(C, H) {
            C === void 0 && (C = ""), H === void 0 && (H = {});
            var W;
            if (C instanceof K) return C;
            typeof C == "number" && (C = numberInputToObject(C)), this.originalInput = C;
            var U = inputToRGB(C);
            this.originalInput = C, this.r = U.r, this.g = U.g, this.b = U.b, this.a = U.a, this.roundA = Math.round(
                    100 * this.a) / 100, this.format = (W = H.format) !== null && W !== void 0 ? W : U.format, this.gradientType =
                H.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)),
                this.b < 1 && (this.b = Math.round(this.b)), this.isValid = U.ok
        }
        return K.prototype.isDark = function () {
            return this.getBrightness() < 128
        }, K.prototype.isLight = function () {
            return !this.isDark()
        }, K.prototype.getBrightness = function () {
            var C = this.toRgb();
            return (C.r * 299 + C.g * 587 + C.b * 114) / 1e3
        }, K.prototype.getLuminance = function () {
            var C = this.toRgb(),
                H, W, U, G = C.r / 255,
                X = C.g / 255,
                Z = C.b / 255;
            return G <= .03928 ? H = G / 12.92 : H = Math.pow((G + .055) / 1.055, 2.4), X <= .03928 ? W = X / 12.92 :
                W = Math.pow((X + .055) / 1.055, 2.4), Z <= .03928 ? U = Z / 12.92 : U = Math.pow((Z + .055) /
                    1.055, 2.4), .2126 * H + .7152 * W + .0722 * U
        }, K.prototype.getAlpha = function () {
            return this.a
        }, K.prototype.setAlpha = function (C) {
            return this.a = boundAlpha(C), this.roundA = Math.round(100 * this.a) / 100, this
        }, K.prototype.isMonochrome = function () {
            var C = this.toHsl().s;
            return C === 0
        }, K.prototype.toHsv = function () {
            var C = rgbToHsv(this.r, this.g, this.b);
            return {
                h: C.h * 360,
                s: C.s,
                v: C.v,
                a: this.a
            }
        }, K.prototype.toHsvString = function () {
            var C = rgbToHsv(this.r, this.g, this.b),
                H = Math.round(C.h * 360),
                W = Math.round(C.s * 100),
                U = Math.round(C.v * 100);
            return this.a === 1 ? "hsv(".concat(H, ", ").concat(W, "%, ").concat(U, "%)") : "hsva(".concat(H, ", ")
                .concat(W, "%, ").concat(U, "%, ").concat(this.roundA, ")")
        }, K.prototype.toHsl = function () {
            var C = rgbToHsl(this.r, this.g, this.b);
            return {
                h: C.h * 360,
                s: C.s,
                l: C.l,
                a: this.a
            }
        }, K.prototype.toHslString = function () {
            var C = rgbToHsl(this.r, this.g, this.b),
                H = Math.round(C.h * 360),
                W = Math.round(C.s * 100),
                U = Math.round(C.l * 100);
            return this.a === 1 ? "hsl(".concat(H, ", ").concat(W, "%, ").concat(U, "%)") : "hsla(".concat(H, ", ")
                .concat(W, "%, ").concat(U, "%, ").concat(this.roundA, ")")
        }, K.prototype.toHex = function (C) {
            return C === void 0 && (C = !1), rgbToHex(this.r, this.g, this.b, C)
        }, K.prototype.toHexString = function (C) {
            return C === void 0 && (C = !1), "#" + this.toHex(C)
        }, K.prototype.toHex8 = function (C) {
            return C === void 0 && (C = !1), rgbaToHex(this.r, this.g, this.b, this.a, C)
        }, K.prototype.toHex8String = function (C) {
            return C === void 0 && (C = !1), "#" + this.toHex8(C)
        }, K.prototype.toHexShortString = function (C) {
            return C === void 0 && (C = !1), this.a === 1 ? this.toHexString(C) : this.toHex8String(C)
        }, K.prototype.toRgb = function () {
            return {
                r: Math.round(this.r),
                g: Math.round(this.g),
                b: Math.round(this.b),
                a: this.a
            }
        }, K.prototype.toRgbString = function () {
            var C = Math.round(this.r),
                H = Math.round(this.g),
                W = Math.round(this.b);
            return this.a === 1 ? "rgb(".concat(C, ", ").concat(H, ", ").concat(W, ")") : "rgba(".concat(C, ", ").concat(
                H, ", ").concat(W, ", ").concat(this.roundA, ")")
        }, K.prototype.toPercentageRgb = function () {
            var C = function (H) {
                return "".concat(Math.round(bound01(H, 255) * 100), "%")
            };
            return {
                r: C(this.r),
                g: C(this.g),
                b: C(this.b),
                a: this.a
            }
        }, K.prototype.toPercentageRgbString = function () {
            var C = function (H) {
                return Math.round(bound01(H, 255) * 100)
            };
            return this.a === 1 ? "rgb(".concat(C(this.r), "%, ").concat(C(this.g), "%, ").concat(C(this.b), "%)") :
                "rgba(".concat(C(this.r), "%, ").concat(C(this.g), "%, ").concat(C(this.b), "%, ").concat(this.roundA,
                    ")")
        }, K.prototype.toName = function () {
            if (this.a === 0) return "transparent";
            if (this.a < 1) return !1;
            for (var C = "#" + rgbToHex(this.r, this.g, this.b, !1), H = 0, W = Object.entries(names); H < W.length; H++) {
                var U = W[H],
                    G = U[0],
                    X = U[1];
                if (C === X) return G
            }
            return !1
        }, K.prototype.toString = function (C) {
            var H = !!C;
            C = C || this.format;
            var W = !1,
                U = this.a < 1 && this.a >= 0,
                G = !H && U && (C.startsWith("hex") || C === "name");
            return G ? C === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (C === "rgb" && (W =
                    this.toRgbString()), C === "prgb" && (W = this.toPercentageRgbString()), (C === "hex" || C ===
                    "hex6") && (W = this.toHexString()), C === "hex3" && (W = this.toHexString(!0)), C ===
                "hex4" && (W = this.toHex8String(!0)), C === "hex8" && (W = this.toHex8String()), C === "name" &&
                (W = this.toName()), C === "hsl" && (W = this.toHslString()), C === "hsv" && (W = this.toHsvString()),
                W || this.toHexString())
        }, K.prototype.toNumber = function () {
            return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b)
        }, K.prototype.clone = function () {
            return new K(this.toString())
        }, K.prototype.lighten = function (C) {
            C === void 0 && (C = 10);
            var H = this.toHsl();
            return H.l += C / 100, H.l = clamp01(H.l), new K(H)
        }, K.prototype.brighten = function (C) {
            C === void 0 && (C = 10);
            var H = this.toRgb();
            return H.r = Math.max(0, Math.min(255, H.r - Math.round(255 * -(C / 100)))), H.g = Math.max(0, Math.min(
                255, H.g - Math.round(255 * -(C / 100)))), H.b = Math.max(0, Math.min(255, H.b - Math.round(255 *
                -(C / 100)))), new K(H)
        }, K.prototype.darken = function (C) {
            C === void 0 && (C = 10);
            var H = this.toHsl();
            return H.l -= C / 100, H.l = clamp01(H.l), new K(H)
        }, K.prototype.tint = function (C) {
            return C === void 0 && (C = 10), this.mix("white", C)
        }, K.prototype.shade = function (C) {
            return C === void 0 && (C = 10), this.mix("black", C)
        }, K.prototype.desaturate = function (C) {
            C === void 0 && (C = 10);
            var H = this.toHsl();
            return H.s -= C / 100, H.s = clamp01(H.s), new K(H)
        }, K.prototype.saturate = function (C) {
            C === void 0 && (C = 10);
            var H = this.toHsl();
            return H.s += C / 100, H.s = clamp01(H.s), new K(H)
        }, K.prototype.greyscale = function () {
            return this.desaturate(100)
        }, K.prototype.spin = function (C) {
            var H = this.toHsl(),
                W = (H.h + C) % 360;
            return H.h = W < 0 ? 360 + W : W, new K(H)
        }, K.prototype.mix = function (C, H) {
            H === void 0 && (H = 50);
            var W = this.toRgb(),
                U = new K(C).toRgb(),
                G = H / 100,
                X = {
                    r: (U.r - W.r) * G + W.r,
                    g: (U.g - W.g) * G + W.g,
                    b: (U.b - W.b) * G + W.b,
                    a: (U.a - W.a) * G + W.a
                };
            return new K(X)
        }, K.prototype.analogous = function (C, H) {
            C === void 0 && (C = 6), H === void 0 && (H = 30);
            var W = this.toHsl(),
                U = 360 / H,
                G = [this];
            for (W.h = (W.h - (U * C >> 1) + 720) % 360; --C;) W.h = (W.h + U) % 360, G.push(new K(W));
            return G
        }, K.prototype.complement = function () {
            var C = this.toHsl();
            return C.h = (C.h + 180) % 360, new K(C)
        }, K.prototype.monochromatic = function (C) {
            C === void 0 && (C = 6);
            for (var H = this.toHsv(), W = H.h, U = H.s, G = H.v, X = [], Z = 1 / C; C--;) X.push(new K({
                h: W,
                s: U,
                v: G
            })), G = (G + Z) % 1;
            return X
        }, K.prototype.splitcomplement = function () {
            var C = this.toHsl(),
                H = C.h;
            return [this, new K({
                h: (H + 72) % 360,
                s: C.s,
                l: C.l
            }), new K({
                h: (H + 216) % 360,
                s: C.s,
                l: C.l
            })]
        }, K.prototype.onBackground = function (C) {
            var H = this.toRgb(),
                W = new K(C).toRgb(),
                U = H.a + W.a * (1 - H.a);
            return new K({
                r: (H.r * H.a + W.r * W.a * (1 - H.a)) / U,
                g: (H.g * H.a + W.g * W.a * (1 - H.a)) / U,
                b: (H.b * H.a + W.b * W.a * (1 - H.a)) / U,
                a: U
            })
        }, K.prototype.triad = function () {
            return this.polyad(3)
        }, K.prototype.tetrad = function () {
            return this.polyad(4)
        }, K.prototype.polyad = function (C) {
            for (var H = this.toHsl(), W = H.h, U = [this], G = 360 / C, X = 1; X < C; X++) U.push(new K({
                h: (W + X * G) % 360,
                s: H.s,
                l: H.l
            }));
            return U
        }, K.prototype.equals = function (C) {
            return this.toRgbString() === new K(C).toRgbString()
        }, K
    }(),
    hueStep = 2,
    saturationStep = .16,
    saturationStep2 = .05,
    brightnessStep1 = .05,
    brightnessStep2 = .15,
    lightColorCount = 5,
    darkColorCount = 4,
    darkColorMap = [{
        index: 7,
        opacity: .15
    }, {
        index: 6,
        opacity: .25
    }, {
        index: 5,
        opacity: .3
    }, {
        index: 5,
        opacity: .45
    }, {
        index: 5,
        opacity: .65
    }, {
        index: 5,
        opacity: .85
    }, {
        index: 4,
        opacity: .9
    }, {
        index: 3,
        opacity: .95
    }, {
        index: 2,
        opacity: .97
    }, {
        index: 1,
        opacity: .98
    }];

function toHsv(K) {
    var C = K.r,
        H = K.g,
        W = K.b,
        U = rgbToHsv(C, H, W);
    return {
        h: U.h * 360,
        s: U.s,
        v: U.v
    }
}

function toHex(K) {
    var C = K.r,
        H = K.g,
        W = K.b;
    return "#".concat(rgbToHex(C, H, W, !1))
}

function mix$1(K, C, H) {
    var W = H / 100,
        U = {
            r: (C.r - K.r) * W + K.r,
            g: (C.g - K.g) * W + K.g,
            b: (C.b - K.b) * W + K.b
        };
    return U
}

function getHue(K, C, H) {
    var W;
    return Math.round(K.h) >= 60 && Math.round(K.h) <= 240 ? W = H ? Math.round(K.h) - hueStep * C : Math.round(K.h) +
        hueStep * C : W = H ? Math.round(K.h) + hueStep * C : Math.round(K.h) - hueStep * C, W < 0 ? W += 360 : W >=
        360 && (W -= 360), W
}

function getSaturation(K, C, H) {
    if (K.h === 0 && K.s === 0) return K.s;
    var W;
    return H ? W = K.s - saturationStep * C : C === darkColorCount ? W = K.s + saturationStep : W = K.s +
        saturationStep2 * C, W > 1 && (W = 1), H && C === lightColorCount && W > .1 && (W = .1), W < .06 && (W = .06),
        Number(W.toFixed(2))
}

function getValue$4(K, C, H) {
    var W;
    return H ? W = K.v + brightnessStep1 * C : W = K.v - brightnessStep2 * C, W > 1 && (W = 1), Number(W.toFixed(2))
}

function generate$1(K) {
    for (var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, H = [], W = inputToRGB(K), U =
            lightColorCount; U > 0; U -= 1) {
        var G = toHsv(W),
            X = toHex(inputToRGB({
                h: getHue(G, U, !0),
                s: getSaturation(G, U, !0),
                v: getValue$4(G, U, !0)
            }));
        H.push(X)
    }
    H.push(toHex(W));
    for (var Z = 1; Z <= darkColorCount; Z += 1) {
        var Q = toHsv(W),
            ee = toHex(inputToRGB({
                h: getHue(Q, Z),
                s: getSaturation(Q, Z),
                v: getValue$4(Q, Z)
            }));
        H.push(ee)
    }
    return C.theme === "dark" ? darkColorMap.map(function (ne) {
        var te = ne.index,
            re = ne.opacity,
            ae = toHex(mix$1(inputToRGB(C.backgroundColor || "#141414"), inputToRGB(H[te]), re * 100));
        return ae
    }) : H
}
var presetPrimaryColors = {
        red: "#F5222D",
        volcano: "#FA541C",
        orange: "#FA8C16",
        gold: "#FAAD14",
        yellow: "#FADB14",
        lime: "#A0D911",
        green: "#52C41A",
        cyan: "#13C2C2",
        blue: "#1890FF",
        geekblue: "#2F54EB",
        purple: "#722ED1",
        magenta: "#EB2F96",
        grey: "#666666"
    },
    presetPalettes = {},
    presetDarkPalettes = {};
Object.keys(presetPrimaryColors).forEach(function (K) {
    presetPalettes[K] = generate$1(presetPrimaryColors[K]), presetPalettes[K].primary = presetPalettes[K][5],
        presetDarkPalettes[K] = generate$1(presetPrimaryColors[K], {
            theme: "dark",
            backgroundColor: "#141414"
        }), presetDarkPalettes[K].primary = presetDarkPalettes[K][5]
});
var containers = [],
    styleElements = [],
    usage = "insert-css: You need to provide a CSS string. Usage: insertCss(cssString[, options]).";

function createStyleElement() {
    var K = document.createElement("style");
    return K.setAttribute("type", "text/css"), K
}

function insertCss(K, C) {
    if (C = C || {}, K === void 0) throw new Error(usage);
    var H = C.prepend === !0 ? "prepend" : "append",
        W = C.container !== void 0 ? C.container : document.querySelector("head"),
        U = containers.indexOf(W);
    U === -1 && (U = containers.push(W) - 1, styleElements[U] = {});
    var G;
    return styleElements[U] !== void 0 && styleElements[U][H] !== void 0 ? G = styleElements[U][H] : (G = styleElements[
            U][H] = createStyleElement(), H === "prepend" ? W.insertBefore(G, W.childNodes[0]) : W.appendChild(G)), K.charCodeAt(
            0) === 65279 && (K = K.substr(1, K.length)), G.styleSheet ? G.styleSheet.cssText += K : G.textContent += K,
        G
}

function _objectSpread$T(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$U(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$U(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}

function warning$1(K, C) {}

function isIconDefinition(K) {
    return typeof K == "object" && typeof K.name == "string" && typeof K.theme == "string" && (typeof K.icon ==
        "object" || typeof K.icon == "function")
}

function generate(K, C, H) {
    return H ? h$1(K.tag, _objectSpread$T({
        key: C
    }, H, K.attrs), (K.children || []).map(function (W, U) {
        return generate(W, "".concat(C, "-").concat(K.tag, "-").concat(U))
    })) : h$1(K.tag, _objectSpread$T({
        key: C
    }, K.attrs), (K.children || []).map(function (W, U) {
        return generate(W, "".concat(C, "-").concat(K.tag, "-").concat(U))
    }))
}

function getSecondaryColor(K) {
    return generate$1(K)[0]
}

function normalizeTwoToneColors(K) {
    return K ? Array.isArray(K) ? K : [K] : []
}
var iconStyles =
    `
.anticon {
  display: inline-block;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.anticon > * {
  line-height: 1;
}

.anticon svg {
  display: inline-block;
}

.anticon::before {
  display: none;
}

.anticon .anticon-icon {
  display: block;
}

.anticon[tabindex] {
  cursor: pointer;
}

.anticon-spin::before,
.anticon-spin {
  display: inline-block;
  -webkit-animation: loadingCircle 1s infinite linear;
  animation: loadingCircle 1s infinite linear;
}

@-webkit-keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}
`,
    cssInjectedFlag = !1,
    useInsertStyles = function () {
        var C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : iconStyles;
        nextTick(function () {
            cssInjectedFlag || (typeof window < "u" && window.document && window.document.documentElement &&
                insertCss(C, {
                    prepend: !0
                }), cssInjectedFlag = !0)
        })
    },
    _excluded$10 = ["icon", "primaryColor", "secondaryColor"];

function _objectWithoutProperties$1(K, C) {
    if (K == null) return {};
    var H = _objectWithoutPropertiesLoose$1(K, C),
        W, U;
    if (Object.getOwnPropertySymbols) {
        var G = Object.getOwnPropertySymbols(K);
        for (U = 0; U < G.length; U++) W = G[U], !(C.indexOf(W) >= 0) && Object.prototype.propertyIsEnumerable.call(K,
            W) && (H[W] = K[W])
    }
    return H
}

function _objectWithoutPropertiesLoose$1(K, C) {
    if (K == null) return {};
    var H = {},
        W = Object.keys(K),
        U, G;
    for (G = 0; G < W.length; G++) U = W[G], !(C.indexOf(U) >= 0) && (H[U] = K[U]);
    return H
}

function _objectSpread$S(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$T(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$T(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var twoToneColorPalette = {
    primaryColor: "#333",
    secondaryColor: "#E6E6E6",
    calculated: !1
};

function setTwoToneColors(K) {
    var C = K.primaryColor,
        H = K.secondaryColor;
    twoToneColorPalette.primaryColor = C, twoToneColorPalette.secondaryColor = H || getSecondaryColor(C),
        twoToneColorPalette.calculated = !!H
}

function getTwoToneColors() {
    return _objectSpread$S({}, twoToneColorPalette)
}
var IconBase = function (C, H) {
    var W = _objectSpread$S({}, C, H.attrs),
        U = W.icon,
        G = W.primaryColor,
        X = W.secondaryColor,
        Z = _objectWithoutProperties$1(W, _excluded$10),
        Q = twoToneColorPalette;
    if (G && (Q = {
            primaryColor: G,
            secondaryColor: X || getSecondaryColor(G)
        }), useInsertStyles(), isIconDefinition(U), !isIconDefinition(U)) return null;
    var ee = U;
    return ee && typeof ee.icon == "function" && (ee = _objectSpread$S({}, ee, {
        icon: ee.icon(Q.primaryColor, Q.secondaryColor)
    })), generate(ee.icon, "svg-".concat(ee.name), _objectSpread$S({}, Z, {
        "data-icon": ee.name,
        width: "1em",
        height: "1em",
        fill: "currentColor",
        "aria-hidden": "true"
    }))
};
IconBase.props = {
    icon: Object,
    primaryColor: String,
    secondaryColor: String,
    focusable: String
};
IconBase.inheritAttrs = !1;
IconBase.displayName = "IconBase";
IconBase.getTwoToneColors = getTwoToneColors;
IconBase.setTwoToneColors = setTwoToneColors;
const VueIcon = IconBase;

function _slicedToArray$1(K, C) {
    return _arrayWithHoles$1(K) || _iterableToArrayLimit$1(K, C) || _unsupportedIterableToArray$1(K, C) ||
        _nonIterableRest$1()
}

function _nonIterableRest$1() {
    throw new TypeError(
        `Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`
    )
}

function _unsupportedIterableToArray$1(K, C) {
    if (K) {
        if (typeof K == "string") return _arrayLikeToArray$1(K, C);
        var H = Object.prototype.toString.call(K).slice(8, -1);
        if (H === "Object" && K.constructor && (H = K.constructor.name), H === "Map" || H === "Set") return Array.from(
            K);
        if (H === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(H)) return _arrayLikeToArray$1(K, C)
    }
}

function _arrayLikeToArray$1(K, C) {
    (C == null || C > K.length) && (C = K.length);
    for (var H = 0, W = new Array(C); H < C; H++) W[H] = K[H];
    return W
}

function _iterableToArrayLimit$1(K, C) {
    var H = K == null ? null : typeof Symbol < "u" && K[Symbol.iterator] || K["@@iterator"];
    if (H != null) {
        var W = [],
            U = !0,
            G = !1,
            X, Z;
        try {
            for (H = H.call(K); !(U = (X = H.next()).done) && (W.push(X.value), !(C && W.length === C)); U = !0);
        } catch (Q) {
            G = !0, Z = Q
        } finally {
            try {
                !U && H.return != null && H.return()
            } finally {
                if (G) throw Z
            }
        }
        return W
    }
}

function _arrayWithHoles$1(K) {
    if (Array.isArray(K)) return K
}

function setTwoToneColor(K) {
    var C = normalizeTwoToneColors(K),
        H = _slicedToArray$1(C, 2),
        W = H[0],
        U = H[1];
    return VueIcon.setTwoToneColors({
        primaryColor: W,
        secondaryColor: U
    })
}

function getTwoToneColor() {
    var K = VueIcon.getTwoToneColors();
    return K.calculated ? [K.primaryColor, K.secondaryColor] : K.primaryColor
}
var _excluded$$ = ["class", "icon", "spin", "rotate", "tabindex", "twoToneColor", "onClick"];

function _slicedToArray(K, C) {
    return _arrayWithHoles(K) || _iterableToArrayLimit(K, C) || _unsupportedIterableToArray(K, C) || _nonIterableRest()
}

function _nonIterableRest() {
    throw new TypeError(
        `Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`
    )
}

function _unsupportedIterableToArray(K, C) {
    if (K) {
        if (typeof K == "string") return _arrayLikeToArray(K, C);
        var H = Object.prototype.toString.call(K).slice(8, -1);
        if (H === "Object" && K.constructor && (H = K.constructor.name), H === "Map" || H === "Set") return Array.from(
            K);
        if (H === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(H)) return _arrayLikeToArray(K, C)
    }
}

function _arrayLikeToArray(K, C) {
    (C == null || C > K.length) && (C = K.length);
    for (var H = 0, W = new Array(C); H < C; H++) W[H] = K[H];
    return W
}

function _iterableToArrayLimit(K, C) {
    var H = K == null ? null : typeof Symbol < "u" && K[Symbol.iterator] || K["@@iterator"];
    if (H != null) {
        var W = [],
            U = !0,
            G = !1,
            X, Z;
        try {
            for (H = H.call(K); !(U = (X = H.next()).done) && (W.push(X.value), !(C && W.length === C)); U = !0);
        } catch (Q) {
            G = !0, Z = Q
        } finally {
            try {
                !U && H.return != null && H.return()
            } finally {
                if (G) throw Z
            }
        }
        return W
    }
}

function _arrayWithHoles(K) {
    if (Array.isArray(K)) return K
}

function _objectSpread$R(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$S(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$S(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}

function _objectWithoutProperties(K, C) {
    if (K == null) return {};
    var H = _objectWithoutPropertiesLoose(K, C),
        W, U;
    if (Object.getOwnPropertySymbols) {
        var G = Object.getOwnPropertySymbols(K);
        for (U = 0; U < G.length; U++) W = G[U], !(C.indexOf(W) >= 0) && Object.prototype.propertyIsEnumerable.call(K,
            W) && (H[W] = K[W])
    }
    return H
}

function _objectWithoutPropertiesLoose(K, C) {
    if (K == null) return {};
    var H = {},
        W = Object.keys(K),
        U, G;
    for (G = 0; G < W.length; G++) U = W[G], !(C.indexOf(U) >= 0) && (H[U] = K[U]);
    return H
}
setTwoToneColor("#1890ff");
var Icon = function (C, H) {
    var W, U = _objectSpread$R({}, C, H.attrs),
        G = U.class,
        X = U.icon,
        Z = U.spin,
        Q = U.rotate,
        ee = U.tabindex,
        ne = U.twoToneColor,
        te = U.onClick,
        re = _objectWithoutProperties(U, _excluded$$),
        ae = (W = {
            anticon: !0
        }, _defineProperty$S(W, "anticon-".concat(X.name), !!X.name), _defineProperty$S(W, G, G), W),
        oe = Z === "" || Z || X.name === "loading" ? "anticon-spin" : "",
        ie = ee;
    ie === void 0 && te && (ie = -1, re.tabindex = ie);
    var ue = Q ? {
            msTransform: "rotate(".concat(Q, "deg)"),
            transform: "rotate(".concat(Q, "deg)")
        } : void 0,
        le = normalizeTwoToneColors(ne),
        se = _slicedToArray(le, 2),
        ce = se[0],
        de = se[1];
    return createVNode("span", _objectSpread$R({
        role: "img",
        "aria-label": X.name
    }, re, {
        onClick: te,
        class: ae
    }), [createVNode(VueIcon, {
        class: oe,
        icon: X,
        primaryColor: ce,
        secondaryColor: de,
        style: ue
    }, null)])
};
Icon.props = {
    spin: Boolean,
    rotate: Number,
    icon: Object,
    twoToneColor: String
};
Icon.displayName = "AntdIcon";
Icon.inheritAttrs = !1;
Icon.getTwoToneColor = getTwoToneColor;
Icon.setTwoToneColor = setTwoToneColor;
const AntdIcon = Icon;

function _objectSpread$Q(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$R(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$R(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var LoadingOutlined = function (C, H) {
    var W = _objectSpread$Q({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$Q({}, W, {
        icon: LoadingOutlinedSvg
    }), null)
};
LoadingOutlined.displayName = "LoadingOutlined";
LoadingOutlined.inheritAttrs = !1;
const LoadingOutlined$1 = LoadingOutlined;
var ExclamationCircleFilled$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z"
            }
        }]
    },
    name: "exclamation-circle",
    theme: "filled"
};
const ExclamationCircleFilledSvg = ExclamationCircleFilled$2;

function _objectSpread$P(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$Q(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$Q(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var ExclamationCircleFilled = function (C, H) {
    var W = _objectSpread$P({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$P({}, W, {
        icon: ExclamationCircleFilledSvg
    }), null)
};
ExclamationCircleFilled.displayName = "ExclamationCircleFilled";
ExclamationCircleFilled.inheritAttrs = !1;
const ExclamationCircleFilled$1 = ExclamationCircleFilled;
var CloseCircleFilled$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 01-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z"
            }
        }]
    },
    name: "close-circle",
    theme: "filled"
};
const CloseCircleFilledSvg = CloseCircleFilled$2;

function _objectSpread$O(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$P(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$P(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var CloseCircleFilled = function (C, H) {
    var W = _objectSpread$O({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$O({}, W, {
        icon: CloseCircleFilledSvg
    }), null)
};
CloseCircleFilled.displayName = "CloseCircleFilled";
CloseCircleFilled.inheritAttrs = !1;
const CloseCircleFilled$1 = CloseCircleFilled;
var CheckCircleFilled$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z"
            }
        }]
    },
    name: "check-circle",
    theme: "filled"
};
const CheckCircleFilledSvg = CheckCircleFilled$2;

function _objectSpread$N(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$O(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$O(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var CheckCircleFilled = function (C, H) {
    var W = _objectSpread$N({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$N({}, W, {
        icon: CheckCircleFilledSvg
    }), null)
};
CheckCircleFilled.displayName = "CheckCircleFilled";
CheckCircleFilled.inheritAttrs = !1;
const CheckCircleFilled$1 = CheckCircleFilled;
var InfoCircleFilled$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z"
            }
        }]
    },
    name: "info-circle",
    theme: "filled"
};
const InfoCircleFilledSvg = InfoCircleFilled$2;

function _objectSpread$M(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$N(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$N(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var InfoCircleFilled = function (C, H) {
    var W = _objectSpread$M({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$M({}, W, {
        icon: InfoCircleFilledSvg
    }), null)
};
InfoCircleFilled.displayName = "InfoCircleFilled";
InfoCircleFilled.inheritAttrs = !1;
const InfoCircleFilled$1 = InfoCircleFilled;
var defaultDuration$1 = 3,
    defaultTop$1, messageInstance, key = 1,
    localPrefixCls = "",
    transitionName = "move-up",
    hasTransitionName = !1,
    getContainer$1 = function () {
        return document.body
    },
    maxCount$1, rtl$1 = !1;

function getKeyThenIncreaseKey() {
    return key++
}

function setMessageConfig(K) {
    K.top !== void 0 && (defaultTop$1 = K.top, messageInstance = null), K.duration !== void 0 && (defaultDuration$1 = K
        .duration), K.prefixCls !== void 0 && (localPrefixCls = K.prefixCls), K.getContainer !== void 0 && (
        getContainer$1 = K.getContainer, messageInstance = null), K.transitionName !== void 0 && (transitionName =
        K.transitionName, messageInstance = null, hasTransitionName = !0), K.maxCount !== void 0 && (maxCount$1 = K
        .maxCount, messageInstance = null), K.rtl !== void 0 && (rtl$1 = K.rtl)
}

function getMessageInstance(K, C) {
    if (messageInstance) {
        C(messageInstance);
        return
    }
    Notification$1.newInstance({
        appContext: K.appContext,
        prefixCls: K.prefixCls || localPrefixCls,
        rootPrefixCls: K.rootPrefixCls,
        transitionName,
        hasTransitionName,
        style: {
            top: defaultTop$1
        },
        getContainer: getContainer$1 || K.getPopupContainer,
        maxCount: maxCount$1,
        name: "message"
    }, function (H) {
        if (messageInstance) {
            C(messageInstance);
            return
        }
        messageInstance = H, C(H)
    })
}
var typeToIcon$1 = {
    info: InfoCircleFilled$1,
    success: CheckCircleFilled$1,
    error: CloseCircleFilled$1,
    warning: ExclamationCircleFilled$1,
    loading: LoadingOutlined$1
};

function notice$1(K) {
    var C = K.duration !== void 0 ? K.duration : defaultDuration$1,
        H = K.key || getKeyThenIncreaseKey(),
        W = new Promise(function (G) {
            var X = function () {
                return typeof K.onClose == "function" && K.onClose(), G(!0)
            };
            getMessageInstance(K, function (Z) {
                Z.notice({
                    key: H,
                    duration: C,
                    style: K.style || {},
                    class: K.class,
                    content: function (ee) {
                        var ne, te = ee.prefixCls,
                            re = typeToIcon$1[K.type],
                            ae = re ? createVNode(re, null, null) : "",
                            oe = classNames("".concat(te, "-custom-content"), (ne = {},
                                _defineProperty$V(ne, "".concat(te, "-").concat(K.type), K.type),
                                _defineProperty$V(ne, "".concat(te, "-rtl"), rtl$1 === !0),
                                ne));
                        return createVNode("div", {
                            class: oe
                        }, [typeof K.icon == "function" ? K.icon() : K.icon || ae,
                            createVNode("span", null, [typeof K.content == "function" ?
                                K.content() : K.content])])
                    },
                    onClose: X,
                    onClick: K.onClick
                })
            })
        }),
        U = function () {
            messageInstance && messageInstance.removeNotice(H)
        };
    return U.then = function (G, X) {
        return W.then(G, X)
    }, U.promise = W, U
}

function isArgsProps(K) {
    return Object.prototype.toString.call(K) === "[object Object]" && !!K.content
}
var api$1 = {
    open: notice$1,
    config: setMessageConfig,
    destroy: function (C) {
        if (messageInstance)
            if (C) {
                var H = messageInstance,
                    W = H.removeNotice;
                W(C)
            } else {
                var U = messageInstance,
                    G = U.destroy;
                G(), messageInstance = null
            }
    }
};

function attachTypeApi(K, C) {
    K[C] = function (H, W, U) {
        return isArgsProps(H) ? K.open(_objectSpread2$1(_objectSpread2$1({}, H), {}, {
            type: C
        })) : (typeof W == "function" && (U = W, W = void 0), K.open({
            content: H,
            duration: W,
            type: C,
            onClose: U
        }))
    }
} ["success", "info", "warning", "error", "loading"].forEach(function (K) {
    return attachTypeApi(api$1, K)
});
api$1.warn = api$1.warning;
const message$1 = api$1;

function asyncGeneratorStep(K, C, H, W, U, G, X) {
    try {
        var Z = K[G](X),
            Q = Z.value
    } catch (ee) {
        H(ee);
        return
    }
    Z.done ? C(Q) : Promise.resolve(Q).then(W, U)
}

function _asyncToGenerator(K) {
    return function () {
        var C = this,
            H = arguments;
        return new Promise(function (W, U) {
            var G = K.apply(C, H);

            function X(Q) {
                asyncGeneratorStep(G, W, U, X, Z, "next", Q)
            }

            function Z(Q) {
                asyncGeneratorStep(G, W, U, X, Z, "throw", Q)
            }
            X(void 0)
        })
    }
}
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global :
    typeof self < "u" ? self : {};

function getDefaultExportFromCjs(K) {
    return K && K.__esModule && Object.prototype.hasOwnProperty.call(K, "default") ? K.default : K
}
var regeneratorRuntimeExports = {},
    regeneratorRuntime$1 = {
        get exports() {
            return regeneratorRuntimeExports
        },
        set exports(K) {
            regeneratorRuntimeExports = K
        }
    },
    _typeofExports = {},
    _typeof$1 = {
        get exports() {
            return _typeofExports
        },
        set exports(K) {
            _typeofExports = K
        }
    };
(function (K) {
    function C(H) {
        return K.exports = C = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (W) {
            return typeof W
        } : function (W) {
            return W && typeof Symbol == "function" && W.constructor === Symbol && W !== Symbol.prototype ?
                "symbol" : typeof W
        }, K.exports.__esModule = !0, K.exports.default = K.exports, C(H)
    }
    K.exports = C, K.exports.__esModule = !0, K.exports.default = K.exports
})(_typeof$1);
(function (K) {
    var C = _typeofExports.default;

    function H() {
        K.exports = H = function () {
            return W
        }, K.exports.__esModule = !0, K.exports.default = K.exports;
        var W = {},
            U = Object.prototype,
            G = U.hasOwnProperty,
            X = Object.defineProperty || function (Pe, $e, ye) {
                Pe[$e] = ye.value
            },
            Z = typeof Symbol == "function" ? Symbol : {},
            Q = Z.iterator || "@@iterator",
            ee = Z.asyncIterator || "@@asyncIterator",
            ne = Z.toStringTag || "@@toStringTag";

        function te(Pe, $e, ye) {
            return Object.defineProperty(Pe, $e, {
                value: ye,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }), Pe[$e]
        }
        try {
            te({}, "")
        } catch {
            te = function (ye, Ce, we) {
                return ye[Ce] = we
            }
        }

        function re(Pe, $e, ye, Ce) {
            var we = $e && $e.prototype instanceof ie ? $e : ie,
                Oe = Object.create(we.prototype),
                Ne = new be(Ce || []);
            return X(Oe, "_invoke", {
                value: me(Pe, ye, Ne)
            }), Oe
        }

        function ae(Pe, $e, ye) {
            try {
                return {
                    type: "normal",
                    arg: Pe.call($e, ye)
                }
            } catch (Ce) {
                return {
                    type: "throw",
                    arg: Ce
                }
            }
        }
        W.wrap = re;
        var oe = {};

        function ie() {}

        function ue() {}

        function le() {}
        var se = {};
        te(se, Q, function () {
            return this
        });
        var ce = Object.getPrototypeOf,
            de = ce && ce(ce(ge([])));
        de && de !== U && G.call(de, Q) && (se = de);
        var ve = le.prototype = ie.prototype = Object.create(se);

        function fe(Pe) {
            ["next", "throw", "return"].forEach(function ($e) {
                te(Pe, $e, function (ye) {
                    return this._invoke($e, ye)
                })
            })
        }

        function pe(Pe, $e) {
            function ye(we, Oe, Ne, Me) {
                var Ve = ae(Pe[we], Pe, Oe);
                if (Ve.type !== "throw") {
                    var ke = Ve.arg,
                        Ee = ke.value;
                    return Ee && C(Ee) == "object" && G.call(Ee, "__await") ? $e.resolve(Ee.__await).then(function (
                        Ae) {
                        ye("next", Ae, Ne, Me)
                    }, function (Ae) {
                        ye("throw", Ae, Ne, Me)
                    }) : $e.resolve(Ee).then(function (Ae) {
                        ke.value = Ae, Ne(ke)
                    }, function (Ae) {
                        return ye("throw", Ae, Ne, Me)
                    })
                }
                Me(Ve.arg)
            }
            var Ce;
            X(this, "_invoke", {
                value: function (Oe, Ne) {
                    function Me() {
                        return new $e(function (Ve, ke) {
                            ye(Oe, Ne, Ve, ke)
                        })
                    }
                    return Ce = Ce ? Ce.then(Me, Me) : Me()
                }
            })
        }

        function me(Pe, $e, ye) {
            var Ce = "suspendedStart";
            return function (we, Oe) {
                if (Ce === "executing") throw new Error("Generator is already running");
                if (Ce === "completed") {
                    if (we === "throw") throw Oe;
                    return xe()
                }
                for (ye.method = we, ye.arg = Oe;;) {
                    var Ne = ye.delegate;
                    if (Ne) {
                        var Me = he(Ne, ye);
                        if (Me) {
                            if (Me === oe) continue;
                            return Me
                        }
                    }
                    if (ye.method === "next") ye.sent = ye._sent = ye.arg;
                    else if (ye.method === "throw") {
                        if (Ce === "suspendedStart") throw Ce = "completed", ye.arg;
                        ye.dispatchException(ye.arg)
                    } else ye.method === "return" && ye.abrupt("return", ye.arg);
                    Ce = "executing";
                    var Ve = ae(Pe, $e, ye);
                    if (Ve.type === "normal") {
                        if (Ce = ye.done ? "completed" : "suspendedYield", Ve.arg === oe) continue;
                        return {
                            value: Ve.arg,
                            done: ye.done
                        }
                    }
                    Ve.type === "throw" && (Ce = "completed", ye.method = "throw", ye.arg = Ve.arg)
                }
            }
        }

        function he(Pe, $e) {
            var ye = $e.method,
                Ce = Pe.iterator[ye];
            if (Ce === void 0) return $e.delegate = null, ye === "throw" && Pe.iterator.return && ($e.method =
                "return", $e.arg = void 0, he(Pe, $e), $e.method === "throw") || ye !== "return" && ($e.method =
                "throw", $e.arg = new TypeError("The iterator does not provide a '" + ye + "' method")), oe;
            var we = ae(Ce, Pe.iterator, $e.arg);
            if (we.type === "throw") return $e.method = "throw", $e.arg = we.arg, $e.delegate = null, oe;
            var Oe = we.arg;
            return Oe ? Oe.done ? ($e[Pe.resultName] = Oe.value, $e.next = Pe.nextLoc, $e.method !== "return" && (
                $e.method = "next", $e.arg = void 0), $e.delegate = null, oe) : Oe : ($e.method = "throw", $e.arg =
                new TypeError("iterator result is not an object"), $e.delegate = null, oe)
        }

        function Se(Pe) {
            var $e = {
                tryLoc: Pe[0]
            };
            1 in Pe && ($e.catchLoc = Pe[1]), 2 in Pe && ($e.finallyLoc = Pe[2], $e.afterLoc = Pe[3]), this.tryEntries
                .push($e)
        }

        function _e(Pe) {
            var $e = Pe.completion || {};
            $e.type = "normal", delete $e.arg, Pe.completion = $e
        }

        function be(Pe) {
            this.tryEntries = [{
                tryLoc: "root"
            }], Pe.forEach(Se, this), this.reset(!0)
        }

        function ge(Pe) {
            if (Pe) {
                var $e = Pe[Q];
                if ($e) return $e.call(Pe);
                if (typeof Pe.next == "function") return Pe;
                if (!isNaN(Pe.length)) {
                    var ye = -1,
                        Ce = function we() {
                            for (; ++ye < Pe.length;)
                                if (G.call(Pe, ye)) return we.value = Pe[ye], we.done = !1, we;
                            return we.value = void 0, we.done = !0, we
                        };
                    return Ce.next = Ce
                }
            }
            return {
                next: xe
            }
        }

        function xe() {
            return {
                value: void 0,
                done: !0
            }
        }
        return ue.prototype = le, X(ve, "constructor", {
            value: le,
            configurable: !0
        }), X(le, "constructor", {
            value: ue,
            configurable: !0
        }), ue.displayName = te(le, ne, "GeneratorFunction"), W.isGeneratorFunction = function (Pe) {
            var $e = typeof Pe == "function" && Pe.constructor;
            return !!$e && ($e === ue || ($e.displayName || $e.name) === "GeneratorFunction")
        }, W.mark = function (Pe) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(Pe, le) : (Pe.__proto__ = le, te(Pe, ne,
                "GeneratorFunction")), Pe.prototype = Object.create(ve), Pe
        }, W.awrap = function (Pe) {
            return {
                __await: Pe
            }
        }, fe(pe.prototype), te(pe.prototype, ee, function () {
            return this
        }), W.AsyncIterator = pe, W.async = function (Pe, $e, ye, Ce, we) {
            we === void 0 && (we = Promise);
            var Oe = new pe(re(Pe, $e, ye, Ce), we);
            return W.isGeneratorFunction($e) ? Oe : Oe.next().then(function (Ne) {
                return Ne.done ? Ne.value : Oe.next()
            })
        }, fe(ve), te(ve, ne, "Generator"), te(ve, Q, function () {
            return this
        }), te(ve, "toString", function () {
            return "[object Generator]"
        }), W.keys = function (Pe) {
            var $e = Object(Pe),
                ye = [];
            for (var Ce in $e) ye.push(Ce);
            return ye.reverse(),
                function we() {
                    for (; ye.length;) {
                        var Oe = ye.pop();
                        if (Oe in $e) return we.value = Oe, we.done = !1, we
                    }
                    return we.done = !0, we
                }
        }, W.values = ge, be.prototype = {
            constructor: be,
            reset: function ($e) {
                if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate =
                    null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(_e), !$e)
                    for (var ye in this) ye.charAt(0) === "t" && G.call(this, ye) && !isNaN(+ye.slice(1)) &&
                        (this[ye] = void 0)
            },
            stop: function () {
                this.done = !0;
                var $e = this.tryEntries[0].completion;
                if ($e.type === "throw") throw $e.arg;
                return this.rval
            },
            dispatchException: function ($e) {
                if (this.done) throw $e;
                var ye = this;

                function Ce(ke, Ee) {
                    return Ne.type = "throw", Ne.arg = $e, ye.next = ke, Ee && (ye.method = "next", ye.arg =
                        void 0), !!Ee
                }
                for (var we = this.tryEntries.length - 1; we >= 0; --we) {
                    var Oe = this.tryEntries[we],
                        Ne = Oe.completion;
                    if (Oe.tryLoc === "root") return Ce("end");
                    if (Oe.tryLoc <= this.prev) {
                        var Me = G.call(Oe, "catchLoc"),
                            Ve = G.call(Oe, "finallyLoc");
                        if (Me && Ve) {
                            if (this.prev < Oe.catchLoc) return Ce(Oe.catchLoc, !0);
                            if (this.prev < Oe.finallyLoc) return Ce(Oe.finallyLoc)
                        } else if (Me) {
                            if (this.prev < Oe.catchLoc) return Ce(Oe.catchLoc, !0)
                        } else {
                            if (!Ve) throw new Error("try statement without catch or finally");
                            if (this.prev < Oe.finallyLoc) return Ce(Oe.finallyLoc)
                        }
                    }
                }
            },
            abrupt: function ($e, ye) {
                for (var Ce = this.tryEntries.length - 1; Ce >= 0; --Ce) {
                    var we = this.tryEntries[Ce];
                    if (we.tryLoc <= this.prev && G.call(we, "finallyLoc") && this.prev < we.finallyLoc) {
                        var Oe = we;
                        break
                    }
                }
                Oe && ($e === "break" || $e === "continue") && Oe.tryLoc <= ye && ye <= Oe.finallyLoc && (
                    Oe = null);
                var Ne = Oe ? Oe.completion : {};
                return Ne.type = $e, Ne.arg = ye, Oe ? (this.method = "next", this.next = Oe.finallyLoc, oe) :
                    this.complete(Ne)
            },
            complete: function ($e, ye) {
                if ($e.type === "throw") throw $e.arg;
                return $e.type === "break" || $e.type === "continue" ? this.next = $e.arg : $e.type ===
                    "return" ? (this.rval = this.arg = $e.arg, this.method = "return", this.next = "end") :
                    $e.type === "normal" && ye && (this.next = ye), oe
            },
            finish: function ($e) {
                for (var ye = this.tryEntries.length - 1; ye >= 0; --ye) {
                    var Ce = this.tryEntries[ye];
                    if (Ce.finallyLoc === $e) return this.complete(Ce.completion, Ce.afterLoc), _e(Ce), oe
                }
            },
            catch: function ($e) {
                for (var ye = this.tryEntries.length - 1; ye >= 0; --ye) {
                    var Ce = this.tryEntries[ye];
                    if (Ce.tryLoc === $e) {
                        var we = Ce.completion;
                        if (we.type === "throw") {
                            var Oe = we.arg;
                            _e(Ce)
                        }
                        return Oe
                    }
                }
                throw new Error("illegal catch attempt")
            },
            delegateYield: function ($e, ye, Ce) {
                return this.delegate = {
                    iterator: ge($e),
                    resultName: ye,
                    nextLoc: Ce
                }, this.method === "next" && (this.arg = void 0), oe
            }
        }, W
    }
    K.exports = H, K.exports.__esModule = !0, K.exports.default = K.exports
})(regeneratorRuntime$1);
var runtime = regeneratorRuntimeExports(),
    regenerator = runtime;
try {
    regeneratorRuntime = runtime
} catch {
    typeof globalThis == "object" ? globalThis.regeneratorRuntime = runtime : Function("r", "regeneratorRuntime = r")(
        runtime)
}
var CheckCircleOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0051.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z"
            }
        }, {
            tag: "path",
            attrs: {
                d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
            }
        }]
    },
    name: "check-circle",
    theme: "outlined"
};
const CheckCircleOutlinedSvg = CheckCircleOutlined$2;

function _objectSpread$L(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$M(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$M(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var CheckCircleOutlined = function (C, H) {
    var W = _objectSpread$L({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$L({}, W, {
        icon: CheckCircleOutlinedSvg
    }), null)
};
CheckCircleOutlined.displayName = "CheckCircleOutlined";
CheckCircleOutlined.inheritAttrs = !1;
const CheckCircleOutlined$1 = CheckCircleOutlined;
var InfoCircleOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
            }
        }, {
            tag: "path",
            attrs: {
                d: "M464 336a48 48 0 1096 0 48 48 0 10-96 0zm72 112h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V456c0-4.4-3.6-8-8-8z"
            }
        }]
    },
    name: "info-circle",
    theme: "outlined"
};
const InfoCircleOutlinedSvg = InfoCircleOutlined$2;

function _objectSpread$K(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$L(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$L(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var InfoCircleOutlined = function (C, H) {
    var W = _objectSpread$K({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$K({}, W, {
        icon: InfoCircleOutlinedSvg
    }), null)
};
InfoCircleOutlined.displayName = "InfoCircleOutlined";
InfoCircleOutlined.inheritAttrs = !1;
const InfoCircleOutlined$1 = InfoCircleOutlined;
var CloseCircleOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M685.4 354.8c0-4.4-3.6-8-8-8l-66 .3L512 465.6l-99.3-118.4-66.1-.3c-4.4 0-8 3.5-8 8 0 1.9.7 3.7 1.9 5.2l130.1 155L340.5 670a8.32 8.32 0 00-1.9 5.2c0 4.4 3.6 8 8 8l66.1-.3L512 564.4l99.3 118.4 66 .3c4.4 0 8-3.5 8-8 0-1.9-.7-3.7-1.9-5.2L553.5 515l130.1-155c1.2-1.4 1.8-3.3 1.8-5.2z"
            }
        }, {
            tag: "path",
            attrs: {
                d: "M512 65C264.6 65 64 265.6 64 513s200.6 448 448 448 448-200.6 448-448S759.4 65 512 65zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
            }
        }]
    },
    name: "close-circle",
    theme: "outlined"
};
const CloseCircleOutlinedSvg = CloseCircleOutlined$2;

function _objectSpread$J(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$K(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$K(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var CloseCircleOutlined = function (C, H) {
    var W = _objectSpread$J({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$J({}, W, {
        icon: CloseCircleOutlinedSvg
    }), null)
};
CloseCircleOutlined.displayName = "CloseCircleOutlined";
CloseCircleOutlined.inheritAttrs = !1;
const CloseCircleOutlined$1 = CloseCircleOutlined;
var ExclamationCircleOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
            }
        }, {
            tag: "path",
            attrs: {
                d: "M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z"
            }
        }]
    },
    name: "exclamation-circle",
    theme: "outlined"
};
const ExclamationCircleOutlinedSvg = ExclamationCircleOutlined$2;

function _objectSpread$I(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$J(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$J(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var ExclamationCircleOutlined = function (C, H) {
    var W = _objectSpread$I({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$I({}, W, {
        icon: ExclamationCircleOutlinedSvg
    }), null)
};
ExclamationCircleOutlined.displayName = "ExclamationCircleOutlined";
ExclamationCircleOutlined.inheritAttrs = !1;
const ExclamationCircleOutlined$1 = ExclamationCircleOutlined;
var CloseOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 00203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z"
            }
        }]
    },
    name: "close",
    theme: "outlined"
};
const CloseOutlinedSvg = CloseOutlined$2;

function _objectSpread$H(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$I(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$I(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var CloseOutlined = function (C, H) {
    var W = _objectSpread$H({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$H({}, W, {
        icon: CloseOutlinedSvg
    }), null)
};
CloseOutlined.displayName = "CloseOutlined";
CloseOutlined.inheritAttrs = !1;
const CloseOutlined$1 = CloseOutlined;
var notificationInstance = {},
    defaultDuration = 4.5,
    defaultTop = "24px",
    defaultBottom = "24px",
    defaultPrefixCls$1 = "",
    defaultPlacement = "topRight",
    defaultGetContainer = function () {
        return document.body
    },
    defaultCloseIcon = null,
    rtl = !1,
    maxCount;

function setNotificationConfig(K) {
    var C = K.duration,
        H = K.placement,
        W = K.bottom,
        U = K.top,
        G = K.getContainer,
        X = K.closeIcon,
        Z = K.prefixCls;
    Z !== void 0 && (defaultPrefixCls$1 = Z), C !== void 0 && (defaultDuration = C), H !== void 0 && (defaultPlacement =
            H), W !== void 0 && (defaultBottom = typeof W == "number" ? "".concat(W, "px") : W), U !== void 0 && (
            defaultTop = typeof U == "number" ? "".concat(U, "px") : U), G !== void 0 && (defaultGetContainer = G), X !==
        void 0 && (defaultCloseIcon = X), K.rtl !== void 0 && (rtl = K.rtl), K.maxCount !== void 0 && (maxCount = K.maxCount)
}

function getPlacementStyle(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultTop,
        H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultBottom,
        W;
    switch (K) {
        case "topLeft":
            W = {
                left: "0px",
                top: C,
                bottom: "auto"
            };
            break;
        case "topRight":
            W = {
                right: "0px",
                top: C,
                bottom: "auto"
            };
            break;
        case "bottomLeft":
            W = {
                left: "0px",
                top: "auto",
                bottom: H
            };
            break;
        default:
            W = {
                right: "0px",
                top: "auto",
                bottom: H
            };
            break
    }
    return W
}

function getNotificationInstance(K, C) {
    var H = K.prefixCls,
        W = K.placement,
        U = W === void 0 ? defaultPlacement : W,
        G = K.getContainer,
        X = G === void 0 ? defaultGetContainer : G,
        Z = K.top,
        Q = K.bottom,
        ee = K.closeIcon,
        ne = ee === void 0 ? defaultCloseIcon : ee,
        te = K.appContext,
        re = globalConfig(),
        ae = re.getPrefixCls,
        oe = ae("notification", H || defaultPrefixCls$1),
        ie = "".concat(oe, "-").concat(U, "-").concat(rtl),
        ue = notificationInstance[ie];
    if (ue) {
        Promise.resolve(ue).then(function (se) {
            C(se)
        });
        return
    }
    var le = classNames("".concat(oe, "-").concat(U), _defineProperty$V({}, "".concat(oe, "-rtl"), rtl === !0));
    Notification$1.newInstance({
        name: "notification",
        prefixCls: H || defaultPrefixCls$1,
        class: le,
        style: getPlacementStyle(U, Z, Q),
        appContext: te,
        getContainer: X,
        closeIcon: function (ce) {
            var de = ce.prefixCls,
                ve = createVNode("span", {
                    class: "".concat(de, "-close-x")
                }, [renderHelper(ne, {}, createVNode(CloseOutlined$1, {
                    class: "".concat(de, "-close-icon")
                }, null))]);
            return ve
        },
        maxCount,
        hasTransitionName: !0
    }, function (se) {
        notificationInstance[ie] = se, C(se)
    })
}
var typeToIcon = {
    success: CheckCircleOutlined$1,
    info: InfoCircleOutlined$1,
    error: CloseCircleOutlined$1,
    warning: ExclamationCircleOutlined$1
};

function notice(K) {
    var C = K.icon,
        H = K.type,
        W = K.description,
        U = K.message,
        G = K.btn,
        X = K.duration === void 0 ? defaultDuration : K.duration;
    getNotificationInstance(K, function (Z) {
        Z.notice({
            content: function (ee) {
                var ne = ee.prefixCls,
                    te = "".concat(ne, "-notice"),
                    re = null;
                if (C) re = function () {
                    return createVNode("span", {
                        class: "".concat(te, "-icon")
                    }, [renderHelper(C)])
                };
                else if (H) {
                    var ae = typeToIcon[H];
                    re = function () {
                        return createVNode(ae, {
                            class: "".concat(te, "-icon ").concat(te, "-icon-").concat(
                                H)
                        }, null)
                    }
                }
                return createVNode("div", {
                    class: re ? "".concat(te, "-with-icon") : ""
                }, [re && re(), createVNode("div", {
                    class: "".concat(te, "-message")
                }, [!W && re ? createVNode("span", {
                    class: "".concat(te, "-message-single-line-auto-margin")
                }, null) : null, renderHelper(U)]), createVNode("div", {
                    class: "".concat(te, "-description")
                }, [renderHelper(W)]), G ? createVNode("span", {
                    class: "".concat(te, "-btn")
                }, [renderHelper(G)]) : null])
            },
            duration: X,
            closable: !0,
            onClose: K.onClose,
            onClick: K.onClick,
            key: K.key,
            style: K.style || {},
            class: K.class
        })
    })
}
var api = {
        open: notice,
        close: function (C) {
            Object.keys(notificationInstance).forEach(function (H) {
                return Promise.resolve(notificationInstance[H]).then(function (W) {
                    W.removeNotice(C)
                })
            })
        },
        config: setNotificationConfig,
        destroy: function () {
            Object.keys(notificationInstance).forEach(function (C) {
                Promise.resolve(notificationInstance[C]).then(function (H) {
                    H.destroy()
                }), delete notificationInstance[C]
            })
        }
    },
    iconTypes = ["success", "info", "warning", "error"];
iconTypes.forEach(function (K) {
    api[K] = function (C) {
        return api.open(_objectSpread2$1(_objectSpread2$1({}, C), {}, {
            type: K
        }))
    }
});
api.warn = api.warning;
const notification = api;

function canUseDom() {
    return !!(typeof window < "u" && window.document && window.document.createElement)
}
var MARK_KEY = "vc-util-key";

function getMark() {
    var K = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
        C = K.mark;
    return C ? C.startsWith("data-") ? C : "data-".concat(C) : MARK_KEY
}

function getContainer(K) {
    if (K.attachTo) return K.attachTo;
    var C = document.querySelector("head");
    return C || document.body
}

function injectCSS(K) {
    var C, H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!canUseDom()) return null;
    var W = document.createElement("style");
    if ((C = H.csp) !== null && C !== void 0 && C.nonce) {
        var U;
        W.nonce = (U = H.csp) === null || U === void 0 ? void 0 : U.nonce
    }
    W.innerHTML = K;
    var G = getContainer(H),
        X = G.firstChild;
    return H.prepend && G.prepend ? G.prepend(W) : H.prepend && X ? G.insertBefore(W, X) : G.appendChild(W), W
}
var containerCache = new Map;

function findExistNode(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        H = getContainer(C);
    return Array.from(containerCache.get(H).children).find(function (W) {
        return W.tagName === "STYLE" && W.getAttribute(getMark(C)) === K
    })
}

function updateCSS(K, C) {
    var H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
        W = getContainer(H);
    if (!containerCache.has(W)) {
        var U = injectCSS("", H),
            G = U.parentNode;
        containerCache.set(W, G), G.removeChild(U)
    }
    var X = findExistNode(C, H);
    if (X) {
        var Z, Q;
        if ((Z = H.csp) !== null && Z !== void 0 && Z.nonce && X.nonce !== ((Q = H.csp) === null || Q === void 0 ? void 0 :
                Q.nonce)) {
            var ee;
            X.nonce = (ee = H.csp) === null || ee === void 0 ? void 0 : ee.nonce
        }
        return X.innerHTML !== K && (X.innerHTML = K), X
    }
    var ne = injectCSS(K, H);
    return ne.setAttribute(getMark(H), C), ne
}
const devWarning = function (K, C, H) {
    warningOnce(K, "[ant-design-vue: ".concat(C, "] ").concat(H))
};
var dynamicStyleMark = "-ant-".concat(Date.now(), "-").concat(Math.random());

function registerTheme(K, C) {
    var H = {},
        W = function (ne, te) {
            var re = ne.clone();
            return re = (te == null ? void 0 : te(re)) || re, re.toRgbString()
        },
        U = function (ne, te) {
            var re = new TinyColor(ne),
                ae = generate$1(re.toRgbString());
            H["".concat(te, "-color")] = W(re), H["".concat(te, "-color-disabled")] = ae[1], H["".concat(te,
                    "-color-hover")] = ae[4], H["".concat(te, "-color-active")] = ae[6], H["".concat(te,
                    "-color-outline")] = re.clone().setAlpha(.2).toRgbString(), H["".concat(te, "-color-deprecated-bg")] =
                ae[1], H["".concat(te, "-color-deprecated-border")] = ae[3]
        };
    if (C.primaryColor) {
        U(C.primaryColor, "primary");
        var G = new TinyColor(C.primaryColor),
            X = generate$1(G.toRgbString());
        X.forEach(function (ee, ne) {
            H["primary-".concat(ne + 1)] = ee
        }), H["primary-color-deprecated-l-35"] = W(G, function (ee) {
            return ee.lighten(35)
        }), H["primary-color-deprecated-l-20"] = W(G, function (ee) {
            return ee.lighten(20)
        }), H["primary-color-deprecated-t-20"] = W(G, function (ee) {
            return ee.tint(20)
        }), H["primary-color-deprecated-t-50"] = W(G, function (ee) {
            return ee.tint(50)
        }), H["primary-color-deprecated-f-12"] = W(G, function (ee) {
            return ee.setAlpha(ee.getAlpha() * .12)
        });
        var Z = new TinyColor(X[0]);
        H["primary-color-active-deprecated-f-30"] = W(Z, function (ee) {
            return ee.setAlpha(ee.getAlpha() * .3)
        }), H["primary-color-active-deprecated-d-02"] = W(Z, function (ee) {
            return ee.darken(2)
        })
    }
    C.successColor && U(C.successColor, "success"), C.warningColor && U(C.warningColor, "warning"), C.errorColor && U(C
        .errorColor, "error"), C.infoColor && U(C.infoColor, "info");
    var Q = Object.keys(H).map(function (ee) {
        return "--".concat(K, "-").concat(ee, ": ").concat(H[ee], ";")
    });
    canUseDom() ? updateCSS(`
  :root {
    `.concat(Q.join(`
`), `
  }
  `), "".concat(dynamicStyleMark,
        "-dynamic-theme")) : devWarning(!1, "ConfigProvider",
        "SSR do not support dynamic theme with css variables.")
}
var GlobalFormContextKey = Symbol("GlobalFormContextKey"),
    useProvideGlobalForm = function (C) {
        provide(GlobalFormContextKey, C)
    },
    useInjectGlobalForm = function () {
        return inject(GlobalFormContextKey, {
            validateMessages: computed(function () {})
        })
    },
    configProviderProps = function () {
        return {
            getTargetContainer: {
                type: Function
            },
            getPopupContainer: {
                type: Function
            },
            prefixCls: String,
            getPrefixCls: {
                type: Function
            },
            renderEmpty: {
                type: Function
            },
            transformCellText: {
                type: Function
            },
            csp: {
                type: Object,
                default: void 0
            },
            input: {
                type: Object
            },
            autoInsertSpaceInButton: {
                type: Boolean,
                default: void 0
            },
            locale: {
                type: Object,
                default: void 0
            },
            pageHeader: {
                type: Object
            },
            componentSize: {
                type: String
            },
            direction: {
                type: String
            },
            space: {
                type: Object
            },
            virtual: {
                type: Boolean,
                default: void 0
            },
            dropdownMatchSelectWidth: {
                type: [Number, Boolean],
                default: !0
            },
            form: {
                type: Object,
                default: void 0
            },
            notUpdateGlobalConfig: Boolean
        }
    },
    defaultPrefixCls = "ant";

function getGlobalPrefixCls() {
    return globalConfigForApi.prefixCls || defaultPrefixCls
}
var globalConfigByCom = reactive({}),
    globalConfigBySet = reactive({}),
    globalConfigForApi = reactive({});
watchEffect(function () {
    _extends$1(globalConfigForApi, globalConfigByCom, globalConfigBySet), globalConfigForApi.prefixCls =
        getGlobalPrefixCls(), globalConfigForApi.getPrefixCls = function (K, C) {
            return C || (K ? "".concat(globalConfigForApi.prefixCls, "-").concat(K) : globalConfigForApi.prefixCls)
        }, globalConfigForApi.getRootPrefixCls = function (K, C) {
            return K || (globalConfigForApi.prefixCls ? globalConfigForApi.prefixCls : C && C.includes("-") ? C
                .replace(/^(.*)-[^-]*$/, "$1") : getGlobalPrefixCls())
        }
});
var stopWatchEffect, setGlobalConfig = function (C) {
        stopWatchEffect && stopWatchEffect(), stopWatchEffect = watchEffect(function () {
            _extends$1(globalConfigBySet, reactive(C)), _extends$1(globalConfigForApi, reactive(C))
        }), C.theme && registerTheme(getGlobalPrefixCls(), C.theme)
    },
    globalConfig = function () {
        return {
            getPrefixCls: function (H, W) {
                return W || (H ? "".concat(getGlobalPrefixCls(), "-").concat(H) : getGlobalPrefixCls())
            },
            getRootPrefixCls: function (H, W) {
                return H || (globalConfigForApi.prefixCls ? globalConfigForApi.prefixCls : W && W.includes("-") ? W
                    .replace(/^(.*)-[^-]*$/, "$1") : getGlobalPrefixCls())
            }
        }
    },
    ConfigProvider = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "AConfigProvider",
        inheritAttrs: !1,
        props: configProviderProps(),
        setup: function (C, H) {
            var W = H.slots,
                U = function (te, re) {
                    var ae = C.prefixCls,
                        oe = ae === void 0 ? "ant" : ae;
                    return re || (te ? "".concat(oe, "-").concat(te) : oe)
                },
                G = function (te) {
                    var re = C.renderEmpty || W.renderEmpty || renderEmpty;
                    return re(te)
                },
                X = function (te, re) {
                    var ae = C.prefixCls;
                    if (re) return re;
                    var oe = ae || U("");
                    return te ? "".concat(oe, "-").concat(te) : oe
                },
                Z = reactive(_objectSpread2$1(_objectSpread2$1({}, C), {}, {
                    getPrefixCls: X,
                    renderEmpty: G
                }));
            Object.keys(C).forEach(function (ne) {
                watch(function () {
                    return C[ne]
                }, function () {
                    Z[ne] = C[ne]
                })
            }), C.notUpdateGlobalConfig || (_extends$1(globalConfigByCom, Z), watch(Z, function () {
                _extends$1(globalConfigByCom, Z)
            }));
            var Q = computed(function () {
                var ne = {};
                if (C.locale) {
                    var te, re;
                    ne = ((te = C.locale.Form) === null || te === void 0 ? void 0 : te.defaultValidateMessages) ||
                        ((re = defaultLocale.Form) === null || re === void 0 ? void 0 : re.defaultValidateMessages) ||
                        {}
                }
                return C.form && C.form.validateMessages && (ne = _objectSpread2$1(_objectSpread2$1({},
                    ne), C.form.validateMessages)), ne
            });
            useProvideGlobalForm({
                validateMessages: Q
            }), provide("configProvider", Z);
            var ee = function (te) {
                var re;
                return createVNode(LocaleProvider$1, {
                    locale: C.locale || te,
                    ANT_MARK__: ANT_MARK
                }, {
                    default: function () {
                        return [(re = W.default) === null || re === void 0 ? void 0 : re.call(W)]
                    }
                })
            };
            return watchEffect(function () {
                    C.direction && (message$1.config({
                        rtl: C.direction === "rtl"
                    }), notification.config({
                        rtl: C.direction === "rtl"
                    }))
                }),
                function () {
                    return createVNode(LocaleReceiver, {
                        children: function (te, re, ae) {
                            return ee(ae)
                        }
                    }, null)
                }
        }
    }),
    defaultConfigProvider = reactive({
        getPrefixCls: function (C, H) {
            return H || (C ? "ant-".concat(C) : "ant")
        },
        renderEmpty,
        direction: "ltr"
    });
ConfigProvider.config = setGlobalConfig;
ConfigProvider.install = function (K) {
    K.component(ConfigProvider.name, ConfigProvider)
};
const ConfigProvider$1 = ConfigProvider,
    useConfigInject = function (K, C) {
        var H = inject("configProvider", defaultConfigProvider),
            W = computed(function () {
                return H.getPrefixCls(K, C.prefixCls)
            }),
            U = computed(function () {
                var se;
                return (se = C.direction) !== null && se !== void 0 ? se : H.direction
            }),
            G = computed(function () {
                return H.getPrefixCls()
            }),
            X = computed(function () {
                return H.autoInsertSpaceInButton
            }),
            Z = computed(function () {
                return H.renderEmpty
            }),
            Q = computed(function () {
                return H.space
            }),
            ee = computed(function () {
                return H.pageHeader
            }),
            ne = computed(function () {
                return H.form
            }),
            te = computed(function () {
                return C.getTargetContainer || H.getTargetContainer
            }),
            re = computed(function () {
                return C.getPopupContainer || H.getPopupContainer
            }),
            ae = computed(function () {
                var se;
                return (se = C.dropdownMatchSelectWidth) !== null && se !== void 0 ? se : H.dropdownMatchSelectWidth
            }),
            oe = computed(function () {
                return (C.virtual === void 0 ? H.virtual !== !1 : C.virtual !== !1) && ae.value !== !1
            }),
            ie = computed(function () {
                return C.size || H.componentSize
            }),
            ue = computed(function () {
                var se;
                return C.autocomplete || ((se = H.input) === null || se === void 0 ? void 0 : se.autocomplete)
            }),
            le = computed(function () {
                return H.csp
            });
        return {
            configProvider: H,
            prefixCls: W,
            direction: U,
            size: ie,
            getTargetContainer: te,
            getPopupContainer: re,
            space: Q,
            pageHeader: ee,
            form: ne,
            autoInsertSpaceInButton: X,
            renderEmpty: Z,
            virtual: oe,
            dropdownMatchSelectWidth: ae,
            rootPrefixCls: G,
            getPrefixCls: H.getPrefixCls,
            autocomplete: ue,
            csp: le
        }
    };

function omit$2(K, C) {
    for (var H = _extends$1({}, K), W = 0; W < C.length; W += 1) {
        var U = C[W];
        delete H[U]
    }
    return H
}

function getDefaultTarget() {
    return typeof window < "u" ? window : null
}
var AffixStatus;
(function (K) {
    K[K.None = 0] = "None", K[K.Prepare = 1] = "Prepare"
})(AffixStatus || (AffixStatus = {}));
var affixProps = function () {
        return {
            offsetTop: Number,
            offsetBottom: Number,
            target: {
                type: Function,
                default: getDefaultTarget
            },
            prefixCls: String,
            onChange: Function,
            onTestUpdatePosition: Function
        }
    },
    Affix = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "AAffix",
        props: affixProps(),
        setup: function (C, H) {
            var W = H.slots,
                U = H.emit,
                G = H.expose,
                X = ref(),
                Z = ref(),
                Q = reactive({
                    affixStyle: void 0,
                    placeholderStyle: void 0,
                    status: AffixStatus.None,
                    lastAffix: !1,
                    prevTarget: null,
                    timeout: null
                }),
                ee = getCurrentInstance(),
                ne = computed(function () {
                    return C.offsetBottom === void 0 && C.offsetTop === void 0 ? 0 : C.offsetTop
                }),
                te = computed(function () {
                    return C.offsetBottom
                }),
                re = function () {
                    var ce = Q.status,
                        de = Q.lastAffix,
                        ve = C.target;
                    if (!(ce !== AffixStatus.Prepare || !Z.value || !X.value || !ve)) {
                        var fe = ve();
                        if (fe) {
                            var pe = {
                                    status: AffixStatus.None
                                },
                                me = getTargetRect(fe),
                                he = getTargetRect(X.value),
                                Se = getFixedTop(he, me, ne.value),
                                _e = getFixedBottom(he, me, te.value);
                            Se !== void 0 ? (pe.affixStyle = {
                                    position: "fixed",
                                    top: Se,
                                    width: he.width + "px",
                                    height: he.height + "px"
                                }, pe.placeholderStyle = {
                                    width: he.width + "px",
                                    height: he.height + "px"
                                }) : _e !== void 0 && (pe.affixStyle = {
                                    position: "fixed",
                                    bottom: _e,
                                    width: he.width + "px",
                                    height: he.height + "px"
                                }, pe.placeholderStyle = {
                                    width: he.width + "px",
                                    height: he.height + "px"
                                }), pe.lastAffix = !!pe.affixStyle, de !== pe.lastAffix && U("change", pe.lastAffix),
                                _extends$1(Q, pe)
                        }
                    }
                },
                ae = function () {
                    _extends$1(Q, {
                        status: AffixStatus.Prepare,
                        affixStyle: void 0,
                        placeholderStyle: void 0
                    }), ee.update()
                },
                oe = throttleByAnimationFrame(function () {
                    ae()
                }),
                ie = throttleByAnimationFrame(function () {
                    var se = C.target,
                        ce = Q.affixStyle;
                    if (se && ce) {
                        var de = se();
                        if (de && X.value) {
                            var ve = getTargetRect(de),
                                fe = getTargetRect(X.value),
                                pe = getFixedTop(fe, ve, ne.value),
                                me = getFixedBottom(fe, ve, te.value);
                            if (pe !== void 0 && ce.top === pe || me !== void 0 && ce.bottom === me) return
                        }
                    }
                    ae()
                });
            G({
                updatePosition: oe,
                lazyUpdatePosition: ie
            }), watch(function () {
                return C.target
            }, function (se) {
                var ce = (se == null ? void 0 : se()) || null;
                Q.prevTarget !== ce && (removeObserveTarget(ee), ce && (addObserveTarget(ce, ee), oe()),
                    Q.prevTarget = ce)
            }), watch(function () {
                return [C.offsetTop, C.offsetBottom]
            }, oe), onMounted(function () {
                var se = C.target;
                se && (Q.timeout = setTimeout(function () {
                    addObserveTarget(se(), ee), oe()
                }))
            }), onUpdated(function () {
                re()
            }), onUnmounted(function () {
                clearTimeout(Q.timeout), removeObserveTarget(ee), oe.cancel(), ie.cancel()
            });
            var ue = useConfigInject("affix", C),
                le = ue.prefixCls;
            return function () {
                var se, ce = Q.affixStyle,
                    de = Q.placeholderStyle,
                    ve = classNames(_defineProperty$V({}, le.value, ce)),
                    fe = omit$2(C, ["prefixCls", "offsetTop", "offsetBottom", "target", "onChange",
                        "onTestUpdatePosition"]);
                return createVNode(ResizeObserver$1, {
                    onResize: oe
                }, {
                    default: function () {
                        return [createVNode("div", _objectSpread2$1(_objectSpread2$1({}, fe), {}, {
                            style: de,
                            ref: X
                        }), [createVNode("div", {
                            class: ve,
                            ref: Z,
                            style: ce
                        }, [(se = W.default) === null || se === void 0 ?
                            void 0 : se.call(W)])])]
                    }
                })
            }
        }
    });
const Affix$1 = withInstall(Affix);

function isWindow$1(K) {
    return K != null && K === K.window
}

function getScroll$3(K, C) {
    if (typeof window > "u") return 0;
    var H = C ? "scrollTop" : "scrollLeft",
        W = 0;
    if (isWindow$1(K) ? W = K[C ? "pageYOffset" : "pageXOffset"] : K instanceof Document ? W = K.documentElement[H] : K &&
        (W = K[H]), K && !isWindow$1(K) && typeof W != "number") {
        var U;
        W = (U = (K.ownerDocument || K).documentElement) === null || U === void 0 ? void 0 : U[H]
    }
    return W
}

function easeInOutCubic(K, C, H, W) {
    var U = H - C;
    return K /= W / 2, K < 1 ? U / 2 * K * K * K + C : U / 2 * ((K -= 2) * K * K + 2) + C
}

function scrollTo$1(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        H = C.getContainer,
        W = H === void 0 ? function () {
            return window
        } : H,
        U = C.callback,
        G = C.duration,
        X = G === void 0 ? 450 : G,
        Z = W(),
        Q = getScroll$3(Z, !0),
        ee = Date.now(),
        ne = function te() {
            var re = Date.now(),
                ae = re - ee,
                oe = easeInOutCubic(ae > X ? X : ae, Q, K, X);
            isWindow$1(Z) ? Z.scrollTo(window.pageXOffset, oe) : Z instanceof HTMLDocument || Z.constructor.name ===
                "HTMLDocument" ? Z.documentElement.scrollTop = oe : Z.scrollTop = oe, ae < X ? wrapperRaf(te) : typeof U ==
                "function" && U()
        };
    wrapperRaf(ne)
}

function noop$d() {}
var AnchorContextKey = Symbol("anchorContextKey"),
    useProvideAnchor = function (C) {
        provide(AnchorContextKey, C)
    },
    useInjectAnchor = function () {
        return inject(AnchorContextKey, {
            registerLink: noop$d,
            unregisterLink: noop$d,
            scrollTo: noop$d,
            activeLink: computed(function () {
                return ""
            }),
            handleClick: noop$d
        })
    };
const useProvideAnchor$1 = useProvideAnchor;

function getDefaultContainer() {
    return window
}

function getOffsetTop(K, C) {
    if (!K.getClientRects().length) return 0;
    var H = K.getBoundingClientRect();
    return H.width || H.height ? C === window ? (C = K.ownerDocument.documentElement, H.top - C.clientTop) : H.top - C.getBoundingClientRect()
        .top : H.top
}
var sharpMatcherRegx = /#([\S ]+)$/,
    anchorProps = function () {
        return {
            prefixCls: String,
            offsetTop: Number,
            bounds: Number,
            affix: {
                type: Boolean,
                default: !0
            },
            showInkInFixed: {
                type: Boolean,
                default: !1
            },
            getContainer: Function,
            wrapperClass: String,
            wrapperStyle: {
                type: Object,
                default: void 0
            },
            getCurrentAnchor: Function,
            targetOffset: Number,
            onChange: Function,
            onClick: Function
        }
    };
const Anchor = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AAnchor",
    inheritAttrs: !1,
    props: anchorProps(),
    setup: function (C, H) {
        var W = H.emit,
            U = H.attrs,
            G = H.slots,
            X = H.expose,
            Z = useConfigInject("anchor", C),
            Q = Z.prefixCls,
            ee = Z.getTargetContainer,
            ne = Z.direction,
            te = ref(),
            re = ref(),
            ae = reactive({
                links: [],
                scrollContainer: null,
                scrollEvent: null,
                animating: !1
            }),
            oe = ref(null),
            ie = computed(function () {
                var ve = C.getContainer;
                return ve || ee.value || getDefaultContainer
            }),
            ue = function () {
                var fe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0,
                    pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5,
                    me = [],
                    he = ie.value();
                if (ae.links.forEach(function (_e) {
                        var be = sharpMatcherRegx.exec(_e.toString());
                        if (be) {
                            var ge = document.getElementById(be[1]);
                            if (ge) {
                                var xe = getOffsetTop(ge, he);
                                xe < fe + pe && me.push({
                                    link: _e,
                                    top: xe
                                })
                            }
                        }
                    }), me.length) {
                    var Se = me.reduce(function (_e, be) {
                        return be.top > _e.top ? be : _e
                    });
                    return Se.link
                }
                return ""
            },
            le = function (fe) {
                var pe = C.getCurrentAnchor;
                oe.value !== fe && (oe.value = typeof pe == "function" ? pe() : fe, W("change", fe))
            },
            se = function (fe) {
                var pe = C.offsetTop,
                    me = C.targetOffset;
                le(fe);
                var he = ie.value(),
                    Se = getScroll$3(he, !0),
                    _e = sharpMatcherRegx.exec(fe);
                if (_e) {
                    var be = document.getElementById(_e[1]);
                    if (be) {
                        var ge = getOffsetTop(be, he),
                            xe = Se + ge;
                        xe -= me !== void 0 ? me : pe || 0, ae.animating = !0, scrollTo$1(xe, {
                            callback: function () {
                                ae.animating = !1
                            },
                            getContainer: ie.value
                        })
                    }
                }
            };
        X({
            scrollTo: se
        });
        var ce = function () {
                if (!ae.animating) {
                    var fe = C.offsetTop,
                        pe = C.bounds,
                        me = C.targetOffset,
                        he = ue(me !== void 0 ? me : fe || 0, pe);
                    le(he)
                }
            },
            de = function () {
                var fe = re.value.getElementsByClassName("".concat(Q.value, "-link-title-active"))[0];
                fe && (te.value.style.top = "".concat(fe.offsetTop + fe.clientHeight / 2 - 4.5, "px"))
            };
        return useProvideAnchor$1({
                registerLink: function (fe) {
                    ae.links.includes(fe) || ae.links.push(fe)
                },
                unregisterLink: function (fe) {
                    var pe = ae.links.indexOf(fe);
                    pe !== -1 && ae.links.splice(pe, 1)
                },
                activeLink: oe,
                scrollTo: se,
                handleClick: function (fe, pe) {
                    W("click", fe, pe)
                }
            }), onMounted(function () {
                nextTick(function () {
                    var ve = ie.value();
                    ae.scrollContainer = ve, ae.scrollEvent = addEventListenerWrap(ae.scrollContainer,
                        "scroll", ce), ce()
                })
            }), onBeforeUnmount(function () {
                ae.scrollEvent && ae.scrollEvent.remove()
            }), onUpdated(function () {
                if (ae.scrollEvent) {
                    var ve = ie.value();
                    ae.scrollContainer !== ve && (ae.scrollContainer = ve, ae.scrollEvent.remove(), ae.scrollEvent =
                        addEventListenerWrap(ae.scrollContainer, "scroll", ce), ce())
                }
                de()
            }),
            function () {
                var ve, fe = C.offsetTop,
                    pe = C.affix,
                    me = C.showInkInFixed,
                    he = Q.value,
                    Se = classNames("".concat(he, "-ink-ball"), {
                        visible: oe.value
                    }),
                    _e = classNames(C.wrapperClass, "".concat(he, "-wrapper"), _defineProperty$V({}, "".concat(
                        he, "-rtl"), ne.value === "rtl")),
                    be = classNames(he, _defineProperty$V({}, "".concat(he, "-fixed"), !pe && !me)),
                    ge = _objectSpread2$1({
                        maxHeight: fe ? "calc(100vh - ".concat(fe, "px)") : "100vh"
                    }, C.wrapperStyle),
                    xe = createVNode("div", {
                        class: _e,
                        style: ge,
                        ref: re
                    }, [createVNode("div", {
                        class: be
                    }, [createVNode("div", {
                        class: "".concat(he, "-ink")
                    }, [createVNode("span", {
                        class: Se,
                        ref: te
                    }, null)]), (ve = G.default) === null || ve === void 0 ? void 0 : ve.call(
                        G)])]);
                return pe ? createVNode(Affix$1, _objectSpread2$1(_objectSpread2$1({}, U), {}, {
                    offsetTop: fe,
                    target: ie.value
                }), {
                    default: function () {
                        return [xe]
                    }
                }) : xe
            }
    }
});
var anchorLinkProps = function () {
    return {
        prefixCls: String,
        href: String,
        title: PropTypes$1.any,
        target: String
    }
};
const AnchorLink = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AAnchorLink",
    props: initDefaultProps$1(anchorLinkProps(), {
        href: "#"
    }),
    slots: ["title"],
    setup: function (C, H) {
        var W = H.slots,
            U = null,
            G = useInjectAnchor(),
            X = G.handleClick,
            Z = G.scrollTo,
            Q = G.unregisterLink,
            ee = G.registerLink,
            ne = G.activeLink,
            te = useConfigInject("anchor", C),
            re = te.prefixCls,
            ae = function (ie) {
                var ue = C.href;
                X(ie, {
                    title: U,
                    href: ue
                }), Z(ue)
            };
        return watch(function () {
                return C.href
            }, function (oe, ie) {
                nextTick(function () {
                    Q(ie), ee(oe)
                })
            }), onMounted(function () {
                ee(C.href)
            }), onBeforeUnmount(function () {
                Q(C.href)
            }),
            function () {
                var oe, ie = C.href,
                    ue = C.target,
                    le = re.value,
                    se = getPropsSlot(W, C, "title");
                U = se;
                var ce = ne.value === ie,
                    de = classNames("".concat(le, "-link"), _defineProperty$V({}, "".concat(le,
                        "-link-active"), ce)),
                    ve = classNames("".concat(le, "-link-title"), _defineProperty$V({}, "".concat(le,
                        "-link-title-active"), ce));
                return createVNode("div", {
                    class: de
                }, [createVNode("a", {
                    class: ve,
                    href: ie,
                    title: typeof se == "string" ? se : "",
                    target: ue,
                    onClick: ae
                }, [se]), (oe = W.default) === null || oe === void 0 ? void 0 : oe.call(W)])
            }
    }
});
Anchor.Link = AnchorLink;
Anchor.install = function (K) {
    return K.component(Anchor.name, Anchor), K.component(Anchor.Link.name, Anchor.Link), K
};

function _toArray(K) {
    return _arrayWithHoles$2(K) || _iterableToArray(K) || _unsupportedIterableToArray$2(K) || _nonIterableRest$2()
}

function getKey$2(K, C) {
    var H = K.key,
        W;
    return "value" in K && (W = K.value), H || (W !== void 0 ? W : "rc-index-key-".concat(C))
}

function fillFieldNames$3(K, C) {
    var H = K || {},
        W = H.label,
        U = H.value,
        G = H.options;
    return {
        label: W || (C ? "children" : "label"),
        value: U || "value",
        options: G || "options"
    }
}

function flattenOptions(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        H = C.fieldNames,
        W = C.childrenAsData,
        U = [],
        G = fillFieldNames$3(H, !1),
        X = G.label,
        Z = G.value,
        Q = G.options;

    function ee(ne, te) {
        ne.forEach(function (re) {
            var ae = re[X];
            if (te || !(Q in re)) {
                var oe = re[Z];
                U.push({
                    key: getKey$2(re, U.length),
                    groupOption: te,
                    data: re,
                    label: ae,
                    value: oe
                })
            } else {
                var ie = ae;
                ie === void 0 && W && (ie = re.label), U.push({
                    key: getKey$2(re, U.length),
                    group: !0,
                    data: re,
                    label: ie
                }), ee(re[Q], !0)
            }
        })
    }
    return ee(K, !1), U
}

function injectPropsWithOption(K) {
    var C = _objectSpread2$1({}, K);
    return "props" in C || Object.defineProperty(C, "props", {
        get: function () {
            return C
        }
    }), C
}

function getSeparatedContent(K, C) {
    if (!C || !C.length) return null;
    var H = !1;

    function W(G, X) {
        var Z = _toArray(X),
            Q = Z[0],
            ee = Z.slice(1);
        if (!Q) return [G];
        var ne = G.split(Q);
        return H = H || ne.length > 1, ne.reduce(function (te, re) {
            return [].concat(_toConsumableArray(te), _toConsumableArray(W(re, ee)))
        }, []).filter(function (te) {
            return te
        })
    }
    var U = W(K, C);
    return H ? U : null
}

function contains(K, C) {
    return K ? K.contains(C) : !1
}
var availablePrefixs = ["moz", "ms", "webkit"];

function requestAnimationFramePolyfill() {
    var K = 0;
    return function (C) {
        var H = new Date().getTime(),
            W = Math.max(0, 16 - (H - K)),
            U = window.setTimeout(function () {
                C(H + W)
            }, W);
        return K = H + W, U
    }
}

function getRequestAnimationFrame() {
    if (typeof window > "u") return function () {};
    if (window.requestAnimationFrame) return window.requestAnimationFrame.bind(window);
    var K = availablePrefixs.filter(function (C) {
        return "".concat(C, "RequestAnimationFrame") in window
    })[0];
    return K ? window["".concat(K, "RequestAnimationFrame")] : requestAnimationFramePolyfill()
}

function cancelRequestAnimationFrame(K) {
    if (typeof window > "u") return null;
    if (window.cancelAnimationFrame) return window.cancelAnimationFrame(K);
    var C = availablePrefixs.filter(function (H) {
        return "".concat(H, "CancelAnimationFrame") in window || "".concat(H, "CancelRequestAnimationFrame") in
            window
    })[0];
    return C ? (window["".concat(C, "CancelAnimationFrame")] || window["".concat(C, "CancelRequestAnimationFrame")]).call(
        this, K) : clearTimeout(K)
}
var raf = getRequestAnimationFrame(),
    cancelAnimationTimeout = function (C) {
        return cancelRequestAnimationFrame(C.id)
    },
    requestAnimationTimeout = function (C) {
        var H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
            W = Date.now();

        function U() {
            Date.now() - W >= H ? C.call() : G.id = raf(U)
        }
        var G = {
            id: raf(U)
        };
        return G
    },
    innerProps = {
        visible: Boolean,
        prefixCls: String,
        zIndex: Number,
        destroyPopupOnHide: Boolean,
        forceRender: Boolean,
        animation: [String, Object],
        transitionName: String,
        stretch: {
            type: String
        },
        align: {
            type: Object
        },
        point: {
            type: Object
        },
        getRootDomNode: {
            type: Function
        },
        getClassNameFromAlign: {
            type: Function
        },
        onMouseenter: {
            type: Function
        },
        onMouseleave: {
            type: Function
        },
        onMousedown: {
            type: Function
        },
        onTouchstart: {
            type: Function
        }
    },
    mobileProps = _objectSpread2$1(_objectSpread2$1({}, innerProps), {}, {
        mobile: {
            type: Object
        }
    }),
    popupProps = _objectSpread2$1(_objectSpread2$1({}, innerProps), {}, {
        mask: Boolean,
        mobile: {
            type: Object
        },
        maskAnimation: String,
        maskTransitionName: String
    });

function getMotion(K) {
    var C = K.prefixCls,
        H = K.animation,
        W = K.transitionName;
    return H ? {
        name: "".concat(C, "-").concat(H)
    } : W ? {
        name: W
    } : {}
}

function Mask$1(K) {
    var C = K.prefixCls,
        H = K.visible,
        W = K.zIndex,
        U = K.mask,
        G = K.maskAnimation,
        X = K.maskTransitionName;
    if (!U) return null;
    var Z = {};
    return (X || G) && (Z = getMotion({
        prefixCls: C,
        transitionName: X,
        animation: G
    })), createVNode(Transition, _objectSpread2$1({
        appear: !0
    }, Z), {
        default: function () {
            return [withDirectives(createVNode("div", {
                style: {
                    zIndex: W
                },
                class: "".concat(C, "-mask")
            }, null), [[resolveDirective("if"), H]])]
        }
    })
}
Mask$1.displayName = "Mask";
const MobilePopupInner = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "MobilePopupInner",
    inheritAttrs: !1,
    props: mobileProps,
    emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
    setup: function (C, H) {
        var W = H.expose,
            U = H.slots,
            G = ref();
        return W({
                forceAlign: function () {},
                getElement: function () {
                    return G.value
                }
            }),
            function () {
                var X, Z = C.zIndex,
                    Q = C.visible,
                    ee = C.prefixCls,
                    ne = C.mobile,
                    te = ne === void 0 ? {} : ne,
                    re = te.popupClassName,
                    ae = te.popupStyle,
                    oe = te.popupMotion,
                    ie = oe === void 0 ? {} : oe,
                    ue = te.popupRender,
                    le = _objectSpread2$1({
                        zIndex: Z
                    }, ae),
                    se = flattenChildren((X = U.default) === null || X === void 0 ? void 0 : X.call(U));
                se.length > 1 && (se = createVNode("div", {
                    class: "".concat(ee, "-content")
                }, [se])), ue && (se = ue(se));
                var ce = classNames(ee, re);
                return createVNode(Transition, _objectSpread2$1({
                    ref: G
                }, ie), {
                    default: function () {
                        return [Q ? createVNode("div", {
                            class: ce,
                            style: le
                        }, [se]) : null]
                    }
                })
            }
    }
});
var StatusQueue = ["measure", "align", null, "motion"];
const useVisibleStatus = function (K, C) {
        var H = ref(null),
            W = ref(),
            U = ref(!1);

        function G(Q) {
            U.value || (H.value = Q)
        }

        function X() {
            wrapperRaf.cancel(W.value)
        }

        function Z(Q) {
            X(), W.value = wrapperRaf(function () {
                var ee = H.value;
                switch (H.value) {
                    case "align":
                        ee = "motion";
                        break;
                    case "motion":
                        ee = "stable";
                        break
                }
                G(ee), Q == null || Q()
            })
        }
        return watch(K, function () {
            G("measure")
        }, {
            immediate: !0,
            flush: "post"
        }), onMounted(function () {
            watch(H, function () {
                switch (H.value) {
                    case "measure":
                        C();
                        break
                }
                H.value && (W.value = wrapperRaf(_asyncToGenerator(regenerator.mark(function Q() {
                    var ee, ne;
                    return regenerator.wrap(function (re) {
                        for (;;) switch (re.prev = re.next) {
                            case 0:
                                ee = StatusQueue.indexOf(H.value), ne =
                                    StatusQueue[ee + 1], ne && ee !==
                                    -1 && G(ne);
                            case 3:
                            case "end":
                                return re.stop()
                        }
                    }, Q)
                }))))
            }, {
                immediate: !0,
                flush: "post"
            })
        }), onBeforeUnmount(function () {
            U.value = !0, X()
        }), [H, Z]
    },
    useStretchStyle = function (K) {
        var C = ref({
            width: 0,
            height: 0
        });

        function H(U) {
            C.value = {
                width: U.offsetWidth,
                height: U.offsetHeight
            }
        }
        var W = computed(function () {
            var U = {};
            if (K.value) {
                var G = C.value,
                    X = G.width,
                    Z = G.height;
                K.value.indexOf("height") !== -1 && Z ? U.height = "".concat(Z, "px") : K.value.indexOf(
                        "minHeight") !== -1 && Z && (U.minHeight = "".concat(Z, "px")), K.value.indexOf("width") !==
                    -1 && X ? U.width = "".concat(X, "px") : K.value.indexOf("minWidth") !== -1 && X && (U.minWidth =
                        "".concat(X, "px"))
            }
            return U
        });
        return [W, H]
    };

function ownKeys(K, C) {
    var H = Object.keys(K);
    if (Object.getOwnPropertySymbols) {
        var W = Object.getOwnPropertySymbols(K);
        C && (W = W.filter(function (U) {
            return Object.getOwnPropertyDescriptor(K, U).enumerable
        })), H.push.apply(H, W)
    }
    return H
}

function _objectSpread2(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? arguments[C] : {};
        C % 2 ? ownKeys(Object(H), !0).forEach(function (W) {
                _defineProperty$H(K, W, H[W])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(K, Object.getOwnPropertyDescriptors(H)) :
            ownKeys(Object(H)).forEach(function (W) {
                Object.defineProperty(K, W, Object.getOwnPropertyDescriptor(H, W))
            })
    }
    return K
}

function _typeof(K) {
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (C) {
        return typeof C
    } : function (C) {
        return C && typeof Symbol == "function" && C.constructor === Symbol && C !== Symbol.prototype ? "symbol" :
            typeof C
    }, _typeof(K)
}

function _defineProperty$H(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var vendorPrefix, jsCssMap = {
    Webkit: "-webkit-",
    Moz: "-moz-",
    ms: "-ms-",
    O: "-o-"
};

function getVendorPrefix() {
    if (vendorPrefix !== void 0) return vendorPrefix;
    vendorPrefix = "";
    var K = document.createElement("p").style,
        C = "Transform";
    for (var H in jsCssMap) H + C in K && (vendorPrefix = H);
    return vendorPrefix
}

function getTransitionName$1() {
    return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : "transitionProperty"
}

function getTransformName() {
    return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : "transform"
}

function setTransitionProperty(K, C) {
    var H = getTransitionName$1();
    H && (K.style[H] = C, H !== "transitionProperty" && (K.style.transitionProperty = C))
}

function setTransform(K, C) {
    var H = getTransformName();
    H && (K.style[H] = C, H !== "transform" && (K.style.transform = C))
}

function getTransitionProperty(K) {
    return K.style.transitionProperty || K.style[getTransitionName$1()]
}

function getTransformXY(K) {
    var C = window.getComputedStyle(K, null),
        H = C.getPropertyValue("transform") || C.getPropertyValue(getTransformName());
    if (H && H !== "none") {
        var W = H.replace(/[^0-9\-.,]/g, "").split(",");
        return {
            x: parseFloat(W[12] || W[4], 0),
            y: parseFloat(W[13] || W[5], 0)
        }
    }
    return {
        x: 0,
        y: 0
    }
}
var matrix2d = /matrix\((.*)\)/,
    matrix3d = /matrix3d\((.*)\)/;

function setTransformXY(K, C) {
    var H = window.getComputedStyle(K, null),
        W = H.getPropertyValue("transform") || H.getPropertyValue(getTransformName());
    if (W && W !== "none") {
        var U, G = W.match(matrix2d);
        if (G) G = G[1], U = G.split(",").map(function (Z) {
            return parseFloat(Z, 10)
        }), U[4] = C.x, U[5] = C.y, setTransform(K, "matrix(".concat(U.join(","), ")"));
        else {
            var X = W.match(matrix3d)[1];
            U = X.split(",").map(function (Z) {
                return parseFloat(Z, 10)
            }), U[12] = C.x, U[13] = C.y, setTransform(K, "matrix3d(".concat(U.join(","), ")"))
        }
    } else setTransform(K, "translateX(".concat(C.x, "px) translateY(").concat(C.y, "px) translateZ(0)"))
}
var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,
    getComputedStyleX;

function forceRelayout(K) {
    var C = K.style.display;
    K.style.display = "none", K.offsetHeight, K.style.display = C
}

function css(K, C, H) {
    var W = H;
    if (_typeof(C) === "object") {
        for (var U in C) C.hasOwnProperty(U) && css(K, U, C[U]);
        return
    }
    if (typeof W < "u") {
        typeof W == "number" && (W = "".concat(W, "px")), K.style[C] = W;
        return
    }
    return getComputedStyleX(K, C)
}

function getClientPosition$1(K) {
    var C, H, W, U = K.ownerDocument,
        G = U.body,
        X = U && U.documentElement;
    return C = K.getBoundingClientRect(), H = Math.floor(C.left), W = Math.floor(C.top), H -= X.clientLeft || G.clientLeft ||
        0, W -= X.clientTop || G.clientTop || 0, {
            left: H,
            top: W
        }
}

function getScroll$2(K, C) {
    var H = K["page".concat(C ? "Y" : "X", "Offset")],
        W = "scroll".concat(C ? "Top" : "Left");
    if (typeof H != "number") {
        var U = K.document;
        H = U.documentElement[W], typeof H != "number" && (H = U.body[W])
    }
    return H
}

function getScrollLeft(K) {
    return getScroll$2(K)
}

function getScrollTop(K) {
    return getScroll$2(K, !0)
}

function getOffset$2(K) {
    var C = getClientPosition$1(K),
        H = K.ownerDocument,
        W = H.defaultView || H.parentWindow;
    return C.left += getScrollLeft(W), C.top += getScrollTop(W), C
}

function isWindow(K) {
    return K != null && K == K.window
}

function getDocument(K) {
    return isWindow(K) ? K.document : K.nodeType === 9 ? K : K.ownerDocument
}

function _getComputedStyle(K, C, H) {
    var W = H,
        U = "",
        G = getDocument(K);
    return W = W || G.defaultView.getComputedStyle(K, null), W && (U = W.getPropertyValue(C) || W[C]), U
}
var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), "i"),
    RE_POS = /^(top|right|bottom|left)$/,
    CURRENT_STYLE = "currentStyle",
    RUNTIME_STYLE = "runtimeStyle",
    LEFT = "left",
    PX = "px";

function _getComputedStyleIE(K, C) {
    var H = K[CURRENT_STYLE] && K[CURRENT_STYLE][C];
    if (_RE_NUM_NO_PX.test(H) && !RE_POS.test(C)) {
        var W = K.style,
            U = W[LEFT],
            G = K[RUNTIME_STYLE][LEFT];
        K[RUNTIME_STYLE][LEFT] = K[CURRENT_STYLE][LEFT], W[LEFT] = C === "fontSize" ? "1em" : H || 0, H = W.pixelLeft +
            PX, W[LEFT] = U, K[RUNTIME_STYLE][LEFT] = G
    }
    return H === "" ? "auto" : H
}
typeof window < "u" && (getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE);

function getOffsetDirection(K, C) {
    return K === "left" ? C.useCssRight ? "right" : K : C.useCssBottom ? "bottom" : K
}

function oppositeOffsetDirection(K) {
    if (K === "left") return "right";
    if (K === "right") return "left";
    if (K === "top") return "bottom";
    if (K === "bottom") return "top"
}

function setLeftTop(K, C, H) {
    css(K, "position") === "static" && (K.style.position = "relative");
    var W = -999,
        U = -999,
        G = getOffsetDirection("left", H),
        X = getOffsetDirection("top", H),
        Z = oppositeOffsetDirection(G),
        Q = oppositeOffsetDirection(X);
    G !== "left" && (W = 999), X !== "top" && (U = 999);
    var ee = "",
        ne = getOffset$2(K);
    ("left" in C || "top" in C) && (ee = getTransitionProperty(K) || "", setTransitionProperty(K, "none")), "left" in C
        && (K.style[Z] = "", K.style[G] = "".concat(W, "px")), "top" in C && (K.style[Q] = "", K.style[X] = "".concat(U,
            "px")), forceRelayout(K);
    var te = getOffset$2(K),
        re = {};
    for (var ae in C)
        if (C.hasOwnProperty(ae)) {
            var oe = getOffsetDirection(ae, H),
                ie = ae === "left" ? W : U,
                ue = ne[ae] - te[ae];
            oe === ae ? re[oe] = ie + ue : re[oe] = ie - ue
        } css(K, re), forceRelayout(K), ("left" in C || "top" in C) && setTransitionProperty(K, ee);
    var le = {};
    for (var se in C)
        if (C.hasOwnProperty(se)) {
            var ce = getOffsetDirection(se, H),
                de = C[se] - ne[se];
            se === ce ? le[ce] = re[ce] + de : le[ce] = re[ce] - de
        } css(K, le)
}

function setTransform$1(K, C) {
    var H = getOffset$2(K),
        W = getTransformXY(K),
        U = {
            x: W.x,
            y: W.y
        };
    "left" in C && (U.x = W.x + C.left - H.left), "top" in C && (U.y = W.y + C.top - H.top), setTransformXY(K, U)
}

function setOffset(K, C, H) {
    if (H.ignoreShake) {
        var W = getOffset$2(K),
            U = W.left.toFixed(0),
            G = W.top.toFixed(0),
            X = C.left.toFixed(0),
            Z = C.top.toFixed(0);
        if (U === X && G === Z) return
    }
    H.useCssRight || H.useCssBottom ? setLeftTop(K, C, H) : H.useCssTransform && getTransformName() in document.body.style ?
        setTransform$1(K, C) : setLeftTop(K, C, H)
}

function each(K, C) {
    for (var H = 0; H < K.length; H++) C(K[H])
}

function isBorderBoxFn(K) {
    return getComputedStyleX(K, "boxSizing") === "border-box"
}
var BOX_MODELS = ["margin", "border", "padding"],
    CONTENT_INDEX = -1,
    PADDING_INDEX = 2,
    BORDER_INDEX = 1,
    MARGIN_INDEX = 0;

function swap(K, C, H) {
    var W = {},
        U = K.style,
        G;
    for (G in C) C.hasOwnProperty(G) && (W[G] = U[G], U[G] = C[G]);
    H.call(K);
    for (G in C) C.hasOwnProperty(G) && (U[G] = W[G])
}

function getPBMWidth(K, C, H) {
    var W = 0,
        U, G, X;
    for (G = 0; G < C.length; G++)
        if (U = C[G], U)
            for (X = 0; X < H.length; X++) {
                var Z = void 0;
                U === "border" ? Z = "".concat(U).concat(H[X], "Width") : Z = U + H[X], W += parseFloat(
                    getComputedStyleX(K, Z)) || 0
            }
    return W
}
var domUtils = {
    getParent: function (C) {
        var H = C;
        do H.nodeType === 11 && H.host ? H = H.host : H = H.parentNode; while (H && H.nodeType !== 1 && H.nodeType !==
            9);
        return H
    }
};
each(["Width", "Height"], function (K) {
    domUtils["doc".concat(K)] = function (C) {
        var H = C.document;
        return Math.max(H.documentElement["scroll".concat(K)], H.body["scroll".concat(K)], domUtils[
            "viewport".concat(K)](H))
    }, domUtils["viewport".concat(K)] = function (C) {
        var H = "client".concat(K),
            W = C.document,
            U = W.body,
            G = W.documentElement,
            X = G[H];
        return W.compatMode === "CSS1Compat" && X || U && U[H] || X
    }
});

function getWH(K, C, H) {
    var W = H;
    if (isWindow(K)) return C === "width" ? domUtils.viewportWidth(K) : domUtils.viewportHeight(K);
    if (K.nodeType === 9) return C === "width" ? domUtils.docWidth(K) : domUtils.docHeight(K);
    var U = C === "width" ? ["Left", "Right"] : ["Top", "Bottom"],
        G = Math.floor(C === "width" ? K.getBoundingClientRect().width : K.getBoundingClientRect().height),
        X = isBorderBoxFn(K),
        Z = 0;
    (G == null || G <= 0) && (G = void 0, Z = getComputedStyleX(K, C), (Z == null || Number(Z) < 0) && (Z = K.style[C] ||
        0), Z = Math.floor(parseFloat(Z)) || 0), W === void 0 && (W = X ? BORDER_INDEX : CONTENT_INDEX);
    var Q = G !== void 0 || X,
        ee = G || Z;
    return W === CONTENT_INDEX ? Q ? ee - getPBMWidth(K, ["border", "padding"], U) : Z : Q ? W === BORDER_INDEX ? ee :
        ee + (W === PADDING_INDEX ? -getPBMWidth(K, ["border"], U) : getPBMWidth(K, ["margin"], U)) : Z + getPBMWidth(K,
            BOX_MODELS.slice(W), U)
}
var cssShow = {
    position: "absolute",
    visibility: "hidden",
    display: "block"
};

function getWHIgnoreDisplay() {
    for (var K = arguments.length, C = new Array(K), H = 0; H < K; H++) C[H] = arguments[H];
    var W, U = C[0];
    return U.offsetWidth !== 0 ? W = getWH.apply(void 0, C) : swap(U, cssShow, function () {
        W = getWH.apply(void 0, C)
    }), W
}
each(["width", "height"], function (K) {
    var C = K.charAt(0).toUpperCase() + K.slice(1);
    domUtils["outer".concat(C)] = function (W, U) {
        return W && getWHIgnoreDisplay(W, K, U ? MARGIN_INDEX : BORDER_INDEX)
    };
    var H = K === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
    domUtils[K] = function (W, U) {
        var G = U;
        if (G !== void 0) {
            if (W) {
                var X = isBorderBoxFn(W);
                return X && (G += getPBMWidth(W, ["padding", "border"], H)), css(W, K, G)
            }
            return
        }
        return W && getWHIgnoreDisplay(W, K, CONTENT_INDEX)
    }
});

function mix(K, C) {
    for (var H in C) C.hasOwnProperty(H) && (K[H] = C[H]);
    return K
}
var utils = {
    getWindow: function (C) {
        if (C && C.document && C.setTimeout) return C;
        var H = C.ownerDocument || C;
        return H.defaultView || H.parentWindow
    },
    getDocument,
    offset: function (C, H, W) {
        if (typeof H < "u") setOffset(C, H, W || {});
        else return getOffset$2(C)
    },
    isWindow,
    each,
    css,
    clone: function (C) {
        var H, W = {};
        for (H in C) C.hasOwnProperty(H) && (W[H] = C[H]);
        var U = C.overflow;
        if (U)
            for (H in C) C.hasOwnProperty(H) && (W.overflow[H] = C.overflow[H]);
        return W
    },
    mix,
    getWindowScrollLeft: function (C) {
        return getScrollLeft(C)
    },
    getWindowScrollTop: function (C) {
        return getScrollTop(C)
    },
    merge: function () {
        for (var C = {}, H = 0; H < arguments.length; H++) utils.mix(C, H < 0 || arguments.length <= H ? void 0 :
            arguments[H]);
        return C
    },
    viewportWidth: 0,
    viewportHeight: 0
};
mix(utils, domUtils);
var getParent$1 = utils.getParent;

function getOffsetParent(K) {
    if (utils.isWindow(K) || K.nodeType === 9) return null;
    var C = utils.getDocument(K),
        H = C.body,
        W, U = utils.css(K, "position"),
        G = U === "fixed" || U === "absolute";
    if (!G) return K.nodeName.toLowerCase() === "html" ? null : getParent$1(K);
    for (W = getParent$1(K); W && W !== H && W.nodeType !== 9; W = getParent$1(W))
        if (U = utils.css(W, "position"), U !== "static") return W;
    return null
}
var getParent$1$1 = utils.getParent;

function isAncestorFixed(K) {
    if (utils.isWindow(K) || K.nodeType === 9) return !1;
    var C = utils.getDocument(K),
        H = C.body,
        W = null;
    for (W = getParent$1$1(K); W && W !== H && W !== C; W = getParent$1$1(W)) {
        var U = utils.css(W, "position");
        if (U === "fixed") return !0
    }
    return !1
}

function getVisibleRectForElement(K, C) {
    for (var H = {
                left: 0,
                right: 1 / 0,
                top: 0,
                bottom: 1 / 0
            }, W = getOffsetParent(K), U = utils.getDocument(K), G = U.defaultView || U.parentWindow, X = U.body, Z = U
            .documentElement; W;) {
        if ((navigator.userAgent.indexOf("MSIE") === -1 || W.clientWidth !== 0) && W !== X && W !== Z && utils.css(W,
                "overflow") !== "visible") {
            var Q = utils.offset(W);
            Q.left += W.clientLeft, Q.top += W.clientTop, H.top = Math.max(H.top, Q.top), H.right = Math.min(H.right, Q
                .left + W.clientWidth), H.bottom = Math.min(H.bottom, Q.top + W.clientHeight), H.left = Math.max(H.left,
                Q.left)
        } else if (W === X || W === Z) break;
        W = getOffsetParent(W)
    }
    var ee = null;
    if (!utils.isWindow(K) && K.nodeType !== 9) {
        ee = K.style.position;
        var ne = utils.css(K, "position");
        ne === "absolute" && (K.style.position = "fixed")
    }
    var te = utils.getWindowScrollLeft(G),
        re = utils.getWindowScrollTop(G),
        ae = utils.viewportWidth(G),
        oe = utils.viewportHeight(G),
        ie = Z.scrollWidth,
        ue = Z.scrollHeight,
        le = window.getComputedStyle(X);
    if (le.overflowX === "hidden" && (ie = G.innerWidth), le.overflowY === "hidden" && (ue = G.innerHeight), K.style &&
        (K.style.position = ee), C || isAncestorFixed(K)) H.left = Math.max(H.left, te), H.top = Math.max(H.top, re), H
        .right = Math.min(H.right, te + ae), H.bottom = Math.min(H.bottom, re + oe);
    else {
        var se = Math.max(ie, te + ae);
        H.right = Math.min(H.right, se);
        var ce = Math.max(ue, re + oe);
        H.bottom = Math.min(H.bottom, ce)
    }
    return H.top >= 0 && H.left >= 0 && H.bottom > H.top && H.right > H.left ? H : null
}

function adjustForViewport(K, C, H, W) {
    var U = utils.clone(K),
        G = {
            width: C.width,
            height: C.height
        };
    return W.adjustX && U.left < H.left && (U.left = H.left), W.resizeWidth && U.left >= H.left && U.left + G.width > H
        .right && (G.width -= U.left + G.width - H.right), W.adjustX && U.left + G.width > H.right && (U.left = Math.max(
            H.right - G.width, H.left)), W.adjustY && U.top < H.top && (U.top = H.top), W.resizeHeight && U.top >= H.top &&
        U.top + G.height > H.bottom && (G.height -= U.top + G.height - H.bottom), W.adjustY && U.top + G.height > H.bottom &&
        (U.top = Math.max(H.bottom - G.height, H.top)), utils.mix(U, G)
}

function getRegion(K) {
    var C, H, W;
    if (!utils.isWindow(K) && K.nodeType !== 9) C = utils.offset(K), H = utils.outerWidth(K), W = utils.outerHeight(K);
    else {
        var U = utils.getWindow(K);
        C = {
            left: utils.getWindowScrollLeft(U),
            top: utils.getWindowScrollTop(U)
        }, H = utils.viewportWidth(U), W = utils.viewportHeight(U)
    }
    return C.width = H, C.height = W, C
}

function getAlignOffset(K, C) {
    var H = C.charAt(0),
        W = C.charAt(1),
        U = K.width,
        G = K.height,
        X = K.left,
        Z = K.top;
    return H === "c" ? Z += G / 2 : H === "b" && (Z += G), W === "c" ? X += U / 2 : W === "r" && (X += U), {
        left: X,
        top: Z
    }
}

function getElFuturePos(K, C, H, W, U) {
    var G = getAlignOffset(C, H[1]),
        X = getAlignOffset(K, H[0]),
        Z = [X.left - G.left, X.top - G.top];
    return {
        left: Math.round(K.left - Z[0] + W[0] - U[0]),
        top: Math.round(K.top - Z[1] + W[1] - U[1])
    }
}

function isFailX(K, C, H) {
    return K.left < H.left || K.left + C.width > H.right
}

function isFailY(K, C, H) {
    return K.top < H.top || K.top + C.height > H.bottom
}

function isCompleteFailX(K, C, H) {
    return K.left > H.right || K.left + C.width < H.left
}

function isCompleteFailY(K, C, H) {
    return K.top > H.bottom || K.top + C.height < H.top
}

function flip(K, C, H) {
    var W = [];
    return utils.each(K, function (U) {
        W.push(U.replace(C, function (G) {
            return H[G]
        }))
    }), W
}

function flipOffset(K, C) {
    return K[C] = -K[C], K
}

function convertOffset(K, C) {
    var H;
    return /%$/.test(K) ? H = parseInt(K.substring(0, K.length - 1), 10) / 100 * C : H = parseInt(K, 10), H || 0
}

function normalizeOffset(K, C) {
    K[0] = convertOffset(K[0], C.width), K[1] = convertOffset(K[1], C.height)
}

function doAlign(K, C, H, W) {
    var U = H.points,
        G = H.offset || [0, 0],
        X = H.targetOffset || [0, 0],
        Z = H.overflow,
        Q = H.source || K;
    G = [].concat(G), X = [].concat(X), Z = Z || {};
    var ee = {},
        ne = 0,
        te = !!(Z && Z.alwaysByViewport),
        re = getVisibleRectForElement(Q, te),
        ae = getRegion(Q);
    normalizeOffset(G, ae), normalizeOffset(X, C);
    var oe = getElFuturePos(ae, C, U, G, X),
        ie = utils.merge(ae, oe);
    if (re && (Z.adjustX || Z.adjustY) && W) {
        if (Z.adjustX && isFailX(oe, ae, re)) {
            var ue = flip(U, /[lr]/gi, {
                    l: "r",
                    r: "l"
                }),
                le = flipOffset(G, 0),
                se = flipOffset(X, 0),
                ce = getElFuturePos(ae, C, ue, le, se);
            isCompleteFailX(ce, ae, re) || (ne = 1, U = ue, G = le, X = se)
        }
        if (Z.adjustY && isFailY(oe, ae, re)) {
            var de = flip(U, /[tb]/gi, {
                    t: "b",
                    b: "t"
                }),
                ve = flipOffset(G, 1),
                fe = flipOffset(X, 1),
                pe = getElFuturePos(ae, C, de, ve, fe);
            isCompleteFailY(pe, ae, re) || (ne = 1, U = de, G = ve, X = fe)
        }
        ne && (oe = getElFuturePos(ae, C, U, G, X), utils.mix(ie, oe));
        var me = isFailX(oe, ae, re),
            he = isFailY(oe, ae, re);
        if (me || he) {
            var Se = U;
            me && (Se = flip(U, /[lr]/gi, {
                l: "r",
                r: "l"
            })), he && (Se = flip(U, /[tb]/gi, {
                t: "b",
                b: "t"
            })), U = Se, G = H.offset || [0, 0], X = H.targetOffset || [0, 0]
        }
        ee.adjustX = Z.adjustX && me, ee.adjustY = Z.adjustY && he, (ee.adjustX || ee.adjustY) && (ie =
            adjustForViewport(oe, ae, re, ee))
    }
    return ie.width !== ae.width && utils.css(Q, "width", utils.width(Q) + ie.width - ae.width), ie.height !== ae.height &&
        utils.css(Q, "height", utils.height(Q) + ie.height - ae.height), utils.offset(Q, {
            left: ie.left,
            top: ie.top
        }, {
            useCssRight: H.useCssRight,
            useCssBottom: H.useCssBottom,
            useCssTransform: H.useCssTransform,
            ignoreShake: H.ignoreShake
        }), {
            points: U,
            offset: G,
            targetOffset: X,
            overflow: ee
        }
}

function isOutOfVisibleRect(K, C) {
    var H = getVisibleRectForElement(K, C),
        W = getRegion(K);
    return !H || W.left + W.width <= H.left || W.top + W.height <= H.top || W.left >= H.right || W.top >= H.bottom
}

function alignElement(K, C, H) {
    var W = H.target || C,
        U = getRegion(W),
        G = !isOutOfVisibleRect(W, H.overflow && H.overflow.alwaysByViewport);
    return doAlign(K, U, H, G)
}
alignElement.__getOffsetParent = getOffsetParent;
alignElement.__getVisibleRectForElement = getVisibleRectForElement;

function alignPoint(K, C, H) {
    var W, U, G = utils.getDocument(K),
        X = G.defaultView || G.parentWindow,
        Z = utils.getWindowScrollLeft(X),
        Q = utils.getWindowScrollTop(X),
        ee = utils.viewportWidth(X),
        ne = utils.viewportHeight(X);
    "pageX" in C ? W = C.pageX : W = Z + C.clientX, "pageY" in C ? U = C.pageY : U = Q + C.clientY;
    var te = {
            left: W,
            top: U,
            width: 0,
            height: 0
        },
        re = W >= 0 && W <= Z + ee && U >= 0 && U <= Q + ne,
        ae = [H.points[0], "cc"];
    return doAlign(K, te, _objectSpread2(_objectSpread2({}, H), {}, {
        points: ae
    }), re)
}

function cloneElement(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0,
        W = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1,
        U = K;
    if (Array.isArray(K) && (U = filterEmpty(K)[0]), !U) return null;
    var G = cloneVNode(U, C, W);
    return G.props = H ? _objectSpread2$1(_objectSpread2$1({}, G.props), C) : G.props, warning$2(_typeof$2(G.props.class) !==
        "object", "class must be string"), G
}

function cloneVNodes(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
    return K.map(function (W) {
        return cloneElement(W, C, H)
    })
}

function deepCloneElement(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0,
        W = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
    if (Array.isArray(K)) return K.map(function (G) {
        return deepCloneElement(G, C, H, W)
    });
    var U = cloneElement(K, C, H, W);
    return Array.isArray(U.children) && (U.children = deepCloneElement(U.children)), U
}
const isVisible = function (K) {
    if (!K) return !1;
    if (K.offsetParent) return !0;
    if (K.getBBox) {
        var C = K.getBBox();
        if (C.width || C.height) return !0
    }
    if (K.getBoundingClientRect) {
        var H = K.getBoundingClientRect();
        if (H.width || H.height) return !0
    }
    return !1
};

function isSamePoint(K, C) {
    return K === C ? !0 : !K || !C ? !1 : "pageX" in C && "pageY" in C ? K.pageX === C.pageX && K.pageY === C.pageY :
        "clientX" in C && "clientY" in C ? K.clientX === C.clientX && K.clientY === C.clientY : !1
}

function restoreFocus(K, C) {
    K !== document.activeElement && contains(C, K) && typeof K.focus == "function" && K.focus()
}

function monitorResize(K, C) {
    var H = null,
        W = null;

    function U(X) {
        var Z = _slicedToArray$2(X, 1),
            Q = Z[0].target;
        if (document.documentElement.contains(Q)) {
            var ee = Q.getBoundingClientRect(),
                ne = ee.width,
                te = ee.height,
                re = Math.floor(ne),
                ae = Math.floor(te);
            (H !== re || W !== ae) && Promise.resolve().then(function () {
                C({
                    width: re,
                    height: ae
                })
            }), H = re, W = ae
        }
    }
    var G = new ResizeObserver$3(U);
    return K && G.observe(K),
        function () {
            G.disconnect()
        }
}
const useBuffer = function (K, C) {
    var H = !1,
        W = null;

    function U() {
        clearTimeout(W)
    }

    function G(X) {
        if (!H || X === !0) {
            if (K() === !1) return;
            H = !0, U(), W = setTimeout(function () {
                H = !1
            }, C.value)
        } else U(), W = setTimeout(function () {
            H = !1, G()
        }, C.value)
    }
    return [G, function () {
        H = !1, U()
    }]
};

function listCacheClear() {
    this.__data__ = [], this.size = 0
}

function eq(K, C) {
    return K === C || K !== K && C !== C
}

function assocIndexOf(K, C) {
    for (var H = K.length; H--;)
        if (eq(K[H][0], C)) return H;
    return -1
}
var arrayProto = Array.prototype,
    splice = arrayProto.splice;

function listCacheDelete(K) {
    var C = this.__data__,
        H = assocIndexOf(C, K);
    if (H < 0) return !1;
    var W = C.length - 1;
    return H == W ? C.pop() : splice.call(C, H, 1), --this.size, !0
}

function listCacheGet(K) {
    var C = this.__data__,
        H = assocIndexOf(C, K);
    return H < 0 ? void 0 : C[H][1]
}

function listCacheHas(K) {
    return assocIndexOf(this.__data__, K) > -1
}

function listCacheSet(K, C) {
    var H = this.__data__,
        W = assocIndexOf(H, K);
    return W < 0 ? (++this.size, H.push([K, C])) : H[W][1] = C, this
}

function ListCache(K) {
    var C = -1,
        H = K == null ? 0 : K.length;
    for (this.clear(); ++C < H;) {
        var W = K[C];
        this.set(W[0], W[1])
    }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype.delete = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

function stackClear() {
    this.__data__ = new ListCache, this.size = 0
}

function stackDelete(K) {
    var C = this.__data__,
        H = C.delete(K);
    return this.size = C.size, H
}

function stackGet(K) {
    return this.__data__.get(K)
}

function stackHas(K) {
    return this.__data__.has(K)
}

function isObject$2(K) {
    var C = typeof K;
    return K != null && (C == "object" || C == "function")
}
var asyncTag = "[object AsyncFunction]",
    funcTag$2 = "[object Function]",
    genTag$1 = "[object GeneratorFunction]",
    proxyTag = "[object Proxy]";

function isFunction$1(K) {
    if (!isObject$2(K)) return !1;
    var C = baseGetTag(K);
    return C == funcTag$2 || C == genTag$1 || C == asyncTag || C == proxyTag
}
var coreJsData = root$2["__core-js_shared__"];
const coreJsData$1 = coreJsData;
var maskSrcKey = function () {
    var K = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
    return K ? "Symbol(src)_1." + K : ""
}();

function isMasked(K) {
    return !!maskSrcKey && maskSrcKey in K
}
var funcProto$1 = Function.prototype,
    funcToString$1 = funcProto$1.toString;

function toSource(K) {
    if (K != null) {
        try {
            return funcToString$1.call(K)
        } catch {}
        try {
            return K + ""
        } catch {}
    }
    return ""
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
    reIsHostCtor = /^\[object .+?Constructor\]$/,
    funcProto = Function.prototype,
    objectProto$c = Object.prototype,
    funcToString = funcProto.toString,
    hasOwnProperty$a = objectProto$c.hasOwnProperty,
    reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(
        /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");

function baseIsNative(K) {
    if (!isObject$2(K) || isMasked(K)) return !1;
    var C = isFunction$1(K) ? reIsNative : reIsHostCtor;
    return C.test(toSource(K))
}

function getValue$3(K, C) {
    return K == null ? void 0 : K[C]
}

function getNative(K, C) {
    var H = getValue$3(K, C);
    return baseIsNative(H) ? H : void 0
}
var Map$1 = getNative(root$2, "Map");
const Map$2 = Map$1;
var nativeCreate = getNative(Object, "create");
const nativeCreate$1 = nativeCreate;

function hashClear() {
    this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {}, this.size = 0
}

function hashDelete(K) {
    var C = this.has(K) && delete this.__data__[K];
    return this.size -= C ? 1 : 0, C
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__",
    objectProto$b = Object.prototype,
    hasOwnProperty$9 = objectProto$b.hasOwnProperty;

function hashGet(K) {
    var C = this.__data__;
    if (nativeCreate$1) {
        var H = C[K];
        return H === HASH_UNDEFINED$2 ? void 0 : H
    }
    return hasOwnProperty$9.call(C, K) ? C[K] : void 0
}
var objectProto$a = Object.prototype,
    hasOwnProperty$8 = objectProto$a.hasOwnProperty;

function hashHas(K) {
    var C = this.__data__;
    return nativeCreate$1 ? C[K] !== void 0 : hasOwnProperty$8.call(C, K)
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";

function hashSet(K, C) {
    var H = this.__data__;
    return this.size += this.has(K) ? 0 : 1, H[K] = nativeCreate$1 && C === void 0 ? HASH_UNDEFINED$1 : C, this
}

function Hash(K) {
    var C = -1,
        H = K == null ? 0 : K.length;
    for (this.clear(); ++C < H;) {
        var W = K[C];
        this.set(W[0], W[1])
    }
}
Hash.prototype.clear = hashClear;
Hash.prototype.delete = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

function mapCacheClear() {
    this.size = 0, this.__data__ = {
        hash: new Hash,
        map: new(Map$2 || ListCache),
        string: new Hash
    }
}

function isKeyable(K) {
    var C = typeof K;
    return C == "string" || C == "number" || C == "symbol" || C == "boolean" ? K !== "__proto__" : K === null
}

function getMapData(K, C) {
    var H = K.__data__;
    return isKeyable(C) ? H[typeof C == "string" ? "string" : "hash"] : H.map
}

function mapCacheDelete(K) {
    var C = getMapData(this, K).delete(K);
    return this.size -= C ? 1 : 0, C
}

function mapCacheGet(K) {
    return getMapData(this, K).get(K)
}

function mapCacheHas(K) {
    return getMapData(this, K).has(K)
}

function mapCacheSet(K, C) {
    var H = getMapData(this, K),
        W = H.size;
    return H.set(K, C), this.size += H.size == W ? 0 : 1, this
}

function MapCache(K) {
    var C = -1,
        H = K == null ? 0 : K.length;
    for (this.clear(); ++C < H;) {
        var W = K[C];
        this.set(W[0], W[1])
    }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype.delete = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var LARGE_ARRAY_SIZE$1 = 200;

function stackSet(K, C) {
    var H = this.__data__;
    if (H instanceof ListCache) {
        var W = H.__data__;
        if (!Map$2 || W.length < LARGE_ARRAY_SIZE$1 - 1) return W.push([K, C]), this.size = ++H.size, this;
        H = this.__data__ = new MapCache(W)
    }
    return H.set(K, C), this.size = H.size, this
}

function Stack(K) {
    var C = this.__data__ = new ListCache(K);
    this.size = C.size
}
Stack.prototype.clear = stackClear;
Stack.prototype.delete = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
var HASH_UNDEFINED = "__lodash_hash_undefined__";

function setCacheAdd(K) {
    return this.__data__.set(K, HASH_UNDEFINED), this
}

function setCacheHas(K) {
    return this.__data__.has(K)
}

function SetCache(K) {
    var C = -1,
        H = K == null ? 0 : K.length;
    for (this.__data__ = new MapCache; ++C < H;) this.add(K[C])
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

function arraySome(K, C) {
    for (var H = -1, W = K == null ? 0 : K.length; ++H < W;)
        if (C(K[H], H, K)) return !0;
    return !1
}

function cacheHas(K, C) {
    return K.has(C)
}
var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;

function equalArrays(K, C, H, W, U, G) {
    var X = H & COMPARE_PARTIAL_FLAG$5,
        Z = K.length,
        Q = C.length;
    if (Z != Q && !(X && Q > Z)) return !1;
    var ee = G.get(K),
        ne = G.get(C);
    if (ee && ne) return ee == C && ne == K;
    var te = -1,
        re = !0,
        ae = H & COMPARE_UNORDERED_FLAG$3 ? new SetCache : void 0;
    for (G.set(K, C), G.set(C, K); ++te < Z;) {
        var oe = K[te],
            ie = C[te];
        if (W) var ue = X ? W(ie, oe, te, C, K, G) : W(oe, ie, te, K, C, G);
        if (ue !== void 0) {
            if (ue) continue;
            re = !1;
            break
        }
        if (ae) {
            if (!arraySome(C, function (le, se) {
                    if (!cacheHas(ae, se) && (oe === le || U(oe, le, H, W, G))) return ae.push(se)
                })) {
                re = !1;
                break
            }
        } else if (!(oe === ie || U(oe, ie, H, W, G))) {
            re = !1;
            break
        }
    }
    return G.delete(K), G.delete(C), re
}
var Uint8Array$1 = root$2.Uint8Array;
const Uint8Array$2 = Uint8Array$1;

function mapToArray(K) {
    var C = -1,
        H = Array(K.size);
    return K.forEach(function (W, U) {
        H[++C] = [U, W]
    }), H
}

function setToArray(K) {
    var C = -1,
        H = Array(K.size);
    return K.forEach(function (W) {
        H[++C] = W
    }), H
}
var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2,
    boolTag$3 = "[object Boolean]",
    dateTag$3 = "[object Date]",
    errorTag$2 = "[object Error]",
    mapTag$5 = "[object Map]",
    numberTag$4 = "[object Number]",
    regexpTag$3 = "[object RegExp]",
    setTag$5 = "[object Set]",
    stringTag$3 = "[object String]",
    symbolTag$3 = "[object Symbol]",
    arrayBufferTag$3 = "[object ArrayBuffer]",
    dataViewTag$4 = "[object DataView]",
    symbolProto$2 = Symbol$2 ? Symbol$2.prototype : void 0,
    symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;

function equalByTag(K, C, H, W, U, G, X) {
    switch (H) {
        case dataViewTag$4:
            if (K.byteLength != C.byteLength || K.byteOffset != C.byteOffset) return !1;
            K = K.buffer, C = C.buffer;
        case arrayBufferTag$3:
            return !(K.byteLength != C.byteLength || !G(new Uint8Array$2(K), new Uint8Array$2(C)));
        case boolTag$3:
        case dateTag$3:
        case numberTag$4:
            return eq(+K, +C);
        case errorTag$2:
            return K.name == C.name && K.message == C.message;
        case regexpTag$3:
        case stringTag$3:
            return K == C + "";
        case mapTag$5:
            var Z = mapToArray;
        case setTag$5:
            var Q = W & COMPARE_PARTIAL_FLAG$4;
            if (Z || (Z = setToArray), K.size != C.size && !Q) return !1;
            var ee = X.get(K);
            if (ee) return ee == C;
            W |= COMPARE_UNORDERED_FLAG$2, X.set(K, C);
            var ne = equalArrays(Z(K), Z(C), W, U, G, X);
            return X.delete(K), ne;
        case symbolTag$3:
            if (symbolValueOf$1) return symbolValueOf$1.call(K) == symbolValueOf$1.call(C)
    }
    return !1
}

function arrayPush(K, C) {
    for (var H = -1, W = C.length, U = K.length; ++H < W;) K[U + H] = C[H];
    return K
}
var isArray$1 = Array.isArray;
const isArray$2 = isArray$1;

function baseGetAllKeys(K, C, H) {
    var W = C(K);
    return isArray$2(K) ? W : arrayPush(W, H(K))
}

function arrayFilter(K, C) {
    for (var H = -1, W = K == null ? 0 : K.length, U = 0, G = []; ++H < W;) {
        var X = K[H];
        C(X, H, K) && (G[U++] = X)
    }
    return G
}

function stubArray() {
    return []
}
var objectProto$9 = Object.prototype,
    propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable,
    nativeGetSymbols$1 = Object.getOwnPropertySymbols,
    getSymbols = nativeGetSymbols$1 ? function (K) {
        return K == null ? [] : (K = Object(K), arrayFilter(nativeGetSymbols$1(K), function (C) {
            return propertyIsEnumerable$1.call(K, C)
        }))
    } : stubArray;
const getSymbols$1 = getSymbols;

function baseTimes(K, C) {
    for (var H = -1, W = Array(K); ++H < K;) W[H] = C(H);
    return W
}
var argsTag$3 = "[object Arguments]";

function baseIsArguments(K) {
    return isObjectLike(K) && baseGetTag(K) == argsTag$3
}
var objectProto$8 = Object.prototype,
    hasOwnProperty$7 = objectProto$8.hasOwnProperty,
    propertyIsEnumerable = objectProto$8.propertyIsEnumerable,
    isArguments = baseIsArguments(function () {
        return arguments
    }()) ? baseIsArguments : function (K) {
        return isObjectLike(K) && hasOwnProperty$7.call(K, "callee") && !propertyIsEnumerable.call(K, "callee")
    };
const isArguments$1 = isArguments;

function stubFalse() {
    return !1
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports,
    freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module,
    moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2,
    Buffer$1 = moduleExports$2 ? root$2.Buffer : void 0,
    nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0,
    isBuffer = nativeIsBuffer || stubFalse;
const isBuffer$1 = isBuffer;
var MAX_SAFE_INTEGER$2 = 9007199254740991,
    reIsUint = /^(?:0|[1-9]\d*)$/;

function isIndex(K, C) {
    var H = typeof K;
    return C = C || MAX_SAFE_INTEGER$2, !!C && (H == "number" || H != "symbol" && reIsUint.test(K)) && K > -1 && K % 1 ==
        0 && K < C
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;

function isLength(K) {
    return typeof K == "number" && K > -1 && K % 1 == 0 && K <= MAX_SAFE_INTEGER$1
}
var argsTag$2 = "[object Arguments]",
    arrayTag$2 = "[object Array]",
    boolTag$2 = "[object Boolean]",
    dateTag$2 = "[object Date]",
    errorTag$1 = "[object Error]",
    funcTag$1 = "[object Function]",
    mapTag$4 = "[object Map]",
    numberTag$3 = "[object Number]",
    objectTag$3 = "[object Object]",
    regexpTag$2 = "[object RegExp]",
    setTag$4 = "[object Set]",
    stringTag$2 = "[object String]",
    weakMapTag$2 = "[object WeakMap]",
    arrayBufferTag$2 = "[object ArrayBuffer]",
    dataViewTag$3 = "[object DataView]",
    float32Tag$2 = "[object Float32Array]",
    float64Tag$2 = "[object Float64Array]",
    int8Tag$2 = "[object Int8Array]",
    int16Tag$2 = "[object Int16Array]",
    int32Tag$2 = "[object Int32Array]",
    uint8Tag$2 = "[object Uint8Array]",
    uint8ClampedTag$2 = "[object Uint8ClampedArray]",
    uint16Tag$2 = "[object Uint16Array]",
    uint32Tag$2 = "[object Uint32Array]",
    typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
    typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[
        uint16Tag$2] = typedArrayTags[uint32Tag$2] = !0;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] =
    typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] =
    typedArrayTags[mapTag$4] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$2] =
    typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = !1;

function baseIsTypedArray(K) {
    return isObjectLike(K) && isLength(K.length) && !!typedArrayTags[baseGetTag(K)]
}

function baseUnary(K) {
    return function (C) {
        return K(C)
    }
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports,
    freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module,
    moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1,
    freeProcess = moduleExports$1 && freeGlobal$1.process,
    nodeUtil = function () {
        try {
            var K = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
            return K || freeProcess && freeProcess.binding && freeProcess.binding("util")
        } catch {}
    }();
const nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray,
    isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
const isTypedArray$1 = isTypedArray;
var objectProto$7 = Object.prototype,
    hasOwnProperty$6 = objectProto$7.hasOwnProperty;

function arrayLikeKeys(K, C) {
    var H = isArray$2(K),
        W = !H && isArguments$1(K),
        U = !H && !W && isBuffer$1(K),
        G = !H && !W && !U && isTypedArray$1(K),
        X = H || W || U || G,
        Z = X ? baseTimes(K.length, String) : [],
        Q = Z.length;
    for (var ee in K)(C || hasOwnProperty$6.call(K, ee)) && !(X && (ee == "length" || U && (ee == "offset" || ee ==
        "parent") || G && (ee == "buffer" || ee == "byteLength" || ee == "byteOffset") || isIndex(ee, Q))) && Z.push(
        ee);
    return Z
}
var objectProto$6 = Object.prototype;

function isPrototype(K) {
    var C = K && K.constructor,
        H = typeof C == "function" && C.prototype || objectProto$6;
    return K === H
}
var nativeKeys = overArg(Object.keys, Object);
const nativeKeys$1 = nativeKeys;
var objectProto$5 = Object.prototype,
    hasOwnProperty$5 = objectProto$5.hasOwnProperty;

function baseKeys(K) {
    if (!isPrototype(K)) return nativeKeys$1(K);
    var C = [];
    for (var H in Object(K)) hasOwnProperty$5.call(K, H) && H != "constructor" && C.push(H);
    return C
}

function isArrayLike(K) {
    return K != null && isLength(K.length) && !isFunction$1(K)
}

function keys$1(K) {
    return isArrayLike(K) ? arrayLikeKeys(K) : baseKeys(K)
}

function getAllKeys$1(K) {
    return baseGetAllKeys(K, keys$1, getSymbols$1)
}
var COMPARE_PARTIAL_FLAG$3 = 1,
    objectProto$4 = Object.prototype,
    hasOwnProperty$4 = objectProto$4.hasOwnProperty;

function equalObjects(K, C, H, W, U, G) {
    var X = H & COMPARE_PARTIAL_FLAG$3,
        Z = getAllKeys$1(K),
        Q = Z.length,
        ee = getAllKeys$1(C),
        ne = ee.length;
    if (Q != ne && !X) return !1;
    for (var te = Q; te--;) {
        var re = Z[te];
        if (!(X ? re in C : hasOwnProperty$4.call(C, re))) return !1
    }
    var ae = G.get(K),
        oe = G.get(C);
    if (ae && oe) return ae == C && oe == K;
    var ie = !0;
    G.set(K, C), G.set(C, K);
    for (var ue = X; ++te < Q;) {
        re = Z[te];
        var le = K[re],
            se = C[re];
        if (W) var ce = X ? W(se, le, re, C, K, G) : W(le, se, re, K, C, G);
        if (!(ce === void 0 ? le === se || U(le, se, H, W, G) : ce)) {
            ie = !1;
            break
        }
        ue || (ue = re == "constructor")
    }
    if (ie && !ue) {
        var de = K.constructor,
            ve = C.constructor;
        de != ve && "constructor" in K && "constructor" in C && !(typeof de == "function" && de instanceof de && typeof ve ==
            "function" && ve instanceof ve) && (ie = !1)
    }
    return G.delete(K), G.delete(C), ie
}
var DataView = getNative(root$2, "DataView");
const DataView$1 = DataView;
var Promise$1 = getNative(root$2, "Promise");
const Promise$2 = Promise$1;
var Set$1 = getNative(root$2, "Set");
const Set$2 = Set$1;
var WeakMap$1 = getNative(root$2, "WeakMap");
const WeakMap$2 = WeakMap$1;
var mapTag$3 = "[object Map]",
    objectTag$2 = "[object Object]",
    promiseTag = "[object Promise]",
    setTag$3 = "[object Set]",
    weakMapTag$1 = "[object WeakMap]",
    dataViewTag$2 = "[object DataView]",
    dataViewCtorString = toSource(DataView$1),
    mapCtorString = toSource(Map$2),
    promiseCtorString = toSource(Promise$2),
    setCtorString = toSource(Set$2),
    weakMapCtorString = toSource(WeakMap$2),
    getTag = baseGetTag;
(DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$2 || Map$2 && getTag(new Map$2) != mapTag$3 ||
    Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2) != setTag$3 || WeakMap$2 &&
    getTag(new WeakMap$2) != weakMapTag$1) && (getTag = function (K) {
    var C = baseGetTag(K),
        H = C == objectTag$2 ? K.constructor : void 0,
        W = H ? toSource(H) : "";
    if (W) switch (W) {
        case dataViewCtorString:
            return dataViewTag$2;
        case mapCtorString:
            return mapTag$3;
        case promiseCtorString:
            return promiseTag;
        case setCtorString:
            return setTag$3;
        case weakMapCtorString:
            return weakMapTag$1
    }
    return C
});
const getTag$1 = getTag;
var COMPARE_PARTIAL_FLAG$2 = 1,
    argsTag$1 = "[object Arguments]",
    arrayTag$1 = "[object Array]",
    objectTag$1 = "[object Object]",
    objectProto$3 = Object.prototype,
    hasOwnProperty$3 = objectProto$3.hasOwnProperty;

function baseIsEqualDeep(K, C, H, W, U, G) {
    var X = isArray$2(K),
        Z = isArray$2(C),
        Q = X ? arrayTag$1 : getTag$1(K),
        ee = Z ? arrayTag$1 : getTag$1(C);
    Q = Q == argsTag$1 ? objectTag$1 : Q, ee = ee == argsTag$1 ? objectTag$1 : ee;
    var ne = Q == objectTag$1,
        te = ee == objectTag$1,
        re = Q == ee;
    if (re && isBuffer$1(K)) {
        if (!isBuffer$1(C)) return !1;
        X = !0, ne = !1
    }
    if (re && !ne) return G || (G = new Stack), X || isTypedArray$1(K) ? equalArrays(K, C, H, W, U, G) : equalByTag(K,
        C, Q, H, W, U, G);
    if (!(H & COMPARE_PARTIAL_FLAG$2)) {
        var ae = ne && hasOwnProperty$3.call(K, "__wrapped__"),
            oe = te && hasOwnProperty$3.call(C, "__wrapped__");
        if (ae || oe) {
            var ie = ae ? K.value() : K,
                ue = oe ? C.value() : C;
            return G || (G = new Stack), U(ie, ue, H, W, G)
        }
    }
    return re ? (G || (G = new Stack), equalObjects(K, C, H, W, U, G)) : !1
}

function baseIsEqual(K, C, H, W, U) {
    return K === C ? !0 : K == null || C == null || !isObjectLike(K) && !isObjectLike(C) ? K !== K && C !== C :
        baseIsEqualDeep(K, C, H, W, baseIsEqual, U)
}

function isEqual$1(K, C) {
    return baseIsEqual(K, C)
}
var alignProps = {
    align: Object,
    target: [Object, Function],
    onAlign: Function,
    monitorBufferTime: Number,
    monitorWindowResize: Boolean,
    disabled: Boolean
};

function getElement(K) {
    return typeof K != "function" ? null : K()
}

function getPoint(K) {
    return _typeof$2(K) !== "object" || !K ? null : K
}
const Align = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "Align",
        props: alignProps,
        emits: ["align"],
        setup: function (C, H) {
            var W = H.expose,
                U = H.slots,
                G = ref({}),
                X = ref(),
                Z = useBuffer(function () {
                    var ie = C.disabled,
                        ue = C.target,
                        le = C.align,
                        se = C.onAlign;
                    if (!ie && ue && X.value) {
                        var ce = X.value,
                            de, ve = getElement(ue),
                            fe = getPoint(ue);
                        G.value.element = ve, G.value.point = fe, G.value.align = le;
                        var pe = document,
                            me = pe.activeElement;
                        return ve && isVisible(ve) ? de = alignElement(ce, ve, le) : fe && (de = alignPoint(
                            ce, fe, le)), restoreFocus(me, ce), se && de && se(ce, de), !0
                    }
                    return !1
                }, computed(function () {
                    return C.monitorBufferTime
                })),
                Q = _slicedToArray$2(Z, 2),
                ee = Q[0],
                ne = Q[1],
                te = ref({
                    cancel: function () {}
                }),
                re = ref({
                    cancel: function () {}
                }),
                ae = function () {
                    var ue = C.target,
                        le = getElement(ue),
                        se = getPoint(ue);
                    X.value !== re.value.element && (re.value.cancel(), re.value.element = X.value, re.value.cancel =
                        monitorResize(X.value, ee)), (G.value.element !== le || !isSamePoint(G.value.point,
                        se) || !isEqual$1(G.value.align, C.align)) && (ee(), te.value.element !== le && (te
                        .value.cancel(), te.value.element = le, te.value.cancel = monitorResize(le, ee)
                    ))
                };
            onMounted(function () {
                nextTick(function () {
                    ae()
                })
            }), onUpdated(function () {
                nextTick(function () {
                    ae()
                })
            }), watch(function () {
                return C.disabled
            }, function (ie) {
                ie ? ne() : ee()
            }, {
                immediate: !0,
                flush: "post"
            });
            var oe = ref(null);
            return watch(function () {
                    return C.monitorWindowResize
                }, function (ie) {
                    ie ? oe.value || (oe.value = addEventListenerWrap(window, "resize", ee)) : oe.value &&
                        (oe.value.remove(), oe.value = null)
                }, {
                    flush: "post"
                }), onUnmounted(function () {
                    te.value.cancel(), re.value.cancel(), oe.value && oe.value.remove(), ne()
                }), W({
                    forceAlign: function () {
                        return ee(!0)
                    }
                }),
                function () {
                    var ie = U == null ? void 0 : U.default();
                    return ie ? cloneElement(ie[0], {
                        ref: X
                    }, !0, !0) : null
                }
        }
    }),
    PopupInner = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "PopupInner",
        inheritAttrs: !1,
        props: innerProps,
        emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
        setup: function (C, H) {
            var W = H.expose,
                U = H.attrs,
                G = H.slots,
                X = ref(),
                Z = ref(),
                Q = ref(),
                ee = useStretchStyle(toRef(C, "stretch")),
                ne = _slicedToArray$2(ee, 2),
                te = ne[0],
                re = ne[1],
                ae = function () {
                    C.stretch && re(C.getRootDomNode())
                },
                oe = ref(!1),
                ie;
            watch(function () {
                return C.visible
            }, function (_e) {
                clearTimeout(ie), _e ? ie = setTimeout(function () {
                    oe.value = C.visible
                }) : oe.value = !1
            }, {
                immediate: !0
            });
            var ue = useVisibleStatus(oe, ae),
                le = _slicedToArray$2(ue, 2),
                se = le[0],
                ce = le[1],
                de = ref(),
                ve = function () {
                    return C.point ? C.point : C.getRootDomNode
                },
                fe = function () {
                    var be;
                    (be = X.value) === null || be === void 0 || be.forceAlign()
                },
                pe = function (be, ge) {
                    var xe = C.getClassNameFromAlign(ge),
                        Pe = Q.value;
                    if (Q.value !== xe && (Q.value = xe), se.value === "align") {
                        var $e;
                        Pe !== xe ? Promise.resolve().then(function () {
                            fe()
                        }) : ce(function () {
                            var ye;
                            (ye = de.value) === null || ye === void 0 || ye.call(de)
                        }), ($e = C.onAlign) === null || $e === void 0 || $e.call(C, be, ge)
                    }
                },
                me = computed(function () {
                    var _e = _typeof$2(C.animation) === "object" ? C.animation : getMotion(C);
                    return ["onAfterEnter", "onAfterLeave"].forEach(function (be) {
                        var ge = _e[be];
                        _e[be] = function (xe) {
                            ce(), se.value = "stable", ge == null || ge(xe)
                        }
                    }), _e
                }),
                he = function () {
                    return new Promise(function (be) {
                        de.value = be
                    })
                };
            watch([me, se], function () {
                !me.value && se.value === "motion" && ce()
            }, {
                immediate: !0
            }), W({
                forceAlign: fe,
                getElement: function () {
                    return Z.value.$el || Z.value
                }
            });
            var Se = computed(function () {
                var _e;
                return !((_e = C.align) !== null && _e !== void 0 && _e.points && (se.value === "align" ||
                    se.value === "stable"))
            });
            return function () {
                var _e, be = C.zIndex,
                    ge = C.align,
                    xe = C.prefixCls,
                    Pe = C.destroyPopupOnHide,
                    $e = C.onMouseenter,
                    ye = C.onMouseleave,
                    Ce = C.onTouchstart,
                    we = Ce === void 0 ? function () {} : Ce,
                    Oe = C.onMousedown,
                    Ne = se.value,
                    Me = [_objectSpread2$1(_objectSpread2$1({}, te.value), {}, {
                        zIndex: be,
                        opacity: Ne === "motion" || Ne === "stable" || !oe.value ? null : 0,
                        pointerEvents: !oe.value && Ne !== "stable" ? "none" : null
                    }), U.style],
                    Ve = flattenChildren((_e = G.default) === null || _e === void 0 ? void 0 : _e.call(G, {
                        visible: C.visible
                    }));
                Ve.length > 1 && (Ve = createVNode("div", {
                    class: "".concat(xe, "-content")
                }, [Ve]));
                var ke = classNames(xe, U.class, Q.value),
                    Ee = oe.value || !C.visible,
                    Ae = Ee ? getTransitionProps(me.value.name, me.value) : {};
                return createVNode(Transition, _objectSpread2$1(_objectSpread2$1({
                    ref: Z
                }, Ae), {}, {
                    onBeforeEnter: he
                }), {
                    default: function () {
                        return !Pe || C.visible ? withDirectives(createVNode(Align, {
                            target: ve(),
                            key: "popup",
                            ref: X,
                            monitorWindowResize: !0,
                            disabled: Se.value,
                            align: ge,
                            onAlign: pe
                        }, {
                            default: function () {
                                return createVNode("div", _objectSpread2$1(
                                    _objectSpread2$1({
                                        class: ke,
                                        onMouseenter: $e,
                                        onMouseleave: ye,
                                        onMousedown: withModifiers(
                                            Oe, ["capture"])
                                    }, _defineProperty$V({},
                                        supportsPassive$1 ?
                                        "onTouchstartPassive" :
                                        "onTouchstart",
                                        withModifiers(we, [
                                            "capture"]))), {}, {
                                        style: Me
                                    }), [Ve])
                            }
                        }), [[vShow, oe.value]]) : null
                    }
                })
            }
        }
    }),
    Popup = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "Popup",
        inheritAttrs: !1,
        props: popupProps,
        setup: function (C, H) {
            var W = H.attrs,
                U = H.slots,
                G = H.expose,
                X = ref(!1),
                Z = ref(!1),
                Q = ref();
            return watch([function () {
                    return C.visible
                }, function () {
                    return C.mobile
                }], function () {
                    X.value = C.visible, C.visible && C.mobile && (Z.value = !0)
                }, {
                    immediate: !0,
                    flush: "post"
                }), G({
                    forceAlign: function () {
                        var ne;
                        (ne = Q.value) === null || ne === void 0 || ne.forceAlign()
                    },
                    getElement: function () {
                        var ne;
                        return (ne = Q.value) === null || ne === void 0 ? void 0 : ne.getElement()
                    }
                }),
                function () {
                    var ee = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, C), W), {}, {
                            visible: X.value
                        }),
                        ne = Z.value ? createVNode(MobilePopupInner, _objectSpread2$1(_objectSpread2$1({}, ee), {}, {
                            mobile: C.mobile,
                            ref: Q
                        }), {
                            default: U.default
                        }) : createVNode(PopupInner, _objectSpread2$1(_objectSpread2$1({}, ee), {}, {
                            ref: Q
                        }), {
                            default: U.default
                        });
                    return createVNode("div", null, [createVNode(Mask$1, ee, null), ne])
                }
        }
    });

function isPointsEq(K, C, H) {
    return H ? K[0] === C[0] : K[0] === C[0] && K[1] === C[1]
}

function getAlignFromPlacement(K, C, H) {
    var W = K[C] || {};
    return _objectSpread2$1(_objectSpread2$1({}, W), H)
}

function getAlignPopupClassName(K, C, H, W) {
    for (var U = H.points, G = Object.keys(K), X = 0; X < G.length; X += 1) {
        var Z = G[X];
        if (isPointsEq(K[Z].points, U, W)) return "".concat(C, "-placement-").concat(Z)
    }
    return ""
}
const BaseMixin = {
    methods: {
        setState: function () {
            var C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
                H = arguments.length > 1 ? arguments[1] : void 0,
                W = typeof C == "function" ? C(this.$data, this.$props) : C;
            if (this.getDerivedStateFromProps) {
                var U = this.getDerivedStateFromProps(getOptionProps(this), _objectSpread2$1(_objectSpread2$1({},
                    this.$data), W));
                if (U === null) return;
                W = _objectSpread2$1(_objectSpread2$1({}, W), U || {})
            }
            _extends$1(this.$data, W), this._.isMounted && this.$forceUpdate(), nextTick(function () {
                H && H()
            })
        },
        __emit: function () {
            var C = [].slice.call(arguments, 0),
                H = C[0];
            H = "on".concat(H[0].toUpperCase()).concat(H.substring(1));
            var W = this.$props[H] || this.$attrs[H];
            if (C.length && W)
                if (Array.isArray(W))
                    for (var U = 0, G = W.length; U < G; U++) W[U].apply(W, _toConsumableArray(C.slice(1)));
                else W.apply(void 0, _toConsumableArray(C.slice(1)))
        }
    }
};
var TriggerContextKey = Symbol("TriggerContextKey"),
    useProviderTrigger = function () {
        var C = null;
        return provide(TriggerContextKey, {
                setPortal: function (W) {
                    C = W
                },
                popPortal: !0
            }),
            function () {
                return C
            }
    },
    useInjectTrigger = function (C) {
        return C ? inject(TriggerContextKey, {
            setPortal: function () {},
            popPortal: !1
        }) : {
            setPortal: function () {},
            popPortal: !1
        }
    },
    PortalContextKey = Symbol("PortalContextKey"),
    useProvidePortal = function (C) {
        var H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            inTriggerContext: !0
        };
        provide(PortalContextKey, {
            inTriggerContext: H.inTriggerContext,
            shouldRender: computed(function () {
                var W = C || {},
                    U = W.sPopupVisible,
                    G = W.popupRef,
                    X = W.forceRender,
                    Z = W.autoDestroy,
                    Q = !1;
                return (U || G || X) && (Q = !0), !U && Z && (Q = !1), Q
            })
        })
    },
    useInjectPortal = function () {
        useProvidePortal({}, {
            inTriggerContext: !1
        });
        var C = inject(PortalContextKey, {
            shouldRender: computed(function () {
                return !1
            }),
            inTriggerContext: !1
        });
        return {
            shouldRender: computed(function () {
                return C.shouldRender.value || C.inTriggerContext === !1
            })
        }
    };
const Portal$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Portal",
    inheritAttrs: !1,
    props: {
        getContainer: PropTypes$1.func.isRequired,
        didUpdate: Function
    },
    setup: function (C, H) {
        var W = H.slots,
            U = !0,
            G, X = useInjectPortal(),
            Z = X.shouldRender;
        onBeforeMount(function () {
            U = !1, Z.value && (G = C.getContainer())
        });
        var Q = watch(Z, function () {
            Z.value && !G && (G = C.getContainer()), G && Q()
        });
        return onUpdated(function () {
                nextTick(function () {
                    if (Z.value) {
                        var ee;
                        (ee = C.didUpdate) === null || ee === void 0 || ee.call(C, C)
                    }
                })
            }), onBeforeUnmount(function () {
                G && G.parentNode && G.parentNode.removeChild(G)
            }),
            function () {
                if (!Z.value) return null;
                if (U) {
                    var ee;
                    return (ee = W.default) === null || ee === void 0 ? void 0 : ee.call(W)
                }
                return G ? createVNode(Teleport, {
                    to: G
                }, W) : null
            }
    }
});

function noop$c() {}

function returnEmptyString() {
    return ""
}

function returnDocument(K) {
    return K ? K.ownerDocument : window.document
}
var ALL_HANDLERS = ["onClick", "onMousedown", "onTouchstart", "onMouseenter", "onMouseleave", "onFocus", "onBlur",
    "onContextmenu"];
const Trigger = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Trigger",
    mixins: [BaseMixin],
    inheritAttrs: !1,
    props: {
        action: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.arrayOf(PropTypes$1.string)]).def([]),
        showAction: PropTypes$1.any.def([]),
        hideAction: PropTypes$1.any.def([]),
        getPopupClassNameFromAlign: PropTypes$1.any.def(returnEmptyString),
        onPopupVisibleChange: Function,
        afterPopupVisibleChange: PropTypes$1.func.def(noop$c),
        popup: PropTypes$1.any,
        popupStyle: {
            type: Object,
            default: void 0
        },
        prefixCls: PropTypes$1.string.def("rc-trigger-popup"),
        popupClassName: PropTypes$1.string.def(""),
        popupPlacement: String,
        builtinPlacements: PropTypes$1.object,
        popupTransitionName: String,
        popupAnimation: PropTypes$1.any,
        mouseEnterDelay: PropTypes$1.number.def(0),
        mouseLeaveDelay: PropTypes$1.number.def(.1),
        zIndex: Number,
        focusDelay: PropTypes$1.number.def(0),
        blurDelay: PropTypes$1.number.def(.15),
        getPopupContainer: Function,
        getDocument: PropTypes$1.func.def(returnDocument),
        forceRender: {
            type: Boolean,
            default: void 0
        },
        destroyPopupOnHide: {
            type: Boolean,
            default: !1
        },
        mask: {
            type: Boolean,
            default: !1
        },
        maskClosable: {
            type: Boolean,
            default: !0
        },
        popupAlign: PropTypes$1.object.def(function () {
            return {}
        }),
        popupVisible: {
            type: Boolean,
            default: void 0
        },
        defaultPopupVisible: {
            type: Boolean,
            default: !1
        },
        maskTransitionName: String,
        maskAnimation: String,
        stretch: String,
        alignPoint: {
            type: Boolean,
            default: void 0
        },
        autoDestroy: {
            type: Boolean,
            default: !1
        },
        mobile: Object,
        getTriggerDOMNode: Function,
        tryPopPortal: Boolean
    },
    setup: function (C) {
        var H = computed(function () {
                var Q = C.popupPlacement,
                    ee = C.popupAlign,
                    ne = C.builtinPlacements;
                return Q && ne ? getAlignFromPlacement(ne, Q, ee) : ee
            }),
            W = useInjectTrigger(C.tryPopPortal),
            U = W.setPortal,
            G = W.popPortal,
            X = ref(null),
            Z = function (ee) {
                X.value = ee
            };
        return {
            popPortal: G,
            setPortal: U,
            vcTriggerContext: inject("vcTriggerContext", {}),
            popupRef: X,
            setPopupRef: Z,
            triggerRef: ref(null),
            align: H,
            focusTime: null,
            clickOutsideHandler: null,
            contextmenuOutsideHandler1: null,
            contextmenuOutsideHandler2: null,
            touchOutsideHandler: null,
            attachId: null,
            delayTimer: null,
            hasPopupMouseDown: !1,
            preClickTime: null,
            preTouchTime: null,
            mouseDownTimeout: null,
            childOriginEvents: {}
        }
    },
    data: function () {
        var C = this,
            H, W = this.$props,
            U;
        return this.popupVisible !== void 0 ? U = !!W.popupVisible : U = !!W.defaultPopupVisible,
            ALL_HANDLERS.forEach(function (G) {
                C["fire".concat(G)] = function (X) {
                    C.fireEvents(G, X)
                }
            }), (H = this.setPortal) === null || H === void 0 || H.call(this, createVNode(Portal$1, {
                key: "portal",
                getContainer: this.getContainer,
                didUpdate: this.handlePortalUpdate
            }, {
                default: this.getComponent
            })), {
                prevPopupVisible: U,
                sPopupVisible: U,
                point: null
            }
    },
    watch: {
        popupVisible: function (C) {
            C !== void 0 && (this.prevPopupVisible = this.sPopupVisible, this.sPopupVisible = C)
        }
    },
    created: function () {
        provide("vcTriggerContext", {
            onPopupMouseDown: this.onPopupMouseDown
        }), useProvidePortal(this)
    },
    deactivated: function () {
        this.setPopupVisible(!1)
    },
    mounted: function () {
        var C = this;
        this.$nextTick(function () {
            C.updatedCal()
        })
    },
    updated: function () {
        var C = this;
        this.$nextTick(function () {
            C.updatedCal()
        })
    },
    beforeUnmount: function () {
        this.clearDelayTimer(), this.clearOutsideHandler(), clearTimeout(this.mouseDownTimeout), wrapperRaf
            .cancel(this.attachId)
    },
    methods: {
        updatedCal: function () {
            var C = this.$props,
                H = this.$data;
            if (H.sPopupVisible) {
                var W;
                !this.clickOutsideHandler && (this.isClickToHide() || this.isContextmenuToShow()) && (W = C
                        .getDocument(this.getRootDomNode()), this.clickOutsideHandler =
                        addEventListenerWrap(W, "mousedown", this.onDocumentClick)), this.touchOutsideHandler ||
                    (W = W || C.getDocument(this.getRootDomNode()), this.touchOutsideHandler =
                        addEventListenerWrap(W, "touchstart", this.onDocumentClick, supportsPassive$1 ? {
                            passive: !1
                        } : !1)), !this.contextmenuOutsideHandler1 && this.isContextmenuToShow() && (W = W ||
                        C.getDocument(this.getRootDomNode()), this.contextmenuOutsideHandler1 =
                        addEventListenerWrap(W, "scroll", this.onContextmenuClose)), !this.contextmenuOutsideHandler2 &&
                    this.isContextmenuToShow() && (this.contextmenuOutsideHandler2 = addEventListenerWrap(
                        window, "blur", this.onContextmenuClose))
            } else this.clearOutsideHandler()
        },
        onMouseenter: function (C) {
            var H = this.$props.mouseEnterDelay;
            this.fireEvents("onMouseenter", C), this.delaySetPopupVisible(!0, H, H ? null : C)
        },
        onMouseMove: function (C) {
            this.fireEvents("onMousemove", C), this.setPoint(C)
        },
        onMouseleave: function (C) {
            this.fireEvents("onMouseleave", C), this.delaySetPopupVisible(!1, this.$props.mouseLeaveDelay)
        },
        onPopupMouseenter: function () {
            this.clearDelayTimer()
        },
        onPopupMouseleave: function (C) {
            var H;
            C && C.relatedTarget && !C.relatedTarget.setTimeout && contains((H = this.popupRef) === null ||
                H === void 0 ? void 0 : H.getElement(), C.relatedTarget) || this.delaySetPopupVisible(!
                1, this.$props.mouseLeaveDelay)
        },
        onFocus: function (C) {
            this.fireEvents("onFocus", C), this.clearDelayTimer(), this.isFocusToShow() && (this.focusTime =
                Date.now(), this.delaySetPopupVisible(!0, this.$props.focusDelay))
        },
        onMousedown: function (C) {
            this.fireEvents("onMousedown", C), this.preClickTime = Date.now()
        },
        onTouchstart: function (C) {
            this.fireEvents("onTouchstart", C), this.preTouchTime = Date.now()
        },
        onBlur: function (C) {
            contains(C.target, C.relatedTarget || document.activeElement) || (this.fireEvents("onBlur", C),
                this.clearDelayTimer(), this.isBlurToHide() && this.delaySetPopupVisible(!1, this.$props
                    .blurDelay))
        },
        onContextmenu: function (C) {
            C.preventDefault(), this.fireEvents("onContextmenu", C), this.setPopupVisible(!0, C)
        },
        onContextmenuClose: function () {
            this.isContextmenuToShow() && this.close()
        },
        onClick: function (C) {
            if (this.fireEvents("onClick", C), this.focusTime) {
                var H;
                if (this.preClickTime && this.preTouchTime ? H = Math.min(this.preClickTime, this.preTouchTime) :
                    this.preClickTime ? H = this.preClickTime : this.preTouchTime && (H = this.preTouchTime),
                    Math.abs(H - this.focusTime) < 20) return;
                this.focusTime = 0
            }
            this.preClickTime = 0, this.preTouchTime = 0, this.isClickToShow() && (this.isClickToHide() ||
                    this.isBlurToHide()) && C && C.preventDefault && C.preventDefault(), C && C.domEvent &&
                C.domEvent.preventDefault();
            var W = !this.$data.sPopupVisible;
            (this.isClickToHide() && !W || W && this.isClickToShow()) && this.setPopupVisible(!this.$data.sPopupVisible,
                C)
        },
        onPopupMouseDown: function () {
            var C = this,
                H = this.vcTriggerContext,
                W = H === void 0 ? {} : H;
            this.hasPopupMouseDown = !0, clearTimeout(this.mouseDownTimeout), this.mouseDownTimeout =
                setTimeout(function () {
                    C.hasPopupMouseDown = !1
                }, 0), W.onPopupMouseDown && W.onPopupMouseDown.apply(W, arguments)
        },
        onDocumentClick: function (C) {
            if (!(this.$props.mask && !this.$props.maskClosable)) {
                var H = C.target,
                    W = this.getRootDomNode(),
                    U = this.getPopupDomNode();
                (!contains(W, H) || this.isContextMenuOnly()) && !contains(U, H) && !this.hasPopupMouseDown &&
                    this.delaySetPopupVisible(!1, .1)
            }
        },
        getPopupDomNode: function () {
            var C;
            return ((C = this.popupRef) === null || C === void 0 ? void 0 : C.getElement()) || null
        },
        getRootDomNode: function () {
            var C = this.$props.getTriggerDOMNode;
            if (C) {
                var H = findDOMNode(this.triggerRef);
                return findDOMNode(C(H))
            }
            try {
                var W = findDOMNode(this.triggerRef);
                if (W) return W
            } catch {}
            return findDOMNode(this)
        },
        handleGetPopupClassFromAlign: function (C) {
            var H = [],
                W = this.$props,
                U = W.popupPlacement,
                G = W.builtinPlacements,
                X = W.prefixCls,
                Z = W.alignPoint,
                Q = W.getPopupClassNameFromAlign;
            return U && G && H.push(getAlignPopupClassName(G, X, C, Z)), Q && H.push(Q(C)), H.join(" ")
        },
        getPopupAlign: function () {
            var C = this.$props,
                H = C.popupPlacement,
                W = C.popupAlign,
                U = C.builtinPlacements;
            return H && U ? getAlignFromPlacement(U, H, W) : W
        },
        getComponent: function () {
            var C = this,
                H = {};
            this.isMouseEnterToShow() && (H.onMouseenter = this.onPopupMouseenter), this.isMouseLeaveToHide() &&
                (H.onMouseleave = this.onPopupMouseleave), H.onMousedown = this.onPopupMouseDown, H[
                    supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart"] = this.onPopupMouseDown;
            var W = this.handleGetPopupClassFromAlign,
                U = this.getRootDomNode,
                G = this.getContainer,
                X = this.$attrs,
                Z = this.$props,
                Q = Z.prefixCls,
                ee = Z.destroyPopupOnHide,
                ne = Z.popupClassName,
                te = Z.popupAnimation,
                re = Z.popupTransitionName,
                ae = Z.popupStyle,
                oe = Z.mask,
                ie = Z.maskAnimation,
                ue = Z.maskTransitionName,
                le = Z.zIndex,
                se = Z.stretch,
                ce = Z.alignPoint,
                de = Z.mobile,
                ve = Z.forceRender,
                fe = this.$data,
                pe = fe.sPopupVisible,
                me = fe.point,
                he = _objectSpread2$1(_objectSpread2$1({
                    prefixCls: Q,
                    destroyPopupOnHide: ee,
                    visible: pe,
                    point: ce ? me : null,
                    align: this.align,
                    animation: te,
                    getClassNameFromAlign: W,
                    stretch: se,
                    getRootDomNode: U,
                    mask: oe,
                    zIndex: le,
                    transitionName: re,
                    maskAnimation: ie,
                    maskTransitionName: ue,
                    getContainer: G,
                    class: ne,
                    style: ae,
                    onAlign: X.onPopupAlign || noop$c
                }, H), {}, {
                    ref: this.setPopupRef,
                    mobile: de,
                    forceRender: ve
                });
            return createVNode(Popup, he, {
                default: this.$slots.popup || function () {
                    return getComponent(C, "popup")
                }
            })
        },
        attachParent: function (C) {
            var H = this;
            wrapperRaf.cancel(this.attachId);
            var W = this.$props,
                U = W.getPopupContainer,
                G = W.getDocument,
                X = this.getRootDomNode(),
                Z;
            U ? (X || U.length === 0) && (Z = U(X)) : Z = G(this.getRootDomNode()).body, Z ? Z.appendChild(
                C) : this.attachId = wrapperRaf(function () {
                H.attachParent(C)
            })
        },
        getContainer: function () {
            var C = this.$props,
                H = C.getDocument,
                W = H(this.getRootDomNode()).createElement("div");
            return W.style.position = "absolute", W.style.top = "0", W.style.left = "0", W.style.width =
                "100%", this.attachParent(W), W
        },
        setPopupVisible: function (C, H) {
            var W = this.alignPoint,
                U = this.sPopupVisible,
                G = this.onPopupVisibleChange;
            this.clearDelayTimer(), U !== C && (hasProp(this, "popupVisible") || this.setState({
                sPopupVisible: C,
                prevPopupVisible: U
            }), G && G(C)), W && H && C && this.setPoint(H)
        },
        setPoint: function (C) {
            var H = this.$props.alignPoint;
            !H || !C || this.setState({
                point: {
                    pageX: C.pageX,
                    pageY: C.pageY
                }
            })
        },
        handlePortalUpdate: function () {
            this.prevPopupVisible !== this.sPopupVisible && this.afterPopupVisibleChange(this.sPopupVisible)
        },
        delaySetPopupVisible: function (C, H, W) {
            var U = this,
                G = H * 1e3;
            if (this.clearDelayTimer(), G) {
                var X = W ? {
                    pageX: W.pageX,
                    pageY: W.pageY
                } : null;
                this.delayTimer = requestAnimationTimeout(function () {
                    U.setPopupVisible(C, X), U.clearDelayTimer()
                }, G)
            } else this.setPopupVisible(C, W)
        },
        clearDelayTimer: function () {
            this.delayTimer && (cancelAnimationTimeout(this.delayTimer), this.delayTimer = null)
        },
        clearOutsideHandler: function () {
            this.clickOutsideHandler && (this.clickOutsideHandler.remove(), this.clickOutsideHandler = null),
                this.contextmenuOutsideHandler1 && (this.contextmenuOutsideHandler1.remove(), this.contextmenuOutsideHandler1 =
                    null), this.contextmenuOutsideHandler2 && (this.contextmenuOutsideHandler2.remove(),
                    this.contextmenuOutsideHandler2 = null), this.touchOutsideHandler && (this.touchOutsideHandler
                    .remove(), this.touchOutsideHandler = null)
        },
        createTwoChains: function (C) {
            var H = function () {},
                W = getEvents(this);
            return this.childOriginEvents[C] && W[C] ? this["fire".concat(C)] : (H = this.childOriginEvents[
                C] || W[C] || H, H)
        },
        isClickToShow: function () {
            var C = this.$props,
                H = C.action,
                W = C.showAction;
            return H.indexOf("click") !== -1 || W.indexOf("click") !== -1
        },
        isContextMenuOnly: function () {
            var C = this.$props.action;
            return C === "contextmenu" || C.length === 1 && C[0] === "contextmenu"
        },
        isContextmenuToShow: function () {
            var C = this.$props,
                H = C.action,
                W = C.showAction;
            return H.indexOf("contextmenu") !== -1 || W.indexOf("contextmenu") !== -1
        },
        isClickToHide: function () {
            var C = this.$props,
                H = C.action,
                W = C.hideAction;
            return H.indexOf("click") !== -1 || W.indexOf("click") !== -1
        },
        isMouseEnterToShow: function () {
            var C = this.$props,
                H = C.action,
                W = C.showAction;
            return H.indexOf("hover") !== -1 || W.indexOf("mouseenter") !== -1
        },
        isMouseLeaveToHide: function () {
            var C = this.$props,
                H = C.action,
                W = C.hideAction;
            return H.indexOf("hover") !== -1 || W.indexOf("mouseleave") !== -1
        },
        isFocusToShow: function () {
            var C = this.$props,
                H = C.action,
                W = C.showAction;
            return H.indexOf("focus") !== -1 || W.indexOf("focus") !== -1
        },
        isBlurToHide: function () {
            var C = this.$props,
                H = C.action,
                W = C.hideAction;
            return H.indexOf("focus") !== -1 || W.indexOf("blur") !== -1
        },
        forcePopupAlign: function () {
            if (this.$data.sPopupVisible) {
                var C;
                (C = this.popupRef) === null || C === void 0 || C.forceAlign()
            }
        },
        fireEvents: function (C, H) {
            this.childOriginEvents[C] && this.childOriginEvents[C](H);
            var W = this.$props[C] || this.$attrs[C];
            W && W(H)
        },
        close: function () {
            this.setPopupVisible(!1)
        }
    },
    render: function () {
        var C = this,
            H = this.$attrs,
            W = filterEmpty(getSlot(this)),
            U = this.$props.alignPoint,
            G = W[0];
        this.childOriginEvents = getEvents(G);
        var X = {
            key: "trigger"
        };
        this.isContextmenuToShow() ? X.onContextmenu = this.onContextmenu : X.onContextmenu = this.createTwoChains(
                "onContextmenu"), this.isClickToHide() || this.isClickToShow() ? (X.onClick = this.onClick,
                X.onMousedown = this.onMousedown, X[supportsPassive$1 ? "onTouchstartPassive" :
                    "onTouchstart"] = this.onTouchstart) : (X.onClick = this.createTwoChains("onClick"), X.onMousedown =
                this.createTwoChains("onMousedown"), X[supportsPassive$1 ? "onTouchstartPassive" :
                    "onTouchstart"] = this.createTwoChains("onTouchstart")), this.isMouseEnterToShow() ? (X
                .onMouseenter = this.onMouseenter, U && (X.onMousemove = this.onMouseMove)) : X.onMouseenter =
            this.createTwoChains("onMouseenter"), this.isMouseLeaveToHide() ? X.onMouseleave = this.onMouseleave :
            X.onMouseleave = this.createTwoChains("onMouseleave"), this.isFocusToShow() || this.isBlurToHide() ?
            (X.onFocus = this.onFocus, X.onBlur = this.onBlur) : (X.onFocus = this.createTwoChains(
                "onFocus"), X.onBlur = function (ne) {
                ne && (!ne.relatedTarget || !contains(ne.target, ne.relatedTarget)) && C.createTwoChains(
                    "onBlur")(ne)
            });
        var Z = classNames(G && G.props && G.props.class, H.class);
        Z && (X.class = Z);
        var Q = cloneElement(G, _objectSpread2$1(_objectSpread2$1({}, X), {}, {
            ref: "triggerRef"
        }), !0, !0);
        if (this.popPortal) return Q;
        var ee = createVNode(Portal$1, {
            key: "portal",
            getContainer: this.getContainer,
            didUpdate: this.handlePortalUpdate
        }, {
            default: this.getComponent
        });
        return createVNode(Fragment, null, [ee, Q])
    }
});
var _excluded$_ = ["empty"],
    getBuiltInPlacements = function (C) {
        var H = C === !0 ? 0 : 1;
        return {
            bottomLeft: {
                points: ["tl", "bl"],
                offset: [0, 4],
                overflow: {
                    adjustX: H,
                    adjustY: 1
                }
            },
            bottomRight: {
                points: ["tr", "br"],
                offset: [0, 4],
                overflow: {
                    adjustX: H,
                    adjustY: 1
                }
            },
            topLeft: {
                points: ["bl", "tl"],
                offset: [0, -4],
                overflow: {
                    adjustX: H,
                    adjustY: 1
                }
            },
            topRight: {
                points: ["br", "tr"],
                offset: [0, -4],
                overflow: {
                    adjustX: H,
                    adjustY: 1
                }
            }
        }
    },
    SelectTrigger = defineComponent({
        name: "SelectTrigger",
        inheritAttrs: !1,
        props: {
            dropdownAlign: Object,
            visible: {
                type: Boolean,
                default: void 0
            },
            disabled: {
                type: Boolean,
                default: void 0
            },
            dropdownClassName: String,
            dropdownStyle: PropTypes$1.object,
            placement: String,
            empty: {
                type: Boolean,
                default: void 0
            },
            prefixCls: String,
            popupClassName: String,
            animation: String,
            transitionName: String,
            getPopupContainer: Function,
            dropdownRender: Function,
            containerWidth: Number,
            dropdownMatchSelectWidth: PropTypes$1.oneOfType([Number, Boolean]).def(!0),
            popupElement: PropTypes$1.any,
            direction: String,
            getTriggerDOMNode: Function,
            onPopupVisibleChange: Function,
            onPopupMouseEnter: Function
        },
        setup: function (C, H) {
            var W = H.slots,
                U = H.attrs,
                G = H.expose,
                X = computed(function () {
                    var Q = C.dropdownMatchSelectWidth;
                    return getBuiltInPlacements(Q)
                }),
                Z = ref();
            return G({
                    getPopupElement: function () {
                        return Z.value
                    }
                }),
                function () {
                    var Q = _objectSpread2$1(_objectSpread2$1({}, C), U),
                        ee = Q.empty,
                        ne = ee === void 0 ? !1 : ee,
                        te = _objectWithoutProperties$2(Q, _excluded$_),
                        re = te.visible,
                        ae = te.dropdownAlign,
                        oe = te.prefixCls,
                        ie = te.popupElement,
                        ue = te.dropdownClassName,
                        le = te.dropdownStyle,
                        se = te.direction,
                        ce = se === void 0 ? "ltr" : se,
                        de = te.placement,
                        ve = te.dropdownMatchSelectWidth,
                        fe = te.containerWidth,
                        pe = te.dropdownRender,
                        me = te.animation,
                        he = te.transitionName,
                        Se = te.getPopupContainer,
                        _e = te.getTriggerDOMNode,
                        be = te.onPopupVisibleChange,
                        ge = te.onPopupMouseEnter,
                        xe = "".concat(oe, "-dropdown"),
                        Pe = ie;
                    pe && (Pe = pe({
                        menuNode: ie,
                        props: C
                    }));
                    var $e = me ? "".concat(xe, "-").concat(me) : he,
                        ye = _objectSpread2$1({
                            minWidth: "".concat(fe, "px")
                        }, le);
                    return typeof ve == "number" ? ye.width = "".concat(ve, "px") : ve && (ye.width = "".concat(
                        fe, "px")), createVNode(Trigger, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                        showAction: be ? ["click"] : [],
                        hideAction: be ? ["click"] : [],
                        popupPlacement: de || (ce === "rtl" ? "bottomRight" : "bottomLeft"),
                        builtinPlacements: X.value,
                        prefixCls: xe,
                        popupTransitionName: $e,
                        popupAlign: ae,
                        popupVisible: re,
                        getPopupContainer: Se,
                        popupClassName: classNames(ue, _defineProperty$V({}, "".concat(xe, "-empty"),
                            ne)),
                        popupStyle: ye,
                        getTriggerDOMNode: _e,
                        onPopupVisibleChange: be
                    }), {
                        default: W.default,
                        popup: function () {
                            return createVNode("div", {
                                ref: Z,
                                onMouseenter: ge
                            }, [Pe])
                        }
                    })
                }
        }
    });
const SelectTrigger$1 = SelectTrigger;
var KeyCode = {
    MAC_ENTER: 3,
    BACKSPACE: 8,
    TAB: 9,
    NUM_CENTER: 12,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    PAUSE: 19,
    CAPS_LOCK: 20,
    ESC: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    PRINT_SCREEN: 44,
    INSERT: 45,
    DELETE: 46,
    ZERO: 48,
    ONE: 49,
    TWO: 50,
    THREE: 51,
    FOUR: 52,
    FIVE: 53,
    SIX: 54,
    SEVEN: 55,
    EIGHT: 56,
    NINE: 57,
    QUESTION_MARK: 63,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    META: 91,
    WIN_KEY_RIGHT: 92,
    CONTEXT_MENU: 93,
    NUM_ZERO: 96,
    NUM_ONE: 97,
    NUM_TWO: 98,
    NUM_THREE: 99,
    NUM_FOUR: 100,
    NUM_FIVE: 101,
    NUM_SIX: 102,
    NUM_SEVEN: 103,
    NUM_EIGHT: 104,
    NUM_NINE: 105,
    NUM_MULTIPLY: 106,
    NUM_PLUS: 107,
    NUM_MINUS: 109,
    NUM_PERIOD: 110,
    NUM_DIVISION: 111,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    NUMLOCK: 144,
    SEMICOLON: 186,
    DASH: 189,
    EQUALS: 187,
    COMMA: 188,
    PERIOD: 190,
    SLASH: 191,
    APOSTROPHE: 192,
    SINGLE_QUOTE: 222,
    OPEN_SQUARE_BRACKET: 219,
    BACKSLASH: 220,
    CLOSE_SQUARE_BRACKET: 221,
    WIN_KEY: 224,
    MAC_FF_META: 224,
    WIN_IME: 229,
    isTextModifyingKeyEvent: function (C) {
        var H = C.keyCode;
        if (C.altKey && !C.ctrlKey || C.metaKey || H >= KeyCode.F1 && H <= KeyCode.F12) return !1;
        switch (H) {
            case KeyCode.ALT:
            case KeyCode.CAPS_LOCK:
            case KeyCode.CONTEXT_MENU:
            case KeyCode.CTRL:
            case KeyCode.DOWN:
            case KeyCode.END:
            case KeyCode.ESC:
            case KeyCode.HOME:
            case KeyCode.INSERT:
            case KeyCode.LEFT:
            case KeyCode.MAC_FF_META:
            case KeyCode.META:
            case KeyCode.NUMLOCK:
            case KeyCode.NUM_CENTER:
            case KeyCode.PAGE_DOWN:
            case KeyCode.PAGE_UP:
            case KeyCode.PAUSE:
            case KeyCode.PRINT_SCREEN:
            case KeyCode.RIGHT:
            case KeyCode.SHIFT:
            case KeyCode.UP:
            case KeyCode.WIN_KEY:
            case KeyCode.WIN_KEY_RIGHT:
                return !1;
            default:
                return !0
        }
    },
    isCharacterKey: function (C) {
        if (C >= KeyCode.ZERO && C <= KeyCode.NINE || C >= KeyCode.NUM_ZERO && C <= KeyCode.NUM_MULTIPLY || C >=
            KeyCode.A && C <= KeyCode.Z || window.navigator.userAgent.indexOf("WebKit") !== -1 && C === 0)
            return !0;
        switch (C) {
            case KeyCode.SPACE:
            case KeyCode.QUESTION_MARK:
            case KeyCode.NUM_PLUS:
            case KeyCode.NUM_MINUS:
            case KeyCode.NUM_PERIOD:
            case KeyCode.NUM_DIVISION:
            case KeyCode.SEMICOLON:
            case KeyCode.DASH:
            case KeyCode.EQUALS:
            case KeyCode.COMMA:
            case KeyCode.PERIOD:
            case KeyCode.SLASH:
            case KeyCode.APOSTROPHE:
            case KeyCode.SINGLE_QUOTE:
            case KeyCode.OPEN_SQUARE_BRACKET:
            case KeyCode.BACKSLASH:
            case KeyCode.CLOSE_SQUARE_BRACKET:
                return !0;
            default:
                return !1
        }
    }
};
const KeyCode$1 = KeyCode;
var TransBtn = function (C, H) {
    var W, U = H.slots,
        G = C.class,
        X = C.customizeIcon,
        Z = C.customizeIconProps,
        Q = C.onMousedown,
        ee = C.onClick,
        ne;
    return typeof X == "function" ? ne = X(Z) : ne = X, createVNode("span", {
        class: G,
        onMousedown: function (re) {
            re.preventDefault(), Q && Q(re)
        },
        style: {
            userSelect: "none",
            WebkitUserSelect: "none"
        },
        unselectable: "on",
        onClick: ee,
        "aria-hidden": !0
    }, [ne !== void 0 ? ne : createVNode("span", {
        class: G.split(/\s+/).map(function (te) {
            return "".concat(te, "-icon")
        })
    }, [(W = U.default) === null || W === void 0 ? void 0 : W.call(U)])])
};
TransBtn.inheritAttrs = !1;
TransBtn.displayName = "TransBtn";
TransBtn.props = {
    class: String,
    customizeIcon: PropTypes$1.any,
    customizeIconProps: PropTypes$1.any,
    onMousedown: Function,
    onClick: Function
};
const TransBtn$1 = TransBtn;

function onCompositionStart(K) {
    K.target.composing = !0
}

function onCompositionEnd(K) {
    K.target.composing && (K.target.composing = !1, trigger(K.target, "input"))
}

function trigger(K, C) {
    var H = document.createEvent("HTMLEvents");
    H.initEvent(C, !0, !0), K.dispatchEvent(H)
}

function addEventListener$2(K, C, H, W) {
    K.addEventListener(C, H, W)
}
var antInput = {
    created: function (C, H) {
        (!H.modifiers || !H.modifiers.lazy) && (addEventListener$2(C, "compositionstart", onCompositionStart),
            addEventListener$2(C, "compositionend", onCompositionEnd), addEventListener$2(C, "change",
                onCompositionEnd))
    }
};
const antInputDirective = antInput;
var inputProps$2 = {
        inputRef: PropTypes$1.any,
        prefixCls: String,
        id: String,
        inputElement: PropTypes$1.VueNode,
        disabled: {
            type: Boolean,
            default: void 0
        },
        autofocus: {
            type: Boolean,
            default: void 0
        },
        autocomplete: String,
        editable: {
            type: Boolean,
            default: void 0
        },
        activeDescendantId: String,
        value: String,
        open: {
            type: Boolean,
            default: void 0
        },
        tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
        attrs: PropTypes$1.object,
        onKeydown: {
            type: Function
        },
        onMousedown: {
            type: Function
        },
        onChange: {
            type: Function
        },
        onPaste: {
            type: Function
        },
        onCompositionstart: {
            type: Function
        },
        onCompositionend: {
            type: Function
        },
        onFocus: {
            type: Function
        },
        onBlur: {
            type: Function
        }
    },
    Input$1 = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "Input",
        inheritAttrs: !1,
        props: inputProps$2,
        setup: function (C) {
            var H = null,
                W = inject("VCSelectContainerEvent");
            return function () {
                var U, G, X = C.prefixCls,
                    Z = C.id,
                    Q = C.inputElement,
                    ee = C.disabled,
                    ne = C.tabindex,
                    te = C.autofocus,
                    re = C.autocomplete,
                    ae = C.editable,
                    oe = C.activeDescendantId,
                    ie = C.value,
                    ue = C.onKeydown,
                    le = C.onMousedown,
                    se = C.onChange,
                    ce = C.onPaste,
                    de = C.onCompositionstart,
                    ve = C.onCompositionend,
                    fe = C.onFocus,
                    pe = C.onBlur,
                    me = C.open,
                    he = C.inputRef,
                    Se = C.attrs,
                    _e = Q || withDirectives(createVNode("input", null, null), [[antInputDirective]]),
                    be = _e.props || {},
                    ge = be.onKeydown,
                    xe = be.onInput,
                    Pe = be.onFocus,
                    $e = be.onBlur,
                    ye = be.onMousedown,
                    Ce = be.onCompositionstart,
                    we = be.onCompositionend,
                    Oe = be.style;
                return _e = cloneElement(_e, _extends$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                    type: "search"
                }, be), {}, {
                    id: Z,
                    ref: he,
                    disabled: ee,
                    tabindex: ne,
                    autocomplete: re || "off",
                    autofocus: te,
                    class: classNames("".concat(X, "-selection-search-input"), (U = _e) ===
                        null || U === void 0 || (G = U.props) === null || G ===
                        void 0 ? void 0 : G.class),
                    role: "combobox",
                    "aria-expanded": me,
                    "aria-haspopup": "listbox",
                    "aria-owns": "".concat(Z, "_list"),
                    "aria-autocomplete": "list",
                    "aria-controls": "".concat(Z, "_list"),
                    "aria-activedescendant": oe
                }, Se), {}, {
                    value: ae ? ie : "",
                    readonly: !ae,
                    unselectable: ae ? null : "on",
                    style: _objectSpread2$1(_objectSpread2$1({}, Oe), {}, {
                        opacity: ae ? null : 0
                    }),
                    onKeydown: function (Me) {
                        ue(Me), ge && ge(Me)
                    },
                    onMousedown: function (Me) {
                        le(Me), ye && ye(Me)
                    },
                    onInput: function (Me) {
                        se(Me), xe && xe(Me)
                    },
                    onCompositionstart: function (Me) {
                        de(Me), Ce && Ce(Me)
                    },
                    onCompositionend: function (Me) {
                        ve(Me), we && we(Me)
                    },
                    onPaste: ce,
                    onFocus: function () {
                        clearTimeout(H), Pe && Pe(arguments.length <= 0 ? void 0 :
                            arguments[0]), fe && fe(arguments.length <= 0 ? void 0 :
                            arguments[0]), W == null || W.focus(arguments.length <=
                            0 ? void 0 : arguments[0])
                    },
                    onBlur: function () {
                        for (var Me = arguments.length, Ve = new Array(Me), ke = 0; ke <
                            Me; ke++) Ve[ke] = arguments[ke];
                        H = setTimeout(function () {
                            $e && $e(Ve[0]), pe && pe(Ve[0]), W == null || W.blur(
                                Ve[0])
                        }, 100)
                    }
                }), _e.type === "textarea" ? {} : {
                    type: "search"
                }), !0, !0), _e
            }
        }
    });
const Input$2 = Input$1;
var attributes =
    `accept acceptcharset accesskey action allowfullscreen allowtransparency
alt async autocomplete autofocus autoplay capture cellpadding cellspacing challenge
charset checked classid classname colspan cols content contenteditable contextmenu
controls coords crossorigin data datetime default defer dir disabled download draggable
enctype form formaction formenctype formmethod formnovalidate formtarget frameborder
headers height hidden high href hreflang htmlfor for httpequiv icon id inputmode integrity
is keyparams keytype kind label lang list loop low manifest marginheight marginwidth max maxlength media
mediagroup method min minlength multiple muted name novalidate nonce open
optimum pattern placeholder poster preload radiogroup readonly rel required
reversed role rowspan rows sandbox scope scoped scrolling seamless selected
shape size sizes span spellcheck src srcdoc srclang srcset start step style
summary tabindex target title type usemap value width wmode wrap`,
    eventsName =
    `onCopy onCut onPaste onCompositionend onCompositionstart onCompositionupdate onKeydown
    onKeypress onKeyup onFocus onBlur onChange onInput onSubmit onClick onContextmenu onDoubleclick onDblclick
    onDrag onDragend onDragenter onDragexit onDragleave onDragover onDragstart onDrop onMousedown
    onMouseenter onMouseleave onMousemove onMouseout onMouseover onMouseup onSelect onTouchcancel
    onTouchend onTouchmove onTouchstart onTouchstartPassive onTouchmovePassive onScroll onWheel onAbort onCanplay onCanplaythrough
    onDurationchange onEmptied onEncrypted onEnded onError onLoadeddata onLoadedmetadata
    onLoadstart onPause onPlay onPlaying onProgress onRatechange onSeeked onSeeking onStalled onSuspend onTimeupdate onVolumechange onWaiting onLoad onError`,
    propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/),
    ariaPrefix = "aria-",
    dataPrefix = "data-";

function match$1(K, C) {
    return K.indexOf(C) === 0
}

function pickAttrs(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
        H;
    C === !1 ? H = {
        aria: !0,
        data: !0,
        attr: !0
    } : C === !0 ? H = {
        aria: !0
    } : H = _objectSpread2$1({}, C);
    var W = {};
    return Object.keys(K).forEach(function (U) {
        (H.aria && (U === "role" || match$1(U, ariaPrefix)) || H.data && match$1(U, dataPrefix) || H.attr && (
            propList.includes(U) || propList.includes(U.toLowerCase()))) && (W[U] = K[U])
    }), W
}
var OverflowContextProviderKey = Symbol("OverflowContextProviderKey"),
    OverflowContextProvider = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "OverflowContextProvider",
        inheritAttrs: !1,
        props: {
            value: {
                type: Object
            }
        },
        setup: function (C, H) {
            var W = H.slots;
            return provide(OverflowContextProviderKey, computed(function () {
                    return C.value
                })),
                function () {
                    var U;
                    return (U = W.default) === null || U === void 0 ? void 0 : U.call(W)
                }
        }
    }),
    useInjectOverflowContext = function () {
        return inject(OverflowContextProviderKey, computed(function () {
            return null
        }))
    },
    _excluded$Z = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "registerSize", "itemKey", "display",
        "order", "component"],
    UNDEFINED = void 0;
const Item$3 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Item",
    props: {
        prefixCls: String,
        item: PropTypes$1.any,
        renderItem: Function,
        responsive: Boolean,
        itemKey: {
            type: [String, Number]
        },
        registerSize: Function,
        display: Boolean,
        order: Number,
        component: PropTypes$1.any,
        invalidate: Boolean
    },
    setup: function (C, H) {
        var W = H.slots,
            U = H.expose,
            G = computed(function () {
                return C.responsive && !C.display
            }),
            X = ref();
        U({
            itemNodeRef: X
        });

        function Z(Q) {
            C.registerSize(C.itemKey, Q)
        }
        return onUnmounted(function () {
                Z(null)
            }),
            function () {
                var Q, ee = C.prefixCls,
                    ne = C.invalidate,
                    te = C.item,
                    re = C.renderItem,
                    ae = C.responsive;
                C.registerSize, C.itemKey, C.display;
                var oe = C.order,
                    ie = C.component,
                    ue = ie === void 0 ? "div" : ie,
                    le = _objectWithoutProperties$2(C, _excluded$Z),
                    se = (Q = W.default) === null || Q === void 0 ? void 0 : Q.call(W),
                    ce = re && te !== UNDEFINED ? re(te) : se,
                    de;
                ne || (de = {
                    opacity: G.value ? 0 : 1,
                    height: G.value ? 0 : UNDEFINED,
                    overflowY: G.value ? "hidden" : UNDEFINED,
                    order: ae ? oe : UNDEFINED,
                    pointerEvents: G.value ? "none" : UNDEFINED,
                    position: G.value ? "absolute" : UNDEFINED
                });
                var ve = {};
                return G.value && (ve["aria-hidden"] = !0), createVNode(ResizeObserver$1, {
                    disabled: !ae,
                    onResize: function (pe) {
                        var me = pe.offsetWidth;
                        Z(me)
                    }
                }, {
                    default: function () {
                        return createVNode(ue, _objectSpread2$1(_objectSpread2$1(
                            _objectSpread2$1({
                                class: classNames(!ne && ee),
                                style: de
                            }, ve), le), {}, {
                            ref: X
                        }), {
                            default: function () {
                                return [ce]
                            }
                        })
                    }
                })
            }
    }
});
var _excluded$Y = ["component"],
    _excluded2$6 = ["className"],
    _excluded3 = ["class"];
const RawItem = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "RawItem",
    inheritAttrs: !1,
    props: {
        component: PropTypes$1.any,
        title: PropTypes$1.any,
        id: String,
        onMouseenter: {
            type: Function
        },
        onMouseleave: {
            type: Function
        },
        onClick: {
            type: Function
        },
        onKeydown: {
            type: Function
        },
        onFocus: {
            type: Function
        }
    },
    setup: function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = useInjectOverflowContext();
        return function () {
            if (!G.value) {
                var X, Z = C.component,
                    Q = Z === void 0 ? "div" : Z,
                    ee = _objectWithoutProperties$2(C, _excluded$Y);
                return createVNode(Q, _objectSpread2$1(_objectSpread2$1({}, ee), U), {
                    default: function () {
                        return [(X = W.default) === null || X === void 0 ? void 0 : X.call(
                            W)]
                    }
                })
            }
            var ne = G.value,
                te = ne.className,
                re = _objectWithoutProperties$2(ne, _excluded2$6),
                ae = U.class,
                oe = _objectWithoutProperties$2(U, _excluded3);
            return createVNode(OverflowContextProvider, {
                value: null
            }, {
                default: function () {
                    return [createVNode(Item$3, _objectSpread2$1(_objectSpread2$1(
                        _objectSpread2$1({
                            class: classNames(te, ae)
                        }, re), oe), C), W)]
                }
            })
        }
    }
});
var _excluded$X = ["class", "style"],
    RESPONSIVE = "responsive",
    INVALIDATE = "invalidate";

function defaultRenderRest(K) {
    return "+ ".concat(K.length, " ...")
}
var overflowProps = function () {
        return {
            id: String,
            prefixCls: String,
            data: Array,
            itemKey: [String, Number, Function],
            itemWidth: {
                type: Number,
                default: 10
            },
            renderItem: Function,
            renderRawItem: Function,
            maxCount: [Number, String],
            renderRest: Function,
            renderRawRest: Function,
            suffix: PropTypes$1.any,
            component: String,
            itemComponent: PropTypes$1.any,
            onVisibleChange: Function,
            ssr: String,
            onMousedown: Function
        }
    },
    Overflow = defineComponent({
        name: "Overflow",
        inheritAttrs: !1,
        props: overflowProps(),
        emits: ["visibleChange"],
        setup: function (C, H) {
            var W = H.attrs,
                U = H.emit,
                G = H.slots,
                X = computed(function () {
                    return C.ssr === "full"
                }),
                Z = ref(null),
                Q = computed(function () {
                    return Z.value || 0
                }),
                ee = ref(new Map),
                ne = ref(0),
                te = ref(0),
                re = ref(0),
                ae = ref(null),
                oe = ref(null),
                ie = computed(function () {
                    return oe.value === null && X.value ? Number.MAX_SAFE_INTEGER : oe.value || 0
                }),
                ue = ref(!1),
                le = computed(function () {
                    return "".concat(C.prefixCls, "-item")
                }),
                se = computed(function () {
                    return Math.max(ne.value, te.value)
                }),
                ce = computed(function () {
                    return !!(C.data.length && C.maxCount === RESPONSIVE)
                }),
                de = computed(function () {
                    return C.maxCount === INVALIDATE
                }),
                ve = computed(function () {
                    return ce.value || typeof C.maxCount == "number" && C.data.length > C.maxCount
                }),
                fe = computed(function () {
                    var $e = C.data;
                    return ce.value ? Z.value === null && X.value ? $e = C.data : $e = C.data.slice(0, Math
                            .min(C.data.length, Q.value / C.itemWidth)) : typeof C.maxCount == "number" &&
                        ($e = C.data.slice(0, C.maxCount)), $e
                }),
                pe = computed(function () {
                    return ce.value ? C.data.slice(ie.value + 1) : C.data.slice(fe.value.length)
                }),
                me = function (ye, Ce) {
                    var we;
                    return typeof C.itemKey == "function" ? C.itemKey(ye) : (we = C.itemKey && (ye == null ?
                        void 0 : ye[C.itemKey])) !== null && we !== void 0 ? we : Ce
                },
                he = computed(function () {
                    return C.renderItem || function ($e) {
                        return $e
                    }
                }),
                Se = function (ye, Ce) {
                    oe.value = ye, Ce || (ue.value = ye < C.data.length - 1, U("visibleChange", ye))
                },
                _e = function (ye, Ce) {
                    Z.value = Ce.clientWidth
                },
                be = function (ye, Ce) {
                    var we = new Map(ee.value);
                    Ce === null ? we.delete(ye) : we.set(ye, Ce), ee.value = we
                },
                ge = function (ye, Ce) {
                    ne.value = te.value, te.value = Ce
                },
                xe = function (ye, Ce) {
                    re.value = Ce
                },
                Pe = function (ye) {
                    return ee.value.get(me(fe.value[ye], ye))
                };
            return watch([Q, ee, te, re, function () {
                    return C.itemKey
                }, fe], function () {
                    if (Q.value && se.value && fe.value) {
                        var $e = re.value,
                            ye = fe.value.length,
                            Ce = ye - 1;
                        if (!ye) {
                            Se(0), ae.value = null;
                            return
                        }
                        for (var we = 0; we < ye; we += 1) {
                            var Oe = Pe(we);
                            if (Oe === void 0) {
                                Se(we - 1, !0);
                                break
                            }
                            if ($e += Oe, Ce === 0 && $e <= Q.value || we === Ce - 1 && $e + Pe(Ce) <= Q.value) {
                                Se(Ce), ae.value = null;
                                break
                            } else if ($e + se.value > Q.value) {
                                Se(we - 1), ae.value = $e - Oe - re.value + te.value;
                                break
                            }
                        }
                        C.suffix && Pe(0) + re.value > Q.value && (ae.value = null)
                    }
                }),
                function () {
                    var $e = ue.value && !!pe.value.length,
                        ye = C.itemComponent,
                        Ce = C.renderRawItem,
                        we = C.renderRawRest,
                        Oe = C.renderRest,
                        Ne = C.prefixCls,
                        Me = Ne === void 0 ? "rc-overflow" : Ne,
                        Ve = C.suffix,
                        ke = C.component,
                        Ee = ke === void 0 ? "div" : ke,
                        Ae = C.id,
                        Re = C.onMousedown,
                        He = W.class,
                        je = W.style,
                        Fe = _objectWithoutProperties$2(W, _excluded$X),
                        Le = {};
                    ae.value !== null && ce.value && (Le = {
                        position: "absolute",
                        left: "".concat(ae.value, "px"),
                        top: 0
                    });
                    var Ie = {
                            prefixCls: le.value,
                            responsive: ce.value,
                            component: ye,
                            invalidate: de.value
                        },
                        Te = Ce ? function (et, Ye) {
                            var ze = me(et, Ye);
                            return createVNode(OverflowContextProvider, {
                                key: ze,
                                value: _objectSpread2$1(_objectSpread2$1({}, Ie), {}, {
                                    order: Ye,
                                    item: et,
                                    itemKey: ze,
                                    registerSize: be,
                                    display: Ye <= ie.value
                                })
                            }, {
                                default: function () {
                                    return [Ce(et, Ye)]
                                }
                            })
                        } : function (et, Ye) {
                            var ze = me(et, Ye);
                            return createVNode(Item$3, _objectSpread2$1(_objectSpread2$1({}, Ie), {}, {
                                order: Ye,
                                key: ze,
                                item: et,
                                renderItem: he.value,
                                itemKey: ze,
                                registerSize: be,
                                display: Ye <= ie.value
                            }), null)
                        },
                        De = function () {
                            return null
                        },
                        Ke = {
                            order: $e ? ie.value : Number.MAX_SAFE_INTEGER,
                            className: "".concat(le.value, " ").concat(le.value, "-rest"),
                            registerSize: ge,
                            display: $e
                        };
                    if (we) we && (De = function () {
                        return createVNode(OverflowContextProvider, {
                            value: _objectSpread2$1(_objectSpread2$1({}, Ie), Ke)
                        }, {
                            default: function () {
                                return [we(pe.value)]
                            }
                        })
                    });
                    else {
                        var We = Oe || defaultRenderRest;
                        De = function () {
                            return createVNode(Item$3, _objectSpread2$1(_objectSpread2$1({}, Ie), Ke), {
                                default: function () {
                                    return typeof We == "function" ? We(pe.value) : We
                                }
                            })
                        }
                    }
                    var Ue = function () {
                        var Ye;
                        return createVNode(Ee, _objectSpread2$1({
                            id: Ae,
                            class: classNames(!de.value && Me, He),
                            style: je,
                            onMousedown: Re
                        }, Fe), {
                            default: function () {
                                return [fe.value.map(Te), ve.value ? De() : null, Ve &&
                                    createVNode(Item$3, _objectSpread2$1(_objectSpread2$1({},
                                        Ie), {}, {
                                        order: ie.value,
                                        class: "".concat(le.value, "-suffix"),
                                        registerSize: xe,
                                        display: !0,
                                        style: Le
                                    }), {
                                        default: function () {
                                            return Ve
                                        }
                                    }), (Ye = G.default) === null || Ye === void 0 ? void 0 :
                                    Ye.call(G)]
                            }
                        })
                    };
                    return createVNode(ResizeObserver$1, {
                        disabled: !ce.value,
                        onResize: _e
                    }, {
                        default: Ue
                    })
                }
        }
    });
Overflow.Item = RawItem;
Overflow.RESPONSIVE = RESPONSIVE;
Overflow.INVALIDATE = INVALIDATE;
const Overflow$1 = Overflow;
var TreeSelectLegacyContextPropsKey = Symbol("TreeSelectLegacyContextPropsKey");

function useProvideLegacySelectContext(K) {
    return provide(TreeSelectLegacyContextPropsKey, K)
}

function useInjectLegacySelectContext() {
    return inject(TreeSelectLegacyContextPropsKey, {})
}
var props$2 = {
        id: String,
        prefixCls: String,
        values: PropTypes$1.array,
        open: {
            type: Boolean,
            default: void 0
        },
        searchValue: String,
        inputRef: PropTypes$1.any,
        placeholder: PropTypes$1.any,
        disabled: {
            type: Boolean,
            default: void 0
        },
        mode: String,
        showSearch: {
            type: Boolean,
            default: void 0
        },
        autofocus: {
            type: Boolean,
            default: void 0
        },
        autocomplete: String,
        activeDescendantId: String,
        tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
        removeIcon: PropTypes$1.any,
        choiceTransitionName: String,
        maxTagCount: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
        maxTagTextLength: Number,
        maxTagPlaceholder: PropTypes$1.any.def(function () {
            return function (K) {
                return "+ ".concat(K.length, " ...")
            }
        }),
        tagRender: Function,
        onToggleOpen: {
            type: Function
        },
        onRemove: Function,
        onInputChange: Function,
        onInputPaste: Function,
        onInputKeyDown: Function,
        onInputMouseDown: Function,
        onInputCompositionStart: Function,
        onInputCompositionEnd: Function
    },
    onPreventMouseDown = function (C) {
        C.preventDefault(), C.stopPropagation()
    },
    SelectSelector = defineComponent({
        name: "MultipleSelectSelector",
        inheritAttrs: !1,
        props: props$2,
        setup: function (C) {
            var H = ref(),
                W = ref(0),
                U = ref(!1),
                G = useInjectLegacySelectContext(),
                X = computed(function () {
                    return "".concat(C.prefixCls, "-selection")
                }),
                Z = computed(function () {
                    return C.open || C.mode === "tags" ? C.searchValue : ""
                }),
                Q = computed(function () {
                    return C.mode === "tags" || C.showSearch && (C.open || U.value)
                });
            onMounted(function () {
                watch(Z, function () {
                    W.value = H.value.scrollWidth
                }, {
                    flush: "post",
                    immediate: !0
                })
            });

            function ee(ae, oe, ie, ue, le) {
                return createVNode("span", {
                    class: classNames("".concat(X.value, "-item"), _defineProperty$V({}, "".concat(X.value,
                        "-item-disabled"), ie)),
                    title: typeof ae == "string" || typeof ae == "number" ? ae.toString() : void 0
                }, [createVNode("span", {
                    class: "".concat(X.value, "-item-content")
                }, [oe]), ue && createVNode(TransBtn$1, {
                    class: "".concat(X.value, "-item-remove"),
                    onMousedown: onPreventMouseDown,
                    onClick: le,
                    customizeIcon: C.removeIcon
                }, {
                    default: function () {
                        return [createTextVNode("")]
                    }
                })])
            }

            function ne(ae, oe, ie, ue, le, se) {
                var ce = function (pe) {
                        onPreventMouseDown(pe), C.onToggleOpen(!open)
                    },
                    de = se;
                if (G.keyEntities) {
                    var ve;
                    de = ((ve = G.keyEntities[ae]) === null || ve === void 0 ? void 0 : ve.node) || {}
                }
                return createVNode("span", {
                    key: ae,
                    onMousedown: ce
                }, [C.tagRender({
                    label: oe,
                    value: ae,
                    disabled: ie,
                    closable: ue,
                    onClose: le,
                    option: de
                })])
            }

            function te(ae) {
                var oe = ae.disabled,
                    ie = ae.label,
                    ue = ae.value,
                    le = ae.option,
                    se = !C.disabled && !oe,
                    ce = ie;
                if (typeof C.maxTagTextLength == "number" && (typeof ie == "string" || typeof ie == "number")) {
                    var de = String(ce);
                    de.length > C.maxTagTextLength && (ce = "".concat(de.slice(0, C.maxTagTextLength), "..."))
                }
                var ve = function (pe) {
                    var me;
                    pe && pe.stopPropagation(), (me = C.onRemove) === null || me === void 0 || me.call(C,
                        ae)
                };
                return typeof C.tagRender == "function" ? ne(ue, ce, oe, se, ve, le) : ee(ie, ce, oe, se, ve)
            }

            function re(ae) {
                var oe = C.maxTagPlaceholder,
                    ie = oe === void 0 ? function (le) {
                        return "+ ".concat(le.length, " ...")
                    } : oe,
                    ue = typeof ie == "function" ? ie(ae) : ie;
                return ee(ue, ue, !1)
            }
            return function () {
                var ae = C.id,
                    oe = C.prefixCls,
                    ie = C.values,
                    ue = C.open,
                    le = C.inputRef,
                    se = C.placeholder,
                    ce = C.disabled,
                    de = C.autofocus,
                    ve = C.autocomplete,
                    fe = C.activeDescendantId,
                    pe = C.tabindex,
                    me = C.onInputChange,
                    he = C.onInputPaste,
                    Se = C.onInputKeyDown,
                    _e = C.onInputMouseDown,
                    be = C.onInputCompositionStart,
                    ge = C.onInputCompositionEnd,
                    xe = createVNode("div", {
                        class: "".concat(X.value, "-search"),
                        style: {
                            width: W.value + "px"
                        },
                        key: "input"
                    }, [createVNode(Input$2, {
                        inputRef: le,
                        open: ue,
                        prefixCls: oe,
                        id: ae,
                        inputElement: null,
                        disabled: ce,
                        autofocus: de,
                        autocomplete: ve,
                        editable: Q.value,
                        activeDescendantId: fe,
                        value: Z.value,
                        onKeydown: Se,
                        onMousedown: _e,
                        onChange: me,
                        onPaste: he,
                        onCompositionstart: be,
                        onCompositionend: ge,
                        tabindex: pe,
                        attrs: pickAttrs(C, !0),
                        onFocus: function () {
                            return U.value = !0
                        },
                        onBlur: function () {
                            return U.value = !1
                        }
                    }, null), createVNode("span", {
                        ref: H,
                        class: "".concat(X.value, "-search-mirror"),
                        "aria-hidden": !0
                    }, [Z.value, createTextVNode(" ")])]),
                    Pe = createVNode(Overflow$1, {
                        prefixCls: "".concat(X.value, "-overflow"),
                        data: ie,
                        renderItem: te,
                        renderRest: re,
                        suffix: xe,
                        itemKey: "key",
                        maxCount: C.maxTagCount,
                        key: "overflow"
                    }, null);
                return createVNode(Fragment, null, [Pe, !ie.length && !Z.value && createVNode("span", {
                    class: "".concat(X.value, "-placeholder")
                }, [se])])
            }
        }
    });
const MultipleSelector = SelectSelector;
var props$1 = {
        inputElement: PropTypes$1.any,
        id: String,
        prefixCls: String,
        values: PropTypes$1.array,
        open: {
            type: Boolean,
            default: void 0
        },
        searchValue: String,
        inputRef: PropTypes$1.any,
        placeholder: PropTypes$1.any,
        disabled: {
            type: Boolean,
            default: void 0
        },
        mode: String,
        showSearch: {
            type: Boolean,
            default: void 0
        },
        autofocus: {
            type: Boolean,
            default: void 0
        },
        autocomplete: String,
        activeDescendantId: String,
        tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
        activeValue: String,
        backfill: {
            type: Boolean,
            default: void 0
        },
        optionLabelRender: Function,
        onInputChange: Function,
        onInputPaste: Function,
        onInputKeyDown: Function,
        onInputMouseDown: Function,
        onInputCompositionStart: Function,
        onInputCompositionEnd: Function
    },
    SingleSelector = defineComponent({
        name: "SingleSelector",
        setup: function (C) {
            var H = ref(!1),
                W = computed(function () {
                    return C.mode === "combobox"
                }),
                U = computed(function () {
                    return W.value || C.showSearch
                }),
                G = computed(function () {
                    var ne = C.searchValue || "";
                    return W.value && C.activeValue && !H.value && (ne = C.activeValue), ne
                }),
                X = useInjectLegacySelectContext();
            watch([W, function () {
                return C.activeValue
            }], function () {
                W.value && (H.value = !1)
            }, {
                immediate: !0
            });
            var Z = computed(function () {
                    return C.mode !== "combobox" && !C.open && !C.showSearch ? !1 : !!G.value
                }),
                Q = computed(function () {
                    var ne = C.values[0];
                    return ne && (typeof ne.label == "string" || typeof ne.label == "number") ? ne.label.toString() :
                        void 0
                }),
                ee = function () {
                    if (C.values[0]) return null;
                    var te = Z.value ? {
                        visibility: "hidden"
                    } : void 0;
                    return createVNode("span", {
                        class: "".concat(C.prefixCls, "-selection-placeholder"),
                        style: te
                    }, [C.placeholder])
                };
            return function () {
                var ne, te = C.inputElement,
                    re = C.prefixCls,
                    ae = C.id,
                    oe = C.values,
                    ie = C.inputRef,
                    ue = C.disabled,
                    le = C.autofocus,
                    se = C.autocomplete,
                    ce = C.activeDescendantId,
                    de = C.open,
                    ve = C.tabindex,
                    fe = C.optionLabelRender,
                    pe = C.onInputKeyDown,
                    me = C.onInputMouseDown,
                    he = C.onInputChange,
                    Se = C.onInputPaste,
                    _e = C.onInputCompositionStart,
                    be = C.onInputCompositionEnd,
                    ge = oe[0],
                    xe = null;
                if (ge && X.customSlots) {
                    var Pe, $e, ye, Ce = (Pe = ge.key) !== null && Pe !== void 0 ? Pe : ge.value,
                        we = (($e = X.keyEntities[Ce]) === null || $e === void 0 ? void 0 : $e.node) || {};
                    xe = X.customSlots[(ye = we.slots) === null || ye === void 0 ? void 0 : ye.title] || X.customSlots
                        .title || ge.label, typeof xe == "function" && (xe = xe(we))
                } else xe = fe && ge ? fe(ge.option) : ge == null ? void 0 : ge.label;
                return createVNode(Fragment, null, [createVNode("span", {
                    class: "".concat(re, "-selection-search")
                }, [createVNode(Input$2, {
                    inputRef: ie,
                    prefixCls: re,
                    id: ae,
                    open: de,
                    inputElement: te,
                    disabled: ue,
                    autofocus: le,
                    autocomplete: se,
                    editable: U.value,
                    activeDescendantId: ce,
                    value: G.value,
                    onKeydown: pe,
                    onMousedown: me,
                    onChange: function (Ne) {
                        H.value = !0, he(Ne)
                    },
                    onPaste: Se,
                    onCompositionstart: _e,
                    onCompositionend: be,
                    tabindex: ve,
                    attrs: pickAttrs(C, !0)
                }, null)]), !W.value && ge && !Z.value && createVNode("span", {
                    class: "".concat(re, "-selection-item"),
                    title: Q.value
                }, [createVNode(Fragment, {
                    key: (ne = ge.key) !== null && ne !== void 0 ? ne : ge.value
                }, [xe])]), ee()])
            }
        }
    });
SingleSelector.props = props$1;
SingleSelector.inheritAttrs = !1;
const SingleSelector$1 = SingleSelector;

function isValidateOpenKey(K) {
    return ![KeyCode$1.ESC, KeyCode$1.SHIFT, KeyCode$1.BACKSPACE, KeyCode$1.TAB, KeyCode$1.WIN_KEY, KeyCode$1.ALT,
        KeyCode$1.META, KeyCode$1.WIN_KEY_RIGHT, KeyCode$1.CTRL, KeyCode$1.SEMICOLON, KeyCode$1.EQUALS, KeyCode$1.CAPS_LOCK,
        KeyCode$1.CONTEXT_MENU, KeyCode$1.F1, KeyCode$1.F2, KeyCode$1.F3, KeyCode$1.F4, KeyCode$1.F5, KeyCode$1.F6,
        KeyCode$1.F7, KeyCode$1.F8, KeyCode$1.F9, KeyCode$1.F10, KeyCode$1.F11, KeyCode$1.F12].includes(K)
}

function useLock() {
    var K = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250,
        C = null,
        H;
    onBeforeUnmount(function () {
        clearTimeout(H)
    });

    function W(U) {
        (U || C === null) && (C = U), clearTimeout(H), H = setTimeout(function () {
            C = null
        }, K)
    }
    return [function () {
        return C
    }, W]
}

function createRef() {
    var K = function C(H) {
        C.current = H
    };
    return K
}
var Selector = defineComponent({
    name: "Selector",
    inheritAttrs: !1,
    props: {
        id: String,
        prefixCls: String,
        showSearch: {
            type: Boolean,
            default: void 0
        },
        open: {
            type: Boolean,
            default: void 0
        },
        values: PropTypes$1.array,
        multiple: {
            type: Boolean,
            default: void 0
        },
        mode: String,
        searchValue: String,
        activeValue: String,
        inputElement: PropTypes$1.any,
        autofocus: {
            type: Boolean,
            default: void 0
        },
        activeDescendantId: String,
        tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
        disabled: {
            type: Boolean,
            default: void 0
        },
        placeholder: PropTypes$1.any,
        removeIcon: PropTypes$1.any,
        maxTagCount: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
        maxTagTextLength: Number,
        maxTagPlaceholder: PropTypes$1.any,
        tagRender: Function,
        optionLabelRender: Function,
        tokenWithEnter: {
            type: Boolean,
            default: void 0
        },
        choiceTransitionName: String,
        onToggleOpen: {
            type: Function
        },
        onSearch: Function,
        onSearchSubmit: Function,
        onRemove: Function,
        onInputKeyDown: {
            type: Function
        },
        domRef: Function
    },
    setup: function (C, H) {
        var W = H.expose,
            U = createRef(),
            G = !1,
            X = useLock(0),
            Z = _slicedToArray$2(X, 2),
            Q = Z[0],
            ee = Z[1],
            ne = function (ve) {
                var fe = ve.which;
                (fe === KeyCode$1.UP || fe === KeyCode$1.DOWN) && ve.preventDefault(), C.onInputKeyDown &&
                    C.onInputKeyDown(ve), fe === KeyCode$1.ENTER && C.mode === "tags" && !G && !C.open && C
                    .onSearchSubmit(ve.target.value), isValidateOpenKey(fe) && C.onToggleOpen(!0)
            },
            te = function () {
                ee(!0)
            },
            re = null,
            ae = function (ve) {
                C.onSearch(ve, !0, G) !== !1 && C.onToggleOpen(!0)
            },
            oe = function () {
                G = !0
            },
            ie = function (ve) {
                G = !1, C.mode !== "combobox" && ae(ve.target.value)
            },
            ue = function (ve) {
                var fe = ve.target.value;
                if (C.tokenWithEnter && re && /[\r\n]/.test(re)) {
                    var pe = re.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
                    fe = fe.replace(pe, re)
                }
                re = null, ae(fe)
            },
            le = function (ve) {
                var fe = ve.clipboardData,
                    pe = fe.getData("text");
                re = pe
            },
            se = function (ve) {
                var fe = ve.target;
                if (fe !== U.current) {
                    var pe = document.body.style.msTouchAction !== void 0;
                    pe ? setTimeout(function () {
                        U.current.focus()
                    }) : U.current.focus()
                }
            },
            ce = function (ve) {
                var fe = Q();
                ve.target !== U.current && !fe && ve.preventDefault(), (C.mode !== "combobox" && (!C.showSearch ||
                    !fe) || !C.open) && (C.open && C.onSearch("", !0, !1), C.onToggleOpen())
            };
        return W({
                focus: function () {
                    U.current.focus()
                },
                blur: function () {
                    U.current.blur()
                }
            }),
            function () {
                var de = C.prefixCls,
                    ve = C.domRef,
                    fe = C.mode,
                    pe = {
                        inputRef: U,
                        onInputKeyDown: ne,
                        onInputMouseDown: te,
                        onInputChange: ue,
                        onInputPaste: le,
                        onInputCompositionStart: oe,
                        onInputCompositionEnd: ie
                    },
                    me = fe === "multiple" || fe === "tags" ? createVNode(MultipleSelector,
                        _objectSpread2$1(_objectSpread2$1({}, C), pe), null) : createVNode(SingleSelector$1,
                        _objectSpread2$1(_objectSpread2$1({}, C), pe), null);
                return createVNode("div", {
                    ref: ve,
                    class: "".concat(de, "-selector"),
                    onClick: se,
                    onMousedown: ce
                }, [me])
            }
    }
});
const Selector$1 = Selector;

function useSelectTriggerControl(K, C, H) {
    function W(U) {
        var G, X, Z, Q = U.target;
        Q.shadowRoot && U.composed && (Q = U.composedPath()[0] || Q);
        var ee = [(G = K[0]) === null || G === void 0 ? void 0 : G.value, (X = K[1]) === null || X === void 0 || (Z = X
            .value) === null || Z === void 0 ? void 0 : Z.getPopupElement()];
        C.value && ee.every(function (ne) {
            return ne && !ne.contains(Q) && ne !== Q
        }) && H(!1)
    }
    onMounted(function () {
        window.addEventListener("mousedown", W)
    }), onBeforeUnmount(function () {
        window.removeEventListener("mousedown", W)
    })
}

function useDelayReset() {
    var K = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10,
        C = ref(!1),
        H, W = function () {
            clearTimeout(H)
        };
    onMounted(function () {
        W()
    });
    var U = function (X, Z) {
        W(), H = setTimeout(function () {
            C.value = X, Z && Z()
        }, K)
    };
    return [C, U, W]
}
var BaseSelectContextKey = Symbol("BaseSelectContextKey");

function useProvideBaseSelectProps(K) {
    return provide(BaseSelectContextKey, K)
}

function useBaseProps() {
    return inject(BaseSelectContextKey, {})
}
const isMobile$2 = function () {
    if (typeof navigator > "u" || typeof window > "u") return !1;
    var K = navigator.userAgent || navigator.vendor || window.opera;
    return !!(
        /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i
        .test(K) ||
        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i
        .test(K == null ? void 0 : K.substr(0, 4)))
};

function toReactive(K) {
    if (!isRef(K)) return reactive(K);
    var C = new Proxy({}, {
        get: function (W, U, G) {
            return Reflect.get(K.value, U, G)
        },
        set: function (W, U, G) {
            return K.value[U] = G, !0
        },
        deleteProperty: function (W, U) {
            return Reflect.deleteProperty(K.value, U)
        },
        has: function (W, U) {
            return Reflect.has(K.value, U)
        },
        ownKeys: function () {
            return Object.keys(K.value)
        },
        getOwnPropertyDescriptor: function () {
            return {
                enumerable: !0,
                configurable: !0
            }
        }
    });
    return reactive(C)
}
var _excluded$W = ["prefixCls", "id", "open", "defaultOpen", "mode", "showSearch", "searchValue", "onSearch",
        "allowClear", "clearIcon", "showArrow", "inputIcon", "disabled", "loading", "getInputElement",
        "getPopupContainer", "placement", "animation", "transitionName", "dropdownStyle", "dropdownClassName",
        "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "showAction", "direction", "tokenSeparators",
        "tagRender", "optionLabelRender", "onPopupScroll", "onDropdownVisibleChange", "onFocus", "onBlur", "onKeyup",
        "onKeydown", "onMousedown", "onClear", "omitDomProps", "getRawInputElement", "displayValues",
        "onDisplayValuesChange", "emptyOptions", "activeDescendantId", "activeValue", "OptionList"],
    DEFAULT_OMIT_PROPS = ["value", "onChange", "removeIcon", "placeholder", "autofocus", "maxTagCount",
        "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabindex",
        "OptionList", "notFoundContent"],
    baseSelectPrivateProps = function () {
        return {
            prefixCls: String,
            id: String,
            omitDomProps: Array,
            displayValues: Array,
            onDisplayValuesChange: Function,
            activeValue: String,
            activeDescendantId: String,
            onActiveValueChange: Function,
            searchValue: String,
            onSearch: Function,
            onSearchSplit: Function,
            maxLength: Number,
            OptionList: PropTypes$1.any,
            emptyOptions: Boolean
        }
    },
    baseSelectPropsWithoutPrivate = function () {
        return {
            showSearch: {
                type: Boolean,
                default: void 0
            },
            tagRender: {
                type: Function
            },
            optionLabelRender: {
                type: Function
            },
            direction: {
                type: String
            },
            tabindex: Number,
            autofocus: Boolean,
            notFoundContent: PropTypes$1.any,
            placeholder: PropTypes$1.any,
            onClear: Function,
            choiceTransitionName: String,
            mode: String,
            disabled: {
                type: Boolean,
                default: void 0
            },
            loading: {
                type: Boolean,
                default: void 0
            },
            open: {
                type: Boolean,
                default: void 0
            },
            defaultOpen: {
                type: Boolean,
                default: void 0
            },
            onDropdownVisibleChange: {
                type: Function
            },
            getInputElement: {
                type: Function
            },
            getRawInputElement: {
                type: Function
            },
            maxTagTextLength: Number,
            maxTagCount: {
                type: [String, Number]
            },
            maxTagPlaceholder: PropTypes$1.any,
            tokenSeparators: {
                type: Array
            },
            allowClear: {
                type: Boolean,
                default: void 0
            },
            showArrow: {
                type: Boolean,
                default: void 0
            },
            inputIcon: PropTypes$1.any,
            clearIcon: PropTypes$1.any,
            removeIcon: PropTypes$1.any,
            animation: String,
            transitionName: String,
            dropdownStyle: {
                type: Object
            },
            dropdownClassName: String,
            dropdownMatchSelectWidth: {
                type: [Boolean, Number],
                default: void 0
            },
            dropdownRender: {
                type: Function
            },
            dropdownAlign: Object,
            placement: {
                type: String
            },
            getPopupContainer: {
                type: Function
            },
            showAction: {
                type: Array
            },
            onBlur: {
                type: Function
            },
            onFocus: {
                type: Function
            },
            onKeyup: Function,
            onKeydown: Function,
            onMousedown: Function,
            onPopupScroll: Function,
            onInputKeyDown: Function,
            onMouseenter: Function,
            onMouseleave: Function,
            onClick: Function
        }
    },
    baseSelectProps = function () {
        return _objectSpread2$1(_objectSpread2$1({}, baseSelectPrivateProps()), baseSelectPropsWithoutPrivate())
    };

function isMultiple(K) {
    return K === "tags" || K === "multiple"
}
const BaseSelect = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "BaseSelect",
    inheritAttrs: !1,
    props: initDefaultProps$1(baseSelectProps(), {
        showAction: [],
        notFoundContent: "Not Found"
    }),
    setup: function (C, H) {
        var W = H.attrs,
            U = H.expose,
            G = H.slots,
            X = computed(function () {
                return isMultiple(C.mode)
            }),
            Z = computed(function () {
                return C.showSearch !== void 0 ? C.showSearch : X.value || C.mode === "combobox"
            }),
            Q = ref(!1);
        onMounted(function () {
            Q.value = isMobile$2()
        });
        var ee = useInjectLegacySelectContext(),
            ne = ref(null),
            te = createRef(),
            re = ref(null),
            ae = ref(null),
            oe = ref(null),
            ie = useDelayReset(),
            ue = _slicedToArray$2(ie, 3),
            le = ue[0],
            se = ue[1],
            ce = ue[2],
            de = function () {
                var Te;
                (Te = ae.value) === null || Te === void 0 || Te.focus()
            },
            ve = function () {
                var Te;
                (Te = ae.value) === null || Te === void 0 || Te.blur()
            };
        U({
            focus: de,
            blur: ve,
            scrollTo: function (Te) {
                var De;
                return (De = oe.value) === null || De === void 0 ? void 0 : De.scrollTo(Te)
            }
        });
        var fe = computed(function () {
                var Ie;
                if (C.mode !== "combobox") return C.searchValue;
                var Te = (Ie = C.displayValues[0]) === null || Ie === void 0 ? void 0 : Ie.value;
                return typeof Te == "string" || typeof Te == "number" ? String(Te) : ""
            }),
            pe = C.open !== void 0 ? C.open : C.defaultOpen,
            me = ref(pe),
            he = ref(pe),
            Se = function (Te) {
                me.value = C.open !== void 0 ? C.open : Te, he.value = me.value
            };
        watch(function () {
            return C.open
        }, function () {
            Se(C.open)
        });
        var _e = computed(function () {
            return !C.notFoundContent && C.emptyOptions
        });
        watchEffect(function () {
            he.value = me.value, (C.disabled || _e.value && he.value && C.mode === "combobox") && (
                he.value = !1)
        });
        var be = computed(function () {
                return _e.value ? !1 : he.value
            }),
            ge = function (Te) {
                var De = Te !== void 0 ? Te : !he.value;
                me.value !== De && !C.disabled && (Se(De), C.onDropdownVisibleChange && C.onDropdownVisibleChange(
                    De))
            },
            xe = computed(function () {
                return (C.tokenSeparators || []).some(function (Ie) {
                    return [`
`, `\r
`].includes(Ie)
                })
            }),
            Pe = function (Te, De, Ke) {
                var We, Ue = !0,
                    et = Te;
                (We = C.onActiveValueChange) === null || We === void 0 || We.call(C, null);
                var Ye = Ke ? null : getSeparatedContent(Te, C.tokenSeparators);
                if (C.mode !== "combobox" && Ye) {
                    var ze;
                    et = "", (ze = C.onSearchSplit) === null || ze === void 0 || ze.call(C, Ye), ge(!1), Ue = !
                        1
                }
                return C.onSearch && fe.value !== et && C.onSearch(et, {
                    source: De ? "typing" : "effect"
                }), Ue
            },
            $e = function (Te) {
                var De;
                !Te || !Te.trim() || (De = C.onSearch) === null || De === void 0 || De.call(C, Te, {
                    source: "submit"
                })
            };
        watch(he, function () {
            !he.value && !X.value && C.mode !== "combobox" && Pe("", !1, !1)
        }, {
            immediate: !0,
            flush: "post"
        }), watch(function () {
            return C.disabled
        }, function () {
            me.value && C.disabled && Se(!1)
        }, {
            immediate: !0
        });
        var ye = useLock(),
            Ce = _slicedToArray$2(ye, 2),
            we = Ce[0],
            Oe = Ce[1],
            Ne = function (Te) {
                var De, Ke = we(),
                    We = Te.which;
                if (We === KeyCode$1.ENTER && (C.mode !== "combobox" && Te.preventDefault(), he.value || ge(
                        !0)), Oe(!!fe.value), We === KeyCode$1.BACKSPACE && !Ke && X.value && !fe.value &&
                    C.displayValues.length) {
                    for (var Ue = _toConsumableArray(C.displayValues), et = null, Ye = Ue.length - 1; Ye >=
                        0; Ye -= 1) {
                        var ze = Ue[Ye];
                        if (!ze.disabled) {
                            Ue.splice(Ye, 1), et = ze;
                            break
                        }
                    }
                    et && C.onDisplayValuesChange(Ue, {
                        type: "remove",
                        values: [et]
                    })
                }
                for (var Be = arguments.length, Ge = new Array(Be > 1 ? Be - 1 : 0), Xe = 1; Xe < Be; Xe++)
                    Ge[Xe - 1] = arguments[Xe];
                if (he.value && oe.value) {
                    var nt;
                    (nt = oe.value).onKeydown.apply(nt, [Te].concat(Ge))
                }(De = C.onKeydown) === null || De === void 0 || De.call.apply(De, [C, Te].concat(Ge))
            },
            Me = function (Te) {
                for (var De = arguments.length, Ke = new Array(De > 1 ? De - 1 : 0), We = 1; We < De; We++)
                    Ke[We - 1] = arguments[We];
                if (he.value && oe.value) {
                    var Ue;
                    (Ue = oe.value).onKeyup.apply(Ue, [Te].concat(Ke))
                }
                C.onKeyup && C.onKeyup.apply(C, [Te].concat(Ke))
            },
            Ve = function (Te) {
                var De = C.displayValues.filter(function (Ke) {
                    return Ke !== Te
                });
                C.onDisplayValuesChange(De, {
                    type: "remove",
                    values: [Te]
                })
            },
            ke = ref(!1),
            Ee = function () {
                se(!0), C.disabled || (C.onFocus && !ke.value && C.onFocus.apply(C, arguments), C.showAction &&
                    C.showAction.includes("focus") && ge(!0)), ke.value = !0
            },
            Ae = function () {
                if (se(!1, function () {
                        ke.value = !1, ge(!1)
                    }), !C.disabled) {
                    var Te = fe.value;
                    Te && (C.mode === "tags" ? C.onSearch(Te, {
                        source: "submit"
                    }) : C.mode === "multiple" && C.onSearch("", {
                        source: "blur"
                    })), C.onBlur && C.onBlur.apply(C, arguments)
                }
            };
        provide("VCSelectContainerEvent", {
            focus: Ee,
            blur: Ae
        });
        var Re = [];
        onMounted(function () {
            Re.forEach(function (Ie) {
                return clearTimeout(Ie)
            }), Re.splice(0, Re.length)
        }), onBeforeUnmount(function () {
            Re.forEach(function (Ie) {
                return clearTimeout(Ie)
            }), Re.splice(0, Re.length)
        });
        var He = function (Te) {
                var De, Ke, We = Te.target,
                    Ue = (De = re.value) === null || De === void 0 ? void 0 : De.getPopupElement();
                if (Ue && Ue.contains(We)) {
                    var et = setTimeout(function () {
                        var Ge = Re.indexOf(et);
                        if (Ge !== -1 && Re.splice(Ge, 1), ce(), !Q.value && !Ue.contains(document.activeElement)) {
                            var Xe;
                            (Xe = ae.value) === null || Xe === void 0 || Xe.focus()
                        }
                    });
                    Re.push(et)
                }
                for (var Ye = arguments.length, ze = new Array(Ye > 1 ? Ye - 1 : 0), Be = 1; Be < Ye; Be++)
                    ze[Be - 1] = arguments[Be];
                (Ke = C.onMousedown) === null || Ke === void 0 || Ke.call.apply(Ke, [C, Te].concat(ze))
            },
            je = ref(null),
            Fe = getCurrentInstance(),
            Le = function () {
                Fe.update()
            };
        return onMounted(function () {
                watch(be, function () {
                    if (be.value) {
                        var Ie, Te = Math.ceil((Ie = ne.value) === null || Ie === void 0 ? void 0 :
                            Ie.offsetWidth);
                        je.value !== Te && !Number.isNaN(Te) && (je.value = Te)
                    }
                }, {
                    immediate: !0,
                    flush: "post"
                })
            }), useSelectTriggerControl([ne, re], be, ge), useProvideBaseSelectProps(toReactive(
                _objectSpread2$1(_objectSpread2$1({}, toRefs(C)), {}, {
                    open: he,
                    triggerOpen: be,
                    showSearch: Z,
                    multiple: X,
                    toggleOpen: ge
                }))),
            function () {
                var Ie, Te = _objectSpread2$1(_objectSpread2$1({}, C), W),
                    De = Te.prefixCls,
                    Ke = Te.id;
                Te.open, Te.defaultOpen;
                var We = Te.mode;
                Te.showSearch, Te.searchValue, Te.onSearch;
                var Ue = Te.allowClear,
                    et = Te.clearIcon,
                    Ye = Te.showArrow,
                    ze = Te.inputIcon,
                    Be = Te.disabled,
                    Ge = Te.loading,
                    Xe = Te.getInputElement,
                    nt = Te.getPopupContainer,
                    it = Te.placement,
                    ft = Te.animation,
                    pt = Te.transitionName,
                    ot = Te.dropdownStyle,
                    Ze = Te.dropdownClassName,
                    ut = Te.dropdownMatchSelectWidth,
                    st = Te.dropdownRender,
                    rt = Te.dropdownAlign;
                Te.showAction;
                var qe = Te.direction;
                Te.tokenSeparators;
                var Je = Te.tagRender,
                    Qe = Te.optionLabelRender;
                Te.onPopupScroll, Te.onDropdownVisibleChange, Te.onFocus, Te.onBlur, Te.onKeyup, Te.onKeydown,
                    Te.onMousedown;
                var lt = Te.onClear,
                    ct = Te.omitDomProps,
                    dt = Te.getRawInputElement,
                    tt = Te.displayValues,
                    at = Te.onDisplayValuesChange,
                    vt = Te.emptyOptions,
                    gt = Te.activeDescendantId,
                    mt = Te.activeValue,
                    ht = Te.OptionList,
                    yt = _objectWithoutProperties$2(Te, _excluded$W),
                    St = We === "combobox" && Xe && Xe() || null,
                    Ct = typeof dt == "function" && dt(),
                    _t = _objectSpread2$1({}, yt),
                    wt;
                Ct && (wt = function (Vt) {
                    ge(Vt)
                }), DEFAULT_OMIT_PROPS.forEach(function (Mt) {
                    delete _t[Mt]
                }), ct == null || ct.forEach(function (Mt) {
                    delete _t[Mt]
                });
                var Et = Ye !== void 0 ? Ye : Ge || !X.value && We !== "combobox",
                    xt;
                Et && (xt = createVNode(TransBtn$1, {
                    class: classNames("".concat(De, "-arrow"), _defineProperty$V({}, "".concat(
                        De, "-arrow-loading"), Ge)),
                    customizeIcon: ze,
                    customizeIconProps: {
                        loading: Ge,
                        searchValue: fe.value,
                        open: he.value,
                        focused: le.value,
                        showSearch: Z.value
                    }
                }, null));
                var kt, Nt = function () {
                    lt == null || lt(), at([], {
                        type: "clear",
                        values: tt
                    }), Pe("", !1, !1)
                };
                !Be && Ue && (tt.length || fe.value) && (kt = createVNode(TransBtn$1, {
                    class: "".concat(De, "-clear"),
                    onMousedown: Nt,
                    customizeIcon: et
                }, {
                    default: function () {
                        return [createTextVNode("")]
                    }
                }));
                var Rt = createVNode(ht, {
                        ref: oe
                    }, _objectSpread2$1(_objectSpread2$1({}, ee.customSlots), {}, {
                        option: G.option
                    })),
                    It = classNames(De, W.class, (Ie = {}, _defineProperty$V(Ie, "".concat(De, "-focused"),
                            le.value), _defineProperty$V(Ie, "".concat(De, "-multiple"), X.value),
                        _defineProperty$V(Ie, "".concat(De, "-single"), !X.value), _defineProperty$V(Ie,
                            "".concat(De, "-allow-clear"), Ue), _defineProperty$V(Ie, "".concat(De,
                            "-show-arrow"), Et), _defineProperty$V(Ie, "".concat(De, "-disabled"), Be),
                        _defineProperty$V(Ie, "".concat(De, "-loading"), Ge), _defineProperty$V(Ie, "".concat(
                            De, "-open"), he.value), _defineProperty$V(Ie, "".concat(De,
                            "-customize-input"), St), _defineProperty$V(Ie, "".concat(De,
                            "-show-search"), Z.value), Ie)),
                    Lt = createVNode(SelectTrigger$1, {
                        ref: re,
                        disabled: Be,
                        prefixCls: De,
                        visible: be.value,
                        popupElement: Rt,
                        containerWidth: je.value,
                        animation: ft,
                        transitionName: pt,
                        dropdownStyle: ot,
                        dropdownClassName: Ze,
                        direction: qe,
                        dropdownMatchSelectWidth: ut,
                        dropdownRender: st,
                        dropdownAlign: rt,
                        placement: it,
                        getPopupContainer: nt,
                        empty: vt,
                        getTriggerDOMNode: function () {
                            return te.current
                        },
                        onPopupVisibleChange: wt,
                        onPopupMouseEnter: Le
                    }, {
                        default: function () {
                            return Ct ? isValidElement(Ct) && cloneElement(Ct, {
                                ref: te
                            }, !1, !0) : createVNode(Selector$1, _objectSpread2$1(
                                _objectSpread2$1({}, C), {}, {
                                    domRef: te,
                                    prefixCls: De,
                                    inputElement: St,
                                    ref: ae,
                                    id: Ke,
                                    showSearch: Z.value,
                                    mode: We,
                                    activeDescendantId: gt,
                                    tagRender: Je,
                                    optionLabelRender: Qe,
                                    values: tt,
                                    open: he.value,
                                    onToggleOpen: ge,
                                    activeValue: mt,
                                    searchValue: fe.value,
                                    onSearch: Pe,
                                    onSearchSubmit: $e,
                                    onRemove: Ve,
                                    tokenWithEnter: xe.value
                                }), null)
                        }
                    }),
                    jt;
                return Ct ? jt = Lt : jt = createVNode("div", _objectSpread2$1(_objectSpread2$1({}, _t), {}, {
                    class: It,
                    ref: ne,
                    onMousedown: He,
                    onKeydown: Ne,
                    onKeyup: Me
                }), [le.value && !he.value && createVNode("span", {
                    style: {
                        width: 0,
                        height: 0,
                        display: "flex",
                        overflow: "hidden",
                        opacity: 0
                    },
                    "aria-live": "polite"
                }, ["".concat(tt.map(function (Mt) {
                    var Vt = Mt.label,
                        Dt = Mt.value;
                    return ["number", "string"].includes(_typeof$2(Vt)) ? Vt :
                        Dt
                }).join(", "))]), Lt, xt, kt]), jt
            }
    }
});
var Filter = function (C, H) {
    var W, U = C.height,
        G = C.offset,
        X = C.prefixCls,
        Z = C.onInnerResize,
        Q = H.slots,
        ee = {},
        ne = {
            display: "flex",
            flexDirection: "column"
        };
    return G !== void 0 && (ee = {
        height: "".concat(U, "px"),
        position: "relative",
        overflow: "hidden"
    }, ne = _objectSpread2$1(_objectSpread2$1({}, ne), {}, {
        transform: "translateY(".concat(G, "px)"),
        position: "absolute",
        left: 0,
        right: 0,
        top: 0
    })), createVNode("div", {
        style: ee
    }, [createVNode(ResizeObserver$1, {
        onResize: function (re) {
            var ae = re.offsetHeight;
            ae && Z && Z()
        }
    }, {
        default: function () {
            return [createVNode("div", {
                style: ne,
                class: classNames(_defineProperty$V({}, "".concat(X,
                    "-holder-inner"), X))
            }, [(W = Q.default) === null || W === void 0 ? void 0 : W.call(Q)])]
        }
    })])
};
Filter.displayName = "Filter";
Filter.inheritAttrs = !1;
Filter.props = {
    prefixCls: String,
    height: Number,
    offset: Number,
    onInnerResize: Function
};
const Filler = Filter;
var Item$1 = function (C, H) {
    var W, U = C.setRef,
        G = H.slots,
        X = flattenChildren((W = G.default) === null || W === void 0 ? void 0 : W.call(G));
    return X && X.length ? cloneVNode(X[0], {
        ref: U
    }) : X
};
Item$1.props = {
    setRef: {
        type: Function,
        default: function () {}
    }
};
const Item$2 = Item$1;
var MIN_SIZE = 20;

function getPageY(K) {
    return "touches" in K ? K.touches[0].pageY : K.pageY
}
const ScrollBar = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ScrollBar",
    inheritAttrs: !1,
    props: {
        prefixCls: String,
        scrollTop: Number,
        scrollHeight: Number,
        height: Number,
        count: Number,
        onScroll: {
            type: Function
        },
        onStartMove: {
            type: Function
        },
        onStopMove: {
            type: Function
        }
    },
    setup: function () {
        return {
            moveRaf: null,
            scrollbarRef: createRef(),
            thumbRef: createRef(),
            visibleTimeout: null,
            state: reactive({
                dragging: !1,
                pageY: null,
                startTop: null,
                visible: !1
            })
        }
    },
    watch: {
        scrollTop: {
            handler: function () {
                this.delayHidden()
            },
            flush: "post"
        }
    },
    mounted: function () {
        var C, H;
        (C = this.scrollbarRef.current) === null || C === void 0 || C.addEventListener("touchstart", this.onScrollbarTouchStart,
            supportsPassive$1 ? {
                passive: !1
            } : !1), (H = this.thumbRef.current) === null || H === void 0 || H.addEventListener(
            "touchstart", this.onMouseDown, supportsPassive$1 ? {
                passive: !1
            } : !1)
    },
    beforeUnmount: function () {
        this.removeEvents(), clearTimeout(this.visibleTimeout)
    },
    methods: {
        delayHidden: function () {
            var C = this;
            clearTimeout(this.visibleTimeout), this.state.visible = !0, this.visibleTimeout = setTimeout(
                function () {
                    C.state.visible = !1
                }, 2e3)
        },
        onScrollbarTouchStart: function (C) {
            C.preventDefault()
        },
        onContainerMouseDown: function (C) {
            C.stopPropagation(), C.preventDefault()
        },
        patchEvents: function () {
            window.addEventListener("mousemove", this.onMouseMove), window.addEventListener("mouseup", this
                .onMouseUp), this.thumbRef.current.addEventListener("touchmove", this.onMouseMove,
                supportsPassive$1 ? {
                    passive: !1
                } : !1), this.thumbRef.current.addEventListener("touchend", this.onMouseUp)
        },
        removeEvents: function () {
            window.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("mouseup",
                    this.onMouseUp), this.scrollbarRef.current.removeEventListener("touchstart", this.onScrollbarTouchStart,
                    supportsPassive$1 ? {
                        passive: !1
                    } : !1), this.thumbRef.current.removeEventListener("touchstart", this.onMouseDown,
                    supportsPassive$1 ? {
                        passive: !1
                    } : !1), this.thumbRef.current.removeEventListener("touchmove", this.onMouseMove,
                    supportsPassive$1 ? {
                        passive: !1
                    } : !1), this.thumbRef.current.removeEventListener("touchend", this.onMouseUp),
                wrapperRaf.cancel(this.moveRaf)
        },
        onMouseDown: function (C) {
            var H = this.$props.onStartMove;
            _extends$1(this.state, {
                dragging: !0,
                pageY: getPageY(C),
                startTop: this.getTop()
            }), H(), this.patchEvents(), C.stopPropagation(), C.preventDefault()
        },
        onMouseMove: function (C) {
            var H = this.state,
                W = H.dragging,
                U = H.pageY,
                G = H.startTop,
                X = this.$props.onScroll;
            if (wrapperRaf.cancel(this.moveRaf), W) {
                var Z = getPageY(C) - U,
                    Q = G + Z,
                    ee = this.getEnableScrollRange(),
                    ne = this.getEnableHeightRange(),
                    te = ne ? Q / ne : 0,
                    re = Math.ceil(te * ee);
                this.moveRaf = wrapperRaf(function () {
                    X(re)
                })
            }
        },
        onMouseUp: function () {
            var C = this.$props.onStopMove;
            this.state.dragging = !1, C(), this.removeEvents()
        },
        getSpinHeight: function () {
            var C = this.$props,
                H = C.height,
                W = C.count,
                U = H / W * 10;
            return U = Math.max(U, MIN_SIZE), U = Math.min(U, H / 2), Math.floor(U)
        },
        getEnableScrollRange: function () {
            var C = this.$props,
                H = C.scrollHeight,
                W = C.height;
            return H - W || 0
        },
        getEnableHeightRange: function () {
            var C = this.$props.height,
                H = this.getSpinHeight();
            return C - H || 0
        },
        getTop: function () {
            var C = this.$props.scrollTop,
                H = this.getEnableScrollRange(),
                W = this.getEnableHeightRange();
            if (C === 0 || H === 0) return 0;
            var U = C / H;
            return U * W
        },
        showScroll: function () {
            var C = this.$props,
                H = C.height,
                W = C.scrollHeight;
            return W > H
        }
    },
    render: function () {
        var C = this.state,
            H = C.dragging,
            W = C.visible,
            U = this.$props.prefixCls,
            G = this.getSpinHeight() + "px",
            X = this.getTop() + "px",
            Z = this.showScroll(),
            Q = Z && W;
        return createVNode("div", {
            ref: this.scrollbarRef,
            class: classNames("".concat(U, "-scrollbar"), _defineProperty$V({}, "".concat(U,
                "-scrollbar-show"), Z)),
            style: {
                width: "8px",
                top: 0,
                bottom: 0,
                right: 0,
                position: "absolute",
                display: Q ? void 0 : "none"
            },
            onMousedown: this.onContainerMouseDown,
            onMousemove: this.delayHidden
        }, [createVNode("div", {
            ref: this.thumbRef,
            class: classNames("".concat(U, "-scrollbar-thumb"), _defineProperty$V({}, "".concat(
                U, "-scrollbar-thumb-moving"), H)),
            style: {
                width: "100%",
                height: G,
                top: X,
                left: 0,
                position: "absolute",
                background: "rgba(0, 0, 0, 0.5)",
                borderRadius: "99px",
                cursor: "pointer",
                userSelect: "none"
            },
            onMousedown: this.onMouseDown
        }, null)])
    }
});

function useHeights(K, C, H, W) {
    var U = new Map,
        G = new Map,
        X = ref(Symbol("update"));
    watch(K, function () {
        X.value = Symbol("update")
    });
    var Z = 0;

    function Q() {
        Z += 1;
        var ne = Z;
        Promise.resolve().then(function () {
            ne === Z && U.forEach(function (te, re) {
                if (te && te.offsetParent) {
                    var ae = te.offsetHeight;
                    G.get(re) !== ae && (X.value = Symbol("update"), G.set(re, te.offsetHeight))
                }
            })
        })
    }

    function ee(ne, te) {
        var re = C(ne),
            ae = U.get(re);
        te ? (U.set(re, te.$el || te), Q()) : U.delete(re), !ae != !te && (te ? H == null || H(ne) : W == null || W(ne))
    }
    return [ee, Q, G, X]
}

function useScrollTo(K, C, H, W, U, G, X, Z) {
    var Q;
    return function (ee) {
        if (ee == null) {
            Z();
            return
        }
        wrapperRaf.cancel(Q);
        var ne = C.value,
            te = W.itemHeight;
        if (typeof ee == "number") X(ee);
        else if (ee && _typeof$2(ee) === "object") {
            var re, ae = ee.align;
            "index" in ee ? re = ee.index : re = ne.findIndex(function (le) {
                return U(le) === ee.key
            });
            var oe = ee.offset,
                ie = oe === void 0 ? 0 : oe,
                ue = function le(se, ce) {
                    if (!(se < 0 || !K.value)) {
                        var de = K.value.clientHeight,
                            ve = !1,
                            fe = ce;
                        if (de) {
                            for (var pe = ce || ae, me = 0, he = 0, Se = 0, _e = Math.min(ne.length, re), be = 0; be <=
                                _e; be += 1) {
                                var ge = U(ne[be]);
                                he = me;
                                var xe = H.get(ge);
                                Se = he + (xe === void 0 ? te : xe), me = Se, be === re && xe === void 0 && (ve = !
                                    0)
                            }
                            var Pe = K.value.scrollTop,
                                $e = null;
                            switch (pe) {
                                case "top":
                                    $e = he - ie;
                                    break;
                                case "bottom":
                                    $e = Se - de + ie;
                                    break;
                                default:
                                    {
                                        var ye = Pe + de;he < Pe ? fe = "top" : Se > ye && (fe = "bottom")
                                    }
                            }
                            $e !== null && $e !== Pe && X($e)
                        }
                        Q = wrapperRaf(function () {
                            ve && G(), le(se - 1, fe)
                        })
                    }
                };
            ue(5)
        }
    }
}
var isFF = (typeof navigator > "u" ? "undefined" : _typeof$2(navigator)) === "object" && /Firefox/i.test(navigator.userAgent);
const isFF$1 = isFF,
    useOriginScroll = function (K, C) {
        var H = !1,
            W = null;

        function U() {
            clearTimeout(W), H = !0, W = setTimeout(function () {
                H = !1
            }, 50)
        }
        return function (G) {
            var X = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
                Z = G < 0 && K.value || G > 0 && C.value;
            return X && Z ? (clearTimeout(W), H = !1) : (!Z || H) && U(), !H && Z
        }
    };

function useFrameWheel(K, C, H, W) {
    var U = 0,
        G = null,
        X = null,
        Z = !1,
        Q = useOriginScroll(C, H);

    function ee(te) {
        if (K.value) {
            wrapperRaf.cancel(G);
            var re = te.deltaY;
            U += re, X = re, !Q(re) && (isFF$1 || te.preventDefault(), G = wrapperRaf(function () {
                var ae = Z ? 10 : 1;
                W(U * ae), U = 0
            }))
        }
    }

    function ne(te) {
        K.value && (Z = te.detail === X)
    }
    return [ee, ne]
}
var SMOOTH_PTG = 14 / 15;

function useMobileTouchMove(K, C, H) {
    var W = !1,
        U = 0,
        G = null,
        X = null,
        Z = function () {
            G && (G.removeEventListener("touchmove", Q), G.removeEventListener("touchend", ee))
        },
        Q = function (ae) {
            if (W) {
                var oe = Math.ceil(ae.touches[0].pageY),
                    ie = U - oe;
                U = oe, H(ie) && ae.preventDefault(), clearInterval(X), X = setInterval(function () {
                    ie *= SMOOTH_PTG, (!H(ie, !0) || Math.abs(ie) <= .1) && clearInterval(X)
                }, 16)
            }
        },
        ee = function () {
            W = !1, Z()
        },
        ne = function (ae) {
            Z(), ae.touches.length === 1 && !W && (W = !0, U = Math.ceil(ae.touches[0].pageY), G = ae.target, G.addEventListener(
                "touchmove", Q, {
                    passive: !1
                }), G.addEventListener("touchend", ee))
        },
        te = function () {};
    onMounted(function () {
        document.addEventListener("touchmove", te, {
            passive: !1
        }), watch(K, function (re) {
            C.value.removeEventListener("touchstart", ne), Z(), clearInterval(X), re && C.value.addEventListener(
                "touchstart", ne, {
                    passive: !1
                })
        }, {
            immediate: !0
        })
    }), onBeforeUnmount(function () {
        document.removeEventListener("touchmove", te)
    })
}
var _excluded$V = ["prefixCls", "height", "itemHeight", "fullHeight", "data", "itemKey", "virtual", "component",
        "onScroll", "children", "style", "class"],
    EMPTY_DATA$1 = [],
    ScrollStyle = {
        overflowY: "auto",
        overflowAnchor: "none"
    };

function renderChildren(K, C, H, W, U, G) {
    var X = G.getKey;
    return K.slice(C, H + 1).map(function (Z, Q) {
        var ee = C + Q,
            ne = U(Z, ee, {}),
            te = X(Z);
        return createVNode(Item$2, {
            key: te,
            setRef: function (ae) {
                return W(Z, ae)
            }
        }, {
            default: function () {
                return [ne]
            }
        })
    })
}
var List$3 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "List",
    inheritAttrs: !1,
    props: {
        prefixCls: String,
        data: PropTypes$1.array,
        height: Number,
        itemHeight: Number,
        fullHeight: {
            type: Boolean,
            default: void 0
        },
        itemKey: {
            type: [String, Number, Function],
            required: !0
        },
        component: {
            type: [String, Object]
        },
        virtual: {
            type: Boolean,
            default: void 0
        },
        children: Function,
        onScroll: Function,
        onMousedown: Function,
        onMouseenter: Function,
        onVisibleChange: Function
    },
    setup: function (C, H) {
        var W = H.expose,
            U = computed(function () {
                var Ve = C.height,
                    ke = C.itemHeight,
                    Ee = C.virtual;
                return !!(Ee !== !1 && Ve && ke)
            }),
            G = computed(function () {
                var Ve = C.height,
                    ke = C.itemHeight,
                    Ee = C.data;
                return U.value && Ee && ke * Ee.length > Ve
            }),
            X = reactive({
                scrollTop: 0,
                scrollMoving: !1
            }),
            Z = computed(function () {
                return C.data || EMPTY_DATA$1
            }),
            Q = shallowRef([]);
        watch(Z, function () {
            Q.value = toRaw(Z.value).slice()
        }, {
            immediate: !0
        });
        var ee = shallowRef(function (Ve) {});
        watch(function () {
            return C.itemKey
        }, function (Ve) {
            typeof Ve == "function" ? ee.value = Ve : ee.value = function (ke) {
                return ke == null ? void 0 : ke[Ve]
            }
        }, {
            immediate: !0
        });
        var ne = ref(),
            te = ref(),
            re = ref(),
            ae = function (ke) {
                return ee.value(ke)
            },
            oe = {
                getKey: ae
            };

        function ie(Ve) {
            var ke;
            typeof Ve == "function" ? ke = Ve(X.scrollTop) : ke = Ve;
            var Ee = he(ke);
            ne.value && (ne.value.scrollTop = Ee), X.scrollTop = Ee
        }
        var ue = useHeights(Q, ae, null, null),
            le = _slicedToArray$2(ue, 4),
            se = le[0],
            ce = le[1],
            de = le[2],
            ve = le[3],
            fe = reactive({
                scrollHeight: void 0,
                start: 0,
                end: 0,
                offset: void 0
            }),
            pe = ref(0);
        onMounted(function () {
            nextTick(function () {
                var Ve;
                pe.value = ((Ve = te.value) === null || Ve === void 0 ? void 0 : Ve.offsetHeight) ||
                    0
            })
        }), onUpdated(function () {
            nextTick(function () {
                var Ve;
                pe.value = ((Ve = te.value) === null || Ve === void 0 ? void 0 : Ve.offsetHeight) ||
                    0
            })
        }), watch([U, Q], function () {
            U.value || _extends$1(fe, {
                scrollHeight: void 0,
                start: 0,
                end: Q.value.length - 1,
                offset: void 0
            })
        }, {
            immediate: !0
        }), watch([U, Q, pe, G], function () {
            U.value && !G.value && _extends$1(fe, {
                scrollHeight: pe.value,
                start: 0,
                end: Q.value.length - 1,
                offset: void 0
            })
        }, {
            immediate: !0
        }), watch([G, U, function () {
            return X.scrollTop
        }, Q, ve, function () {
            return C.height
        }, pe], function () {
            if (!(!U.value || !G.value)) {
                for (var Ve = 0, ke, Ee, Ae, Re = Q.value.length, He = Q.value, je = X.scrollTop,
                        Fe = C.itemHeight, Le = C.height, Ie = je + Le, Te = 0; Te < Re; Te += 1) {
                    var De = He[Te],
                        Ke = ae(De),
                        We = de.get(Ke);
                    We === void 0 && (We = Fe);
                    var Ue = Ve + We;
                    ke === void 0 && Ue >= je && (ke = Te, Ee = Ve), Ae === void 0 && Ue > Ie && (
                        Ae = Te), Ve = Ue
                }
                ke === void 0 && (ke = 0, Ee = 0), Ae === void 0 && (Ae = Re - 1), Ae = Math.min(Ae +
                    1, Re), _extends$1(fe, {
                    scrollHeight: Ve,
                    start: ke,
                    end: Ae,
                    offset: Ee
                })
            }
        }, {
            immediate: !0
        });
        var me = computed(function () {
            return fe.scrollHeight - C.height
        });

        function he(Ve) {
            var ke = Ve;
            return Number.isNaN(me.value) || (ke = Math.min(ke, me.value)), ke = Math.max(ke, 0), ke
        }
        var Se = computed(function () {
                return X.scrollTop <= 0
            }),
            _e = computed(function () {
                return X.scrollTop >= me.value
            }),
            be = useOriginScroll(Se, _e);

        function ge(Ve) {
            var ke = Ve;
            ie(ke)
        }

        function xe(Ve) {
            var ke, Ee = Ve.currentTarget.scrollTop;
            Math.abs(Ee - X.scrollTop) >= 1 && ie(Ee), (ke = C.onScroll) === null || ke === void 0 || ke.call(
                C, Ve)
        }
        var Pe = useFrameWheel(U, Se, _e, function (Ve) {
                ie(function (ke) {
                    var Ee = ke + Ve;
                    return Ee
                })
            }),
            $e = _slicedToArray$2(Pe, 2),
            ye = $e[0],
            Ce = $e[1];
        useMobileTouchMove(U, ne, function (Ve, ke) {
            return be(Ve, ke) ? !1 : (ye({
                preventDefault: function () {},
                deltaY: Ve
            }), !0)
        });

        function we(Ve) {
            U.value && Ve.preventDefault()
        }
        var Oe = function () {
            ne.value && (ne.value.removeEventListener("wheel", ye, supportsPassive$1 ? {
                passive: !1
            } : !1), ne.value.removeEventListener("DOMMouseScroll", Ce), ne.value.removeEventListener(
                "MozMousePixelScroll", we))
        };
        watchEffect(function () {
            nextTick(function () {
                ne.value && (Oe(), ne.value.addEventListener("wheel", ye, supportsPassive$1 ?
                        {
                            passive: !1
                        } : !1), ne.value.addEventListener("DOMMouseScroll", Ce), ne.value
                    .addEventListener("MozMousePixelScroll", we))
            })
        }), onBeforeUnmount(function () {
            Oe()
        });
        var Ne = useScrollTo(ne, Q, de, C, ae, ce, ie, function () {
            var Ve;
            (Ve = re.value) === null || Ve === void 0 || Ve.delayHidden()
        });
        W({
            scrollTo: Ne
        });
        var Me = computed(function () {
            var Ve = null;
            return C.height && (Ve = _objectSpread2$1(_defineProperty$V({}, C.fullHeight ? "height" :
                "maxHeight", C.height + "px"), ScrollStyle), U.value && (Ve.overflowY =
                "hidden", X.scrollMoving && (Ve.pointerEvents = "none"))), Ve
        });
        return watch([function () {
            return fe.start
        }, function () {
            return fe.end
        }, Q], function () {
            if (C.onVisibleChange) {
                var Ve = Q.value.slice(fe.start, fe.end + 1);
                C.onVisibleChange(Ve, Q.value)
            }
        }, {
            flush: "post"
        }), {
            state: X,
            mergedData: Q,
            componentStyle: Me,
            onFallbackScroll: xe,
            onScrollBar: ge,
            componentRef: ne,
            useVirtual: U,
            calRes: fe,
            collectHeight: ce,
            setInstance: se,
            sharedConfig: oe,
            scrollBarRef: re,
            fillerInnerRef: te
        }
    },
    render: function () {
        var C = this,
            H = _objectSpread2$1(_objectSpread2$1({}, this.$props), this.$attrs),
            W = H.prefixCls,
            U = W === void 0 ? "rc-virtual-list" : W,
            G = H.height;
        H.itemHeight, H.fullHeight, H.data, H.itemKey, H.virtual;
        var X = H.component,
            Z = X === void 0 ? "div" : X;
        H.onScroll;
        var Q = H.children,
            ee = Q === void 0 ? this.$slots.default : Q,
            ne = H.style,
            te = H.class,
            re = _objectWithoutProperties$2(H, _excluded$V),
            ae = classNames(U, te),
            oe = this.state.scrollTop,
            ie = this.calRes,
            ue = ie.scrollHeight,
            le = ie.offset,
            se = ie.start,
            ce = ie.end,
            de = this.componentStyle,
            ve = this.onFallbackScroll,
            fe = this.onScrollBar,
            pe = this.useVirtual,
            me = this.collectHeight,
            he = this.sharedConfig,
            Se = this.setInstance,
            _e = this.mergedData;
        return createVNode("div", _objectSpread2$1({
            style: _objectSpread2$1(_objectSpread2$1({}, ne), {}, {
                position: "relative"
            }),
            class: ae
        }, re), [createVNode(Z, {
            class: "".concat(U, "-holder"),
            style: de,
            ref: "componentRef",
            onScroll: ve
        }, {
            default: function () {
                return [createVNode(Filler, {
                    prefixCls: U,
                    height: ue,
                    offset: le,
                    onInnerResize: me,
                    ref: "fillerInnerRef"
                }, {
                    default: function () {
                        return renderChildren(_e, se, ce, Se, ee, he)
                    }
                })]
            }
        }), pe && createVNode(ScrollBar, {
            ref: "scrollBarRef",
            prefixCls: U,
            scrollTop: oe,
            height: G,
            scrollHeight: ue,
            count: _e.length,
            onScroll: fe,
            onStartMove: function () {
                C.state.scrollMoving = !0
            },
            onStopMove: function () {
                C.state.scrollMoving = !1
            }
        }, null)])
    }
});
const List$4 = List$3;

function useMemo(K, C, H) {
    var W = ref(K());
    return watch(C, function (U, G) {
        H ? H(U, G) && (W.value = K()) : W.value = K()
    }), W
}

function isPlatformMac() {
    return /(mac\sos|macintosh)/i.test(navigator.appVersion)
}
var SelectContextKey = Symbol("SelectContextKey");

function useProvideSelectProps(K) {
    return provide(SelectContextKey, K)
}

function useSelectProps() {
    return inject(SelectContextKey, {})
}
var _excluded$U = ["disabled", "title", "children", "style", "class", "className"];

function isTitleType(K) {
    return typeof K == "string" || typeof K == "number"
}
var OptionList$2 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "OptionList",
    inheritAttrs: !1,
    slots: ["option"],
    setup: function (C, H) {
        var W = H.expose,
            U = H.slots,
            G = useBaseProps(),
            X = useSelectProps(),
            Z = computed(function () {
                return "".concat(G.prefixCls, "-item")
            }),
            Q = useMemo(function () {
                return X.flattenOptions
            }, [function () {
                return G.open
            }, function () {
                return X.flattenOptions
            }], function (fe) {
                return fe[0]
            }),
            ee = createRef(),
            ne = function (pe) {
                pe.preventDefault()
            },
            te = function (pe) {
                ee.current && ee.current.scrollTo(typeof pe == "number" ? {
                    index: pe
                } : pe)
            },
            re = function (pe) {
                for (var me = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, he = Q.value
                        .length, Se = 0; Se < he; Se += 1) {
                    var _e = (pe + Se * me + he) % he,
                        be = Q.value[_e],
                        ge = be.group,
                        xe = be.data;
                    if (!ge && !xe.disabled) return _e
                }
                return -1
            },
            ae = reactive({
                activeIndex: re(0)
            }),
            oe = function (pe) {
                var me = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
                ae.activeIndex = pe;
                var he = {
                        source: me ? "keyboard" : "mouse"
                    },
                    Se = Q.value[pe];
                if (!Se) {
                    X.onActiveValue(null, -1, he);
                    return
                }
                X.onActiveValue(Se.value, pe, he)
            };
        watch([function () {
            return Q.value.length
        }, function () {
            return G.searchValue
        }], function () {
            oe(X.defaultActiveFirstOption !== !1 ? re(0) : -1)
        }, {
            immediate: !0
        });
        var ie = function (pe) {
            return X.rawValues.has(pe) && G.mode !== "combobox"
        };
        watch([function () {
            return G.open
        }, function () {
            return G.searchValue
        }], function () {
            if (!G.multiple && G.open && X.rawValues.size === 1) {
                var fe = Array.from(X.rawValues)[0],
                    pe = toRaw(Q.value).findIndex(function (me) {
                        var he = me.data;
                        return he[X.fieldNames.value] === fe
                    });
                pe !== -1 && (oe(pe), nextTick(function () {
                    te(pe)
                }))
            }
            G.open && nextTick(function () {
                var me;
                (me = ee.current) === null || me === void 0 || me.scrollTo(void 0)
            })
        }, {
            immediate: !0,
            flush: "post"
        });
        var ue = function (pe) {
                pe !== void 0 && X.onSelect(pe, {
                    selected: !X.rawValues.has(pe)
                }), G.multiple || G.toggleOpen(!1)
            },
            le = function (pe) {
                return typeof pe.label == "function" ? pe.label() : pe.label
            };

        function se(fe) {
            var pe = Q.value[fe];
            if (!pe) return null;
            var me = pe.data || {},
                he = me.value,
                Se = pe.group,
                _e = pickAttrs(me, !0),
                be = le(pe);
            return pe ? createVNode("div", _objectSpread2$1(_objectSpread2$1({
                "aria-label": typeof be == "string" && !Se ? be : null
            }, _e), {}, {
                key: fe,
                role: Se ? "presentation" : "option",
                id: "".concat(G.id, "_list_").concat(fe),
                "aria-selected": ie(he)
            }), [he]) : null
        }
        var ce = function (pe) {
                var me = pe.which,
                    he = pe.ctrlKey;
                switch (me) {
                    case KeyCode$1.N:
                    case KeyCode$1.P:
                    case KeyCode$1.UP:
                    case KeyCode$1.DOWN:
                        {
                            var Se = 0;
                            if (me === KeyCode$1.UP ? Se = -1 : me === KeyCode$1.DOWN ? Se = 1 :
                                isPlatformMac() && he && (me === KeyCode$1.N ? Se = 1 : me === KeyCode$1.P &&
                                    (Se = -1)), Se !== 0) {
                                var _e = re(ae.activeIndex + Se, Se);
                                te(_e), oe(_e, !0)
                            }
                            break
                        }
                    case KeyCode$1.ENTER:
                        {
                            var be = Q.value[ae.activeIndex];be && !be.data.disabled ? ue(be.value) : ue(
                                void 0),
                            G.open && pe.preventDefault();
                            break
                        }
                    case KeyCode$1.ESC:
                        G.toggleOpen(!1), G.open && pe.stopPropagation()
                }
            },
            de = function () {},
            ve = function (pe) {
                te(pe)
            };
        return W({
                onKeydown: ce,
                onKeyup: de,
                scrollTo: ve
            }),
            function () {
                var fe = G.id,
                    pe = G.notFoundContent,
                    me = G.onPopupScroll,
                    he = X.menuItemSelectedIcon,
                    Se = X.fieldNames,
                    _e = X.virtual,
                    be = X.listHeight,
                    ge = X.listItemHeight,
                    xe = U.option,
                    Pe = ae.activeIndex,
                    $e = Object.keys(Se).map(function (ye) {
                        return Se[ye]
                    });
                return Q.value.length === 0 ? createVNode("div", {
                    role: "listbox",
                    id: "".concat(fe, "_list"),
                    class: "".concat(Z.value, "-empty"),
                    onMousedown: ne
                }, [pe]) : createVNode(Fragment, null, [createVNode("div", {
                    role: "listbox",
                    id: "".concat(fe, "_list"),
                    style: {
                        height: 0,
                        width: 0,
                        overflow: "hidden"
                    }
                }, [se(Pe - 1), se(Pe), se(Pe + 1)]), createVNode(List$4, {
                    itemKey: "key",
                    ref: ee,
                    data: Q.value,
                    height: be,
                    itemHeight: ge,
                    fullHeight: !1,
                    onMousedown: ne,
                    onScroll: me,
                    virtual: _e
                }, {
                    default: function (Ce, we) {
                        var Oe, Ne = Ce.group,
                            Me = Ce.groupOption,
                            Ve = Ce.data,
                            ke = Ce.value,
                            Ee = Ve.key,
                            Ae = typeof Ce.label == "function" ? Ce.label() : Ce.label;
                        if (Ne) {
                            var Re, He = (Re = Ve.title) !== null && Re !== void 0 ? Re :
                                isTitleType(Ae) && Ae;
                            return createVNode("div", {
                                class: classNames(Z.value, "".concat(Z.value,
                                    "-group")),
                                title: He
                            }, [xe ? xe(Ve) : Ae !== void 0 ? Ae : Ee])
                        }
                        var je = Ve.disabled,
                            Fe = Ve.title;
                        Ve.children;
                        var Le = Ve.style,
                            Ie = Ve.class,
                            Te = Ve.className,
                            De = _objectWithoutProperties$2(Ve, _excluded$U),
                            Ke = omit$2(De, $e),
                            We = ie(ke),
                            Ue = "".concat(Z.value, "-option"),
                            et = classNames(Z.value, Ue, Ie, Te, (Oe = {},
                                _defineProperty$V(Oe, "".concat(Ue, "-grouped"), Me),
                                _defineProperty$V(Oe, "".concat(Ue, "-active"), Pe ===
                                    we && !je), _defineProperty$V(Oe, "".concat(Ue,
                                    "-disabled"), je), _defineProperty$V(Oe, "".concat(
                                    Ue, "-selected"), We), Oe)),
                            Ye = le(Ce),
                            ze = !he || typeof he == "function" || We,
                            Be = typeof Ye == "number" ? Ye : Ye || ke,
                            Ge = isTitleType(Be) ? Be.toString() : void 0;
                        return Fe !== void 0 && (Ge = Fe), createVNode("div",
                            _objectSpread2$1(_objectSpread2$1({}, Ke), {}, {
                                "aria-selected": We,
                                class: et,
                                title: Ge,
                                onMousemove: function (nt) {
                                    De.onMousemove && De.onMousemove(nt), !
                                        (Pe === we || je) && oe(we)
                                },
                                onClick: function (nt) {
                                    je || ue(ke), De.onClick && De.onClick(
                                        nt)
                                },
                                style: Le
                            }), [createVNode("div", {
                                    class: "".concat(Ue, "-content")
                                }, [xe ? xe(Ve) : Be]), isValidElement(he) || We,
                                ze && createVNode(TransBtn$1, {
                                    class: "".concat(Z.value, "-option-state"),
                                    customizeIcon: he,
                                    customizeIconProps: {
                                        isSelected: We
                                    }
                                }, {
                                    default: function () {
                                        return [We ? "" : null]
                                    }
                                })])
                    }
                })])
            }
    }
});
const OptionList$3 = OptionList$2;
var _excluded$T = ["value", "disabled"];

function convertNodeToOption(K) {
    var C = K.key,
        H = K.children,
        W = K.props,
        U = W.value,
        G = W.disabled,
        X = _objectWithoutProperties$2(W, _excluded$T),
        Z = H == null ? void 0 : H.default;
    return _objectSpread2$1({
        key: C,
        value: U !== void 0 ? U : C,
        children: Z,
        disabled: G || G === ""
    }, X)
}

function convertChildrenToData$1(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
        H = flattenChildren(K).map(function (W, U) {
            var G;
            if (!isValidElement(W) || !W.type) return null;
            var X = W.type.isSelectOptGroup,
                Z = W.key,
                Q = W.children,
                ee = W.props;
            if (C || !X) return convertNodeToOption(W);
            var ne = Q && Q.default ? Q.default() : void 0,
                te = (ee == null ? void 0 : ee.label) || ((G = Q.label) === null || G === void 0 ? void 0 : G.call(
                    Q)) || Z;
            return _objectSpread2$1(_objectSpread2$1({
                key: "__RC_SELECT_GRP__".concat(Z === null ? U : String(Z), "__")
            }, ee), {}, {
                label: te,
                options: convertChildrenToData$1(ne || [])
            })
        }).filter(function (W) {
            return W
        });
    return H
}

function useOptions(K, C, H) {
    var W = shallowRef(),
        U = shallowRef(),
        G = shallowRef(),
        X = shallowRef([]);
    return watch([K, C], function () {
        K.value ? X.value = toRaw(K.value).slice() : X.value = convertChildrenToData$1(C.value)
    }, {
        immediate: !0,
        deep: !0
    }), watchEffect(function () {
        var Z = X.value,
            Q = new Map,
            ee = new Map,
            ne = H.value;

        function te(re) {
            for (var ae = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, oe = 0; oe < re.length; oe +=
                1) {
                var ie = re[oe];
                !ie[ne.options] || ae ? (Q.set(ie[ne.value], ie), ee.set(ie[ne.label], ie)) : te(ie[ne.options],
                    !0)
            }
        }
        te(Z), W.value = Z, U.value = Q, G.value = ee
    }), {
        options: W,
        valueOptions: U,
        labelOptions: G
    }
}
var uuid$4 = 0,
    isBrowserClient = canUseDom();

function getUUID$1() {
    var K;
    return isBrowserClient ? (K = uuid$4, uuid$4 += 1) : K = "TEST_OR_SSR", K
}

function useId() {
    var K = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ref(""),
        C = "rc_select_".concat(getUUID$1());
    return K.value || C
}

function toArray$8(K) {
    return Array.isArray(K) ? K : K !== void 0 ? [K] : []
}

function includes(K, C) {
    return toArray$8(K).join("").toUpperCase().includes(C)
}
const useFilterOptions = function (K, C, H, W, U) {
        return computed(function () {
            var G = H.value,
                X = U == null ? void 0 : U.value,
                Z = W == null ? void 0 : W.value;
            if (!G || Z === !1) return K.value;
            var Q = C.value,
                ee = Q.options,
                ne = Q.label,
                te = Q.value,
                re = [],
                ae = typeof Z == "function",
                oe = G.toUpperCase(),
                ie = ae ? Z : function (le, se) {
                    return X ? includes(se[X], oe) : se[ee] ? includes(se[ne !== "children" ? ne : "label"], oe) :
                        includes(se[te], oe)
                },
                ue = ae ? function (le) {
                    return injectPropsWithOption(le)
                } : function (le) {
                    return le
                };
            return K.value.forEach(function (le) {
                if (le[ee]) {
                    var se = ie(G, ue(le));
                    if (se) re.push(le);
                    else {
                        var ce = le[ee].filter(function (de) {
                            return ie(G, ue(de))
                        });
                        ce.length && re.push(_objectSpread2$1(_objectSpread2$1({}, le), {},
                            _defineProperty$V({}, ee, ce)))
                    }
                    return
                }
                ie(G, ue(le)) && re.push(le)
            }), re
        })
    },
    useCache$1 = function (K, C) {
        var H = shallowRef({
                values: new Map,
                options: new Map
            }),
            W = computed(function () {
                var G = H.value,
                    X = G.values,
                    Z = G.options,
                    Q = K.value.map(function (te) {
                        if (te.label === void 0) {
                            var re;
                            return _objectSpread2$1(_objectSpread2$1({}, te), {}, {
                                label: (re = X.get(te.value)) === null || re === void 0 ? void 0 : re.label
                            })
                        }
                        return te
                    }),
                    ee = new Map,
                    ne = new Map;
                return Q.forEach(function (te) {
                    ee.set(te.value, te), ne.set(te.value, C.value.get(te.value) || Z.get(te.value))
                }), H.value.values = ee, H.value.options = ne, Q
            }),
            U = function (X) {
                return C.value.get(X) || H.value.options.get(X)
            };
        return [W, U]
    };

function useMergedState(K, C) {
    var H = C || {},
        W = H.defaultValue,
        U = H.value,
        G = U === void 0 ? ref() : U,
        X = typeof K == "function" ? K() : K;
    G.value !== void 0 && (X = unref(G)), W !== void 0 && (X = typeof W == "function" ? W() : W);
    var Z = ref(X),
        Q = ref(X);
    watchEffect(function () {
        var ne = G.value !== void 0 ? G.value : Z.value;
        C.postState && (ne = C.postState(ne)), Q.value = ne
    });

    function ee(ne) {
        var te = Q.value;
        Z.value = ne, toRaw(Q.value) !== ne && C.onChange && C.onChange(ne, te)
    }
    return watch(G, function () {
        Z.value = G.value
    }), [Q, ee]
}

function useState(K) {
    var C = typeof K == "function" ? K() : K,
        H = ref(C);

    function W(U) {
        H.value = U
    }
    return [H, W]
}
var OMIT_DOM_PROPS = ["inputValue"];

function selectProps$1() {
    return _objectSpread2$1(_objectSpread2$1({}, baseSelectPropsWithoutPrivate()), {}, {
        prefixCls: String,
        id: String,
        backfill: {
            type: Boolean,
            default: void 0
        },
        fieldNames: Object,
        inputValue: String,
        searchValue: String,
        onSearch: Function,
        autoClearSearchValue: {
            type: Boolean,
            default: void 0
        },
        onSelect: Function,
        onDeselect: Function,
        filterOption: {
            type: [Boolean, Function],
            default: void 0
        },
        filterSort: Function,
        optionFilterProp: String,
        optionLabelProp: String,
        options: Array,
        defaultActiveFirstOption: {
            type: Boolean,
            default: void 0
        },
        virtual: {
            type: Boolean,
            default: void 0
        },
        listHeight: Number,
        listItemHeight: Number,
        menuItemSelectedIcon: PropTypes$1.any,
        mode: String,
        labelInValue: {
            type: Boolean,
            default: void 0
        },
        value: PropTypes$1.any,
        defaultValue: PropTypes$1.any,
        onChange: Function,
        children: Array
    })
}

function isRawValue$1(K) {
    return !K || _typeof$2(K) !== "object"
}
const Select$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Select",
    inheritAttrs: !1,
    props: initDefaultProps$1(selectProps$1(), {
        prefixCls: "vc-select",
        autoClearSearchValue: !0,
        listHeight: 200,
        listItemHeight: 20,
        dropdownMatchSelectWidth: !0
    }),
    setup: function (C, H) {
        var W = H.expose,
            U = H.attrs,
            G = H.slots,
            X = useId(toRef(C, "id")),
            Z = computed(function () {
                return isMultiple(C.mode)
            }),
            Q = computed(function () {
                return !!(!C.options && C.children)
            }),
            ee = computed(function () {
                return C.filterOption === void 0 && C.mode === "combobox" ? !1 : C.filterOption
            }),
            ne = computed(function () {
                return fillFieldNames$3(C.fieldNames, Q.value)
            }),
            te = useMergedState("", {
                value: computed(function () {
                    return C.searchValue !== void 0 ? C.searchValue : C.inputValue
                }),
                postState: function (Be) {
                    return Be || ""
                }
            }),
            re = _slicedToArray$2(te, 2),
            ae = re[0],
            oe = re[1],
            ie = useOptions(toRef(C, "options"), toRef(C, "children"), ne),
            ue = ie.valueOptions,
            le = ie.labelOptions,
            se = ie.options,
            ce = function (Be) {
                var Ge = toArray$8(Be);
                return Ge.map(function (Xe) {
                    var nt, it, ft, pt;
                    if (isRawValue$1(Xe)) nt = Xe;
                    else {
                        var ot;
                        ft = Xe.key, it = Xe.label, nt = (ot = Xe.value) !== null && ot !== void 0 ?
                            ot : ft
                    }
                    var Ze = ue.value.get(nt);
                    if (Ze) {
                        var ut;
                        it === void 0 && (it = Ze == null ? void 0 : Ze[C.optionLabelProp || ne.value
                            .label]), ft === void 0 && (ft = (ut = Ze == null ? void 0 : Ze.key) !==
                            null && ut !== void 0 ? ut : nt), pt = Ze == null ? void 0 : Ze.disabled
                    }
                    return {
                        label: it,
                        value: nt,
                        key: ft,
                        disabled: pt,
                        option: Ze
                    }
                })
            },
            de = useMergedState(C.defaultValue, {
                value: toRef(C, "value")
            }),
            ve = _slicedToArray$2(de, 2),
            fe = ve[0],
            pe = ve[1],
            me = computed(function () {
                var ze, Be = ce(fe.value);
                return C.mode === "combobox" && !((ze = Be[0]) !== null && ze !== void 0 && ze.value) ?
                    [] : Be
            }),
            he = useCache$1(me, ue),
            Se = _slicedToArray$2(he, 2),
            _e = Se[0],
            be = Se[1],
            ge = computed(function () {
                if (!C.mode && _e.value.length === 1) {
                    var ze = _e.value[0];
                    if (ze.value === null && (ze.label === null || ze.label === void 0)) return []
                }
                return _e.value.map(function (Be) {
                    var Ge;
                    return _objectSpread2$1(_objectSpread2$1({}, Be), {}, {
                        label: (Ge = typeof Be.label == "function" ? Be.label() : Be.label) !==
                            null && Ge !== void 0 ? Ge : Be.value
                    })
                })
            }),
            xe = computed(function () {
                return new Set(_e.value.map(function (ze) {
                    return ze.value
                }))
            });
        watchEffect(function () {
            if (C.mode === "combobox") {
                var ze, Be = (ze = _e.value[0]) === null || ze === void 0 ? void 0 : ze.value;
                Be != null && oe(String(Be))
            }
        }, {
            flush: "post"
        });
        var Pe = function (Be, Ge) {
                var Xe, nt = Ge || Be;
                return Xe = {}, _defineProperty$V(Xe, ne.value.value, Be), _defineProperty$V(Xe, ne.value.label,
                    nt), Xe
            },
            $e = shallowRef();
        watchEffect(function () {
            if (C.mode !== "tags") {
                $e.value = se.value;
                return
            }
            var ze = se.value.slice(),
                Be = function (Xe) {
                    return ue.value.has(Xe)
                };
            _toConsumableArray(_e.value).sort(function (Ge, Xe) {
                return Ge.value < Xe.value ? -1 : 1
            }).forEach(function (Ge) {
                var Xe = Ge.value;
                Be(Xe) || ze.push(Pe(Xe, Ge.label))
            }), $e.value = ze
        });
        var ye = useFilterOptions($e, ne, ae, ee, toRef(C, "optionFilterProp")),
            Ce = computed(function () {
                return C.mode !== "tags" || !ae.value || ye.value.some(function (ze) {
                    return ze[C.optionFilterProp || "value"] === ae.value
                }) ? ye.value : [Pe(ae.value)].concat(_toConsumableArray(ye.value))
            }),
            we = computed(function () {
                return C.filterSort ? _toConsumableArray(Ce.value).sort(function (ze, Be) {
                    return C.filterSort(ze, Be)
                }) : Ce.value
            }),
            Oe = computed(function () {
                return flattenOptions(we.value, {
                    fieldNames: ne.value,
                    childrenAsData: Q.value
                })
            }),
            Ne = function (Be) {
                var Ge = ce(Be);
                if (pe(Ge), C.onChange && (Ge.length !== _e.value.length || Ge.some(function (it, ft) {
                        var pt;
                        return ((pt = _e.value[ft]) === null || pt === void 0 ? void 0 : pt.value) !==
                            (it == null ? void 0 : it.value)
                    }))) {
                    var Xe = C.labelInValue ? Ge.map(function (it) {
                            return _objectSpread2$1(_objectSpread2$1({}, it), {}, {
                                originLabel: it.label,
                                label: typeof it.label == "function" ? it.label() : it.label
                            })
                        }) : Ge.map(function (it) {
                            return it.value
                        }),
                        nt = Ge.map(function (it) {
                            return injectPropsWithOption(be(it.value))
                        });
                    C.onChange(Z.value ? Xe : Xe[0], Z.value ? nt : nt[0])
                }
            },
            Me = useState(null),
            Ve = _slicedToArray$2(Me, 2),
            ke = Ve[0],
            Ee = Ve[1],
            Ae = useState(0),
            Re = _slicedToArray$2(Ae, 2),
            He = Re[0],
            je = Re[1],
            Fe = computed(function () {
                return C.defaultActiveFirstOption !== void 0 ? C.defaultActiveFirstOption : C.mode !==
                    "combobox"
            }),
            Le = function (Be, Ge) {
                var Xe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
                    nt = Xe.source,
                    it = nt === void 0 ? "keyboard" : nt;
                je(Ge), C.backfill && C.mode === "combobox" && Be !== null && it === "keyboard" && Ee(
                    String(Be))
            },
            Ie = function (Be, Ge) {
                var Xe = function () {
                    var qe, Je = be(Be),
                        Qe = Je == null ? void 0 : Je[ne.value.label];
                    return [C.labelInValue ? {
                        label: typeof Qe == "function" ? Qe() : Qe,
                        originLabel: Qe,
                        value: Be,
                        key: (qe = Je == null ? void 0 : Je.key) !== null && qe !== void 0 ? qe :
                            Be
                    } : Be, injectPropsWithOption(Je)]
                };
                if (Ge && C.onSelect) {
                    var nt = Xe(),
                        it = _slicedToArray$2(nt, 2),
                        ft = it[0],
                        pt = it[1];
                    C.onSelect(ft, pt)
                } else if (!Ge && C.onDeselect) {
                    var ot = Xe(),
                        Ze = _slicedToArray$2(ot, 2),
                        ut = Ze[0],
                        st = Ze[1];
                    C.onDeselect(ut, st)
                }
            },
            Te = function (Be, Ge) {
                var Xe, nt = Z.value ? Ge.selected : !0;
                nt ? Xe = Z.value ? [].concat(_toConsumableArray(_e.value), [Be]) : [Be] : Xe = _e.value.filter(
                        function (it) {
                            return it.value !== Be
                        }), Ne(Xe), Ie(Be, nt), C.mode === "combobox" ? Ee("") : (!Z.value || C.autoClearSearchValue) &&
                    (oe(""), Ee(""))
            },
            De = function (Be, Ge) {
                Ne(Be), (Ge.type === "remove" || Ge.type === "clear") && Ge.values.forEach(function (Xe) {
                    Ie(Xe.value, !1)
                })
            },
            Ke = function (Be, Ge) {
                if (oe(Be), Ee(null), Ge.source === "submit") {
                    var Xe = (Be || "").trim();
                    if (Xe) {
                        var nt = Array.from(new Set([].concat(_toConsumableArray(xe.value), [Xe])));
                        Ne(nt), Ie(Xe, !0), oe("")
                    }
                    return
                }
                if (Ge.source !== "blur") {
                    var it;
                    C.mode === "combobox" && Ne(Be), (it = C.onSearch) === null || it === void 0 || it.call(
                        C, Be)
                }
            },
            We = function (Be) {
                var Ge = Be;
                C.mode !== "tags" && (Ge = Be.map(function (nt) {
                    var it = le.value.get(nt);
                    return it == null ? void 0 : it.value
                }).filter(function (nt) {
                    return nt !== void 0
                }));
                var Xe = Array.from(new Set([].concat(_toConsumableArray(xe.value), _toConsumableArray(Ge))));
                Ne(Xe), Xe.forEach(function (nt) {
                    Ie(nt, !0)
                })
            },
            Ue = computed(function () {
                return C.virtual !== !1 && C.dropdownMatchSelectWidth !== !1
            });
        useProvideSelectProps(toReactive(_objectSpread2$1(_objectSpread2$1({}, ie), {}, {
            flattenOptions: Oe,
            onActiveValue: Le,
            defaultActiveFirstOption: Fe,
            onSelect: Te,
            menuItemSelectedIcon: toRef(C, "menuItemSelectedIcon"),
            rawValues: xe,
            fieldNames: ne,
            virtual: Ue,
            listHeight: toRef(C, "listHeight"),
            listItemHeight: toRef(C, "listItemHeight"),
            childrenAsData: Q
        })));
        var et = ref();
        W({
            focus: function () {
                var Be;
                (Be = et.value) === null || Be === void 0 || Be.focus()
            },
            blur: function () {
                var Be;
                (Be = et.value) === null || Be === void 0 || Be.blur()
            },
            scrollTo: function (Be) {
                var Ge;
                (Ge = et.value) === null || Ge === void 0 || Ge.scrollTo(Be)
            }
        });
        var Ye = computed(function () {
            return omit$2(C, ["id", "mode", "prefixCls", "backfill", "fieldNames", "inputValue",
                "searchValue", "onSearch", "autoClearSearchValue", "onSelect", "onDeselect",
                "dropdownMatchSelectWidth", "filterOption", "filterSort",
                "optionFilterProp", "optionLabelProp", "options", "children",
                "defaultActiveFirstOption", "menuItemSelectedIcon", "virtual", "listHeight",
                "listItemHeight", "value", "defaultValue", "labelInValue", "onChange"])
        });
        return function () {
            return createVNode(BaseSelect, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, Ye.value),
                U), {}, {
                id: X,
                prefixCls: C.prefixCls,
                ref: et,
                omitDomProps: OMIT_DOM_PROPS,
                mode: C.mode,
                displayValues: ge.value,
                onDisplayValuesChange: De,
                searchValue: ae.value,
                onSearch: Ke,
                onSearchSplit: We,
                dropdownMatchSelectWidth: C.dropdownMatchSelectWidth,
                OptionList: OptionList$3,
                emptyOptions: !Oe.value.length,
                activeValue: ke.value,
                activeDescendantId: "".concat(X, "_list_").concat(He.value)
            }), G)
        }
    }
});
var Option$3 = function () {
    return null
};
Option$3.isSelectOption = !0;
Option$3.displayName = "ASelectOption";
const Option$4 = Option$3;
var OptGroup$2 = function () {
    return null
};
OptGroup$2.isSelectOptGroup = !0;
OptGroup$2.displayName = "ASelectOptGroup";
const OptGroup$3 = OptGroup$2;
var DownOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"
            }
        }]
    },
    name: "down",
    theme: "outlined"
};
const DownOutlinedSvg = DownOutlined$2;

function _objectSpread$G(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$G(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$G(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var DownOutlined = function (C, H) {
    var W = _objectSpread$G({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$G({}, W, {
        icon: DownOutlinedSvg
    }), null)
};
DownOutlined.displayName = "DownOutlined";
DownOutlined.inheritAttrs = !1;
const DownOutlined$1 = DownOutlined;
var CheckOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z"
            }
        }]
    },
    name: "check",
    theme: "outlined"
};
const CheckOutlinedSvg = CheckOutlined$2;

function _objectSpread$F(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$F(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$F(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var CheckOutlined = function (C, H) {
    var W = _objectSpread$F({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$F({}, W, {
        icon: CheckOutlinedSvg
    }), null)
};
CheckOutlined.displayName = "CheckOutlined";
CheckOutlined.inheritAttrs = !1;
const CheckOutlined$1 = CheckOutlined;
var SearchOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z"
            }
        }]
    },
    name: "search",
    theme: "outlined"
};
const SearchOutlinedSvg = SearchOutlined$2;

function _objectSpread$E(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$E(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$E(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var SearchOutlined = function (C, H) {
    var W = _objectSpread$E({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$E({}, W, {
        icon: SearchOutlinedSvg
    }), null)
};
SearchOutlined.displayName = "SearchOutlined";
SearchOutlined.inheritAttrs = !1;
const SearchOutlined$1 = SearchOutlined;

function getIcons(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        H = K.loading,
        W = K.multiple,
        U = K.prefixCls,
        G = K.suffixIcon || C.suffixIcon && C.suffixIcon(),
        X = K.clearIcon || C.clearIcon && C.clearIcon(),
        Z = K.menuItemSelectedIcon || C.menuItemSelectedIcon && C.menuItemSelectedIcon(),
        Q = K.removeIcon || C.removeIcon && C.removeIcon(),
        ee = X;
    X || (ee = createVNode(CloseCircleFilled$1, null, null));
    var ne = null;
    if (G !== void 0) ne = G;
    else if (H) ne = createVNode(LoadingOutlined$1, {
        spin: !0
    }, null);
    else {
        var te = "".concat(U, "-suffix");
        ne = function (ie) {
            var ue = ie.open,
                le = ie.showSearch;
            return ue && le ? createVNode(SearchOutlined$1, {
                class: te
            }, null) : createVNode(DownOutlined$1, {
                class: te
            }, null)
        }
    }
    var re = null;
    Z !== void 0 ? re = Z : W ? re = createVNode(CheckOutlined$1, null, null) : re = null;
    var ae = null;
    return Q !== void 0 ? ae = Q : ae = createVNode(CloseOutlined$1, null, null), {
        clearIcon: ee,
        suffixIcon: ne,
        itemIcon: re,
        removeIcon: ae
    }
}
var ContextKey$1 = Symbol("ContextProps"),
    InternalContextKey = Symbol("InternalContextProps"),
    useProvideFormItemContext = function (C) {
        var H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : computed(function () {
                return !0
            }),
            W = ref(new Map),
            U = function (Z, Q) {
                W.value.set(Z, Q), W.value = new Map(W.value)
            },
            G = function (Z) {
                W.value.delete(Z), W.value = new Map(W.value)
            };
        getCurrentInstance(), watch([H, W], function () {}), provide(ContextKey$1, C), provide(InternalContextKey, {
            addFormItemField: U,
            removeFormItemField: G
        })
    },
    defaultContext = {
        id: computed(function () {}),
        onFieldBlur: function () {},
        onFieldChange: function () {},
        clearValidate: function () {}
    },
    defaultInternalContext = {
        addFormItemField: function () {},
        removeFormItemField: function () {}
    },
    useInjectFormItemContext = function () {
        var C = inject(InternalContextKey, defaultInternalContext),
            H = Symbol("FormItemFieldKey"),
            W = getCurrentInstance();
        return C.addFormItemField(H, W.type), onBeforeUnmount(function () {
            C.removeFormItemField(H)
        }), provide(InternalContextKey, defaultInternalContext), provide(ContextKey$1, defaultContext), inject(
            ContextKey$1, defaultContext)
    };
const FormItemRest = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AFormItemRest",
    setup: function (C, H) {
        var W = H.slots;
        return provide(InternalContextKey, defaultInternalContext), provide(ContextKey$1, defaultContext),
            function () {
                var U;
                return (U = W.default) === null || U === void 0 ? void 0 : U.call(W)
            }
    }
});
var selectProps = function () {
        return _objectSpread2$1(_objectSpread2$1({}, omit$2(selectProps$1(), ["inputIcon", "mode", "getInputElement",
            "getRawInputElement", "backfill"])), {}, {
            value: {
                type: [Array, Object, String, Number]
            },
            defaultValue: {
                type: [Array, Object, String, Number]
            },
            notFoundContent: PropTypes$1.any,
            suffixIcon: PropTypes$1.any,
            itemIcon: PropTypes$1.any,
            size: String,
            mode: String,
            bordered: {
                type: Boolean,
                default: !0
            },
            transitionName: String,
            choiceTransitionName: {
                type: String,
                default: ""
            },
            "onUpdate:value": Function
        })
    },
    SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE",
    Select = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ASelect",
        Option: Option$4,
        OptGroup: OptGroup$3,
        inheritAttrs: !1,
        props: initDefaultProps$1(selectProps(), {
            listHeight: 256,
            listItemHeight: 24
        }),
        SECRET_COMBOBOX_MODE_DO_NOT_USE,
        slots: ["notFoundContent", "suffixIcon", "itemIcon", "removeIcon", "clearIcon", "dropdownRender", "option",
            "placeholder", "tagRender", "maxTagPlaceholder", "optionLabel"],
        setup: function (C, H) {
            var W = H.attrs,
                U = H.emit,
                G = H.slots,
                X = H.expose,
                Z = ref(),
                Q = useInjectFormItemContext(),
                ee = function () {
                    var Se;
                    (Se = Z.value) === null || Se === void 0 || Se.focus()
                },
                ne = function () {
                    var Se;
                    (Se = Z.value) === null || Se === void 0 || Se.blur()
                },
                te = function (Se) {
                    var _e;
                    (_e = Z.value) === null || _e === void 0 || _e.scrollTo(Se)
                },
                re = computed(function () {
                    var he = C.mode;
                    if (he !== "combobox") return he === SECRET_COMBOBOX_MODE_DO_NOT_USE ? "combobox" : he
                }),
                ae = useConfigInject("select", C),
                oe = ae.prefixCls,
                ie = ae.direction,
                ue = ae.configProvider,
                le = ae.size,
                se = ae.getPrefixCls,
                ce = computed(function () {
                    return se()
                }),
                de = computed(function () {
                    return getTransitionName$2(ce.value, "slide-up", C.transitionName)
                }),
                ve = computed(function () {
                    var he;
                    return classNames((he = {}, _defineProperty$V(he, "".concat(oe.value, "-lg"), le.value ===
                            "large"), _defineProperty$V(he, "".concat(oe.value, "-sm"), le.value ===
                            "small"), _defineProperty$V(he, "".concat(oe.value, "-rtl"), ie.value ===
                            "rtl"), _defineProperty$V(he, "".concat(oe.value, "-borderless"), !C.bordered),
                        he))
                }),
                fe = function () {
                    for (var Se = arguments.length, _e = new Array(Se), be = 0; be < Se; be++) _e[be] =
                        arguments[be];
                    U("update:value", _e[0]), U.apply(void 0, ["change"].concat(_e)), Q.onFieldChange()
                },
                pe = function (Se) {
                    U("blur", Se), Q.onFieldBlur()
                };
            X({
                blur: ne,
                focus: ee,
                scrollTo: te
            });
            var me = computed(function () {
                return re.value === "multiple" || re.value === "tags"
            });
            return function () {
                var he, Se, _e = C.notFoundContent,
                    be = C.listHeight,
                    ge = be === void 0 ? 256 : be,
                    xe = C.listItemHeight,
                    Pe = xe === void 0 ? 24 : xe,
                    $e = C.getPopupContainer,
                    ye = C.dropdownClassName,
                    Ce = C.virtual,
                    we = C.dropdownMatchSelectWidth,
                    Oe = C.id,
                    Ne = Oe === void 0 ? Q.id.value : Oe,
                    Me = C.placeholder,
                    Ve = Me === void 0 ? (he = G.placeholder) === null || he === void 0 ? void 0 : he.call(
                        G) : Me,
                    ke = ue.renderEmpty,
                    Ee = ue.getPopupContainer,
                    Ae;
                _e !== void 0 ? Ae = _e : G.notFoundContent ? Ae = G.notFoundContent() : re.value ===
                    "combobox" ? Ae = null : Ae = ke("Select");
                var Re = getIcons(_objectSpread2$1(_objectSpread2$1({}, C), {}, {
                        multiple: me.value,
                        prefixCls: oe.value
                    }), G),
                    He = Re.suffixIcon,
                    je = Re.itemIcon,
                    Fe = Re.removeIcon,
                    Le = Re.clearIcon,
                    Ie = omit$2(C, ["prefixCls", "suffixIcon", "itemIcon", "removeIcon", "clearIcon",
                        "size", "bordered"]),
                    Te = classNames(ye, _defineProperty$V({}, "".concat(oe.value, "-dropdown-").concat(ie.value),
                        ie.value === "rtl"));
                return createVNode(Select$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                    ref: Z,
                    virtual: Ce,
                    dropdownMatchSelectWidth: we
                }, Ie), W), {}, {
                    placeholder: Ve,
                    listHeight: ge,
                    listItemHeight: Pe,
                    mode: re.value,
                    prefixCls: oe.value,
                    direction: ie.value,
                    inputIcon: He,
                    menuItemSelectedIcon: je,
                    removeIcon: Fe,
                    clearIcon: Le,
                    notFoundContent: Ae,
                    class: [ve.value, W.class],
                    getPopupContainer: $e || Ee,
                    dropdownClassName: Te,
                    onChange: fe,
                    onBlur: pe,
                    id: Ne,
                    dropdownRender: Ie.dropdownRender || G.dropdownRender,
                    transitionName: de.value,
                    children: (Se = G.default) === null || Se === void 0 ? void 0 : Se.call(G),
                    tagRender: C.tagRender || G.tagRender,
                    optionLabelRender: G.optionLabel,
                    maxTagPlaceholder: C.maxTagPlaceholder || G.maxTagPlaceholder
                }), {
                    option: G.option
                })
            }
        }
    });
Select.install = function (K) {
    return K.component(Select.name, Select), K.component(Select.Option.displayName, Select.Option), K.component(
        Select.OptGroup.displayName, Select.OptGroup), K
};
var SelectOption = Select.Option,
    SelectOptGroup = Select.OptGroup;
const VcSelect = Select;
var Option$1 = function () {
    return null
};
Option$1.isSelectOption = !0;
Option$1.displayName = "AAutoCompleteOption";
const Option$2 = Option$1;
var OptGroup = function () {
    return null
};
OptGroup.isSelectOptGroup = !0;
OptGroup.displayName = "AAutoCompleteOptGroup";
const OptGroup$1 = OptGroup;

function isSelectOptionOrSelectOptGroup(K) {
    var C, H;
    return (K == null || (C = K.type) === null || C === void 0 ? void 0 : C.isSelectOption) || (K == null || (H = K.type) ===
        null || H === void 0 ? void 0 : H.isSelectOptGroup)
}
var autoCompleteProps = function () {
        return _objectSpread2$1(_objectSpread2$1({}, omit$2(selectProps(), ["loading", "mode", "optionLabelProp",
            "labelInValue"])), {}, {
            dataSource: Array,
            dropdownMenuStyle: {
                type: Object,
                default: void 0
            },
            dropdownMatchSelectWidth: {
                type: [Number, Boolean],
                default: !0
            },
            prefixCls: String,
            showSearch: {
                type: Boolean,
                default: void 0
            },
            transitionName: String,
            choiceTransitionName: {
                type: String,
                default: "zoom"
            },
            autofocus: {
                type: Boolean,
                default: void 0
            },
            backfill: {
                type: Boolean,
                default: void 0
            },
            filterOption: {
                type: [Boolean, Function],
                default: !1
            },
            defaultActiveFirstOption: {
                type: Boolean,
                default: !0
            }
        })
    },
    AutoCompleteOption = Option$2,
    AutoCompleteOptGroup = OptGroup$1,
    AutoComplete = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "AAutoComplete",
        inheritAttrs: !1,
        props: autoCompleteProps(),
        slots: ["option"],
        setup: function (C, H) {
            var W = H.slots,
                U = H.attrs,
                G = H.expose;
            warning$2(!("dataSource" in W), "AutoComplete",
                "`dataSource` slot is deprecated, please use props `options` instead."), warning$2(!(
                    "options" in W), "AutoComplete",
                "`options` slot is deprecated, please use props `options` instead.");
            var X = ref(),
                Z = function () {
                    var ae, oe = flattenChildren((ae = W.default) === null || ae === void 0 ? void 0 : ae.call(
                            W)),
                        ie = oe.length ? oe[0] : void 0;
                    return ie
                },
                Q = function () {
                    var ae;
                    (ae = X.value) === null || ae === void 0 || ae.focus()
                },
                ee = function () {
                    var ae;
                    (ae = X.value) === null || ae === void 0 || ae.blur()
                };
            G({
                focus: Q,
                blur: ee
            });
            var ne = useConfigInject("select", C),
                te = ne.prefixCls;
            return function () {
                var re, ae, oe = C.size,
                    ie = C.dataSource,
                    ue = C.notFoundContent,
                    le = ue === void 0 ? (re = W.notFoundContent) === null || re === void 0 ? void 0 : re.call(
                        W) : ue,
                    se, ce = U.class,
                    de = (ae = {}, _defineProperty$V(ae, ce, !!ce), _defineProperty$V(ae, "".concat(te.value,
                            "-lg"), oe === "large"), _defineProperty$V(ae, "".concat(te.value, "-sm"), oe ===
                            "small"), _defineProperty$V(ae, "".concat(te.value, "-show-search"), !0),
                        _defineProperty$V(ae, "".concat(te.value, "-auto-complete"), !0), ae);
                if (C.options === void 0) {
                    var ve, fe, pe = ((ve = W.dataSource) === null || ve === void 0 ? void 0 : ve.call(W)) ||
                        ((fe = W.options) === null || fe === void 0 ? void 0 : fe.call(W)) || [];
                    pe.length && isSelectOptionOrSelectOptGroup(pe[0]) ? se = pe : se = ie ? ie.map(
                        function (he) {
                            if (isValidElement(he)) return he;
                            switch (_typeof$2(he)) {
                                case "string":
                                    return createVNode(Option$2, {
                                        key: he,
                                        value: he
                                    }, {
                                        default: function () {
                                            return [he]
                                        }
                                    });
                                case "object":
                                    return createVNode(Option$2, {
                                        key: he.value,
                                        value: he.value
                                    }, {
                                        default: function () {
                                            return [he.text]
                                        }
                                    });
                                default:
                                    throw new Error(
                                        "AutoComplete[dataSource] only supports type `string[] | Object[]`."
                                    )
                            }
                        }) : []
                }
                var me = omit$2(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, C), U), {}, {
                    mode: VcSelect.SECRET_COMBOBOX_MODE_DO_NOT_USE,
                    getInputElement: Z,
                    notFoundContent: le,
                    class: de,
                    ref: X
                }), ["dataSource", "loading"]);
                return createVNode(VcSelect, me, _objectSpread2$1({
                    default: function () {
                        return [se]
                    }
                }, omit$2(W, ["default", "dataSource", "options"])))
            }
        }
    });
const index$m = _extends$1(AutoComplete, {
    Option: Option$2,
    OptGroup: OptGroup$1,
    install: function (C) {
        return C.component(AutoComplete.name, AutoComplete), C.component(Option$2.displayName, Option$2), C
            .component(OptGroup$1.displayName, OptGroup$1), C
    }
});
var iconMapFilled = {
        success: CheckCircleFilled$1,
        info: InfoCircleFilled$1,
        error: CloseCircleFilled$1,
        warning: ExclamationCircleFilled$1
    },
    iconMapOutlined = {
        success: CheckCircleOutlined$1,
        info: InfoCircleOutlined$1,
        error: CloseCircleOutlined$1,
        warning: ExclamationCircleOutlined$1
    },
    AlertTypes = tuple$1("success", "info", "warning", "error"),
    alertProps = function () {
        return {
            type: PropTypes$1.oneOf(AlertTypes),
            closable: {
                type: Boolean,
                default: void 0
            },
            closeText: PropTypes$1.any,
            message: PropTypes$1.any,
            description: PropTypes$1.any,
            afterClose: Function,
            showIcon: {
                type: Boolean,
                default: void 0
            },
            prefixCls: String,
            banner: {
                type: Boolean,
                default: void 0
            },
            icon: PropTypes$1.any,
            closeIcon: PropTypes$1.any,
            onClose: Function
        }
    },
    Alert = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "AAlert",
        inheritAttrs: !1,
        props: alertProps(),
        setup: function (C, H) {
            var W = H.slots,
                U = H.emit,
                G = H.attrs,
                X = H.expose,
                Z = useConfigInject("alert", C),
                Q = Z.prefixCls,
                ee = Z.direction,
                ne = ref(!1),
                te = ref(!1),
                re = ref(),
                ae = function (le) {
                    le.preventDefault();
                    var se = re.value;
                    se.style.height = "".concat(se.offsetHeight, "px"), se.style.height = "".concat(se.offsetHeight,
                        "px"), ne.value = !0, U("close", le)
                },
                oe = function () {
                    var le;
                    ne.value = !1, te.value = !0, (le = C.afterClose) === null || le === void 0 || le.call(C)
                };
            X({
                animationEnd: oe
            });
            var ie = ref({});
            return function () {
                var ue, le, se = C.banner,
                    ce = C.closeIcon,
                    de = ce === void 0 ? (ue = W.closeIcon) === null || ue === void 0 ? void 0 : ue.call(W) :
                    ce,
                    ve = C.closable,
                    fe = C.type,
                    pe = C.showIcon,
                    me = getPropsSlot(W, C, "closeText"),
                    he = getPropsSlot(W, C, "description"),
                    Se = getPropsSlot(W, C, "message"),
                    _e = getPropsSlot(W, C, "icon");
                pe = se && pe === void 0 ? !0 : pe, fe = se && fe === void 0 ? "warning" : fe || "info";
                var be = (he ? iconMapOutlined : iconMapFilled)[fe] || null;
                me && (ve = !0);
                var ge = Q.value,
                    xe = classNames(ge, (le = {}, _defineProperty$V(le, "".concat(ge, "-").concat(fe), !0),
                        _defineProperty$V(le, "".concat(ge, "-closing"), ne.value), _defineProperty$V(
                            le, "".concat(ge, "-with-description"), !!he), _defineProperty$V(le, "".concat(
                            ge, "-no-icon"), !pe), _defineProperty$V(le, "".concat(ge, "-banner"), !!se),
                        _defineProperty$V(le, "".concat(ge, "-closable"), ve), _defineProperty$V(le, ""
                            .concat(ge, "-rtl"), ee.value === "rtl"), le)),
                    Pe = ve ? createVNode("button", {
                        type: "button",
                        onClick: ae,
                        class: "".concat(ge, "-close-icon"),
                        tabindex: 0
                    }, [me ? createVNode("span", {
                        class: "".concat(ge, "-close-text")
                    }, [me]) : de === void 0 ? createVNode(CloseOutlined$1, null, null) : de]) : null,
                    $e = _e && (isValidElement(_e) ? cloneElement(_e, {
                        class: "".concat(ge, "-icon")
                    }) : createVNode("span", {
                        class: "".concat(ge, "-icon")
                    }, [_e])) || createVNode(be, {
                        class: "".concat(ge, "-icon")
                    }, null),
                    ye = getTransitionProps("".concat(ge, "-motion"), {
                        appear: !1,
                        css: !0,
                        onAfterLeave: oe,
                        onBeforeLeave: function (we) {
                            we.style.maxHeight = "".concat(we.offsetHeight, "px")
                        },
                        onLeave: function (we) {
                            we.style.maxHeight = "0px"
                        }
                    });
                return te.value ? null : createVNode(Transition, ye, {
                    default: function () {
                        return [withDirectives(createVNode("div", _objectSpread2$1(
                            _objectSpread2$1({
                                role: "alert"
                            }, G), {}, {
                                style: [G.style, ie.value],
                                class: [G.class, xe],
                                "data-show": !ne.value,
                                ref: re
                            }), [pe ? $e : null, createVNode("div", {
                            class: "".concat(ge, "-content")
                        }, [Se ? createVNode("div", {
                            class: "".concat(ge, "-message")
                        }, [Se]) : null, he ? createVNode("div", {
                            class: "".concat(ge, "-description")
                        }, [he]) : null]), Pe]), [[vShow, !ne.value]])]
                    }
                })
            }
        }
    });
const index$l = withInstall(Alert);
var responsiveArray = ["xxxl", "xxl", "xl", "lg", "md", "sm", "xs"],
    responsiveMap = {
        xs: "(max-width: 575px)",
        sm: "(min-width: 576px)",
        md: "(min-width: 768px)",
        lg: "(min-width: 992px)",
        xl: "(min-width: 1200px)",
        xxl: "(min-width: 1600px)",
        xxxl: "(min-width: 2000px)"
    },
    subscribers = new Map,
    subUid = -1,
    screens = {},
    responsiveObserve = {
        matchHandlers: {},
        dispatch: function (C) {
            return screens = C, subscribers.forEach(function (H) {
                return H(screens)
            }), subscribers.size >= 1
        },
        subscribe: function (C) {
            return subscribers.size || this.register(), subUid += 1, subscribers.set(subUid, C), C(screens), subUid
        },
        unsubscribe: function (C) {
            subscribers.delete(C), subscribers.size || this.unregister()
        },
        unregister: function () {
            var C = this;
            Object.keys(responsiveMap).forEach(function (H) {
                var W = responsiveMap[H],
                    U = C.matchHandlers[W];
                U == null || U.mql.removeListener(U == null ? void 0 : U.listener)
            }), subscribers.clear()
        },
        register: function () {
            var C = this;
            Object.keys(responsiveMap).forEach(function (H) {
                var W = responsiveMap[H],
                    U = function (Z) {
                        var Q = Z.matches;
                        C.dispatch(_objectSpread2$1(_objectSpread2$1({}, screens), {}, _defineProperty$V({},
                            H, Q)))
                    },
                    G = window.matchMedia(W);
                G.addListener(U), C.matchHandlers[W] = {
                    mql: G,
                    listener: U
                }, U(G)
            })
        }
    };
const ResponsiveObserve = responsiveObserve;

function useBreakpoint() {
    var K = ref({}),
        C = null;
    return onMounted(function () {
        C = ResponsiveObserve.subscribe(function (H) {
            K.value = H
        })
    }), onUnmounted(function () {
        ResponsiveObserve.unsubscribe(C)
    }), K
}
var sizeProvider = Symbol("SizeProvider"),
    useProvideSize = function (C) {
        var H = inject("configProvider", defaultConfigProvider),
            W = computed(function () {
                return C.size || H.componentSize
            });
        return provide(sizeProvider, W), W
    },
    useInjectSize = function (C) {
        var H = C ? computed(function () {
            return C.size
        }) : inject(sizeProvider, computed(function () {
            return "default"
        }));
        return H
    };
const useProvideSize$1 = useProvideSize;

function eagerComputed(K) {
    var C = shallowRef();
    return watchEffect(function () {
        C.value = K()
    }, {
        flush: "sync"
    }), C
}
var avatarProps$1 = function () {
        return {
            prefixCls: String,
            shape: {
                type: String,
                default: "circle"
            },
            size: {
                type: [Number, String, Object],
                default: function () {
                    return "default"
                }
            },
            src: String,
            srcset: String,
            icon: PropTypes$1.any,
            alt: String,
            gap: Number,
            draggable: {
                type: Boolean,
                default: void 0
            },
            crossOrigin: String,
            loadError: {
                type: Function
            }
        }
    },
    Avatar = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "AAvatar",
        inheritAttrs: !1,
        props: avatarProps$1(),
        slots: ["icon"],
        setup: function (C, H) {
            var W = H.slots,
                U = H.attrs,
                G = ref(!0),
                X = ref(!1),
                Z = ref(1),
                Q = ref(null),
                ee = ref(null),
                ne = useConfigInject("avatar", C),
                te = ne.prefixCls,
                re = useInjectSize(),
                ae = computed(function () {
                    return C.size === "default" ? re.value : C.size
                }),
                oe = useBreakpoint(),
                ie = eagerComputed(function () {
                    if (_typeof$2(C.size) === "object") {
                        var ce = responsiveArray.find(function (ve) {
                                return oe.value[ve]
                            }),
                            de = C.size[ce];
                        return de
                    }
                }),
                ue = function (de) {
                    return ie.value ? {
                        width: "".concat(ie.value, "px"),
                        height: "".concat(ie.value, "px"),
                        lineHeight: "".concat(ie.value, "px"),
                        fontSize: "".concat(de ? ie.value / 2 : 18, "px")
                    } : {}
                },
                le = function () {
                    if (!(!Q.value || !ee.value)) {
                        var de = Q.value.offsetWidth,
                            ve = ee.value.offsetWidth;
                        if (de !== 0 && ve !== 0) {
                            var fe = C.gap,
                                pe = fe === void 0 ? 4 : fe;
                            pe * 2 < ve && (Z.value = ve - pe * 2 < de ? (ve - pe * 2) / de : 1)
                        }
                    }
                },
                se = function () {
                    var de = C.loadError,
                        ve = de == null ? void 0 : de();
                    ve !== !1 && (G.value = !1)
                };
            return watch(function () {
                    return C.src
                }, function () {
                    nextTick(function () {
                        G.value = !0, Z.value = 1
                    })
                }), watch(function () {
                    return C.gap
                }, function () {
                    nextTick(function () {
                        le()
                    })
                }), onMounted(function () {
                    nextTick(function () {
                        le(), X.value = !0
                    })
                }),
                function () {
                    var ce, de, ve = C.shape,
                        fe = C.src,
                        pe = C.alt,
                        me = C.srcset,
                        he = C.draggable,
                        Se = C.crossOrigin,
                        _e = getPropsSlot(W, C, "icon"),
                        be = te.value,
                        ge = (ce = {}, _defineProperty$V(ce, "".concat(U.class), !!U.class), _defineProperty$V(
                                ce, be, !0), _defineProperty$V(ce, "".concat(be, "-lg"), ae.value === "large"),
                            _defineProperty$V(ce, "".concat(be, "-sm"), ae.value === "small"),
                            _defineProperty$V(ce, "".concat(be, "-").concat(ve), ve), _defineProperty$V(ce, "".concat(
                                be, "-image"), fe && G.value), _defineProperty$V(ce, "".concat(be, "-icon"), _e),
                            ce),
                        xe = typeof ae.value == "number" ? {
                            width: "".concat(ae.value, "px"),
                            height: "".concat(ae.value, "px"),
                            lineHeight: "".concat(ae.value, "px"),
                            fontSize: _e ? "".concat(ae.value / 2, "px") : "18px"
                        } : {},
                        Pe = (de = W.default) === null || de === void 0 ? void 0 : de.call(W),
                        $e;
                    if (fe && G.value) $e = createVNode("img", {
                        draggable: he,
                        src: fe,
                        srcset: me,
                        onError: se,
                        alt: pe,
                        crossorigin: Se
                    }, null);
                    else if (_e) $e = _e;
                    else if (X.value || Z.value !== 1) {
                        var ye = "scale(".concat(Z.value, ") translateX(-50%)"),
                            Ce = {
                                msTransform: ye,
                                WebkitTransform: ye,
                                transform: ye
                            },
                            we = typeof ae.value == "number" ? {
                                lineHeight: "".concat(ae.value, "px")
                            } : {};
                        $e = createVNode(ResizeObserver$1, {
                            onResize: le
                        }, {
                            default: function () {
                                return [createVNode("span", {
                                    class: "".concat(be, "-string"),
                                    ref: Q,
                                    style: _objectSpread2$1(_objectSpread2$1({}, we),
                                        Ce)
                                }, [Pe])]
                            }
                        })
                    } else $e = createVNode("span", {
                        class: "".concat(be, "-string"),
                        ref: Q,
                        style: {
                            opacity: 0
                        }
                    }, [Pe]);
                    return createVNode("span", _objectSpread2$1(_objectSpread2$1({}, U), {}, {
                        ref: ee,
                        class: ge,
                        style: [xe, ue(!!_e), U.style]
                    }), [$e])
                }
        }
    });
const Avatar$1 = Avatar;
var autoAdjustOverflow$2 = {
        adjustX: 1,
        adjustY: 1
    },
    targetOffset$2 = [0, 0],
    placements$3 = {
        left: {
            points: ["cr", "cl"],
            overflow: autoAdjustOverflow$2,
            offset: [-4, 0],
            targetOffset: targetOffset$2
        },
        right: {
            points: ["cl", "cr"],
            overflow: autoAdjustOverflow$2,
            offset: [4, 0],
            targetOffset: targetOffset$2
        },
        top: {
            points: ["bc", "tc"],
            overflow: autoAdjustOverflow$2,
            offset: [0, -4],
            targetOffset: targetOffset$2
        },
        bottom: {
            points: ["tc", "bc"],
            overflow: autoAdjustOverflow$2,
            offset: [0, 4],
            targetOffset: targetOffset$2
        },
        topLeft: {
            points: ["bl", "tl"],
            overflow: autoAdjustOverflow$2,
            offset: [0, -4],
            targetOffset: targetOffset$2
        },
        leftTop: {
            points: ["tr", "tl"],
            overflow: autoAdjustOverflow$2,
            offset: [-4, 0],
            targetOffset: targetOffset$2
        },
        topRight: {
            points: ["br", "tr"],
            overflow: autoAdjustOverflow$2,
            offset: [0, -4],
            targetOffset: targetOffset$2
        },
        rightTop: {
            points: ["tl", "tr"],
            overflow: autoAdjustOverflow$2,
            offset: [4, 0],
            targetOffset: targetOffset$2
        },
        bottomRight: {
            points: ["tr", "br"],
            overflow: autoAdjustOverflow$2,
            offset: [0, 4],
            targetOffset: targetOffset$2
        },
        rightBottom: {
            points: ["bl", "br"],
            overflow: autoAdjustOverflow$2,
            offset: [4, 0],
            targetOffset: targetOffset$2
        },
        bottomLeft: {
            points: ["tl", "bl"],
            overflow: autoAdjustOverflow$2,
            offset: [0, 4],
            targetOffset: targetOffset$2
        },
        leftBottom: {
            points: ["br", "bl"],
            overflow: autoAdjustOverflow$2,
            offset: [-4, 0],
            targetOffset: targetOffset$2
        }
    },
    tooltipContentProps = {
        prefixCls: String,
        id: String,
        overlayInnerStyle: PropTypes$1.any
    };
const Content$2 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Content",
    props: tooltipContentProps,
    slots: ["overlay"],
    setup: function (C, H) {
        var W = H.slots;
        return function () {
            var U;
            return createVNode("div", {
                class: "".concat(C.prefixCls, "-inner"),
                id: C.id,
                role: "tooltip",
                style: C.overlayInnerStyle
            }, [(U = W.overlay) === null || U === void 0 ? void 0 : U.call(W)])
        }
    }
});
var _excluded$S = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls",
    "afterVisibleChange", "transitionName", "animation", "placement", "align", "destroyTooltipOnHide",
    "defaultVisible"];

function noop$b() {}
const Tooltip$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Tooltip",
    inheritAttrs: !1,
    props: {
        trigger: PropTypes$1.any.def(["hover"]),
        defaultVisible: {
            type: Boolean,
            default: void 0
        },
        visible: {
            type: Boolean,
            default: void 0
        },
        placement: PropTypes$1.string.def("right"),
        transitionName: String,
        animation: PropTypes$1.any,
        afterVisibleChange: PropTypes$1.func.def(function () {}),
        overlayStyle: {
            type: Object,
            default: void 0
        },
        overlayClassName: String,
        prefixCls: PropTypes$1.string.def("rc-tooltip"),
        mouseEnterDelay: PropTypes$1.number.def(.1),
        mouseLeaveDelay: PropTypes$1.number.def(.1),
        getPopupContainer: Function,
        destroyTooltipOnHide: {
            type: Boolean,
            default: !1
        },
        align: PropTypes$1.object.def(function () {
            return {}
        }),
        arrowContent: PropTypes$1.any.def(null),
        tipId: String,
        builtinPlacements: PropTypes$1.object,
        overlayInnerStyle: {
            type: Object,
            default: void 0
        },
        popupVisible: {
            type: Boolean,
            default: void 0
        },
        onVisibleChange: Function,
        onPopupAlign: Function
    },
    slots: ["arrowContent", "overlay"],
    setup: function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = H.expose,
            X = ref(),
            Z = function () {
                var re = C.prefixCls,
                    ae = C.tipId,
                    oe = C.overlayInnerStyle;
                return [createVNode("div", {
                    class: "".concat(re, "-arrow"),
                    key: "arrow"
                }, [getPropsSlot(W, C, "arrowContent")]), createVNode(Content$2, {
                    key: "content",
                    prefixCls: re,
                    id: ae,
                    overlayInnerStyle: oe
                }, {
                    overlay: W.overlay
                })]
            },
            Q = function () {
                return X.value.getPopupDomNode()
            };
        G({
            getPopupDomNode: Q,
            triggerDOM: X,
            forcePopupAlign: function () {
                var re;
                return (re = X.value) === null || re === void 0 ? void 0 : re.forcePopupAlign()
            }
        });
        var ee = ref(!1),
            ne = ref(!1);
        return watchEffect(function () {
                var te = C.destroyTooltipOnHide;
                if (typeof te == "boolean") ee.value = te;
                else if (te && _typeof$2(te) === "object") {
                    var re = te.keepParent;
                    ee.value = re === !0, ne.value = re === !1
                }
            }),
            function () {
                var te = C.overlayClassName,
                    re = C.trigger,
                    ae = C.mouseEnterDelay,
                    oe = C.mouseLeaveDelay,
                    ie = C.overlayStyle,
                    ue = C.prefixCls,
                    le = C.afterVisibleChange,
                    se = C.transitionName,
                    ce = C.animation,
                    de = C.placement,
                    ve = C.align;
                C.destroyTooltipOnHide;
                var fe = C.defaultVisible,
                    pe = _objectWithoutProperties$2(C, _excluded$S),
                    me = _objectSpread2$1({}, pe);
                C.visible !== void 0 && (me.popupVisible = C.visible);
                var he = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                    popupClassName: te,
                    prefixCls: ue,
                    action: re,
                    builtinPlacements: placements$3,
                    popupPlacement: de,
                    popupAlign: ve,
                    afterPopupVisibleChange: le,
                    popupTransitionName: se,
                    popupAnimation: ce,
                    defaultPopupVisible: fe,
                    destroyPopupOnHide: ee.value,
                    autoDestroy: ne.value,
                    mouseLeaveDelay: oe,
                    popupStyle: ie,
                    mouseEnterDelay: ae
                }, me), U), {}, {
                    onPopupVisibleChange: C.onVisibleChange || noop$b,
                    onPopupAlign: C.onPopupAlign || noop$b,
                    ref: X,
                    popup: Z()
                });
                return createVNode(Trigger, he, {
                    default: W.default
                })
            }
    }
});
var PresetStatusColorTypes = tuple$1("success", "processing", "error", "default", "warning"),
    PresetColorTypes = tuple$1("pink", "red", "yellow", "orange", "cyan", "green", "blue", "purple", "geekblue",
        "magenta", "volcano", "gold", "lime");
const abstractTooltipProps = function () {
    return {
        trigger: [String, Array],
        visible: {
            type: Boolean,
            default: void 0
        },
        defaultVisible: {
            type: Boolean,
            default: void 0
        },
        placement: String,
        color: String,
        transitionName: String,
        overlayStyle: {
            type: Object,
            default: void 0
        },
        overlayClassName: String,
        openClassName: String,
        prefixCls: String,
        mouseEnterDelay: Number,
        mouseLeaveDelay: Number,
        getPopupContainer: Function,
        arrowPointAtCenter: {
            type: Boolean,
            default: void 0
        },
        autoAdjustOverflow: {
            type: [Boolean, Object],
            default: void 0
        },
        destroyTooltipOnHide: {
            type: Boolean,
            default: void 0
        },
        align: {
            type: Object,
            default: void 0
        },
        builtinPlacements: {
            type: Object,
            default: void 0
        },
        children: Array,
        onVisibleChange: Function,
        "onUpdate:visible": Function
    }
};
var autoAdjustOverflowEnabled = {
        adjustX: 1,
        adjustY: 1
    },
    autoAdjustOverflowDisabled = {
        adjustX: 0,
        adjustY: 0
    },
    targetOffset$1 = [0, 0];

function getOverflowOptions(K) {
    return typeof K == "boolean" ? K ? autoAdjustOverflowEnabled : autoAdjustOverflowDisabled : _objectSpread2$1(
        _objectSpread2$1({}, autoAdjustOverflowDisabled), K)
}

function getPlacements(K) {
    var C = K.arrowWidth,
        H = C === void 0 ? 4 : C,
        W = K.horizontalArrowShift,
        U = W === void 0 ? 16 : W,
        G = K.verticalArrowShift,
        X = G === void 0 ? 8 : G,
        Z = K.autoAdjustOverflow,
        Q = K.arrowPointAtCenter,
        ee = {
            left: {
                points: ["cr", "cl"],
                offset: [-4, 0]
            },
            right: {
                points: ["cl", "cr"],
                offset: [4, 0]
            },
            top: {
                points: ["bc", "tc"],
                offset: [0, -4]
            },
            bottom: {
                points: ["tc", "bc"],
                offset: [0, 4]
            },
            topLeft: {
                points: ["bl", "tc"],
                offset: [-(U + H), -4]
            },
            leftTop: {
                points: ["tr", "cl"],
                offset: [-4, -(X + H)]
            },
            topRight: {
                points: ["br", "tc"],
                offset: [U + H, -4]
            },
            rightTop: {
                points: ["tl", "cr"],
                offset: [4, -(X + H)]
            },
            bottomRight: {
                points: ["tr", "bc"],
                offset: [U + H, 4]
            },
            rightBottom: {
                points: ["bl", "cr"],
                offset: [4, X + H]
            },
            bottomLeft: {
                points: ["tl", "bc"],
                offset: [-(U + H), 4]
            },
            leftBottom: {
                points: ["br", "cl"],
                offset: [-4, X + H]
            }
        };
    return Object.keys(ee).forEach(function (ne) {
        ee[ne] = Q ? _objectSpread2$1(_objectSpread2$1({}, ee[ne]), {}, {
            overflow: getOverflowOptions(Z),
            targetOffset: targetOffset$1
        }) : _objectSpread2$1(_objectSpread2$1({}, placements$3[ne]), {}, {
            overflow: getOverflowOptions(Z)
        }), ee[ne].ignoreShake = !0
    }), ee
}

function firstNotUndefined() {
    for (var K = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], C = 0, H = K.length; C < H; C++)
        if (K[C] !== void 0) return K[C]
}
var splitObject = function (C, H) {
        var W = {},
            U = _objectSpread2$1({}, C);
        return H.forEach(function (G) {
            C && G in C && (W[G] = C[G], delete U[G])
        }), {
            picked: W,
            omitted: U
        }
    },
    PresetColorRegex$1 = new RegExp("^(".concat(PresetColorTypes.join("|"), ")(-inverse)?$")),
    tooltipProps = function () {
        return _objectSpread2$1(_objectSpread2$1({}, abstractTooltipProps()), {}, {
            title: PropTypes$1.any
        })
    },
    tooltipDefaultProps = function () {
        return {
            trigger: "hover",
            transitionName: "zoom-big-fast",
            align: {},
            placement: "top",
            mouseEnterDelay: .1,
            mouseLeaveDelay: .1,
            arrowPointAtCenter: !1,
            autoAdjustOverflow: !0
        }
    };
const ToolTip = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ATooltip",
        inheritAttrs: !1,
        props: initDefaultProps$1(tooltipProps(), {
            trigger: "hover",
            transitionName: "zoom-big-fast",
            align: {},
            placement: "top",
            mouseEnterDelay: .1,
            mouseLeaveDelay: .1,
            arrowPointAtCenter: !1,
            autoAdjustOverflow: !0
        }),
        slots: ["title"],
        setup: function (C, H) {
            var W = H.slots,
                U = H.emit,
                G = H.attrs,
                X = H.expose,
                Z = useConfigInject("tooltip", C),
                Q = Z.prefixCls,
                ee = Z.getPopupContainer,
                ne = ref(firstNotUndefined([C.visible, C.defaultVisible])),
                te = ref();
            onMounted(function () {
                warning$2(C.defaultVisible === void 0, "Tooltip",
                    "'defaultVisible' is deprecated, please use 'v-model:visible'")
            });
            var re;
            watch(function () {
                return C.visible
            }, function (ve) {
                wrapperRaf.cancel(re), re = wrapperRaf(function () {
                    ne.value = !!ve
                })
            });
            var ae = function () {
                    var fe, pe = (fe = C.title) !== null && fe !== void 0 ? fe : W.title;
                    return !pe && pe !== 0
                },
                oe = function (fe) {
                    var pe = ae();
                    C.visible === void 0 && (ne.value = pe ? !1 : fe), pe || (U("update:visible", fe), U(
                        "visibleChange", fe))
                },
                ie = function () {
                    return te.value.getPopupDomNode()
                };
            X({
                getPopupDomNode: ie,
                visible: ne,
                forcePopupAlign: function () {
                    var fe;
                    return (fe = te.value) === null || fe === void 0 ? void 0 : fe.forcePopupAlign()
                }
            });
            var ue = computed(function () {
                    var ve = C.builtinPlacements,
                        fe = C.arrowPointAtCenter,
                        pe = C.autoAdjustOverflow;
                    return ve || getPlacements({
                        arrowPointAtCenter: fe,
                        autoAdjustOverflow: pe
                    })
                }),
                le = function (fe) {
                    return fe || fe === ""
                },
                se = function (fe) {
                    var pe = fe.type;
                    if (_typeof$2(pe) === "object" && fe.props && ((pe.__ANT_BUTTON === !0 || pe === "button") &&
                            le(fe.props.disabled) || pe.__ANT_SWITCH === !0 && (le(fe.props.disabled) || le(fe.props
                                .loading)))) {
                        var me = splitObject(getStyle(fe), ["position", "left", "right", "top", "bottom",
                                "float", "display", "zIndex"]),
                            he = me.picked,
                            Se = me.omitted,
                            _e = _objectSpread2$1(_objectSpread2$1({
                                display: "inline-block"
                            }, he), {}, {
                                cursor: "not-allowed",
                                lineHeight: 1,
                                width: fe.props && fe.props.block ? "100%" : null
                            }),
                            be = _objectSpread2$1(_objectSpread2$1({}, Se), {}, {
                                pointerEvents: "none"
                            }),
                            ge = cloneElement(fe, {
                                style: be
                            }, !0);
                        return createVNode("span", {
                            style: _e,
                            class: "".concat(Q.value, "-disabled-compatible-wrapper")
                        }, [ge])
                    }
                    return fe
                },
                ce = function () {
                    var fe, pe;
                    return (fe = C.title) !== null && fe !== void 0 ? fe : (pe = W.title) === null || pe ===
                        void 0 ? void 0 : pe.call(W)
                },
                de = function (fe, pe) {
                    var me = ue.value,
                        he = Object.keys(me).filter(function (be) {
                            return me[be].points[0] === pe.points[0] && me[be].points[1] === pe.points[1]
                        })[0];
                    if (he) {
                        var Se = fe.getBoundingClientRect(),
                            _e = {
                                top: "50%",
                                left: "50%"
                            };
                        he.indexOf("top") >= 0 || he.indexOf("Bottom") >= 0 ? _e.top = "".concat(Se.height - pe
                            .offset[1], "px") : (he.indexOf("Top") >= 0 || he.indexOf("bottom") >= 0) && (
                            _e.top = "".concat(-pe.offset[1], "px")), he.indexOf("left") >= 0 || he.indexOf(
                            "Right") >= 0 ? _e.left = "".concat(Se.width - pe.offset[0], "px") : (he.indexOf(
                            "right") >= 0 || he.indexOf("Left") >= 0) && (_e.left = "".concat(-pe.offset[0],
                            "px")), fe.style.transformOrigin = "".concat(_e.left, " ").concat(_e.top)
                    }
                };
            return function () {
                var ve, fe, pe, me = C.openClassName,
                    he = C.color,
                    Se = C.overlayClassName,
                    _e = (ve = filterEmpty((fe = W.default) === null || fe === void 0 ? void 0 : fe.call(W))) !==
                    null && ve !== void 0 ? ve : null;
                _e = _e.length === 1 ? _e[0] : _e;
                var be = ne.value;
                if (C.visible === void 0 && ae() && (be = !1), !_e) return null;
                var ge = se(isValidElement(_e) ? _e : createVNode("span", null, [_e])),
                    xe = classNames((pe = {}, _defineProperty$V(pe, me || "".concat(Q.value, "-open"), !0),
                        _defineProperty$V(pe, ge.props && ge.props.class, ge.props && ge.props.class),
                        pe)),
                    Pe = classNames(Se, _defineProperty$V({}, "".concat(Q.value, "-").concat(he), he &&
                        PresetColorRegex$1.test(he))),
                    $e, ye;
                he && !PresetColorRegex$1.test(he) && ($e = {
                    backgroundColor: he
                }, ye = {
                    backgroundColor: he
                });
                var Ce = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, G), C), {}, {
                    prefixCls: Q.value,
                    getPopupContainer: ee.value,
                    builtinPlacements: ue.value,
                    visible: be,
                    ref: te,
                    overlayClassName: Pe,
                    overlayInnerStyle: $e,
                    onVisibleChange: oe,
                    onPopupAlign: de
                });
                return createVNode(Tooltip$1, Ce, {
                    default: function () {
                        return [ne.value ? cloneElement(ge, {
                            class: xe
                        }) : ge]
                    },
                    arrowContent: function () {
                        return createVNode("span", {
                            class: "".concat(Q.value, "-arrow-content"),
                            style: ye
                        }, null)
                    },
                    overlay: ce
                })
            }
        }
    }),
    Tooltip = withInstall(ToolTip);
var popoverProps = function () {
        return _objectSpread2$1(_objectSpread2$1({}, abstractTooltipProps()), {}, {
            content: PropTypes$1.any,
            title: PropTypes$1.any
        })
    },
    Popover = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "APopover",
        props: initDefaultProps$1(popoverProps(), _objectSpread2$1(_objectSpread2$1({}, tooltipDefaultProps()), {}, {
            trigger: "hover",
            transitionName: "zoom-big",
            placement: "top",
            mouseEnterDelay: .1,
            mouseLeaveDelay: .1
        })),
        setup: function (C, H) {
            var W = H.expose,
                U = H.slots,
                G = ref();
            W({
                getPopupDomNode: function () {
                    var re, ae;
                    return (re = G.value) === null || re === void 0 || (ae = re.getPopupDomNode) ===
                        null || ae === void 0 ? void 0 : ae.call(re)
                }
            });
            var X = useConfigInject("popover", C),
                Z = X.prefixCls,
                Q = X.configProvider,
                ee = computed(function () {
                    return Q.getPrefixCls()
                }),
                ne = function () {
                    var re, ae, oe = C.title,
                        ie = oe === void 0 ? filterEmpty((re = U.title) === null || re === void 0 ? void 0 : re
                            .call(U)) : oe,
                        ue = C.content,
                        le = ue === void 0 ? filterEmpty((ae = U.content) === null || ae === void 0 ? void 0 :
                            ae.call(U)) : ue,
                        se = !!(Array.isArray(ie) ? ie.length : ie),
                        ce = !!(Array.isArray(le) ? le.length : ie);
                    if (!(!se && !ce)) return createVNode(Fragment, null, [se && createVNode("div", {
                        class: "".concat(Z.value, "-title")
                    }, [ie]), createVNode("div", {
                        class: "".concat(Z.value, "-inner-content")
                    }, [le])])
                };
            return function () {
                return createVNode(Tooltip, _objectSpread2$1(_objectSpread2$1({}, omit$2(C, ["title",
                    "content"])), {}, {
                    prefixCls: Z.value,
                    ref: G,
                    transitionName: getTransitionName$2(ee.value, "zoom-big", C.transitionName)
                }), {
                    title: ne,
                    default: U.default
                })
            }
        }
    });
const Popover$1 = withInstall(Popover);
var groupProps = function () {
        return {
            prefixCls: String,
            maxCount: Number,
            maxStyle: {
                type: Object,
                default: void 0
            },
            maxPopoverPlacement: {
                type: String,
                default: "top"
            },
            maxPopoverTrigger: String,
            size: {
                type: [Number, String, Object],
                default: "default"
            }
        }
    },
    Group$3 = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "AAvatarGroup",
        inheritAttrs: !1,
        props: groupProps(),
        setup: function (C, H) {
            var W = H.slots,
                U = H.attrs,
                G = useConfigInject("avatar-group", C),
                X = G.prefixCls,
                Z = G.direction;
            return useProvideSize$1(C),
                function () {
                    var Q, ee = C.maxPopoverPlacement,
                        ne = ee === void 0 ? "top" : ee,
                        te = C.maxCount,
                        re = C.maxStyle,
                        ae = C.maxPopoverTrigger,
                        oe = ae === void 0 ? "hover" : ae,
                        ie = (Q = {}, _defineProperty$V(Q, X.value, !0), _defineProperty$V(Q, "".concat(X.value,
                                "-rtl"), Z.value === "rtl"), _defineProperty$V(Q, "".concat(U.class), !!U.class),
                            Q),
                        ue = getPropsSlot(W, C),
                        le = flattenChildren(ue).map(function (ve, fe) {
                            return cloneElement(ve, {
                                key: "avatar-key-".concat(fe)
                            })
                        }),
                        se = le.length;
                    if (te && te < se) {
                        var ce = le.slice(0, te),
                            de = le.slice(te, se);
                        return ce.push(createVNode(Popover$1, {
                            key: "avatar-popover-key",
                            content: de,
                            trigger: oe,
                            placement: ne,
                            overlayClassName: "".concat(X.value, "-popover")
                        }, {
                            default: function () {
                                return [createVNode(Avatar$1, {
                                    style: re
                                }, {
                                    default: function () {
                                        return ["+".concat(se - te)]
                                    }
                                })]
                            }
                        })), createVNode("div", _objectSpread2$1(_objectSpread2$1({}, U), {}, {
                            class: ie,
                            style: U.style
                        }), [ce])
                    }
                    return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, U), {}, {
                        class: ie,
                        style: U.style
                    }), [le])
                }
        }
    });
const Group$4 = Group$3;
Avatar$1.Group = Group$4;
Avatar$1.install = function (K) {
    return K.component(Avatar$1.name, Avatar$1), K.component(Group$4.name, Group$4), K
};
var VerticalAlignTopOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M859.9 168H164.1c-4.5 0-8.1 3.6-8.1 8v60c0 4.4 3.6 8 8.1 8h695.8c4.5 0 8.1-3.6 8.1-8v-60c0-4.4-3.6-8-8.1-8zM518.3 355a8 8 0 00-12.6 0l-112 141.7a7.98 7.98 0 006.3 12.9h73.9V848c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V509.7H624c6.7 0 10.4-7.7 6.3-12.9L518.3 355z"
            }
        }]
    },
    name: "vertical-align-top",
    theme: "outlined"
};
const VerticalAlignTopOutlinedSvg = VerticalAlignTopOutlined$2;

function _objectSpread$D(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$D(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$D(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var VerticalAlignTopOutlined = function (C, H) {
    var W = _objectSpread$D({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$D({}, W, {
        icon: VerticalAlignTopOutlinedSvg
    }), null)
};
VerticalAlignTopOutlined.displayName = "VerticalAlignTopOutlined";
VerticalAlignTopOutlined.inheritAttrs = !1;
const VerticalAlignTopOutlined$1 = VerticalAlignTopOutlined;
var backTopProps = function () {
        return {
            visibilityHeight: {
                type: Number,
                default: 400
            },
            duration: {
                type: Number,
                default: 450
            },
            target: Function,
            prefixCls: String,
            onClick: Function
        }
    },
    BackTop = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ABackTop",
        inheritAttrs: !1,
        props: backTopProps(),
        setup: function (C, H) {
            var W = H.slots,
                U = H.attrs,
                G = H.emit,
                X = useConfigInject("back-top", C),
                Z = X.prefixCls,
                Q = X.direction,
                ee = ref(),
                ne = reactive({
                    visible: !1,
                    scrollEvent: null
                }),
                te = function () {
                    return ee.value && ee.value.ownerDocument ? ee.value.ownerDocument : window
                },
                re = function (le) {
                    var se = C.target,
                        ce = se === void 0 ? te : se,
                        de = C.duration;
                    scrollTo$1(0, {
                        getContainer: ce,
                        duration: de
                    }), G("click", le)
                },
                ae = throttleByAnimationFrame(function (ue) {
                    var le = C.visibilityHeight,
                        se = getScroll$3(ue.target, !0);
                    ne.visible = se > le
                }),
                oe = function () {
                    var le = C.target,
                        se = le || te,
                        ce = se();
                    ne.scrollEvent = addEventListenerWrap(ce, "scroll", function (de) {
                        ae(de)
                    }), ae({
                        target: ce
                    })
                },
                ie = function () {
                    ne.scrollEvent && ne.scrollEvent.remove(), ae.cancel()
                };
            return watch(function () {
                    return C.target
                }, function () {
                    ie(), nextTick(function () {
                        oe()
                    })
                }), onMounted(function () {
                    nextTick(function () {
                        oe()
                    })
                }), onActivated(function () {
                    nextTick(function () {
                        oe()
                    })
                }), onDeactivated(function () {
                    ie()
                }), onBeforeUnmount(function () {
                    ie()
                }),
                function () {
                    var ue, le, se = createVNode("div", {
                            class: "".concat(Z.value, "-content")
                        }, [createVNode("div", {
                            class: "".concat(Z.value, "-icon")
                        }, [createVNode(VerticalAlignTopOutlined$1, null, null)])]),
                        ce = _objectSpread2$1(_objectSpread2$1({}, U), {}, {
                            onClick: re,
                            class: (ue = {}, _defineProperty$V(ue, "".concat(Z.value), !0),
                                _defineProperty$V(ue, "".concat(U.class), U.class), _defineProperty$V(
                                    ue, "".concat(Z.value, "-rtl"), Q.value === "rtl"), ue)
                        }),
                        de = getTransitionProps("fade");
                    return createVNode(Transition, de, {
                        default: function () {
                            return [withDirectives(createVNode("div", _objectSpread2$1(
                                _objectSpread2$1({}, ce), {}, {
                                    ref: ee
                                }), [((le = W.default) === null || le === void 0 ?
                                void 0 : le.call(W)) || se]), [[vShow, ne.visible]])]
                        }
                    })
                }
        }
    });
const index$k = withInstall(BackTop);

function UnitNumber(K) {
    var C = K.prefixCls,
        H = K.value,
        W = K.current,
        U = K.offset,
        G = U === void 0 ? 0 : U,
        X;
    return G && (X = {
        position: "absolute",
        top: "".concat(G, "00%"),
        left: 0
    }), createVNode("p", {
        style: X,
        class: classNames("".concat(C, "-only-unit"), {
            current: W
        })
    }, [H])
}

function getOffset$1(K, C, H) {
    for (var W = K, U = 0;
        (W + 10) % 10 !== C;) W += H, U += H;
    return U
}
const SingleNumber = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "SingleNumber",
    props: {
        prefixCls: String,
        value: String,
        count: Number
    },
    setup: function (C) {
        var H = computed(function () {
                return Number(C.value)
            }),
            W = computed(function () {
                return Math.abs(C.count)
            }),
            U = reactive({
                prevValue: H.value,
                prevCount: W.value
            }),
            G = function () {
                U.prevValue = H.value, U.prevCount = W.value
            },
            X = ref();
        return watch(H, function () {
                clearTimeout(X.value), X.value = setTimeout(function () {
                    G()
                }, 1e3)
            }, {
                flush: "post"
            }), onUnmounted(function () {
                clearTimeout(X.value)
            }),
            function () {
                var Z, Q = {},
                    ee = H.value;
                if (U.prevValue === ee || Number.isNaN(ee) || Number.isNaN(U.prevValue)) Z = [UnitNumber(
                    _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                        current: !0
                    }))], Q = {
                    transition: "none"
                };
                else {
                    Z = [];
                    for (var ne = ee + 10, te = [], re = ee; re <= ne; re += 1) te.push(re);
                    var ae = te.findIndex(function (ie) {
                        return ie % 10 === U.prevValue
                    });
                    Z = te.map(function (ie, ue) {
                        var le = ie % 10;
                        return UnitNumber(_objectSpread2$1(_objectSpread2$1({}, C), {}, {
                            value: le,
                            offset: ue - ae,
                            current: ue === ae
                        }))
                    });
                    var oe = U.prevCount < W.value ? 1 : -1;
                    Q = {
                        transform: "translateY(".concat(-getOffset$1(U.prevValue, ee, oe), "00%)")
                    }
                }
                return createVNode("span", {
                    class: "".concat(C.prefixCls, "-only"),
                    style: Q,
                    onTransitionend: function () {
                        return G()
                    }
                }, [Z])
            }
    }
});
var _excluded$R = ["prefixCls", "count", "title", "show", "component", "class", "style"],
    scrollNumberProps = {
        prefixCls: String,
        count: PropTypes$1.any,
        component: String,
        title: PropTypes$1.any,
        show: Boolean
    };
const ScrollNumber = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ScrollNumber",
    inheritAttrs: !1,
    props: scrollNumberProps,
    setup: function (C, H) {
        var W = H.attrs,
            U = H.slots,
            G = useConfigInject("scroll-number", C),
            X = G.prefixCls;
        return function () {
            var Z, Q = _objectSpread2$1(_objectSpread2$1({}, C), W);
            Q.prefixCls;
            var ee = Q.count,
                ne = Q.title;
            Q.show;
            var te = Q.component,
                re = te === void 0 ? "sup" : te,
                ae = Q.class,
                oe = Q.style,
                ie = _objectWithoutProperties$2(Q, _excluded$R),
                ue = _objectSpread2$1(_objectSpread2$1({}, ie), {}, {
                    style: oe,
                    "data-show": C.show,
                    class: classNames(X.value, ae),
                    title: ne
                }),
                le = ee;
            if (ee && Number(ee) % 1 === 0) {
                var se = String(ee).split("");
                le = se.map(function (de, ve) {
                    return createVNode(SingleNumber, {
                        prefixCls: X.value,
                        count: Number(ee),
                        value: de,
                        key: se.length - ve
                    }, null)
                })
            }
            oe && oe.borderColor && (ue.style = _objectSpread2$1(_objectSpread2$1({}, oe), {}, {
                boxShadow: "0 0 0 1px ".concat(oe.borderColor, " inset")
            }));
            var ce = filterEmpty((Z = U.default) === null || Z === void 0 ? void 0 : Z.call(U));
            return ce && ce.length ? cloneElement(ce, {
                class: classNames("".concat(X.value, "-custom-component"))
            }, !1) : createVNode(re, ue, {
                default: function () {
                    return [le]
                }
            })
        }
    }
});

function isPresetColor(K) {
    return PresetColorTypes.indexOf(K) !== -1
}
var _excluded$Q = ["class", "style"],
    ribbonProps = function () {
        return {
            prefix: String,
            color: {
                type: String
            },
            text: PropTypes$1.any,
            placement: {
                type: String,
                default: "end"
            }
        }
    };
const Ribbon = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ABadgeRibbon",
    inheritAttrs: !1,
    props: ribbonProps(),
    slots: ["text"],
    setup: function (C, H) {
        var W = H.attrs,
            U = H.slots,
            G = useConfigInject("ribbon", C),
            X = G.prefixCls,
            Z = G.direction,
            Q = computed(function () {
                return isPresetColor(C.color)
            }),
            ee = computed(function () {
                var ne;
                return [X.value, "".concat(X.value, "-placement-").concat(C.placement), (ne = {},
                    _defineProperty$V(ne, "".concat(X.value, "-rtl"), Z.value === "rtl"),
                    _defineProperty$V(ne, "".concat(X.value, "-color-").concat(C.color), Q.value),
                    ne)]
            });
        return function () {
            var ne, te, re = W.class,
                ae = W.style,
                oe = _objectWithoutProperties$2(W, _excluded$Q),
                ie = {},
                ue = {};
            return C.color && !Q.value && (ie.background = C.color, ue.color = C.color), createVNode(
                "div", _objectSpread2$1({
                    class: "".concat(X.value, "-wrapper")
                }, oe), [(ne = U.default) === null || ne === void 0 ? void 0 : ne.call(U),
                    createVNode("div", {
                        class: [ee.value, re],
                        style: _objectSpread2$1(_objectSpread2$1({}, ie), ae)
                    }, [createVNode("span", {
                        class: "".concat(X.value, "-text")
                    }, [C.text || ((te = U.text) === null || te === void 0 ? void 0 :
                        te.call(U))]), createVNode("div", {
                        class: "".concat(X.value, "-corner"),
                        style: ue
                    }, null)])])
        }
    }
});
var isNumeric$1 = function (C) {
    return !isNaN(parseFloat(C)) && isFinite(C)
};
const isNumeric$2 = isNumeric$1;
var badgeProps = function () {
    return {
        count: PropTypes$1.any,
        showZero: {
            type: Boolean,
            default: void 0
        },
        overflowCount: {
            type: Number,
            default: 99
        },
        dot: {
            type: Boolean,
            default: void 0
        },
        prefixCls: String,
        scrollNumberPrefixCls: String,
        status: {
            type: String
        },
        size: {
            type: String,
            default: "default"
        },
        color: String,
        text: PropTypes$1.any,
        offset: Array,
        numberStyle: {
            type: Object,
            default: void 0
        },
        title: String
    }
};
const Badge = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ABadge",
    Ribbon,
    inheritAttrs: !1,
    props: badgeProps(),
    slots: ["text", "count"],
    setup: function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = useConfigInject("badge", C),
            X = G.prefixCls,
            Z = G.direction,
            Q = computed(function () {
                return C.count > C.overflowCount ? "".concat(C.overflowCount, "+") : C.count
            }),
            ee = computed(function () {
                return C.status !== null && C.status !== void 0 || C.color !== null && C.color !== void 0
            }),
            ne = computed(function () {
                return Q.value === "0" || Q.value === 0
            }),
            te = computed(function () {
                return C.dot && !ne.value
            }),
            re = computed(function () {
                return te.value ? "" : Q.value
            }),
            ae = computed(function () {
                var de = re.value === null || re.value === void 0 || re.value === "";
                return (de || ne.value && !C.showZero) && !te.value
            }),
            oe = ref(C.count),
            ie = ref(re.value),
            ue = ref(te.value);
        watch([function () {
            return C.count
        }, re, te], function () {
            ae.value || (oe.value = C.count, ie.value = re.value, ue.value = te.value)
        }, {
            immediate: !0
        });
        var le = computed(function () {
                var de;
                return de = {}, _defineProperty$V(de, "".concat(X.value, "-status-dot"), ee.value),
                    _defineProperty$V(de, "".concat(X.value, "-status-").concat(C.status), !!C.status),
                    _defineProperty$V(de, "".concat(X.value, "-status-").concat(C.color), isPresetColor(
                        C.color)), de
            }),
            se = computed(function () {
                return C.color && !isPresetColor(C.color) ? {
                    background: C.color
                } : {}
            }),
            ce = computed(function () {
                var de;
                return de = {}, _defineProperty$V(de, "".concat(X.value, "-dot"), ue.value),
                    _defineProperty$V(de, "".concat(X.value, "-count"), !ue.value), _defineProperty$V(
                        de, "".concat(X.value, "-count-sm"), C.size === "small"), _defineProperty$V(de,
                        "".concat(X.value, "-multiple-words"), !ue.value && ie.value && ie.value.toString()
                        .length > 1), _defineProperty$V(de, "".concat(X.value, "-status-").concat(C.status),
                        !!C.status), _defineProperty$V(de, "".concat(X.value, "-status-").concat(C.color),
                        isPresetColor(C.color)), de
            });
        return function () {
            var de, ve, fe, pe = C.offset,
                me = C.title,
                he = C.color,
                Se = U.style,
                _e = getPropsSlot(W, C, "text"),
                be = X.value,
                ge = oe.value,
                xe = flattenChildren((de = W.default) === null || de === void 0 ? void 0 : de.call(W));
            xe = xe.length ? xe : null;
            var Pe = !!(!ae.value || W.count),
                $e = function () {
                    if (!pe) return _objectSpread2$1({}, Se);
                    var ke = {
                        marginTop: isNumeric$2(pe[1]) ? "".concat(pe[1], "px") : pe[1]
                    };
                    return Z.value === "rtl" ? ke.left = "".concat(parseInt(pe[0], 10), "px") : ke.right =
                        "".concat(-parseInt(pe[0], 10), "px"), _objectSpread2$1(_objectSpread2$1({}, ke),
                            Se)
                }(),
                ye = me || (typeof ge == "string" || typeof ge == "number" ? ge : void 0),
                Ce = Pe || !_e ? null : createVNode("span", {
                    class: "".concat(be, "-status-text")
                }, [_e]),
                we = _typeof$2(ge) === "object" || ge === void 0 && W.count ? cloneElement(ge || ((ve =
                    W.count) === null || ve === void 0 ? void 0 : ve.call(W)), {
                    style: $e
                }, !1) : null,
                Oe = classNames(be, (fe = {}, _defineProperty$V(fe, "".concat(be, "-status"), ee.value),
                    _defineProperty$V(fe, "".concat(be, "-not-a-wrapper"), !xe), _defineProperty$V(
                        fe, "".concat(be, "-rtl"), Z.value === "rtl"), fe), U.class);
            if (!xe && ee.value) {
                var Ne = $e.color;
                return createVNode("span", _objectSpread2$1(_objectSpread2$1({}, U), {}, {
                    class: Oe,
                    style: $e
                }), [createVNode("span", {
                    class: le.value,
                    style: se.value
                }, null), createVNode("span", {
                    style: {
                        color: Ne
                    },
                    class: "".concat(be, "-status-text")
                }, [_e])])
            }
            var Me = getTransitionProps(xe ? "".concat(be, "-zoom") : "", {
                    appear: !1
                }),
                Ve = _objectSpread2$1(_objectSpread2$1({}, $e), C.numberStyle);
            return he && !isPresetColor(he) && (Ve = Ve || {}, Ve.background = he), createVNode("span",
                _objectSpread2$1(_objectSpread2$1({}, U), {}, {
                    class: Oe
                }), [xe, createVNode(Transition, Me, {
                    default: function () {
                        return [withDirectives(createVNode(ScrollNumber, {
                            prefixCls: C.scrollNumberPrefixCls,
                            show: Pe,
                            class: ce.value,
                            count: ie.value,
                            title: ye,
                            style: Ve,
                            key: "scrollNumber"
                        }, {
                            default: function () {
                                return [we]
                            }
                        }), [[vShow, Pe]])]
                    }
                }), Ce])
        }
    }
});
Badge.install = function (K) {
    return K.component(Badge.name, Badge), K.component(Ribbon.name, Ribbon), K
};
var autoAdjustOverflow$1 = {
        adjustX: 1,
        adjustY: 1
    },
    targetOffset = [0, 0],
    placements$1 = {
        topLeft: {
            points: ["bl", "tl"],
            overflow: autoAdjustOverflow$1,
            offset: [0, -4],
            targetOffset
        },
        topCenter: {
            points: ["bc", "tc"],
            overflow: autoAdjustOverflow$1,
            offset: [0, -4],
            targetOffset
        },
        topRight: {
            points: ["br", "tr"],
            overflow: autoAdjustOverflow$1,
            offset: [0, -4],
            targetOffset
        },
        bottomLeft: {
            points: ["tl", "bl"],
            overflow: autoAdjustOverflow$1,
            offset: [0, 4],
            targetOffset
        },
        bottomCenter: {
            points: ["tc", "bc"],
            overflow: autoAdjustOverflow$1,
            offset: [0, 4],
            targetOffset
        },
        bottomRight: {
            points: ["tr", "br"],
            overflow: autoAdjustOverflow$1,
            offset: [0, 4],
            targetOffset
        }
    };
const placements$2 = placements$1;
var _excluded$P = ["prefixCls", "arrow", "showAction", "overlayStyle", "trigger", "placement", "align",
    "getPopupContainer", "transitionName", "animation", "overlayClassName"];
const Dropdown$2 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    props: {
        minOverlayWidthMatchTrigger: {
            type: Boolean,
            default: void 0
        },
        arrow: {
            type: Boolean,
            default: !1
        },
        prefixCls: PropTypes$1.string.def("rc-dropdown"),
        transitionName: String,
        overlayClassName: PropTypes$1.string.def(""),
        openClassName: String,
        animation: PropTypes$1.any,
        align: PropTypes$1.object,
        overlayStyle: {
            type: Object,
            default: void 0
        },
        placement: PropTypes$1.string.def("bottomLeft"),
        overlay: PropTypes$1.any,
        trigger: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.arrayOf(PropTypes$1.string)]).def(
            "hover"),
        alignPoint: {
            type: Boolean,
            default: void 0
        },
        showAction: PropTypes$1.array,
        hideAction: PropTypes$1.array,
        getPopupContainer: Function,
        visible: {
            type: Boolean,
            default: void 0
        },
        defaultVisible: {
            type: Boolean,
            default: !1
        },
        mouseEnterDelay: PropTypes$1.number.def(.15),
        mouseLeaveDelay: PropTypes$1.number.def(.1)
    },
    emits: ["visibleChange", "overlayClick"],
    slots: ["overlay"],
    setup: function (C, H) {
        var W = H.slots,
            U = H.emit,
            G = H.expose,
            X = ref(!!C.visible);
        watch(function () {
            return C.visible
        }, function (oe) {
            oe !== void 0 && (X.value = oe)
        });
        var Z = ref();
        G({
            triggerRef: Z
        });
        var Q = function (ie) {
                C.visible === void 0 && (X.value = !1), U("overlayClick", ie)
            },
            ee = function (ie) {
                C.visible === void 0 && (X.value = ie), U("visibleChange", ie)
            },
            ne = function () {
                var ie, ue = (ie = W.overlay) === null || ie === void 0 ? void 0 : ie.call(W),
                    le = {
                        prefixCls: "".concat(C.prefixCls, "-menu"),
                        onClick: Q,
                        getPopupContainer: function () {
                            return Z.value.getPopupDomNode()
                        }
                    };
                return createVNode(Fragment, null, [C.arrow && createVNode("div", {
                    class: "".concat(C.prefixCls, "-arrow")
                }, null), cloneElement(ue, le, !1)])
            },
            te = computed(function () {
                var oe = C.minOverlayWidthMatchTrigger,
                    ie = oe === void 0 ? !C.alignPoint : oe;
                return ie
            }),
            re = function () {
                var ie, ue = (ie = W.default) === null || ie === void 0 ? void 0 : ie.call(W);
                return X.value && ue ? cloneElement(ue[0], {
                    class: C.openClassName || "".concat(C.prefixCls, "-open")
                }, !1) : ue
            },
            ae = computed(function () {
                return !C.hideAction && C.trigger.indexOf("contextmenu") !== -1 ? ["click"] : C.hideAction
            });
        return function () {
            var oe = C.prefixCls,
                ie = C.arrow,
                ue = C.showAction,
                le = C.overlayStyle,
                se = C.trigger,
                ce = C.placement,
                de = C.align,
                ve = C.getPopupContainer,
                fe = C.transitionName,
                pe = C.animation,
                me = C.overlayClassName,
                he = _objectWithoutProperties$2(C, _excluded$P);
            return createVNode(Trigger, _objectSpread2$1(_objectSpread2$1({}, he), {}, {
                prefixCls: oe,
                ref: Z,
                popupClassName: classNames(me, _defineProperty$V({}, "".concat(oe,
                    "-show-arrow"), ie)),
                popupStyle: le,
                builtinPlacements: placements$2,
                action: se,
                showAction: ue,
                hideAction: ae.value || [],
                popupPlacement: ce,
                popupAlign: de,
                popupTransitionName: fe,
                popupAnimation: pe,
                popupVisible: X.value,
                stretch: te.value ? "minWidth" : "",
                onPopupVisibleChange: ee,
                getPopupContainer: ve
            }), {
                popup: ne,
                default: re
            })
        }
    }
});
var START_EVENT_NAME_MAP = {
        transitionstart: {
            transition: "transitionstart",
            WebkitTransition: "webkitTransitionStart",
            MozTransition: "mozTransitionStart",
            OTransition: "oTransitionStart",
            msTransition: "MSTransitionStart"
        },
        animationstart: {
            animation: "animationstart",
            WebkitAnimation: "webkitAnimationStart",
            MozAnimation: "mozAnimationStart",
            OAnimation: "oAnimationStart",
            msAnimation: "MSAnimationStart"
        }
    },
    END_EVENT_NAME_MAP = {
        transitionend: {
            transition: "transitionend",
            WebkitTransition: "webkitTransitionEnd",
            MozTransition: "mozTransitionEnd",
            OTransition: "oTransitionEnd",
            msTransition: "MSTransitionEnd"
        },
        animationend: {
            animation: "animationend",
            WebkitAnimation: "webkitAnimationEnd",
            MozAnimation: "mozAnimationEnd",
            OAnimation: "oAnimationEnd",
            msAnimation: "MSAnimationEnd"
        }
    },
    startEvents = [],
    endEvents = [];

function detectEvents() {
    var K = document.createElement("div"),
        C = K.style;
    "AnimationEvent" in window || (delete START_EVENT_NAME_MAP.animationstart.animation, delete END_EVENT_NAME_MAP.animationend
        .animation), "TransitionEvent" in window || (delete START_EVENT_NAME_MAP.transitionstart.transition, delete END_EVENT_NAME_MAP
        .transitionend.transition);

    function H(W, U) {
        for (var G in W)
            if (W.hasOwnProperty(G)) {
                var X = W[G];
                for (var Z in X)
                    if (Z in C) {
                        U.push(X[Z]);
                        break
                    }
            }
    }
    H(START_EVENT_NAME_MAP, startEvents), H(END_EVENT_NAME_MAP, endEvents)
}
typeof window < "u" && typeof document < "u" && detectEvents();

function addEventListener$1(K, C, H) {
    K.addEventListener(C, H, !1)
}

function removeEventListener$1(K, C, H) {
    K.removeEventListener(C, H, !1)
}
var TransitionEvents = {
    startEvents,
    addStartEventListener: function (C, H) {
        if (startEvents.length === 0) {
            setTimeout(H, 0);
            return
        }
        startEvents.forEach(function (W) {
            addEventListener$1(C, W, H)
        })
    },
    removeStartEventListener: function (C, H) {
        startEvents.length !== 0 && startEvents.forEach(function (W) {
            removeEventListener$1(C, W, H)
        })
    },
    endEvents,
    addEndEventListener: function (C, H) {
        if (endEvents.length === 0) {
            setTimeout(H, 0);
            return
        }
        endEvents.forEach(function (W) {
            addEventListener$1(C, W, H)
        })
    },
    removeEndEventListener: function (C, H) {
        endEvents.length !== 0 && endEvents.forEach(function (W) {
            removeEventListener$1(C, W, H)
        })
    }
};
const TransitionEvents$1 = TransitionEvents;
var styleForPesudo;

function isHidden(K) {
    return !K || K.offsetParent === null
}

function isNotGrey(K) {
    var C = (K || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\.\d]*)?\)/);
    return C && C[1] && C[2] && C[3] ? !(C[1] === C[2] && C[2] === C[3]) : !0
}
const Wave = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Wave",
    props: {
        insertExtraNode: Boolean,
        disabled: Boolean
    },
    setup: function (C, H) {
        var W = H.slots,
            U = H.expose,
            G = getCurrentInstance(),
            X = useConfigInject("", C),
            Z = X.csp,
            Q = X.prefixCls;
        U({
            csp: Z
        });
        var ee = null,
            ne = null,
            te = null,
            re = !1,
            ae = null,
            oe = !1,
            ie = function (fe) {
                if (!oe) {
                    var pe = findDOMNode(G);
                    !fe || fe.target !== pe || re || ce(pe)
                }
            },
            ue = function (fe) {
                !fe || fe.animationName !== "fadeEffect" || ce(fe.target)
            },
            le = function () {
                var fe = C.insertExtraNode;
                return fe ? "".concat(Q.value, "-click-animating") : "".concat(Q.value,
                    "-click-animating-without-extra-node")
            },
            se = function (fe, pe) {
                var me = C.insertExtraNode,
                    he = C.disabled;
                if (!(he || !fe || isHidden(fe) || fe.className.indexOf("-leave") >= 0)) {
                    ae = document.createElement("div"), ae.className = "".concat(Q.value,
                        "-click-animating-node");
                    var Se = le();
                    if (fe.removeAttribute(Se), fe.setAttribute(Se, "true"), styleForPesudo =
                        styleForPesudo || document.createElement("style"), pe && pe !== "#ffffff" && pe !==
                        "rgb(255, 255, 255)" && isNotGrey(pe) && !/rgba\(\d*, \d*, \d*, 0\)/.test(pe) && pe !==
                        "transparent") {
                        var _e;
                        (_e = Z.value) !== null && _e !== void 0 && _e.nonce && (styleForPesudo.nonce = Z.value
                                .nonce), ae.style.borderColor = pe, styleForPesudo.innerHTML = `
        [`
                            .concat(Q.value, "-click-animating-without-extra-node='true']::after, .").concat(
                                Q.value, `-click-animating-node {
          --antd-wave-shadow-color: `).concat(
                                pe, `;
        }`), document.body.contains(styleForPesudo) || document.body
                            .appendChild(styleForPesudo)
                    }
                    me && fe.appendChild(ae), TransitionEvents$1.addStartEventListener(fe, ie),
                        TransitionEvents$1.addEndEventListener(fe, ue)
                }
            },
            ce = function (fe) {
                if (!(!fe || fe === ae || !(fe instanceof Element))) {
                    var pe = C.insertExtraNode,
                        me = le();
                    fe.setAttribute(me, "false"), styleForPesudo && (styleForPesudo.innerHTML = ""), pe &&
                        ae && fe.contains(ae) && fe.removeChild(ae), TransitionEvents$1.removeStartEventListener(
                            fe, ie), TransitionEvents$1.removeEndEventListener(fe, ue)
                }
            },
            de = function (fe) {
                if (!(!fe || !fe.getAttribute || fe.getAttribute("disabled") || fe.className.indexOf(
                        "disabled") >= 0)) {
                    var pe = function (he) {
                        if (!(he.target.tagName === "INPUT" || isHidden(he.target))) {
                            ce(fe);
                            var Se = getComputedStyle(fe).getPropertyValue("border-top-color") ||
                                getComputedStyle(fe).getPropertyValue("border-color") ||
                                getComputedStyle(fe).getPropertyValue("background-color");
                            ne = setTimeout(function () {
                                return se(fe, Se)
                            }, 0), wrapperRaf.cancel(te), re = !0, te = wrapperRaf(function () {
                                re = !1
                            }, 10)
                        }
                    };
                    return fe.addEventListener("click", pe, !0), {
                        cancel: function () {
                            fe.removeEventListener("click", pe, !0)
                        }
                    }
                }
            };
        return onMounted(function () {
                nextTick(function () {
                    var ve = findDOMNode(G);
                    ve.nodeType === 1 && (ee = de(ve))
                })
            }), onBeforeUnmount(function () {
                ee && ee.cancel(), clearTimeout(ne), oe = !0
            }),
            function () {
                var ve;
                return (ve = W.default) === null || ve === void 0 ? void 0 : ve.call(W)[0]
            }
    }
});

function convertLegacyProps(K) {
    return K === "danger" ? {
        danger: !0
    } : {
        type: K
    }
}
var buttonProps = function () {
    return {
        prefixCls: String,
        type: String,
        htmlType: {
            type: String,
            default: "button"
        },
        shape: {
            type: String
        },
        size: {
            type: String
        },
        loading: {
            type: [Boolean, Object],
            default: function () {
                return !1
            }
        },
        disabled: {
            type: Boolean,
            default: void 0
        },
        ghost: {
            type: Boolean,
            default: void 0
        },
        block: {
            type: Boolean,
            default: void 0
        },
        danger: {
            type: Boolean,
            default: void 0
        },
        icon: PropTypes$1.any,
        href: String,
        target: String,
        title: String,
        onClick: {
            type: Function
        },
        onMousedown: {
            type: Function
        }
    }
};
const buttonTypes = buttonProps;
var getCollapsedWidth = function (C) {
        C && (C.style.width = "0px", C.style.opacity = "0", C.style.transform = "scale(0)")
    },
    getRealWidth = function (C) {
        nextTick(function () {
            C && (C.style.width = "".concat(C.scrollWidth, "px"), C.style.opacity = "1", C.style.transform =
                "scale(1)")
        })
    },
    resetStyle = function (C) {
        C && C.style && (C.style.width = null, C.style.opacity = null, C.style.transform = null)
    };
const LoadingIcon = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "LoadingIcon",
    props: {
        prefixCls: String,
        loading: [Boolean, Object],
        existIcon: Boolean
    },
    setup: function (C) {
        return function () {
            var H = C.existIcon,
                W = C.prefixCls,
                U = C.loading;
            if (H) return createVNode("span", {
                class: "".concat(W, "-loading-icon")
            }, [createVNode(LoadingOutlined$1, null, null)]);
            var G = !!U;
            return createVNode(Transition, {
                name: "".concat(W, "-loading-icon-motion"),
                onBeforeEnter: getCollapsedWidth,
                onEnter: getRealWidth,
                onAfterEnter: resetStyle,
                onBeforeLeave: getRealWidth,
                onLeave: function (Z) {
                    setTimeout(function () {
                        getCollapsedWidth(Z)
                    })
                },
                onAfterLeave: resetStyle
            }, {
                default: function () {
                    return [G ? createVNode("span", {
                        class: "".concat(W, "-loading-icon")
                    }, [createVNode(LoadingOutlined$1, null, null)]) : null]
                }
            })
        }
    }
});
var rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/,
    isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);

function isUnborderedButtonType(K) {
    return K === "text" || K === "link"
}
const Button$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AButton",
    inheritAttrs: !1,
    __ANT_BUTTON: !0,
    props: initDefaultProps$1(buttonTypes(), {
        type: "default"
    }),
    slots: ["icon"],
    setup: function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = H.emit,
            X = useConfigInject("btn", C),
            Z = X.prefixCls,
            Q = X.autoInsertSpaceInButton,
            ee = X.direction,
            ne = X.size,
            te = ref(null),
            re = ref(void 0),
            ae = !1,
            oe = ref(!1),
            ie = ref(!1),
            ue = computed(function () {
                return Q.value !== !1
            }),
            le = computed(function () {
                return _typeof$2(C.loading) === "object" && C.loading.delay ? C.loading.delay || !0 : !
                    !C.loading
            });
        watch(le, function (fe) {
            clearTimeout(re.value), typeof le.value == "number" ? re.value = setTimeout(function () {
                oe.value = fe
            }, le.value) : oe.value = fe
        }, {
            immediate: !0
        });
        var se = computed(function () {
                var fe, pe = C.type,
                    me = C.shape,
                    he = me === void 0 ? "default" : me,
                    Se = C.ghost,
                    _e = C.block,
                    be = C.danger,
                    ge = Z.value,
                    xe = {
                        large: "lg",
                        small: "sm",
                        middle: void 0
                    },
                    Pe = ne.value,
                    $e = Pe && xe[Pe] || "";
                return fe = {}, _defineProperty$V(fe, "".concat(ge), !0), _defineProperty$V(fe, "".concat(
                        ge, "-").concat(pe), pe), _defineProperty$V(fe, "".concat(ge, "-").concat(he),
                        he !== "default" && he), _defineProperty$V(fe, "".concat(ge, "-").concat($e),
                        $e), _defineProperty$V(fe, "".concat(ge, "-loading"), oe.value),
                    _defineProperty$V(fe, "".concat(ge, "-background-ghost"), Se && !
                        isUnborderedButtonType(pe)), _defineProperty$V(fe, "".concat(ge,
                        "-two-chinese-chars"), ie.value && ue.value), _defineProperty$V(fe, "".concat(
                        ge, "-block"), _e), _defineProperty$V(fe, "".concat(ge, "-dangerous"), !!be),
                    _defineProperty$V(fe, "".concat(ge, "-rtl"), ee.value === "rtl"), fe
            }),
            ce = function () {
                var pe = te.value;
                if (!(!pe || Q.value === !1)) {
                    var me = pe.textContent;
                    ae && isTwoCNChar(me) ? ie.value || (ie.value = !0) : ie.value && (ie.value = !1)
                }
            },
            de = function (pe) {
                if (oe.value || C.disabled) {
                    pe.preventDefault();
                    return
                }
                G("click", pe)
            },
            ve = function (pe, me) {
                var he = me ? " " : "";
                if (pe.type === Text$2) {
                    var Se = pe.children.trim();
                    return isTwoCNChar(Se) && (Se = Se.split("").join(he)), createVNode("span", null, [Se])
                }
                return pe
            };
        return watchEffect(function () {
                devWarning(!(C.ghost && isUnborderedButtonType(C.type)), "Button",
                    "`link` or `text` button can't be a `ghost` button.")
            }), onMounted(ce), onUpdated(ce), onBeforeUnmount(function () {
                re.value && clearTimeout(re.value)
            }),
            function () {
                var fe, pe, me = C.icon,
                    he = me === void 0 ? (fe = W.icon) === null || fe === void 0 ? void 0 : fe.call(W) : me,
                    Se = flattenChildren((pe = W.default) === null || pe === void 0 ? void 0 : pe.call(W));
                ae = Se.length === 1 && !he && !isUnborderedButtonType(C.type);
                var _e = C.type,
                    be = C.htmlType,
                    ge = C.disabled,
                    xe = C.href,
                    Pe = C.title,
                    $e = C.target,
                    ye = C.onMousedown,
                    Ce = oe.value ? "loading" : he,
                    we = _objectSpread2$1(_objectSpread2$1({}, U), {}, {
                        title: Pe,
                        disabled: ge,
                        class: [se.value, U.class, _defineProperty$V({}, "".concat(Z.value,
                            "-icon-only"), Se.length === 0 && !!Ce)],
                        onClick: de,
                        onMousedown: ye
                    });
                ge || delete we.disabled;
                var Oe = he && !oe.value ? he : createVNode(LoadingIcon, {
                        existIcon: !!he,
                        prefixCls: Z.value,
                        loading: !!oe.value
                    }, null),
                    Ne = Se.map(function (Ve) {
                        return ve(Ve, ae && ue.value)
                    });
                if (xe !== void 0) return createVNode("a", _objectSpread2$1(_objectSpread2$1({}, we), {}, {
                    href: xe,
                    target: $e,
                    ref: te
                }), [Oe, Ne]);
                var Me = createVNode("button", _objectSpread2$1(_objectSpread2$1({}, we), {}, {
                    ref: te,
                    type: be
                }), [Oe, Ne]);
                return isUnborderedButtonType(_e) ? Me : createVNode(Wave, {
                    ref: "wave",
                    disabled: !!oe.value
                }, {
                    default: function () {
                        return [Me]
                    }
                })
            }
    }
});

function _defineProperties(K, C) {
    for (var H = 0; H < C.length; H++) {
        var W = C[H];
        W.enumerable = W.enumerable || !1, W.configurable = !0, "value" in W && (W.writable = !0), Object.defineProperty(
            K, _toPropertyKey(W.key), W)
    }
}

function _createClass(K, C, H) {
    return C && _defineProperties(K.prototype, C), H && _defineProperties(K, H), Object.defineProperty(K, "prototype", {
        writable: !1
    }), K
}

function _classCallCheck(K, C) {
    if (!(K instanceof C)) throw new TypeError("Cannot call a class as a function")
}
var UnreachableException = _createClass(function K(C) {
        _classCallCheck(this, K), this.error = new Error("unreachable case: ".concat(JSON.stringify(C)))
    }),
    buttonGroupProps = function () {
        return {
            prefixCls: String,
            size: {
                type: String
            }
        }
    };
const ButtonGroup$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AButtonGroup",
    props: buttonGroupProps(),
    setup: function (C, H) {
        var W = H.slots,
            U = useConfigInject("btn-group", C),
            G = U.prefixCls,
            X = U.direction,
            Z = computed(function () {
                var Q, ee = C.size,
                    ne = "";
                switch (ee) {
                    case "large":
                        ne = "lg";
                        break;
                    case "small":
                        ne = "sm";
                        break;
                    case "middle":
                    case void 0:
                        break;
                    default:
                        console.warn(new UnreachableException(ee).error)
                }
                return Q = {}, _defineProperty$V(Q, "".concat(G.value), !0), _defineProperty$V(Q, "".concat(
                    G.value, "-").concat(ne), ne), _defineProperty$V(Q, "".concat(G.value, "-rtl"),
                    X.value === "rtl"), Q
            });
        return function () {
            var Q;
            return createVNode("div", {
                class: Z.value
            }, [flattenChildren((Q = W.default) === null || Q === void 0 ? void 0 : Q.call(W))])
        }
    }
});
Button$1.Group = ButtonGroup$1;
Button$1.install = function (K) {
    return K.component(Button$1.name, Button$1), K.component(ButtonGroup$1.name, ButtonGroup$1), K
};
var dropdownProps = function () {
        return {
            arrow: {
                type: [Boolean, Object],
                default: void 0
            },
            trigger: {
                type: [Array, String]
            },
            overlay: PropTypes$1.any,
            visible: {
                type: Boolean,
                default: void 0
            },
            disabled: {
                type: Boolean,
                default: void 0
            },
            align: {
                type: Object
            },
            getPopupContainer: Function,
            prefixCls: String,
            transitionName: String,
            placement: String,
            overlayClassName: String,
            overlayStyle: {
                type: Object,
                default: void 0
            },
            forceRender: {
                type: Boolean,
                default: void 0
            },
            mouseEnterDelay: Number,
            mouseLeaveDelay: Number,
            openClassName: String,
            minOverlayWidthMatchTrigger: {
                type: Boolean,
                default: void 0
            },
            destroyPopupOnHide: {
                type: Boolean,
                default: void 0
            },
            onVisibleChange: {
                type: Function
            },
            "onUpdate:visible": {
                type: Function
            }
        }
    },
    buttonTypesProps = buttonTypes(),
    dropdownButtonProps = function () {
        return _objectSpread2$1(_objectSpread2$1({}, dropdownProps()), {}, {
            type: buttonTypesProps.type,
            size: String,
            htmlType: buttonTypesProps.htmlType,
            href: String,
            disabled: {
                type: Boolean,
                default: void 0
            },
            prefixCls: String,
            icon: PropTypes$1.any,
            title: String,
            loading: buttonTypesProps.loading,
            onClick: {
                type: Function
            }
        })
    },
    EllipsisOutlined$2 = {
        icon: {
            tag: "svg",
            attrs: {
                viewBox: "64 64 896 896",
                focusable: "false"
            },
            children: [{
                tag: "path",
                attrs: {
                    d: "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z"
                }
            }]
        },
        name: "ellipsis",
        theme: "outlined"
    };
const EllipsisOutlinedSvg = EllipsisOutlined$2;

function _objectSpread$C(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$C(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$C(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var EllipsisOutlined = function (C, H) {
    var W = _objectSpread$C({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$C({}, W, {
        icon: EllipsisOutlinedSvg
    }), null)
};
EllipsisOutlined.displayName = "EllipsisOutlined";
EllipsisOutlined.inheritAttrs = !1;
const EllipsisOutlined$1 = EllipsisOutlined;
var _excluded$O = ["type", "disabled", "loading", "htmlType", "class", "overlay", "trigger", "align", "visible",
        "onVisibleChange", "placement", "href", "title", "icon", "mouseEnterDelay", "mouseLeaveDelay",
        "overlayClassName", "overlayStyle", "destroyPopupOnHide", "onClick", "onUpdate:visible"],
    ButtonGroup = Button$1.Group;
const DropdownButton = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ADropdownButton",
    inheritAttrs: !1,
    __ANT_BUTTON: !0,
    props: initDefaultProps$1(dropdownButtonProps(), {
        trigger: "hover",
        placement: "bottomRight",
        type: "default"
    }),
    slots: ["icon", "leftButton", "rightButton", "overlay"],
    setup: function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = H.emit,
            X = function (re) {
                G("update:visible", re), G("visibleChange", re)
            },
            Z = useConfigInject("dropdown-button", C),
            Q = Z.prefixCls,
            ee = Z.direction,
            ne = Z.getPopupContainer;
        return function () {
            var te, re, ae = _objectSpread2$1(_objectSpread2$1({}, C), U),
                oe = ae.type,
                ie = oe === void 0 ? "default" : oe,
                ue = ae.disabled,
                le = ae.loading,
                se = ae.htmlType,
                ce = ae.class,
                de = ce === void 0 ? "" : ce,
                ve = ae.overlay,
                fe = ve === void 0 ? (te = W.overlay) === null || te === void 0 ? void 0 : te.call(W) :
                ve,
                pe = ae.trigger,
                me = ae.align,
                he = ae.visible;
            ae.onVisibleChange;
            var Se = ae.placement,
                _e = Se === void 0 ? ee.value === "rtl" ? "bottomLeft" : "bottomRight" : Se,
                be = ae.href,
                ge = ae.title,
                xe = ae.icon,
                Pe = xe === void 0 ? ((re = W.icon) === null || re === void 0 ? void 0 : re.call(W)) ||
                createVNode(EllipsisOutlined$1, null, null) : xe,
                $e = ae.mouseEnterDelay,
                ye = ae.mouseLeaveDelay,
                Ce = ae.overlayClassName,
                we = ae.overlayStyle,
                Oe = ae.destroyPopupOnHide,
                Ne = ae.onClick;
            ae["onUpdate:visible"];
            var Me = _objectWithoutProperties$2(ae, _excluded$O),
                Ve = {
                    align: me,
                    disabled: ue,
                    trigger: ue ? [] : pe,
                    placement: _e,
                    getPopupContainer: ne.value,
                    onVisibleChange: X,
                    mouseEnterDelay: $e,
                    mouseLeaveDelay: ye,
                    visible: he,
                    overlayClassName: Ce,
                    overlayStyle: we,
                    destroyPopupOnHide: Oe
                },
                ke = createVNode(Button$1, {
                    type: ie,
                    disabled: ue,
                    loading: le,
                    onClick: Ne,
                    htmlType: se,
                    href: be,
                    title: ge
                }, {
                    default: W.default
                }),
                Ee = createVNode(Button$1, {
                    type: ie,
                    icon: Pe
                }, null);
            return createVNode(ButtonGroup, _objectSpread2$1(_objectSpread2$1({}, Me), {}, {
                class: classNames(Q.value, de)
            }), {
                default: function () {
                    return [W.leftButton ? W.leftButton({
                        button: ke
                    }) : ke, createVNode(Dropdown$1, Ve, {
                        default: function () {
                            return [W.rightButton ? W.rightButton({
                                button: Ee
                            }) : Ee]
                        },
                        overlay: function () {
                            return fe
                        }
                    })]
                }
            })
        }
    }
});
var RightOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z"
            }
        }]
    },
    name: "right",
    theme: "outlined"
};
const RightOutlinedSvg = RightOutlined$2;

function _objectSpread$B(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$B(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$B(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var RightOutlined = function (C, H) {
    var W = _objectSpread$B({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$B({}, W, {
        icon: RightOutlinedSvg
    }), null)
};
RightOutlined.displayName = "RightOutlined";
RightOutlined.inheritAttrs = !1;
const RightOutlined$1 = RightOutlined;
var Dropdown = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ADropdown",
    inheritAttrs: !1,
    props: initDefaultProps$1(dropdownProps(), {
        mouseEnterDelay: .15,
        mouseLeaveDelay: .1,
        placement: "bottomLeft",
        trigger: "hover"
    }),
    slots: ["overlay"],
    setup: function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = H.emit,
            X = useConfigInject("dropdown", C),
            Z = X.prefixCls,
            Q = X.rootPrefixCls,
            ee = X.direction,
            ne = X.getPopupContainer,
            te = computed(function () {
                var ie = C.placement,
                    ue = ie === void 0 ? "" : ie,
                    le = C.transitionName;
                return le !== void 0 ? le : ue.indexOf("top") >= 0 ? "".concat(Q.value, "-slide-down") :
                    "".concat(Q.value, "-slide-up")
            }),
            re = function () {
                var ue, le, se, ce = C.overlay || ((ue = W.overlay) === null || ue === void 0 ? void 0 : ue
                        .call(W)),
                    de = Array.isArray(ce) ? ce[0] : ce;
                if (!de) return null;
                var ve = de.props || {};
                devWarning(!ve.mode || ve.mode === "vertical", "Dropdown", 'mode="'.concat(ve.mode,
                    `" is not supported for Dropdown's Menu.`));
                var fe = ve.selectable,
                    pe = fe === void 0 ? !1 : fe,
                    me = ve.expandIcon,
                    he = me === void 0 ? (le = de.children) === null || le === void 0 || (se = le.expandIcon) ===
                    null || se === void 0 ? void 0 : se.call(le) : me,
                    Se = typeof he < "u" && isValidElement(he) ? he : createVNode("span", {
                        class: "".concat(Z.value, "-menu-submenu-arrow")
                    }, [createVNode(RightOutlined$1, {
                        class: "".concat(Z.value, "-menu-submenu-arrow-icon")
                    }, null)]),
                    _e = isValidElement(de) ? cloneElement(de, {
                        mode: "vertical",
                        selectable: pe,
                        expandIcon: function () {
                            return Se
                        }
                    }) : de;
                return _e
            },
            ae = computed(function () {
                var ie = C.placement;
                if (!ie) return ee.value === "rtl" ? "bottomRight" : "bottomLeft";
                if (ie.includes("Center")) {
                    var ue = ie.slice(0, ie.indexOf("Center"));
                    return devWarning(!ie.includes("Center"), "Dropdown", "You are using '".concat(ie,
                        "' placement in Dropdown, which is deprecated. Try to use '").concat(ue,
                        "' instead.")), ue
                }
                return ie
            }),
            oe = function (ue) {
                G("update:visible", ue), G("visibleChange", ue)
            };
        return function () {
            var ie, ue, le = C.arrow,
                se = C.trigger,
                ce = C.disabled,
                de = C.overlayClassName,
                ve = (ie = W.default) === null || ie === void 0 ? void 0 : ie.call(W)[0],
                fe = cloneElement(ve, _extends$1({
                    class: classNames(ve == null || (ue = ve.props) === null || ue === void 0 ?
                        void 0 : ue.class, _defineProperty$V({}, "".concat(Z.value, "-rtl"),
                            ee.value === "rtl"), "".concat(Z.value, "-trigger"))
                }, ce ? {
                    disabled: ce
                } : {})),
                pe = classNames(de, _defineProperty$V({}, "".concat(Z.value, "-rtl"), ee.value ===
                    "rtl")),
                me = ce ? [] : se,
                he;
            me && me.indexOf("contextmenu") !== -1 && (he = !0);
            var Se = getPlacements({
                    arrowPointAtCenter: _typeof$2(le) === "object" && le.pointAtCenter,
                    autoAdjustOverflow: !0
                }),
                _e = omit$2(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, C), U), {}, {
                    builtinPlacements: Se,
                    overlayClassName: pe,
                    arrow: le,
                    alignPoint: he,
                    prefixCls: Z.value,
                    getPopupContainer: ne.value,
                    transitionName: te.value,
                    trigger: me,
                    onVisibleChange: oe,
                    placement: ae.value
                }), ["overlay", "onUpdate:visible"]);
            return createVNode(Dropdown$2, _e, {
                default: function () {
                    return [fe]
                },
                overlay: re
            })
        }
    }
});
Dropdown.Button = DropdownButton;
const Dropdown$1 = Dropdown;
var _excluded$N = ["class", "style"],
    breadcrumbItemProps = function () {
        return {
            prefixCls: String,
            href: String,
            separator: PropTypes$1.any,
            overlay: PropTypes$1.any,
            onClick: Function
        }
    };
const BreadcrumbItem = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ABreadcrumbItem",
    inheritAttrs: !1,
    __ANT_BREADCRUMB_ITEM: !0,
    props: breadcrumbItemProps(),
    slots: ["separator", "overlay"],
    setup: function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = useConfigInject("breadcrumb", C),
            X = G.prefixCls,
            Z = function (ee, ne) {
                var te = getPropsSlot(W, C, "overlay");
                return te ? createVNode(Dropdown$1, {
                    overlay: te,
                    placement: "bottom"
                }, {
                    default: function () {
                        return [createVNode("span", {
                            class: "".concat(ne, "-overlay-link")
                        }, [ee, createVNode(DownOutlined$1, null, null)])]
                    }
                }) : ee
            };
        return function () {
            var Q, ee = (Q = getPropsSlot(W, C, "separator")) !== null && Q !== void 0 ? Q : "/",
                ne = getPropsSlot(W, C),
                te = U.class,
                re = U.style,
                ae = _objectWithoutProperties$2(U, _excluded$N),
                oe;
            return C.href !== void 0 ? oe = createVNode("a", _objectSpread2$1({
                class: "".concat(X.value, "-link"),
                onClick: C.onClick
            }, ae), [ne]) : oe = createVNode("span", _objectSpread2$1({
                class: "".concat(X.value, "-link"),
                onClick: C.onClick
            }, ae), [ne]), oe = Z(oe, X.value), ne ? createVNode("span", {
                class: te,
                style: re
            }, [oe, ee && createVNode("span", {
                class: "".concat(X.value, "-separator")
            }, [ee])]) : null
        }
    }
});

function shallowEqual(K, C, H, W) {
    var U = H ? H.call(W, K, C) : void 0;
    if (U !== void 0) return !!U;
    if (K === C) return !0;
    if (_typeof$2(K) !== "object" || !K || _typeof$2(C) !== "object" || !C) return !1;
    var G = Object.keys(K),
        X = Object.keys(C);
    if (G.length !== X.length) return !1;
    for (var Z = Object.prototype.hasOwnProperty.bind(C), Q = 0; Q < G.length; Q++) {
        var ee = G[Q];
        if (!Z(ee)) return !1;
        var ne = K[ee],
            te = C[ee];
        if (U = H ? H.call(W, ne, te, ee) : void 0, U === !1 || U === void 0 && ne !== te) return !1
    }
    return !0
}

function shallowequal(K, C, H, W) {
    return shallowEqual(toRaw(K), toRaw(C), H, W)
}
var MenuContextKey = Symbol("menuContextKey"),
    useProvideMenu = function (C) {
        provide(MenuContextKey, C)
    },
    useInjectMenu = function () {
        return inject(MenuContextKey)
    },
    ForceRenderKey = Symbol("ForceRenderKey"),
    useProvideForceRender = function (C) {
        provide(ForceRenderKey, C)
    },
    useInjectForceRender = function () {
        return inject(ForceRenderKey, !1)
    },
    MenuFirstLevelContextKey = Symbol("menuFirstLevelContextKey"),
    useProvideFirstLevel = function (C) {
        provide(MenuFirstLevelContextKey, C)
    },
    useInjectFirstLevel = function () {
        return inject(MenuFirstLevelContextKey, !0)
    },
    MenuContextProvider = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "MenuContextProvider",
        inheritAttrs: !1,
        props: {
            mode: {
                type: String,
                default: void 0
            },
            overflowDisabled: {
                type: Boolean,
                default: void 0
            },
            isRootMenu: {
                type: Boolean,
                default: void 0
            }
        },
        setup: function (C, H) {
            var W = H.slots,
                U = useInjectMenu(),
                G = _objectSpread2$1({}, U);
            return C.mode !== void 0 && (G.mode = toRef(C, "mode")), C.isRootMenu !== void 0 && (G.isRootMenu =
                    toRef(C, "isRootMenu")), C.overflowDisabled !== void 0 && (G.overflowDisabled = toRef(C,
                    "overflowDisabled")), useProvideMenu(G),
                function () {
                    var X;
                    return (X = W.default) === null || X === void 0 ? void 0 : X.call(W)
                }
        }
    });
const useProvideMenu$1 = useProvideMenu;

function baseFindIndex(K, C, H, W) {
    for (var U = K.length, G = H + (W ? 1 : -1); W ? G-- : ++G < U;)
        if (C(K[G], G, K)) return G;
    return -1
}

function baseIsNaN(K) {
    return K !== K
}

function strictIndexOf(K, C, H) {
    for (var W = H - 1, U = K.length; ++W < U;)
        if (K[W] === C) return W;
    return -1
}

function baseIndexOf(K, C, H) {
    return C === C ? strictIndexOf(K, C, H) : baseFindIndex(K, baseIsNaN, H)
}

function arrayIncludes(K, C) {
    var H = K == null ? 0 : K.length;
    return !!H && baseIndexOf(K, C, 0) > -1
}

function arrayIncludesWith(K, C, H) {
    for (var W = -1, U = K == null ? 0 : K.length; ++W < U;)
        if (H(C, K[W])) return !0;
    return !1
}

function noop$a() {}
var INFINITY$3 = 1 / 0,
    createSet = Set$2 && 1 / setToArray(new Set$2([, -0]))[1] == INFINITY$3 ? function (K) {
        return new Set$2(K)
    } : noop$a;
const createSet$1 = createSet;
var LARGE_ARRAY_SIZE = 200;

function baseUniq(K, C, H) {
    var W = -1,
        U = arrayIncludes,
        G = K.length,
        X = !0,
        Z = [],
        Q = Z;
    if (H) X = !1, U = arrayIncludesWith;
    else if (G >= LARGE_ARRAY_SIZE) {
        var ee = C ? null : createSet$1(K);
        if (ee) return setToArray(ee);
        X = !1, U = cacheHas, Q = new SetCache
    } else Q = C ? [] : Z;
    e: for (; ++W < G;) {
        var ne = K[W],
            te = C ? C(ne) : ne;
        if (ne = H || ne !== 0 ? ne : 0, X && te === te) {
            for (var re = Q.length; re--;)
                if (Q[re] === te) continue e;
            C && Q.push(te), Z.push(ne)
        } else U(Q, te, H) || (Q !== Z && Q.push(te), Z.push(ne))
    }
    return Z
}

function uniq(K) {
    return K && K.length ? baseUniq(K) : []
}
var SiderCollapsedKey = Symbol("siderCollapsed"),
    SiderHookProviderKey = Symbol("siderHookProvider"),
    OVERFLOW_KEY = "$$__vc-menu-more__key",
    KeyPathContext = Symbol("KeyPathContext"),
    useInjectKeyPath = function () {
        return inject(KeyPathContext, {
            parentEventKeys: computed(function () {
                return []
            }),
            parentKeys: computed(function () {
                return []
            }),
            parentInfo: {}
        })
    },
    useProvideKeyPath = function (C, H, W) {
        var U = useInjectKeyPath(),
            G = U.parentEventKeys,
            X = U.parentKeys,
            Z = computed(function () {
                return [].concat(_toConsumableArray(G.value), [C])
            }),
            Q = computed(function () {
                return [].concat(_toConsumableArray(X.value), [H])
            });
        return provide(KeyPathContext, {
            parentEventKeys: Z,
            parentKeys: Q,
            parentInfo: W
        }), Q
    },
    measure$1 = Symbol("measure"),
    PathContext = defineComponent({
        compatConfig: {
            MODE: 3
        },
        setup: function (C, H) {
            var W = H.slots;
            return provide(measure$1, !0),
                function () {
                    var U;
                    return (U = W.default) === null || U === void 0 ? void 0 : U.call(W)
                }
        }
    }),
    useMeasure = function () {
        return inject(measure$1, !1)
    };
const useProvideKeyPath$1 = useProvideKeyPath;

function useDirectionStyle(K) {
    var C = useInjectMenu(),
        H = C.mode,
        W = C.rtl,
        U = C.inlineIndent;
    return computed(function () {
        return H.value !== "inline" ? null : W.value ? {
            paddingRight: "".concat(K.value * U.value, "px")
        } : {
            paddingLeft: "".concat(K.value * U.value, "px")
        }
    })
}
var indexGuid$3 = 0,
    menuItemProps = function () {
        return {
            id: String,
            role: String,
            disabled: Boolean,
            danger: Boolean,
            title: {
                type: [String, Boolean],
                default: void 0
            },
            icon: PropTypes$1.any,
            onMouseenter: Function,
            onMouseleave: Function,
            onClick: Function,
            onKeydown: Function,
            onFocus: Function
        }
    };
const MenuItem$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AMenuItem",
    inheritAttrs: !1,
    props: menuItemProps(),
    slots: ["icon", "title"],
    setup: function (C, H) {
        var W = H.slots,
            U = H.emit,
            G = H.attrs,
            X = getCurrentInstance(),
            Z = useMeasure(),
            Q = _typeof$2(X.vnode.key) === "symbol" ? String(X.vnode.key) : X.vnode.key;
        devWarning(_typeof$2(X.vnode.key) !== "symbol", "MenuItem", 'MenuItem `:key="'.concat(String(Q),
            '"` not support Symbol type'));
        var ee = "menu_item_".concat(++indexGuid$3, "_$$_").concat(Q),
            ne = useInjectKeyPath(),
            te = ne.parentEventKeys,
            re = ne.parentKeys,
            ae = useInjectMenu(),
            oe = ae.prefixCls,
            ie = ae.activeKeys,
            ue = ae.disabled,
            le = ae.changeActiveKeys,
            se = ae.rtl,
            ce = ae.inlineCollapsed,
            de = ae.siderCollapsed,
            ve = ae.onItemClick,
            fe = ae.selectedKeys,
            pe = ae.registerMenuInfo,
            me = ae.unRegisterMenuInfo,
            he = useInjectFirstLevel(),
            Se = ref(!1),
            _e = computed(function () {
                return [].concat(_toConsumableArray(re.value), [Q])
            }),
            be = {
                eventKey: ee,
                key: Q,
                parentEventKeys: te,
                parentKeys: re,
                isLeaf: !0
            };
        pe(ee, be), onBeforeUnmount(function () {
            me(ee)
        }), watch(ie, function () {
            Se.value = !!ie.value.find(function (ke) {
                return ke === Q
            })
        }, {
            immediate: !0
        });
        var ge = computed(function () {
                return ue.value || C.disabled
            }),
            xe = computed(function () {
                return fe.value.includes(Q)
            }),
            Pe = computed(function () {
                var ke, Ee = "".concat(oe.value, "-item");
                return ke = {}, _defineProperty$V(ke, "".concat(Ee), !0), _defineProperty$V(ke, "".concat(
                        Ee, "-danger"), C.danger), _defineProperty$V(ke, "".concat(Ee, "-active"), Se.value),
                    _defineProperty$V(ke, "".concat(Ee, "-selected"), xe.value), _defineProperty$V(ke,
                        "".concat(Ee, "-disabled"), ge.value), ke
            }),
            $e = function (Ee) {
                return {
                    key: Q,
                    eventKey: ee,
                    keyPath: _e.value,
                    eventKeyPath: [].concat(_toConsumableArray(te.value), [ee]),
                    domEvent: Ee,
                    item: _objectSpread2$1(_objectSpread2$1({}, C), G)
                }
            },
            ye = function (Ee) {
                if (!ge.value) {
                    var Ae = $e(Ee);
                    U("click", Ee), ve(Ae)
                }
            },
            Ce = function (Ee) {
                ge.value || (le(_e.value), U("mouseenter", Ee))
            },
            we = function (Ee) {
                ge.value || (le([]), U("mouseleave", Ee))
            },
            Oe = function (Ee) {
                if (U("keydown", Ee), Ee.which === KeyCode$1.ENTER) {
                    var Ae = $e(Ee);
                    U("click", Ee), ve(Ae)
                }
            },
            Ne = function (Ee) {
                le(_e.value), U("focus", Ee)
            },
            Me = function (Ee, Ae) {
                var Re = createVNode("span", {
                    class: "".concat(oe.value, "-title-content")
                }, [Ae]);
                return (!Ee || isValidElement(Ae) && Ae.type === "span") && Ae && ce.value && he && typeof Ae ==
                    "string" ? createVNode("div", {
                        class: "".concat(oe.value, "-inline-collapsed-noicon")
                    }, [Ae.charAt(0)]) : Re
            },
            Ve = useDirectionStyle(computed(function () {
                return _e.value.length
            }));
        return function () {
            var ke, Ee, Ae, Re;
            if (Z) return null;
            var He = (ke = C.title) !== null && ke !== void 0 ? ke : (Ee = W.title) === null || Ee ===
                void 0 ? void 0 : Ee.call(W),
                je = flattenChildren((Ae = W.default) === null || Ae === void 0 ? void 0 : Ae.call(W)),
                Fe = je.length,
                Le = He;
            typeof He > "u" ? Le = he && Fe ? je : "" : He === !1 && (Le = "");
            var Ie = {
                title: Le
            };
            !de.value && !ce.value && (Ie.title = null, Ie.visible = !1);
            var Te = {};
            C.role === "option" && (Te["aria-selected"] = xe.value);
            var De = getPropsSlot(W, C, "icon");
            return createVNode(Tooltip, _objectSpread2$1(_objectSpread2$1({}, Ie), {}, {
                placement: se.value ? "left" : "right",
                overlayClassName: "".concat(oe.value, "-inline-collapsed-tooltip")
            }), {
                default: function () {
                    return [createVNode(Overflow$1.Item, _objectSpread2$1(_objectSpread2$1(
                        _objectSpread2$1({
                            component: "li"
                        }, G), {}, {
                            id: C.id,
                            style: _objectSpread2$1(_objectSpread2$1({}, G.style ||
                                {}), Ve.value),
                            class: [Pe.value, (Re = {}, _defineProperty$V(
                                Re, "".concat(G.class), !!G.class
                            ), _defineProperty$V(Re, "".concat(
                                oe.value,
                                "-item-only-child"), (De ?
                                Fe + 1 : Fe) === 1), Re)],
                            role: C.role || "menuitem",
                            tabindex: C.disabled ? null : -1,
                            "data-menu-id": Q,
                            "aria-disabled": C.disabled
                        }, Te), {}, {
                        onMouseenter: Ce,
                        onMouseleave: we,
                        onClick: ye,
                        onKeydown: Oe,
                        onFocus: Ne,
                        title: typeof He == "string" ? He : void 0
                    }), {
                        default: function () {
                            return [cloneElement(De, {
                                class: "".concat(oe.value,
                                    "-item-icon")
                            }, !1), Me(De, je)]
                        }
                    })]
                }
            })
        }
    }
});
var autoAdjustOverflow = {
        adjustX: 1,
        adjustY: 1
    },
    placements = {
        topLeft: {
            points: ["bl", "tl"],
            overflow: autoAdjustOverflow,
            offset: [0, -7]
        },
        bottomLeft: {
            points: ["tl", "bl"],
            overflow: autoAdjustOverflow,
            offset: [0, 7]
        },
        leftTop: {
            points: ["tr", "tl"],
            overflow: autoAdjustOverflow,
            offset: [-4, 0]
        },
        rightTop: {
            points: ["tl", "tr"],
            overflow: autoAdjustOverflow,
            offset: [4, 0]
        }
    },
    placementsRtl = {
        topLeft: {
            points: ["bl", "tl"],
            overflow: autoAdjustOverflow,
            offset: [0, -7]
        },
        bottomLeft: {
            points: ["tl", "bl"],
            overflow: autoAdjustOverflow,
            offset: [0, 7]
        },
        rightTop: {
            points: ["tr", "tl"],
            overflow: autoAdjustOverflow,
            offset: [-4, 0]
        },
        leftTop: {
            points: ["tl", "tr"],
            overflow: autoAdjustOverflow,
            offset: [4, 0]
        }
    },
    popupPlacementMap = {
        horizontal: "bottomLeft",
        vertical: "rightTop",
        "vertical-left": "rightTop",
        "vertical-right": "leftTop"
    };
const PopupTrigger = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "PopupTrigger",
    inheritAttrs: !1,
    props: {
        prefixCls: String,
        mode: String,
        visible: Boolean,
        popupClassName: String,
        popupOffset: Array,
        disabled: Boolean,
        onVisibleChange: Function
    },
    slots: ["popup"],
    emits: ["visibleChange"],
    setup: function (C, H) {
        var W = H.slots,
            U = H.emit,
            G = ref(!1),
            X = useInjectMenu(),
            Z = X.getPopupContainer,
            Q = X.rtl,
            ee = X.subMenuOpenDelay,
            ne = X.subMenuCloseDelay,
            te = X.builtinPlacements,
            re = X.triggerSubMenuAction,
            ae = X.isRootMenu,
            oe = X.forceSubMenuRender,
            ie = X.motion,
            ue = X.defaultMotions,
            le = useInjectForceRender(),
            se = computed(function () {
                return Q.value ? _objectSpread2$1(_objectSpread2$1({}, placementsRtl), te.value) :
                    _objectSpread2$1(_objectSpread2$1({}, placements), te.value)
            }),
            ce = computed(function () {
                return popupPlacementMap[C.mode]
            }),
            de = ref();
        watch(function () {
            return C.visible
        }, function (pe) {
            wrapperRaf.cancel(de.value), de.value = wrapperRaf(function () {
                G.value = pe
            })
        }, {
            immediate: !0
        }), onBeforeUnmount(function () {
            wrapperRaf.cancel(de.value)
        });
        var ve = function (me) {
                U("visibleChange", me)
            },
            fe = computed(function () {
                var pe, me, he = ie.value || ((pe = ue.value) === null || pe === void 0 ? void 0 : pe[C
                        .mode]) || ((me = ue.value) === null || me === void 0 ? void 0 : me.other),
                    Se = typeof he == "function" ? he() : he;
                return Se ? getTransitionProps(Se.name, {
                    css: !0
                }) : void 0
            });
        return function () {
            var pe = C.prefixCls,
                me = C.popupClassName,
                he = C.mode,
                Se = C.popupOffset,
                _e = C.disabled;
            return createVNode(Trigger, {
                prefixCls: pe,
                popupClassName: classNames("".concat(pe, "-popup"), _defineProperty$V({}, "".concat(
                    pe, "-rtl"), Q.value), me),
                stretch: he === "horizontal" ? "minWidth" : null,
                getPopupContainer: ae.value ? Z.value : function (be) {
                    return be.parentNode
                },
                builtinPlacements: se.value,
                popupPlacement: ce.value,
                popupVisible: G.value,
                popupAlign: Se && {
                    offset: Se
                },
                action: _e ? [] : [re.value],
                mouseEnterDelay: ee.value,
                mouseLeaveDelay: ne.value,
                onPopupVisibleChange: ve,
                forceRender: le || oe.value,
                popupAnimation: fe.value
            }, {
                popup: W.popup,
                default: W.default
            })
        }
    }
});
var InternalSubMenuList = function (C, H) {
    var W, U = H.slots,
        G = H.attrs,
        X = useInjectMenu(),
        Z = X.prefixCls,
        Q = X.mode;
    return createVNode("ul", _objectSpread2$1(_objectSpread2$1({}, G), {}, {
        class: classNames(Z.value, "".concat(Z.value, "-sub"), "".concat(Z.value, "-").concat(Q.value ===
            "inline" ? "inline" : "vertical")),
        "data-menu-list": !0
    }), [(W = U.default) === null || W === void 0 ? void 0 : W.call(U)])
};
InternalSubMenuList.displayName = "SubMenuList";
const SubMenuList = InternalSubMenuList,
    InlineSubMenuList = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "InlineSubMenuList",
        inheritAttrs: !1,
        props: {
            id: String,
            open: Boolean,
            keyPath: Array
        },
        setup: function (C, H) {
            var W = H.slots,
                U = computed(function () {
                    return "inline"
                }),
                G = useInjectMenu(),
                X = G.motion,
                Z = G.mode,
                Q = G.defaultMotions,
                ee = computed(function () {
                    return Z.value === U.value
                }),
                ne = ref(!ee.value),
                te = computed(function () {
                    return ee.value ? C.open : !1
                });
            watch(Z, function () {
                ee.value && (ne.value = !1)
            }, {
                flush: "post"
            });
            var re = computed(function () {
                var ae, oe, ie = X.value || ((ae = Q.value) === null || ae === void 0 ? void 0 : ae[U.value]) ||
                    ((oe = Q.value) === null || oe === void 0 ? void 0 : oe.other),
                    ue = typeof ie == "function" ? ie() : ie;
                return _objectSpread2$1(_objectSpread2$1({}, ue), {}, {
                    appear: C.keyPath.length <= 1
                })
            });
            return function () {
                var ae;
                return ne.value ? null : createVNode(MenuContextProvider, {
                    mode: U.value
                }, {
                    default: function () {
                        return [createVNode(Transition, re.value, {
                            default: function () {
                                return [withDirectives(createVNode(SubMenuList, {
                                    id: C.id
                                }, {
                                    default: function () {
                                        return [(ae = W.default) ===
                                            null || ae ===
                                            void 0 ?
                                            void 0 : ae
                                            .call(W)]
                                    }
                                }), [[vShow, te.value]])]
                            }
                        })]
                    }
                })
            }
        }
    });
var indexGuid$2 = 0,
    subMenuProps = function () {
        return {
            icon: PropTypes$1.any,
            title: PropTypes$1.any,
            disabled: Boolean,
            level: Number,
            popupClassName: String,
            popupOffset: Array,
            internalPopupClose: Boolean,
            eventKey: String,
            expandIcon: Function,
            onMouseenter: Function,
            onMouseleave: Function,
            onTitleClick: Function
        }
    };
const SubMenu$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ASubMenu",
    inheritAttrs: !1,
    props: subMenuProps(),
    slots: ["icon", "title", "expandIcon"],
    setup: function (C, H) {
        var W, U, G = H.slots,
            X = H.attrs,
            Z = H.emit;
        useProvideFirstLevel(!1);
        var Q = useMeasure(),
            ee = getCurrentInstance(),
            ne = _typeof$2(ee.vnode.key) === "symbol" ? String(ee.vnode.key) : ee.vnode.key;
        devWarning(_typeof$2(ee.vnode.key) !== "symbol", "SubMenu", 'SubMenu `:key="'.concat(String(ne),
            '"` not support Symbol type'));
        var te = isValid$5(ne) ? ne : "sub_menu_".concat(++indexGuid$2, "_$$_not_set_key"),
            re = (W = C.eventKey) !== null && W !== void 0 ? W : isValid$5(ne) ? "sub_menu_".concat(++
                indexGuid$2, "_$$_").concat(ne) : te,
            ae = useInjectKeyPath(),
            oe = ae.parentEventKeys,
            ie = ae.parentInfo,
            ue = ae.parentKeys,
            le = computed(function () {
                return [].concat(_toConsumableArray(ue.value), [te])
            }),
            se = ref([]),
            ce = {
                eventKey: re,
                key: te,
                parentEventKeys: oe,
                childrenEventKeys: se,
                parentKeys: ue
            };
        (U = ie.childrenEventKeys) === null || U === void 0 || U.value.push(re), onBeforeUnmount(function () {
            if (ie.childrenEventKeys) {
                var Ge;
                ie.childrenEventKeys.value = (Ge = ie.childrenEventKeys) === null || Ge === void 0 ?
                    void 0 : Ge.value.filter(function (Xe) {
                        return Xe != re
                    })
            }
        }), useProvideKeyPath$1(re, te, ce);
        var de = useInjectMenu(),
            ve = de.prefixCls,
            fe = de.activeKeys,
            pe = de.disabled,
            me = de.changeActiveKeys,
            he = de.mode,
            Se = de.inlineCollapsed,
            _e = de.antdMenuTheme,
            be = de.openKeys,
            ge = de.overflowDisabled,
            xe = de.onOpenChange,
            Pe = de.registerMenuInfo,
            $e = de.unRegisterMenuInfo,
            ye = de.selectedSubMenuKeys,
            Ce = de.expandIcon,
            we = ne != null,
            Oe = !Q && (useInjectForceRender() || !we);
        useProvideForceRender(Oe), (Q && we || !Q && !we || Oe) && (Pe(re, ce), onBeforeUnmount(function () {
            $e(re)
        }));
        var Ne = computed(function () {
                return "".concat(ve.value, "-submenu")
            }),
            Me = computed(function () {
                return pe.value || C.disabled
            }),
            Ve = ref(),
            ke = ref(),
            Ee = computed(function () {
                return be.value.includes(te)
            }),
            Ae = computed(function () {
                return !ge.value && Ee.value
            }),
            Re = computed(function () {
                return ye.value.includes(te)
            }),
            He = ref(!1);
        watch(fe, function () {
            He.value = !!fe.value.find(function (Ge) {
                return Ge === te
            })
        }, {
            immediate: !0
        });
        var je = function (Xe) {
                Me.value || (Z("titleClick", Xe, te), he.value === "inline" && xe(te, !Ee.value))
            },
            Fe = function (Xe) {
                Me.value || (me(le.value), Z("mouseenter", Xe))
            },
            Le = function (Xe) {
                Me.value || (me([]), Z("mouseleave", Xe))
            },
            Ie = useDirectionStyle(computed(function () {
                return le.value.length
            })),
            Te = function (Xe) {
                he.value !== "inline" && xe(te, Xe)
            },
            De = function () {
                me(le.value)
            },
            Ke = re && "".concat(re, "-popup"),
            We = computed(function () {
                return classNames(ve.value, "".concat(ve.value, "-").concat(_e.value), C.popupClassName)
            }),
            Ue = function (Xe, nt) {
                if (!nt) return Se.value && !ue.value.length && Xe && typeof Xe == "string" ? createVNode(
                    "div", {
                        class: "".concat(ve.value, "-inline-collapsed-noicon")
                    }, [Xe.charAt(0)]) : createVNode("span", {
                    class: "".concat(ve.value, "-title-content")
                }, [Xe]);
                var it = isValidElement(Xe) && Xe.type === "span";
                return createVNode(Fragment, null, [cloneElement(nt, {
                    class: "".concat(ve.value, "-item-icon")
                }, !1), it ? Xe : createVNode("span", {
                    class: "".concat(ve.value, "-title-content")
                }, [Xe])])
            },
            et = computed(function () {
                return he.value !== "inline" && le.value.length > 1 ? "vertical" : he.value
            }),
            Ye = computed(function () {
                return he.value === "horizontal" ? "vertical" : he.value
            }),
            ze = computed(function () {
                return et.value === "horizontal" ? "vertical" : et.value
            }),
            Be = function () {
                var Xe = Ne.value,
                    nt = getPropsSlot(G, C, "icon"),
                    it = C.expandIcon || G.expandIcon || Ce.value,
                    ft = Ue(getPropsSlot(G, C, "title"), nt);
                return createVNode("div", {
                    style: Ie.value,
                    class: "".concat(Xe, "-title"),
                    tabindex: Me.value ? null : -1,
                    ref: Ve,
                    title: typeof ft == "string" ? ft : null,
                    "data-menu-id": te,
                    "aria-expanded": Ae.value,
                    "aria-haspopup": !0,
                    "aria-controls": Ke,
                    "aria-disabled": Me.value,
                    onClick: je,
                    onFocus: De
                }, [ft, he.value !== "horizontal" && it ? it(_objectSpread2$1(_objectSpread2$1({},
                    C), {}, {
                    isOpen: Ae.value
                })) : createVNode("i", {
                    class: "".concat(Xe, "-arrow")
                }, null)])
            };
        return function () {
            var Ge;
            if (Q) {
                var Xe;
                return we ? (Xe = G.default) === null || Xe === void 0 ? void 0 : Xe.call(G) : null
            }
            var nt = Ne.value,
                it = function () {
                    return null
                };
            return !ge.value && he.value !== "inline" ? it = function () {
                return createVNode(PopupTrigger, {
                    mode: et.value,
                    prefixCls: nt,
                    visible: !C.internalPopupClose && Ae.value,
                    popupClassName: We.value,
                    popupOffset: C.popupOffset,
                    disabled: Me.value,
                    onVisibleChange: Te
                }, {
                    default: function () {
                        return [Be()]
                    },
                    popup: function () {
                        return createVNode(MenuContextProvider, {
                            mode: ze.value,
                            isRootMenu: !1
                        }, {
                            default: function () {
                                return [createVNode(SubMenuList, {
                                    id: Ke,
                                    ref: ke
                                }, {
                                    default: G.default
                                })]
                            }
                        })
                    }
                })
            } : it = function () {
                return createVNode(PopupTrigger, null, {
                    default: Be
                })
            }, createVNode(MenuContextProvider, {
                mode: Ye.value
            }, {
                default: function () {
                    return [createVNode(Overflow$1.Item, _objectSpread2$1(_objectSpread2$1({
                        component: "li"
                    }, X), {}, {
                        role: "none",
                        class: classNames(nt, "".concat(nt, "-").concat(he.value),
                            X.class, (Ge = {}, _defineProperty$V(Ge, ""
                                    .concat(nt, "-open"), Ae.value),
                                _defineProperty$V(Ge, "".concat(nt,
                                    "-active"), He.value),
                                _defineProperty$V(Ge, "".concat(nt,
                                    "-selected"), Re.value),
                                _defineProperty$V(Ge, "".concat(nt,
                                    "-disabled"), Me.value), Ge)),
                        onMouseenter: Fe,
                        onMouseleave: Le,
                        "data-submenu-id": te
                    }), {
                        default: function () {
                            return createVNode(Fragment, null, [it(), !ge.value &&
                                createVNode(InlineSubMenuList, {
                                    id: Ke,
                                    open: Ae.value,
                                    keyPath: le.value
                                }, {
                                    default: G.default
                                })])
                        }
                    })]
                }
            })
        }
    }
});

function hasClass(K, C) {
    if (K.classList) return K.classList.contains(C);
    var H = K.className;
    return " ".concat(H, " ").indexOf(" ".concat(C, " ")) > -1
}

function addClass(K, C) {
    K.classList ? K.classList.add(C) : hasClass(K, C) || (K.className = "".concat(K.className, " ").concat(C))
}

function removeClass(K, C) {
    if (K.classList) K.classList.remove(C);
    else if (hasClass(K, C)) {
        var H = K.className;
        K.className = " ".concat(H, " ").replace(" ".concat(C, " "), " ")
    }
}
var collapseMotion = function () {
    var C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ant-motion-collapse",
        H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return {
        name: C,
        appear: H,
        css: !0,
        onBeforeEnter: function (U) {
            U.style.height = "0px", U.style.opacity = "0", addClass(U, C)
        },
        onEnter: function (U) {
            nextTick(function () {
                U.style.height = "".concat(U.scrollHeight, "px"), U.style.opacity = "1"
            })
        },
        onAfterEnter: function (U) {
            U && (removeClass(U, C), U.style.height = null, U.style.opacity = null)
        },
        onBeforeLeave: function (U) {
            addClass(U, C), U.style.height = "".concat(U.offsetHeight, "px"), U.style.opacity = null
        },
        onLeave: function (U) {
            setTimeout(function () {
                U.style.height = "0px", U.style.opacity = "0"
            })
        },
        onAfterLeave: function (U) {
            U && (removeClass(U, C), U.style && (U.style.height = null, U.style.opacity = null))
        }
    }
};
const collapseMotion$1 = collapseMotion;
var menuProps = function () {
        return {
            id: String,
            prefixCls: String,
            disabled: Boolean,
            inlineCollapsed: Boolean,
            disabledOverflow: Boolean,
            forceSubMenuRender: Boolean,
            openKeys: Array,
            selectedKeys: Array,
            activeKey: String,
            selectable: {
                type: Boolean,
                default: !0
            },
            multiple: {
                type: Boolean,
                default: !1
            },
            motion: Object,
            theme: {
                type: String,
                default: "light"
            },
            mode: {
                type: String,
                default: "vertical"
            },
            inlineIndent: {
                type: Number,
                default: 24
            },
            subMenuOpenDelay: {
                type: Number,
                default: .1
            },
            subMenuCloseDelay: {
                type: Number,
                default: .1
            },
            builtinPlacements: {
                type: Object
            },
            triggerSubMenuAction: {
                type: String,
                default: "hover"
            },
            getPopupContainer: Function,
            expandIcon: Function,
            onOpenChange: Function,
            onSelect: Function,
            onDeselect: Function,
            onClick: [Function, Array],
            onFocus: Function,
            onBlur: Function,
            onMousedown: Function,
            "onUpdate:openKeys": Function,
            "onUpdate:selectedKeys": Function,
            "onUpdate:activeKey": Function
        }
    },
    EMPTY_LIST$2 = [];
const Menu = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AMenu",
    inheritAttrs: !1,
    props: menuProps(),
    slots: ["expandIcon", "overflowedIndicator"],
    setup: function (C, H) {
        var W = H.slots,
            U = H.emit,
            G = H.attrs,
            X = useConfigInject("menu", C),
            Z = X.prefixCls,
            Q = X.direction,
            ee = X.getPrefixCls,
            ne = ref({}),
            te = inject(SiderCollapsedKey, ref(void 0)),
            re = computed(function () {
                return te.value !== void 0 ? te.value : C.inlineCollapsed
            }),
            ae = ref(!1);
        onMounted(function () {
            ae.value = !0
        }), watchEffect(function () {
            devWarning(!(C.inlineCollapsed === !0 && C.mode !== "inline"), "Menu",
                "`inlineCollapsed` should only be used when `mode` is inline."), devWarning(!(
                    te.value !== void 0 && C.inlineCollapsed === !0), "Menu",
                "`inlineCollapsed` not control Menu under Sider. Should set `collapsed` on Sider instead."
            )
        });
        var oe = ref([]),
            ie = ref([]),
            ue = ref({});
        watch(ne, function () {
            for (var ke = {}, Ee = 0, Ae = Object.values(ne.value); Ee < Ae.length; Ee++) {
                var Re = Ae[Ee];
                ke[Re.key] = Re
            }
            ue.value = ke
        }, {
            flush: "post"
        }), watchEffect(function () {
            if (C.activeKey !== void 0) {
                var ke = [],
                    Ee = C.activeKey ? ue.value[C.activeKey] : void 0;
                Ee && C.activeKey !== void 0 ? ke = uniq([].concat(unref(Ee.parentKeys), C.activeKey)) :
                    ke = [], shallowequal(oe.value, ke) || (oe.value = ke)
            }
        }), watch(function () {
            return C.selectedKeys
        }, function (ke) {
            ke && (ie.value = ke.slice())
        }, {
            immediate: !0,
            deep: !0
        });
        var le = ref([]);
        watch([ue, ie], function () {
            var ke = [];
            ie.value.forEach(function (Ee) {
                var Ae = ue.value[Ee];
                Ae && (ke = ke.concat(unref(Ae.parentKeys)))
            }), ke = uniq(ke), shallowequal(le.value, ke) || (le.value = ke)
        }, {
            immediate: !0
        });
        var se = function (Ee) {
                if (C.selectable) {
                    var Ae = Ee.key,
                        Re = ie.value.includes(Ae),
                        He;
                    C.multiple ? Re ? He = ie.value.filter(function (Fe) {
                        return Fe !== Ae
                    }) : He = [].concat(_toConsumableArray(ie.value), [Ae]) : He = [Ae];
                    var je = _objectSpread2$1(_objectSpread2$1({}, Ee), {}, {
                        selectedKeys: He
                    });
                    shallowequal(He, ie.value) || (C.selectedKeys === void 0 && (ie.value = He), U(
                        "update:selectedKeys", He), Re && C.multiple ? U("deselect", je) : U(
                        "select", je)), me.value !== "inline" && !C.multiple && ce.value.length && _e(
                        EMPTY_LIST$2)
                }
            },
            ce = ref([]);
        watch(function () {
            return C.openKeys
        }, function () {
            var ke = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ce.value;
            shallowequal(ce.value, ke) || (ce.value = ke.slice())
        }, {
            immediate: !0,
            deep: !0
        });
        var de, ve = function (Ee) {
                clearTimeout(de), de = setTimeout(function () {
                    C.activeKey === void 0 && (oe.value = Ee), U("update:activeKey", Ee[Ee.length -
                        1])
                })
            },
            fe = computed(function () {
                return !!C.disabled
            }),
            pe = computed(function () {
                return Q.value === "rtl"
            }),
            me = ref("vertical"),
            he = ref(!1);
        watchEffect(function () {
            (C.mode === "inline" || C.mode === "vertical") && re.value ? (me.value = "vertical", he
                .value = re.value) : (me.value = C.mode, he.value = !1)
        });
        var Se = computed(function () {
                return me.value === "inline"
            }),
            _e = function (Ee) {
                ce.value = Ee, U("update:openKeys", Ee), U("openChange", Ee)
            },
            be = ref(ce.value),
            ge = ref(!1);
        watch(ce, function () {
            Se.value && (be.value = ce.value)
        }, {
            immediate: !0
        }), watch(Se, function () {
            if (!ge.value) {
                ge.value = !0;
                return
            }
            Se.value ? ce.value = be.value : _e(EMPTY_LIST$2)
        }, {
            immediate: !0
        });
        var xe = computed(function () {
                var ke;
                return ke = {}, _defineProperty$V(ke, "".concat(Z.value), !0), _defineProperty$V(ke, ""
                        .concat(Z.value, "-root"), !0), _defineProperty$V(ke, "".concat(Z.value, "-").concat(
                        me.value), !0), _defineProperty$V(ke, "".concat(Z.value, "-inline-collapsed"),
                        he.value), _defineProperty$V(ke, "".concat(Z.value, "-rtl"), pe.value),
                    _defineProperty$V(ke, "".concat(Z.value, "-").concat(C.theme), !0), ke
            }),
            Pe = computed(function () {
                return ee()
            }),
            $e = computed(function () {
                return {
                    horizontal: {
                        name: "".concat(Pe.value, "-slide-up")
                    },
                    inline: collapseMotion$1,
                    other: {
                        name: "".concat(Pe.value, "-zoom-big")
                    }
                }
            });
        useProvideFirstLevel(!0);
        var ye = function ke() {
                var Ee = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
                    Ae = [],
                    Re = ne.value;
                return Ee.forEach(function (He) {
                    var je = Re[He],
                        Fe = je.key,
                        Le = je.childrenEventKeys;
                    Ae.push.apply(Ae, [Fe].concat(_toConsumableArray(ke(unref(Le)))))
                }), Ae
            },
            Ce = function (Ee) {
                U("click", Ee), se(Ee)
            },
            we = function (Ee, Ae) {
                var Re, He = ((Re = ue.value[Ee]) === null || Re === void 0 ? void 0 : Re.childrenEventKeys) ||
                    [],
                    je = ce.value.filter(function (Le) {
                        return Le !== Ee
                    });
                if (Ae) je.push(Ee);
                else if (me.value !== "inline") {
                    var Fe = ye(unref(He));
                    je = uniq(je.filter(function (Le) {
                        return !Fe.includes(Le)
                    }))
                }
                shallowequal(ce, je) || _e(je)
            },
            Oe = function (Ee, Ae) {
                ne.value = _objectSpread2$1(_objectSpread2$1({}, ne.value), {}, _defineProperty$V({}, Ee,
                    Ae))
            },
            Ne = function (Ee) {
                delete ne.value[Ee], ne.value = _objectSpread2$1({}, ne.value)
            },
            Me = ref(0),
            Ve = computed(function () {
                return C.expandIcon || W.expandIcon ? function (ke) {
                    var Ee = C.expandIcon || W.expandIcon;
                    return Ee = typeof Ee == "function" ? Ee(ke) : Ee, cloneElement(Ee, {
                        class: "".concat(Z.value, "-submenu-expand-icon")
                    }, !1)
                } : null
            });
        return useProvideMenu$1({
                store: ne,
                prefixCls: Z,
                activeKeys: oe,
                openKeys: ce,
                selectedKeys: ie,
                changeActiveKeys: ve,
                disabled: fe,
                rtl: pe,
                mode: me,
                inlineIndent: computed(function () {
                    return C.inlineIndent
                }),
                subMenuCloseDelay: computed(function () {
                    return C.subMenuCloseDelay
                }),
                subMenuOpenDelay: computed(function () {
                    return C.subMenuOpenDelay
                }),
                builtinPlacements: computed(function () {
                    return C.builtinPlacements
                }),
                triggerSubMenuAction: computed(function () {
                    return C.triggerSubMenuAction
                }),
                getPopupContainer: computed(function () {
                    return C.getPopupContainer
                }),
                inlineCollapsed: he,
                antdMenuTheme: computed(function () {
                    return C.theme
                }),
                siderCollapsed: te,
                defaultMotions: computed(function () {
                    return ae.value ? $e.value : null
                }),
                motion: computed(function () {
                    return ae.value ? C.motion : null
                }),
                overflowDisabled: ref(void 0),
                onOpenChange: we,
                onItemClick: Ce,
                registerMenuInfo: Oe,
                unRegisterMenuInfo: Ne,
                selectedSubMenuKeys: le,
                isRootMenu: ref(!0),
                expandIcon: Ve,
                forceSubMenuRender: computed(function () {
                    return C.forceSubMenuRender
                })
            }),
            function () {
                var ke, Ee, Ae = flattenChildren((ke = W.default) === null || ke === void 0 ? void 0 : ke.call(
                        W)),
                    Re = Me.value >= Ae.length - 1 || me.value !== "horizontal" || C.disabledOverflow,
                    He = me.value !== "horizontal" || C.disabledOverflow ? Ae : Ae.map(function (Fe, Le) {
                        return createVNode(MenuContextProvider, {
                            key: Fe.key,
                            overflowDisabled: Le > Me.value
                        }, {
                            default: function () {
                                return Fe
                            }
                        })
                    }),
                    je = ((Ee = W.overflowedIndicator) === null || Ee === void 0 ? void 0 : Ee.call(W)) ||
                    createVNode(EllipsisOutlined$1, null, null);
                return createVNode(Overflow$1, _objectSpread2$1(_objectSpread2$1({}, G), {}, {
                    onMousedown: C.onMousedown,
                    prefixCls: "".concat(Z.value, "-overflow"),
                    component: "ul",
                    itemComponent: MenuItem$1,
                    class: [xe.value, G.class],
                    role: "menu",
                    id: C.id,
                    data: He,
                    renderRawItem: function (Le) {
                        return Le
                    },
                    renderRawRest: function (Le) {
                        var Ie = Le.length,
                            Te = Ie ? Ae.slice(-Ie) : null;
                        return createVNode(Fragment, null, [createVNode(SubMenu$1, {
                            eventKey: OVERFLOW_KEY,
                            key: OVERFLOW_KEY,
                            title: je,
                            disabled: Re,
                            internalPopupClose: Ie === 0
                        }, {
                            default: function () {
                                return Te
                            }
                        }), createVNode(PathContext, null, {
                            default: function () {
                                return [createVNode(SubMenu$1, {
                                    eventKey: OVERFLOW_KEY,
                                    key: OVERFLOW_KEY,
                                    title: je,
                                    disabled: Re,
                                    internalPopupClose: Ie ===
                                        0
                                }, {
                                    default: function () {
                                        return Te
                                    }
                                })]
                            }
                        })])
                    },
                    maxCount: me.value !== "horizontal" || C.disabledOverflow ? Overflow$1.INVALIDATE :
                        Overflow$1.RESPONSIVE,
                    ssr: "full",
                    "data-menu-list": !0,
                    onVisibleChange: function (Le) {
                        Me.value = Le
                    }
                }), {
                    default: function () {
                        return [createVNode(Teleport, {
                            to: "body"
                        }, {
                            default: function () {
                                return [createVNode("div", {
                                    style: {
                                        display: "none"
                                    },
                                    "aria-hidden": !0
                                }, [createVNode(PathContext, null, {
                                    default: function () {
                                        return [He]
                                    }
                                })])]
                            }
                        })]
                    }
                })
            }
    }
});
var menuItemGroupProps = function () {
    return {
        title: PropTypes$1.any
    }
};
const ItemGroup = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AMenuItemGroup",
    inheritAttrs: !1,
    props: menuItemGroupProps(),
    slots: ["title"],
    setup: function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = useInjectMenu(),
            X = G.prefixCls,
            Z = computed(function () {
                return "".concat(X.value, "-item-group")
            }),
            Q = useMeasure();
        return function () {
            var ee, ne;
            return Q ? (ee = W.default) === null || ee === void 0 ? void 0 : ee.call(W) : createVNode(
                "li", _objectSpread2$1(_objectSpread2$1({}, U), {}, {
                    onClick: function (re) {
                        return re.stopPropagation()
                    },
                    class: Z.value
                }), [createVNode("div", {
                    title: typeof C.title == "string" ? C.title : void 0,
                    class: "".concat(Z.value, "-title")
                }, [getPropsSlot(W, C, "title")]), createVNode("ul", {
                    class: "".concat(Z.value, "-list")
                }, [(ne = W.default) === null || ne === void 0 ? void 0 : ne.call(W)])])
        }
    }
});
var menuDividerProps = function () {
    return {
        prefixCls: String,
        dashed: Boolean
    }
};
const Divider$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AMenuDivider",
    props: menuDividerProps(),
    setup: function (C) {
        var H = useConfigInject("menu", C),
            W = H.prefixCls,
            U = computed(function () {
                var G;
                return G = {}, _defineProperty$V(G, "".concat(W.value, "-item-divider"), !0),
                    _defineProperty$V(G, "".concat(W.value, "-item-divider-dashed"), !!C.dashed), G
            });
        return function () {
            return createVNode("li", {
                class: U.value
            }, null)
        }
    }
});
Menu.install = function (K) {
    return K.component(Menu.name, Menu), K.component(MenuItem$1.name, MenuItem$1), K.component(SubMenu$1.name,
        SubMenu$1), K.component(Divider$1.name, Divider$1), K.component(ItemGroup.name, ItemGroup), K
};
Menu.Item = MenuItem$1;
Menu.Divider = Divider$1;
Menu.SubMenu = SubMenu$1;
Menu.ItemGroup = ItemGroup;
var breadcrumbProps = function () {
    return {
        prefixCls: String,
        routes: {
            type: Array
        },
        params: PropTypes$1.any,
        separator: PropTypes$1.any,
        itemRender: {
            type: Function
        }
    }
};

function getBreadcrumbName(K, C) {
    if (!K.breadcrumbName) return null;
    var H = Object.keys(C).join("|"),
        W = K.breadcrumbName.replace(new RegExp(":(".concat(H, ")"), "g"), function (U, G) {
            return C[G] || U
        });
    return W
}

function defaultItemRender$1(K) {
    var C = K.route,
        H = K.params,
        W = K.routes,
        U = K.paths,
        G = W.indexOf(C) === W.length - 1,
        X = getBreadcrumbName(C, H);
    return G ? createVNode("span", null, [X]) : createVNode("a", {
        href: "#/".concat(U.join("/"))
    }, [X])
}
const Breadcrumb = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ABreadcrumb",
    props: breadcrumbProps(),
    slots: ["separator", "itemRender"],
    setup: function (C, H) {
        var W = H.slots,
            U = useConfigInject("breadcrumb", C),
            G = U.prefixCls,
            X = U.direction,
            Z = function (te, re) {
                return te = (te || "").replace(/^\//, ""), Object.keys(re).forEach(function (ae) {
                    te = te.replace(":".concat(ae), re[ae])
                }), te
            },
            Q = function (te, re, ae) {
                var oe = _toConsumableArray(te),
                    ie = Z(re || "", ae);
                return ie && oe.push(ie), oe
            },
            ee = function (te) {
                var re = te.routes,
                    ae = re === void 0 ? [] : re,
                    oe = te.params,
                    ie = oe === void 0 ? {} : oe,
                    ue = te.separator,
                    le = te.itemRender,
                    se = le === void 0 ? defaultItemRender$1 : le,
                    ce = [];
                return ae.map(function (de) {
                    var ve = Z(de.path, ie);
                    ve && ce.push(ve);
                    var fe = [].concat(ce),
                        pe = null;
                    return de.children && de.children.length && (pe = createVNode(Menu, null, {
                        default: function () {
                            return [de.children.map(function (he) {
                                return createVNode(Menu.Item, {
                                    key: he.path || he.breadcrumbName
                                }, {
                                    default: function () {
                                        return [se({
                                            route: he,
                                            params: ie,
                                            routes: ae,
                                            paths: Q(
                                                fe,
                                                he
                                                .path,
                                                ie
                                            )
                                        })]
                                    }
                                })
                            })]
                        }
                    })), createVNode(BreadcrumbItem, {
                        overlay: pe,
                        separator: ue,
                        key: ve || de.breadcrumbName
                    }, {
                        default: function () {
                            return [se({
                                route: de,
                                params: ie,
                                routes: ae,
                                paths: fe
                            })]
                        }
                    })
                })
            };
        return function () {
            var ne, te, re, ae = C.routes,
                oe = C.params,
                ie = oe === void 0 ? {} : oe,
                ue = flattenChildren(getPropsSlot(W, C)),
                le = (ne = getPropsSlot(W, C, "separator")) !== null && ne !== void 0 ? ne : "/",
                se = C.itemRender || W.itemRender || defaultItemRender$1;
            ae && ae.length > 0 ? re = ee({
                routes: ae,
                params: ie,
                separator: le,
                itemRender: se
            }) : ue.length && (re = ue.map(function (de, ve) {
                return warning$2(_typeof$2(de.type) === "object" && (de.type.__ANT_BREADCRUMB_ITEM ||
                        de.type.__ANT_BREADCRUMB_SEPARATOR), "Breadcrumb",
                    "Only accepts Breadcrumb.Item and Breadcrumb.Separator as it's children"
                ), cloneVNode(de, {
                    separator: le,
                    key: ve
                })
            }));
            var ce = (te = {}, _defineProperty$V(te, G.value, !0), _defineProperty$V(te, "".concat(G.value,
                "-rtl"), X.value === "rtl"), te);
            return createVNode("div", {
                class: ce
            }, [re])
        }
    }
});
var _excluded$M = ["separator", "class"],
    breadcrumbSeparatorProps = function () {
        return {
            prefixCls: String
        }
    };
const BreadcrumbSeparator = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ABreadcrumbSeparator",
    __ANT_BREADCRUMB_SEPARATOR: !0,
    inheritAttrs: !1,
    props: breadcrumbSeparatorProps(),
    setup: function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = useConfigInject("breadcrumb", C),
            X = G.prefixCls;
        return function () {
            var Z;
            U.separator;
            var Q = U.class,
                ee = _objectWithoutProperties$2(U, _excluded$M),
                ne = flattenChildren((Z = W.default) === null || Z === void 0 ? void 0 : Z.call(W));
            return createVNode("span", _objectSpread2$1({
                class: ["".concat(X.value, "-separator"), Q]
            }, ee), [ne.length > 0 ? ne : "/"])
        }
    }
});
Breadcrumb.Item = BreadcrumbItem;
Breadcrumb.Separator = BreadcrumbSeparator;
Breadcrumb.install = function (K) {
    return K.component(Breadcrumb.name, Breadcrumb), K.component(BreadcrumbItem.name, BreadcrumbItem), K.component(
        BreadcrumbSeparator.name, BreadcrumbSeparator), K
};
var dayjs_minExports = {},
    dayjs_min = {
        get exports() {
            return dayjs_minExports
        },
        set exports(K) {
            dayjs_minExports = K
        }
    };
(function (K, C) {
    (function (H, W) {
        K.exports = W()
    })(commonjsGlobal, function () {
        var H = 1e3,
            W = 6e4,
            U = 36e5,
            G = "millisecond",
            X = "second",
            Z = "minute",
            Q = "hour",
            ee = "day",
            ne = "week",
            te = "month",
            re = "quarter",
            ae = "year",
            oe = "date",
            ie = "Invalid Date",
            ue = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
            le = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
            se = {
                name: "en",
                weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                months: "January_February_March_April_May_June_July_August_September_October_November_December"
                    .split("_"),
                ordinal: function (ge) {
                    var xe = ["th", "st", "nd", "rd"],
                        Pe = ge % 100;
                    return "[" + ge + (xe[(Pe - 20) % 10] || xe[Pe] || xe[0]) + "]"
                }
            },
            ce = function (ge, xe, Pe) {
                var $e = String(ge);
                return !$e || $e.length >= xe ? ge : "" + Array(xe + 1 - $e.length).join(Pe) + ge
            },
            de = {
                s: ce,
                z: function (ge) {
                    var xe = -ge.utcOffset(),
                        Pe = Math.abs(xe),
                        $e = Math.floor(Pe / 60),
                        ye = Pe % 60;
                    return (xe <= 0 ? "+" : "-") + ce($e, 2, "0") + ":" + ce(ye, 2, "0")
                },
                m: function ge(xe, Pe) {
                    if (xe.date() < Pe.date()) return -ge(Pe, xe);
                    var $e = 12 * (Pe.year() - xe.year()) + (Pe.month() - xe.month()),
                        ye = xe.clone().add($e, te),
                        Ce = Pe - ye < 0,
                        we = xe.clone().add($e + (Ce ? -1 : 1), te);
                    return +(-($e + (Pe - ye) / (Ce ? ye - we : we - ye)) || 0)
                },
                a: function (ge) {
                    return ge < 0 ? Math.ceil(ge) || 0 : Math.floor(ge)
                },
                p: function (ge) {
                    return {
                        M: te,
                        y: ae,
                        w: ne,
                        d: ee,
                        D: oe,
                        h: Q,
                        m: Z,
                        s: X,
                        ms: G,
                        Q: re
                    } [ge] || String(ge || "").toLowerCase().replace(/s$/, "")
                },
                u: function (ge) {
                    return ge === void 0
                }
            },
            ve = "en",
            fe = {};
        fe[ve] = se;
        var pe = function (ge) {
                return ge instanceof _e
            },
            me = function ge(xe, Pe, $e) {
                var ye;
                if (!xe) return ve;
                if (typeof xe == "string") {
                    var Ce = xe.toLowerCase();
                    fe[Ce] && (ye = Ce), Pe && (fe[Ce] = Pe, ye = Ce);
                    var we = xe.split("-");
                    if (!ye && we.length > 1) return ge(we[0])
                } else {
                    var Oe = xe.name;
                    fe[Oe] = xe, ye = Oe
                }
                return !$e && ye && (ve = ye), ye || !$e && ve
            },
            he = function (ge, xe) {
                if (pe(ge)) return ge.clone();
                var Pe = typeof xe == "object" ? xe : {};
                return Pe.date = ge, Pe.args = arguments, new _e(Pe)
            },
            Se = de;
        Se.l = me, Se.i = pe, Se.w = function (ge, xe) {
            return he(ge, {
                locale: xe.$L,
                utc: xe.$u,
                x: xe.$x,
                $offset: xe.$offset
            })
        };
        var _e = function () {
                function ge(Pe) {
                    this.$L = me(Pe.locale, null, !0), this.parse(Pe)
                }
                var xe = ge.prototype;
                return xe.parse = function (Pe) {
                    this.$d = function ($e) {
                        var ye = $e.date,
                            Ce = $e.utc;
                        if (ye === null) return new Date(NaN);
                        if (Se.u(ye)) return new Date;
                        if (ye instanceof Date) return new Date(ye);
                        if (typeof ye == "string" && !/Z$/i.test(ye)) {
                            var we = ye.match(ue);
                            if (we) {
                                var Oe = we[2] - 1 || 0,
                                    Ne = (we[7] || "0").substring(0, 3);
                                return Ce ? new Date(Date.UTC(we[1], Oe, we[3] || 1, we[4] || 0, we[5] ||
                                    0, we[6] || 0, Ne)) : new Date(we[1], Oe, we[3] || 1, we[4] ||
                                    0, we[5] || 0, we[6] || 0, Ne)
                            }
                        }
                        return new Date(ye)
                    }(Pe), this.$x = Pe.x || {}, this.init()
                }, xe.init = function () {
                    var Pe = this.$d;
                    this.$y = Pe.getFullYear(), this.$M = Pe.getMonth(), this.$D = Pe.getDate(), this.$W =
                        Pe.getDay(), this.$H = Pe.getHours(), this.$m = Pe.getMinutes(), this.$s = Pe.getSeconds(),
                        this.$ms = Pe.getMilliseconds()
                }, xe.$utils = function () {
                    return Se
                }, xe.isValid = function () {
                    return this.$d.toString() !== ie
                }, xe.isSame = function (Pe, $e) {
                    var ye = he(Pe);
                    return this.startOf($e) <= ye && ye <= this.endOf($e)
                }, xe.isAfter = function (Pe, $e) {
                    return he(Pe) < this.startOf($e)
                }, xe.isBefore = function (Pe, $e) {
                    return this.endOf($e) < he(Pe)
                }, xe.$g = function (Pe, $e, ye) {
                    return Se.u(Pe) ? this[$e] : this.set(ye, Pe)
                }, xe.unix = function () {
                    return Math.floor(this.valueOf() / 1e3)
                }, xe.valueOf = function () {
                    return this.$d.getTime()
                }, xe.startOf = function (Pe, $e) {
                    var ye = this,
                        Ce = !!Se.u($e) || $e,
                        we = Se.p(Pe),
                        Oe = function (He, je) {
                            var Fe = Se.w(ye.$u ? Date.UTC(ye.$y, je, He) : new Date(ye.$y, je, He), ye);
                            return Ce ? Fe : Fe.endOf(ee)
                        },
                        Ne = function (He, je) {
                            return Se.w(ye.toDate()[He].apply(ye.toDate("s"), (Ce ? [0, 0, 0, 0] : [23, 59,
                                59, 999]).slice(je)), ye)
                        },
                        Me = this.$W,
                        Ve = this.$M,
                        ke = this.$D,
                        Ee = "set" + (this.$u ? "UTC" : "");
                    switch (we) {
                        case ae:
                            return Ce ? Oe(1, 0) : Oe(31, 11);
                        case te:
                            return Ce ? Oe(1, Ve) : Oe(0, Ve + 1);
                        case ne:
                            var Ae = this.$locale().weekStart || 0,
                                Re = (Me < Ae ? Me + 7 : Me) - Ae;
                            return Oe(Ce ? ke - Re : ke + (6 - Re), Ve);
                        case ee:
                        case oe:
                            return Ne(Ee + "Hours", 0);
                        case Q:
                            return Ne(Ee + "Minutes", 1);
                        case Z:
                            return Ne(Ee + "Seconds", 2);
                        case X:
                            return Ne(Ee + "Milliseconds", 3);
                        default:
                            return this.clone()
                    }
                }, xe.endOf = function (Pe) {
                    return this.startOf(Pe, !1)
                }, xe.$set = function (Pe, $e) {
                    var ye, Ce = Se.p(Pe),
                        we = "set" + (this.$u ? "UTC" : ""),
                        Oe = (ye = {}, ye[ee] = we + "Date", ye[oe] = we + "Date", ye[te] = we + "Month",
                            ye[ae] = we + "FullYear", ye[Q] = we + "Hours", ye[Z] = we + "Minutes", ye[X] =
                            we + "Seconds", ye[G] = we + "Milliseconds", ye)[Ce],
                        Ne = Ce === ee ? this.$D + ($e - this.$W) : $e;
                    if (Ce === te || Ce === ae) {
                        var Me = this.clone().set(oe, 1);
                        Me.$d[Oe](Ne), Me.init(), this.$d = Me.set(oe, Math.min(this.$D, Me.daysInMonth()))
                            .$d
                    } else Oe && this.$d[Oe](Ne);
                    return this.init(), this
                }, xe.set = function (Pe, $e) {
                    return this.clone().$set(Pe, $e)
                }, xe.get = function (Pe) {
                    return this[Se.p(Pe)]()
                }, xe.add = function (Pe, $e) {
                    var ye, Ce = this;
                    Pe = Number(Pe);
                    var we = Se.p($e),
                        Oe = function (Ve) {
                            var ke = he(Ce);
                            return Se.w(ke.date(ke.date() + Math.round(Ve * Pe)), Ce)
                        };
                    if (we === te) return this.set(te, this.$M + Pe);
                    if (we === ae) return this.set(ae, this.$y + Pe);
                    if (we === ee) return Oe(1);
                    if (we === ne) return Oe(7);
                    var Ne = (ye = {}, ye[Z] = W, ye[Q] = U, ye[X] = H, ye)[we] || 1,
                        Me = this.$d.getTime() + Pe * Ne;
                    return Se.w(Me, this)
                }, xe.subtract = function (Pe, $e) {
                    return this.add(-1 * Pe, $e)
                }, xe.format = function (Pe) {
                    var $e = this,
                        ye = this.$locale();
                    if (!this.isValid()) return ye.invalidDate || ie;
                    var Ce = Pe || "YYYY-MM-DDTHH:mm:ssZ",
                        we = Se.z(this),
                        Oe = this.$H,
                        Ne = this.$m,
                        Me = this.$M,
                        Ve = ye.weekdays,
                        ke = ye.months,
                        Ee = function (je, Fe, Le, Ie) {
                            return je && (je[Fe] || je($e, Ce)) || Le[Fe].slice(0, Ie)
                        },
                        Ae = function (je) {
                            return Se.s(Oe % 12 || 12, je, "0")
                        },
                        Re = ye.meridiem || function (je, Fe, Le) {
                            var Ie = je < 12 ? "AM" : "PM";
                            return Le ? Ie.toLowerCase() : Ie
                        },
                        He = {
                            YY: String(this.$y).slice(-2),
                            YYYY: this.$y,
                            M: Me + 1,
                            MM: Se.s(Me + 1, 2, "0"),
                            MMM: Ee(ye.monthsShort, Me, ke, 3),
                            MMMM: Ee(ke, Me),
                            D: this.$D,
                            DD: Se.s(this.$D, 2, "0"),
                            d: String(this.$W),
                            dd: Ee(ye.weekdaysMin, this.$W, Ve, 2),
                            ddd: Ee(ye.weekdaysShort, this.$W, Ve, 3),
                            dddd: Ve[this.$W],
                            H: String(Oe),
                            HH: Se.s(Oe, 2, "0"),
                            h: Ae(1),
                            hh: Ae(2),
                            a: Re(Oe, Ne, !0),
                            A: Re(Oe, Ne, !1),
                            m: String(Ne),
                            mm: Se.s(Ne, 2, "0"),
                            s: String(this.$s),
                            ss: Se.s(this.$s, 2, "0"),
                            SSS: Se.s(this.$ms, 3, "0"),
                            Z: we
                        };
                    return Ce.replace(le, function (je, Fe) {
                        return Fe || He[je] || we.replace(":", "")
                    })
                }, xe.utcOffset = function () {
                    return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
                }, xe.diff = function (Pe, $e, ye) {
                    var Ce, we = Se.p($e),
                        Oe = he(Pe),
                        Ne = (Oe.utcOffset() - this.utcOffset()) * W,
                        Me = this - Oe,
                        Ve = Se.m(this, Oe);
                    return Ve = (Ce = {}, Ce[ae] = Ve / 12, Ce[te] = Ve, Ce[re] = Ve / 3, Ce[ne] = (Me - Ne) /
                        6048e5, Ce[ee] = (Me - Ne) / 864e5, Ce[Q] = Me / U, Ce[Z] = Me / W, Ce[X] = Me /
                        H, Ce)[we] || Me, ye ? Ve : Se.a(Ve)
                }, xe.daysInMonth = function () {
                    return this.endOf(te).$D
                }, xe.$locale = function () {
                    return fe[this.$L]
                }, xe.locale = function (Pe, $e) {
                    if (!Pe) return this.$L;
                    var ye = this.clone(),
                        Ce = me(Pe, $e, !0);
                    return Ce && (ye.$L = Ce), ye
                }, xe.clone = function () {
                    return Se.w(this.$d, this)
                }, xe.toDate = function () {
                    return new Date(this.valueOf())
                }, xe.toJSON = function () {
                    return this.isValid() ? this.toISOString() : null
                }, xe.toISOString = function () {
                    return this.$d.toISOString()
                }, xe.toString = function () {
                    return this.$d.toUTCString()
                }, ge
            }(),
            be = _e.prototype;
        return he.prototype = be, [["$ms", G], ["$s", X], ["$m", Z], ["$H", Q], ["$W", ee], ["$M", te], ["$y",
            ae], ["$D", oe]].forEach(function (ge) {
            be[ge[1]] = function (xe) {
                return this.$g(xe, ge[0], ge[1])
            }
        }), he.extend = function (ge, xe) {
            return ge.$i || (ge(xe, _e, he), ge.$i = !0), he
        }, he.locale = me, he.isDayjs = pe, he.unix = function (ge) {
            return he(1e3 * ge)
        }, he.en = fe[ve], he.Ls = fe, he.p = {}, he
    })
})(dayjs_min);
const dayjs = dayjs_minExports;
var weekdayExports = {},
    weekday$1 = {
        get exports() {
            return weekdayExports
        },
        set exports(K) {
            weekdayExports = K
        }
    };
(function (K, C) {
    (function (H, W) {
        K.exports = W()
    })(commonjsGlobal, function () {
        return function (H, W) {
            W.prototype.weekday = function (U) {
                var G = this.$locale().weekStart || 0,
                    X = this.$W,
                    Z = (X < G ? X + 7 : X) - G;
                return this.$utils().u(U) ? Z : this.subtract(Z, "day").add(U, "day")
            }
        }
    })
})(weekday$1);
const weekday = weekdayExports;
var localeDataExports = {},
    localeData$2 = {
        get exports() {
            return localeDataExports
        },
        set exports(K) {
            localeDataExports = K
        }
    };
(function (K, C) {
    (function (H, W) {
        K.exports = W()
    })(commonjsGlobal, function () {
        return function (H, W, U) {
            var G = W.prototype,
                X = function (te) {
                    return te && (te.indexOf ? te : te.s)
                },
                Z = function (te, re, ae, oe, ie) {
                    var ue = te.name ? te : te.$locale(),
                        le = X(ue[re]),
                        se = X(ue[ae]),
                        ce = le || se.map(function (ve) {
                            return ve.slice(0, oe)
                        });
                    if (!ie) return ce;
                    var de = ue.weekStart;
                    return ce.map(function (ve, fe) {
                        return ce[(fe + (de || 0)) % 7]
                    })
                },
                Q = function () {
                    return U.Ls[U.locale()]
                },
                ee = function (te, re) {
                    return te.formats[re] || function (ae) {
                        return ae.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function (oe, ie, ue) {
                            return ie || ue.slice(1)
                        })
                    }(te.formats[re.toUpperCase()])
                },
                ne = function () {
                    var te = this;
                    return {
                        months: function (re) {
                            return re ? re.format("MMMM") : Z(te, "months")
                        },
                        monthsShort: function (re) {
                            return re ? re.format("MMM") : Z(te, "monthsShort", "months", 3)
                        },
                        firstDayOfWeek: function () {
                            return te.$locale().weekStart || 0
                        },
                        weekdays: function (re) {
                            return re ? re.format("dddd") : Z(te, "weekdays")
                        },
                        weekdaysMin: function (re) {
                            return re ? re.format("dd") : Z(te, "weekdaysMin", "weekdays", 2)
                        },
                        weekdaysShort: function (re) {
                            return re ? re.format("ddd") : Z(te, "weekdaysShort", "weekdays", 3)
                        },
                        longDateFormat: function (re) {
                            return ee(te.$locale(), re)
                        },
                        meridiem: this.$locale().meridiem,
                        ordinal: this.$locale().ordinal
                    }
                };
            G.localeData = function () {
                return ne.bind(this)()
            }, U.localeData = function () {
                var te = Q();
                return {
                    firstDayOfWeek: function () {
                        return te.weekStart || 0
                    },
                    weekdays: function () {
                        return U.weekdays()
                    },
                    weekdaysShort: function () {
                        return U.weekdaysShort()
                    },
                    weekdaysMin: function () {
                        return U.weekdaysMin()
                    },
                    months: function () {
                        return U.months()
                    },
                    monthsShort: function () {
                        return U.monthsShort()
                    },
                    longDateFormat: function (re) {
                        return ee(te, re)
                    },
                    meridiem: te.meridiem,
                    ordinal: te.ordinal
                }
            }, U.months = function () {
                return Z(Q(), "months")
            }, U.monthsShort = function () {
                return Z(Q(), "monthsShort", "months", 3)
            }, U.weekdays = function (te) {
                return Z(Q(), "weekdays", null, null, te)
            }, U.weekdaysShort = function (te) {
                return Z(Q(), "weekdaysShort", "weekdays", 3, te)
            }, U.weekdaysMin = function (te) {
                return Z(Q(), "weekdaysMin", "weekdays", 2, te)
            }
        }
    })
})(localeData$2);
const localeData$1 = localeDataExports;
var weekOfYearExports = {},
    weekOfYear$2 = {
        get exports() {
            return weekOfYearExports
        },
        set exports(K) {
            weekOfYearExports = K
        }
    };
(function (K, C) {
    (function (H, W) {
        K.exports = W()
    })(commonjsGlobal, function () {
        var H = "week",
            W = "year";
        return function (U, G, X) {
            var Z = G.prototype;
            Z.week = function (Q) {
                if (Q === void 0 && (Q = null), Q !== null) return this.add(7 * (Q - this.week()),
                    "day");
                var ee = this.$locale().yearStart || 1;
                if (this.month() === 11 && this.date() > 25) {
                    var ne = X(this).startOf(W).add(1, W).date(ee),
                        te = X(this).endOf(H);
                    if (ne.isBefore(te)) return 1
                }
                var re = X(this).startOf(W).date(ee).startOf(H).subtract(1, "millisecond"),
                    ae = this.diff(re, H, !0);
                return ae < 0 ? X(this).startOf("week").week() : Math.ceil(ae)
            }, Z.weeks = function (Q) {
                return Q === void 0 && (Q = null), this.week(Q)
            }
        }
    })
})(weekOfYear$2);
const weekOfYear$1 = weekOfYearExports;
var weekYearExports = {},
    weekYear$1 = {
        get exports() {
            return weekYearExports
        },
        set exports(K) {
            weekYearExports = K
        }
    };
(function (K, C) {
    (function (H, W) {
        K.exports = W()
    })(commonjsGlobal, function () {
        return function (H, W) {
            W.prototype.weekYear = function () {
                var U = this.month(),
                    G = this.week(),
                    X = this.year();
                return G === 1 && U === 11 ? X + 1 : U === 0 && G >= 52 ? X - 1 : X
            }
        }
    })
})(weekYear$1);
const weekYear = weekYearExports;
var advancedFormatExports = {},
    advancedFormat$1 = {
        get exports() {
            return advancedFormatExports
        },
        set exports(K) {
            advancedFormatExports = K
        }
    };
(function (K, C) {
    (function (H, W) {
        K.exports = W()
    })(commonjsGlobal, function () {
        return function (H, W) {
            var U = W.prototype,
                G = U.format;
            U.format = function (X) {
                var Z = this,
                    Q = this.$locale();
                if (!this.isValid()) return G.bind(this)(X);
                var ee = this.$utils(),
                    ne = (X || "YYYY-MM-DDTHH:mm:ssZ").replace(
                        /\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g,
                        function (te) {
                            switch (te) {
                                case "Q":
                                    return Math.ceil((Z.$M + 1) / 3);
                                case "Do":
                                    return Q.ordinal(Z.$D);
                                case "gggg":
                                    return Z.weekYear();
                                case "GGGG":
                                    return Z.isoWeekYear();
                                case "wo":
                                    return Q.ordinal(Z.week(), "W");
                                case "w":
                                case "ww":
                                    return ee.s(Z.week(), te === "w" ? 1 : 2, "0");
                                case "W":
                                case "WW":
                                    return ee.s(Z.isoWeek(), te === "W" ? 1 : 2, "0");
                                case "k":
                                case "kk":
                                    return ee.s(String(Z.$H === 0 ? 24 : Z.$H), te === "k" ? 1 : 2, "0");
                                case "X":
                                    return Math.floor(Z.$d.getTime() / 1e3);
                                case "x":
                                    return Z.$d.getTime();
                                case "z":
                                    return "[" + Z.offsetName() + "]";
                                case "zzz":
                                    return "[" + Z.offsetName("long") + "]";
                                default:
                                    return te
                            }
                        });
                return G.bind(this)(ne)
            }
        }
    })
})(advancedFormat$1);
const advancedFormat = advancedFormatExports;
var customParseFormatExports = {},
    customParseFormat$1 = {
        get exports() {
            return customParseFormatExports
        },
        set exports(K) {
            customParseFormatExports = K
        }
    };
(function (K, C) {
    (function (H, W) {
        K.exports = W()
    })(commonjsGlobal, function () {
        var H = {
                LTS: "h:mm:ss A",
                LT: "h:mm A",
                L: "MM/DD/YYYY",
                LL: "MMMM D, YYYY",
                LLL: "MMMM D, YYYY h:mm A",
                LLLL: "dddd, MMMM D, YYYY h:mm A"
            },
            W = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,
            U = /\d\d/,
            G = /\d\d?/,
            X = /\d*[^-_:/,()\s\d]+/,
            Z = {},
            Q = function (ie) {
                return (ie = +ie) + (ie > 68 ? 1900 : 2e3)
            },
            ee = function (ie) {
                return function (ue) {
                    this[ie] = +ue
                }
            },
            ne = [/[+-]\d\d:?(\d\d)?|Z/, function (ie) {
                (this.zone || (this.zone = {})).offset = function (ue) {
                    if (!ue || ue === "Z") return 0;
                    var le = ue.match(/([+-]|\d\d)/g),
                        se = 60 * le[1] + (+le[2] || 0);
                    return se === 0 ? 0 : le[0] === "+" ? -se : se
                }(ie)
            }],
            te = function (ie) {
                var ue = Z[ie];
                return ue && (ue.indexOf ? ue : ue.s.concat(ue.f))
            },
            re = function (ie, ue) {
                var le, se = Z.meridiem;
                if (se) {
                    for (var ce = 1; ce <= 24; ce += 1)
                        if (ie.indexOf(se(ce, 0, ue)) > -1) {
                            le = ce > 12;
                            break
                        }
                } else le = ie === (ue ? "pm" : "PM");
                return le
            },
            ae = {
                A: [X, function (ie) {
                    this.afternoon = re(ie, !1)
                }],
                a: [X, function (ie) {
                    this.afternoon = re(ie, !0)
                }],
                S: [/\d/, function (ie) {
                    this.milliseconds = 100 * +ie
                }],
                SS: [U, function (ie) {
                    this.milliseconds = 10 * +ie
                }],
                SSS: [/\d{3}/, function (ie) {
                    this.milliseconds = +ie
                }],
                s: [G, ee("seconds")],
                ss: [G, ee("seconds")],
                m: [G, ee("minutes")],
                mm: [G, ee("minutes")],
                H: [G, ee("hours")],
                h: [G, ee("hours")],
                HH: [G, ee("hours")],
                hh: [G, ee("hours")],
                D: [G, ee("day")],
                DD: [U, ee("day")],
                Do: [X, function (ie) {
                    var ue = Z.ordinal,
                        le = ie.match(/\d+/);
                    if (this.day = le[0], ue)
                        for (var se = 1; se <= 31; se += 1) ue(se).replace(/\[|\]/g, "") === ie && (
                            this.day = se)
                }],
                M: [G, ee("month")],
                MM: [U, ee("month")],
                MMM: [X, function (ie) {
                    var ue = te("months"),
                        le = (te("monthsShort") || ue.map(function (se) {
                            return se.slice(0, 3)
                        })).indexOf(ie) + 1;
                    if (le < 1) throw new Error;
                    this.month = le % 12 || le
                }],
                MMMM: [X, function (ie) {
                    var ue = te("months").indexOf(ie) + 1;
                    if (ue < 1) throw new Error;
                    this.month = ue % 12 || ue
                }],
                Y: [/[+-]?\d+/, ee("year")],
                YY: [U, function (ie) {
                    this.year = Q(ie)
                }],
                YYYY: [/\d{4}/, ee("year")],
                Z: ne,
                ZZ: ne
            };

        function oe(ie) {
            var ue, le;
            ue = ie, le = Z && Z.formats;
            for (var se = (ie = ue.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function (he, Se, _e) {
                    var be = _e && _e.toUpperCase();
                    return Se || le[_e] || H[_e] || le[be].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,
                        function (ge, xe, Pe) {
                            return xe || Pe.slice(1)
                        })
                })).match(W), ce = se.length, de = 0; de < ce; de += 1) {
                var ve = se[de],
                    fe = ae[ve],
                    pe = fe && fe[0],
                    me = fe && fe[1];
                se[de] = me ? {
                    regex: pe,
                    parser: me
                } : ve.replace(/^\[|\]$/g, "")
            }
            return function (he) {
                for (var Se = {}, _e = 0, be = 0; _e < ce; _e += 1) {
                    var ge = se[_e];
                    if (typeof ge == "string") be += ge.length;
                    else {
                        var xe = ge.regex,
                            Pe = ge.parser,
                            $e = he.slice(be),
                            ye = xe.exec($e)[0];
                        Pe.call(Se, ye), he = he.replace(ye, "")
                    }
                }
                return function (Ce) {
                    var we = Ce.afternoon;
                    if (we !== void 0) {
                        var Oe = Ce.hours;
                        we ? Oe < 12 && (Ce.hours += 12) : Oe === 12 && (Ce.hours = 0), delete Ce.afternoon
                    }
                }(Se), Se
            }
        }
        return function (ie, ue, le) {
            le.p.customParseFormat = !0, ie && ie.parseTwoDigitYear && (Q = ie.parseTwoDigitYear);
            var se = ue.prototype,
                ce = se.parse;
            se.parse = function (de) {
                var ve = de.date,
                    fe = de.utc,
                    pe = de.args;
                this.$u = fe;
                var me = pe[1];
                if (typeof me == "string") {
                    var he = pe[2] === !0,
                        Se = pe[3] === !0,
                        _e = he || Se,
                        be = pe[2];
                    Se && (be = pe[2]), Z = this.$locale(), !he && be && (Z = le.Ls[be]), this.$d =
                        function ($e, ye, Ce) {
                            try {
                                if (["x", "X"].indexOf(ye) > -1) return new Date((ye === "X" ? 1e3 : 1) *
                                    $e);
                                var we = oe(ye)($e),
                                    Oe = we.year,
                                    Ne = we.month,
                                    Me = we.day,
                                    Ve = we.hours,
                                    ke = we.minutes,
                                    Ee = we.seconds,
                                    Ae = we.milliseconds,
                                    Re = we.zone,
                                    He = new Date,
                                    je = Me || (Oe || Ne ? 1 : He.getDate()),
                                    Fe = Oe || He.getFullYear(),
                                    Le = 0;
                                Oe && !Ne || (Le = Ne > 0 ? Ne - 1 : He.getMonth());
                                var Ie = Ve || 0,
                                    Te = ke || 0,
                                    De = Ee || 0,
                                    Ke = Ae || 0;
                                return Re ? new Date(Date.UTC(Fe, Le, je, Ie, Te, De, Ke + 60 * Re.offset *
                                        1e3)) : Ce ? new Date(Date.UTC(Fe, Le, je, Ie, Te, De, Ke)) :
                                    new Date(Fe, Le, je, Ie, Te, De, Ke)
                            } catch {
                                return new Date("")
                            }
                        }(ve, me, fe), this.init(), be && be !== !0 && (this.$L = this.locale(be).$L),
                        _e && ve != this.format(me) && (this.$d = new Date("")), Z = {}
                } else if (me instanceof Array)
                    for (var ge = me.length, xe = 1; xe <= ge; xe += 1) {
                        pe[1] = me[xe - 1];
                        var Pe = le.apply(this, pe);
                        if (Pe.isValid()) {
                            this.$d = Pe.$d, this.$L = Pe.$L, this.init();
                            break
                        }
                        xe === ge && (this.$d = new Date(""))
                    } else ce.call(this, de)
            }
        }
    })
})(customParseFormat$1);
const customParseFormat = customParseFormatExports;
dayjs.extend(customParseFormat);
dayjs.extend(advancedFormat);
dayjs.extend(weekday);
dayjs.extend(localeData$1);
dayjs.extend(weekOfYear$1);
dayjs.extend(weekYear);
dayjs.extend(function (K, C) {
    var H = C.prototype,
        W = H.format;
    H.format = function (G) {
        var X = (G || "").replace("Wo", "wo");
        return W.bind(this)(X)
    }
});
var localeMap = {
        bn_BD: "bn-bd",
        by_BY: "be",
        en_GB: "en-gb",
        en_US: "en",
        fr_BE: "fr",
        fr_CA: "fr-ca",
        hy_AM: "hy-am",
        kmr_IQ: "ku",
        nl_BE: "nl-be",
        pt_BR: "pt-br",
        zh_CN: "zh-cn",
        zh_HK: "zh-hk",
        zh_TW: "zh-tw"
    },
    parseLocale = function (C) {
        var H = localeMap[C];
        return H || C.split("_")[0]
    },
    parseNoMatchNotice = function () {
        noteOnce(!1, "Not match any format. Please help to fire a issue about this.")
    },
    generateConfig = {
        getNow: function () {
            return dayjs()
        },
        getFixedDate: function (C) {
            return dayjs(C, ["YYYY-M-DD", "YYYY-MM-DD"])
        },
        getEndDate: function (C) {
            return C.endOf("month")
        },
        getWeekDay: function (C) {
            var H = C.locale("en");
            return H.weekday() + H.localeData().firstDayOfWeek()
        },
        getYear: function (C) {
            return C.year()
        },
        getMonth: function (C) {
            return C.month()
        },
        getDate: function (C) {
            return C.date()
        },
        getHour: function (C) {
            return C.hour()
        },
        getMinute: function (C) {
            return C.minute()
        },
        getSecond: function (C) {
            return C.second()
        },
        addYear: function (C, H) {
            return C.add(H, "year")
        },
        addMonth: function (C, H) {
            return C.add(H, "month")
        },
        addDate: function (C, H) {
            return C.add(H, "day")
        },
        setYear: function (C, H) {
            return C.year(H)
        },
        setMonth: function (C, H) {
            return C.month(H)
        },
        setDate: function (C, H) {
            return C.date(H)
        },
        setHour: function (C, H) {
            return C.hour(H)
        },
        setMinute: function (C, H) {
            return C.minute(H)
        },
        setSecond: function (C, H) {
            return C.second(H)
        },
        isAfter: function (C, H) {
            return C.isAfter(H)
        },
        isValidate: function (C) {
            return C.isValid()
        },
        locale: {
            getWeekFirstDay: function (C) {
                return dayjs().locale(parseLocale(C)).localeData().firstDayOfWeek()
            },
            getWeekFirstDate: function (C, H) {
                return H.locale(parseLocale(C)).weekday(0)
            },
            getWeek: function (C, H) {
                return H.locale(parseLocale(C)).week()
            },
            getShortWeekDays: function (C) {
                return dayjs().locale(parseLocale(C)).localeData().weekdaysMin()
            },
            getShortMonths: function (C) {
                return dayjs().locale(parseLocale(C)).localeData().monthsShort()
            },
            format: function (C, H, W) {
                return H.locale(parseLocale(C)).format(W)
            },
            parse: function (C, H, W) {
                for (var U = parseLocale(C), G = 0; G < W.length; G += 1) {
                    var X = W[G],
                        Z = H;
                    if (X.includes("wo") || X.includes("Wo")) {
                        for (var Q = Z.split("-")[0], ee = Z.split("-")[1], ne = dayjs(Q, "YYYY").startOf("year").locale(
                                U), te = 0; te <= 52; te += 1) {
                            var re = ne.add(te, "week");
                            if (re.format("Wo") === ee) return re
                        }
                        return parseNoMatchNotice(), null
                    }
                    var ae = dayjs(Z, X, !0).locale(U);
                    if (ae.isValid()) return ae
                }
                return H || parseNoMatchNotice(), null
            }
        },
        toDate: function (C, H) {
            return Array.isArray(C) ? C.map(function (W) {
                return typeof W == "string" && W ? dayjs(W, H) : W || null
            }) : typeof C == "string" && C ? dayjs(C, H) : C || null
        },
        toString: function (C, H) {
            return Array.isArray(C) ? C.map(function (W) {
                return dayjs.isDayjs(W) ? W.format(H) : W
            }) : dayjs.isDayjs(C) ? C.format(H) : C
        }
    };
const dayjsGenerateConfig = generateConfig;
var MAX_SAFE_INTEGER = 9007199254740991,
    nativeFloor = Math.floor;

function baseRepeat(K, C) {
    var H = "";
    if (!K || C < 1 || C > MAX_SAFE_INTEGER) return H;
    do C % 2 && (H += K), C = nativeFloor(C / 2), C && (K += K); while (C);
    return H
}

function arrayMap(K, C) {
    for (var H = -1, W = K == null ? 0 : K.length, U = Array(W); ++H < W;) U[H] = C(K[H], H, K);
    return U
}
var symbolTag$2 = "[object Symbol]";

function isSymbol(K) {
    return typeof K == "symbol" || isObjectLike(K) && baseGetTag(K) == symbolTag$2
}
var INFINITY$2 = 1 / 0,
    symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0,
    symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;

function baseToString(K) {
    if (typeof K == "string") return K;
    if (isArray$2(K)) return arrayMap(K, baseToString) + "";
    if (isSymbol(K)) return symbolToString ? symbolToString.call(K) : "";
    var C = K + "";
    return C == "0" && 1 / K == -INFINITY$2 ? "-0" : C
}

function baseSlice(K, C, H) {
    var W = -1,
        U = K.length;
    C < 0 && (C = -C > U ? 0 : U + C), H = H > U ? U : H, H < 0 && (H += U), U = C > H ? 0 : H - C >>> 0, C >>>= 0;
    for (var G = Array(U); ++W < U;) G[W] = K[W + C];
    return G
}

function castSlice(K, C, H) {
    var W = K.length;
    return H = H === void 0 ? W : H, !C && H >= W ? K : baseSlice(K, C, H)
}
var rsAstralRange$2 = "\\ud800-\\udfff",
    rsComboMarksRange$2 = "\\u0300-\\u036f",
    reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange$2 = "\\u20d0-\\u20ff",
    rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2,
    rsVarRange$2 = "\\ufe0e\\ufe0f",
    rsZWJ$2 = "\\u200d",
    reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$2 + rsVarRange$2 + "]");

function hasUnicode(K) {
    return reHasUnicode.test(K)
}

function baseProperty(K) {
    return function (C) {
        return C == null ? void 0 : C[K]
    }
}
var asciiSize = baseProperty("length");
const asciiSize$1 = asciiSize;
var rsAstralRange$1 = "\\ud800-\\udfff",
    rsComboMarksRange$1 = "\\u0300-\\u036f",
    reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange$1 = "\\u20d0-\\u20ff",
    rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
    rsVarRange$1 = "\\ufe0e\\ufe0f",
    rsAstral$1 = "[" + rsAstralRange$1 + "]",
    rsCombo$1 = "[" + rsComboRange$1 + "]",
    rsFitz$1 = "\\ud83c[\\udffb-\\udfff]",
    rsModifier$1 = "(?:" + rsCombo$1 + "|" + rsFitz$1 + ")",
    rsNonAstral$1 = "[^" + rsAstralRange$1 + "]",
    rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}",
    rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]",
    rsZWJ$1 = "\\u200d",
    reOptMod$1 = rsModifier$1 + "?",
    rsOptVar$1 = "[" + rsVarRange$1 + "]?",
    rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 +
    reOptMod$1 + ")*",
    rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
    rsSymbol$1 = "(?:" + [rsNonAstral$1 + rsCombo$1 + "?", rsCombo$1, rsRegional$1, rsSurrPair$1, rsAstral$1].join("|") +
    ")",
    reUnicode$1 = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol$1 + rsSeq$1, "g");

function unicodeSize(K) {
    for (var C = reUnicode$1.lastIndex = 0; reUnicode$1.test(K);) ++C;
    return C
}

function stringSize(K) {
    return hasUnicode(K) ? unicodeSize(K) : asciiSize$1(K)
}

function asciiToArray(K) {
    return K.split("")
}
var rsAstralRange = "\\ud800-\\udfff",
    rsComboMarksRange = "\\u0300-\\u036f",
    reComboHalfMarksRange = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange = "\\u20d0-\\u20ff",
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = "\\ufe0e\\ufe0f",
    rsAstral = "[" + rsAstralRange + "]",
    rsCombo = "[" + rsComboRange + "]",
    rsFitz = "\\ud83c[\\udffb-\\udfff]",
    rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")",
    rsNonAstral = "[^" + rsAstralRange + "]",
    rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
    rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
    rsZWJ = "\\u200d",
    reOptMod = rsModifier + "?",
    rsOptVar = "[" + rsVarRange + "]?",
    rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod +
    ")*",
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")",
    reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");

function unicodeToArray(K) {
    return K.match(reUnicode) || []
}

function stringToArray(K) {
    return hasUnicode(K) ? unicodeToArray(K) : asciiToArray(K)
}
var nativeCeil = Math.ceil;

function createPadding(K, C) {
    C = C === void 0 ? " " : baseToString(C);
    var H = C.length;
    if (H < 2) return H ? baseRepeat(C, K) : C;
    var W = baseRepeat(C, nativeCeil(K / stringSize(C)));
    return hasUnicode(C) ? castSlice(stringToArray(W), 0, K).join("") : W.slice(0, K)
}
var reWhitespace = /\s/;

function trimmedEndIndex(K) {
    for (var C = K.length; C-- && reWhitespace.test(K.charAt(C)););
    return C
}
var reTrimStart = /^\s+/;

function baseTrim(K) {
    return K && K.slice(0, trimmedEndIndex(K) + 1).replace(reTrimStart, "")
}
var NAN = 0 / 0,
    reIsBadHex = /^[-+]0x[0-9a-f]+$/i,
    reIsBinary = /^0b[01]+$/i,
    reIsOctal = /^0o[0-7]+$/i,
    freeParseInt = parseInt;

function toNumber(K) {
    if (typeof K == "number") return K;
    if (isSymbol(K)) return NAN;
    if (isObject$2(K)) {
        var C = typeof K.valueOf == "function" ? K.valueOf() : K;
        K = isObject$2(C) ? C + "" : C
    }
    if (typeof K != "string") return K === 0 ? K : +K;
    K = baseTrim(K);
    var H = reIsBinary.test(K);
    return H || reIsOctal.test(K) ? freeParseInt(K.slice(2), H ? 2 : 8) : reIsBadHex.test(K) ? NAN : +K
}
var INFINITY$1 = 1 / 0,
    MAX_INTEGER = 17976931348623157e292;

function toFinite(K) {
    if (!K) return K === 0 ? K : 0;
    if (K = toNumber(K), K === INFINITY$1 || K === -INFINITY$1) {
        var C = K < 0 ? -1 : 1;
        return C * MAX_INTEGER
    }
    return K === K ? K : 0
}

function toInteger(K) {
    var C = toFinite(K),
        H = C % 1;
    return C === C ? H ? C - H : C : 0
}

function toString$1(K) {
    return K == null ? "" : baseToString(K)
}

function padStart(K, C, H) {
    K = toString$1(K), C = toInteger(C);
    var W = C ? stringSize(K) : 0;
    return C && W < C ? createPadding(C - W, H) + K : K
}

function useMergeProps(K) {
    var C = useAttrs();
    return _objectSpread2$1(_objectSpread2$1({}, K), C)
}
var PanelContextKey = Symbol("PanelContextProps"),
    useProvidePanel = function (C) {
        provide(PanelContextKey, C)
    },
    useInjectPanel = function () {
        return inject(PanelContextKey, {})
    },
    HIDDEN_STYLE$2 = {
        visibility: "hidden"
    };

function Header$2(K, C) {
    var H, W = C.slots,
        U = useMergeProps(K),
        G = U.prefixCls,
        X = U.prevIcon,
        Z = X === void 0 ? "" : X,
        Q = U.nextIcon,
        ee = Q === void 0 ? "" : Q,
        ne = U.superPrevIcon,
        te = ne === void 0 ? "" : ne,
        re = U.superNextIcon,
        ae = re === void 0 ? "" : re,
        oe = U.onSuperPrev,
        ie = U.onSuperNext,
        ue = U.onPrev,
        le = U.onNext,
        se = useInjectPanel(),
        ce = se.hideNextBtn,
        de = se.hidePrevBtn;
    return createVNode("div", {
        class: G
    }, [oe && createVNode("button", {
        type: "button",
        onClick: oe,
        tabindex: -1,
        class: "".concat(G, "-super-prev-btn"),
        style: de.value ? HIDDEN_STYLE$2 : {}
    }, [te]), ue && createVNode("button", {
        type: "button",
        onClick: ue,
        tabindex: -1,
        class: "".concat(G, "-prev-btn"),
        style: de.value ? HIDDEN_STYLE$2 : {}
    }, [Z]), createVNode("div", {
        class: "".concat(G, "-view")
    }, [(H = W.default) === null || H === void 0 ? void 0 : H.call(W)]), le && createVNode("button", {
        type: "button",
        onClick: le,
        tabindex: -1,
        class: "".concat(G, "-next-btn"),
        style: ce.value ? HIDDEN_STYLE$2 : {}
    }, [ee]), ie && createVNode("button", {
        type: "button",
        onClick: ie,
        tabindex: -1,
        class: "".concat(G, "-super-next-btn"),
        style: ce.value ? HIDDEN_STYLE$2 : {}
    }, [ae])])
}
Header$2.displayName = "Header";
Header$2.inheritAttrs = !1;

function DecadeHeader(K) {
    var C = useMergeProps(K),
        H = C.prefixCls,
        W = C.generateConfig,
        U = C.viewDate,
        G = C.onPrevDecades,
        X = C.onNextDecades,
        Z = useInjectPanel(),
        Q = Z.hideHeader;
    if (Q) return null;
    var ee = "".concat(H, "-header"),
        ne = W.getYear(U),
        te = Math.floor(ne / DECADE_DISTANCE_COUNT) * DECADE_DISTANCE_COUNT,
        re = te + DECADE_DISTANCE_COUNT - 1;
    return createVNode(Header$2, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        prefixCls: ee,
        onSuperPrev: G,
        onSuperNext: X
    }), {
        default: function () {
            return [te, createTextVNode("-"), re]
        }
    })
}
DecadeHeader.displayName = "DecadeHeader";
DecadeHeader.inheritAttrs = !1;

function setTime(K, C, H, W, U) {
    var G = K.setHour(C, H);
    return G = K.setMinute(G, W), G = K.setSecond(G, U), G
}

function setDateTime(K, C, H) {
    if (!H) return C;
    var W = C;
    return W = K.setHour(W, K.getHour(H)), W = K.setMinute(W, K.getMinute(H)), W = K.setSecond(W, K.getSecond(H)), W
}

function getLowerBoundTime(K, C, H, W, U, G) {
    var X = Math.floor(K / W) * W;
    if (X < K) return [X, 60 - U, 60 - G];
    var Z = Math.floor(C / U) * U;
    if (Z < C) return [X, Z, 60 - G];
    var Q = Math.floor(H / G) * G;
    return [X, Z, Q]
}

function getLastDay(K, C) {
    var H = K.getYear(C),
        W = K.getMonth(C) + 1,
        U = K.getEndDate(K.getFixedDate("".concat(H, "-").concat(W, "-01"))),
        G = K.getDate(U),
        X = W < 10 ? "0".concat(W) : "".concat(W);
    return "".concat(H, "-").concat(X, "-").concat(G)
}

function PanelBody(K) {
    for (var C = useMergeProps(K), H = C.prefixCls, W = C.disabledDate, U = C.onSelect, G = C.picker, X = C.rowNum, Z =
            C.colNum, Q = C.prefixColumn, ee = C.rowClassName, ne = C.baseDate, te = C.getCellClassName, re = C.getCellText,
            ae = C.getCellNode, oe = C.getCellDate, ie = C.generateConfig, ue = C.titleCell, le = C.headerCells, se =
            useInjectPanel(), ce = se.onDateMouseenter, de = se.onDateMouseleave, ve = se.mode, fe = "".concat(H,
                "-cell"), pe = [], me = 0; me < X; me += 1) {
        for (var he = [], Se = void 0, _e = function () {
                var xe, Pe = me * Z + be,
                    $e = oe(ne, Pe),
                    ye = getCellDateDisabled({
                        cellDate: $e,
                        mode: ve.value,
                        disabledDate: W,
                        generateConfig: ie
                    });
                be === 0 && (Se = $e, Q && he.push(Q(Se)));
                var Ce = ue && ue($e);
                he.push(createVNode("td", {
                    key: be,
                    title: Ce,
                    class: classNames(fe, _objectSpread2$1((xe = {}, _defineProperty$V(xe, "".concat(fe,
                            "-disabled"), ye), _defineProperty$V(xe, "".concat(fe, "-start"),
                            re($e) === 1 || G === "year" && Number(Ce) % 10 === 0),
                        _defineProperty$V(xe, "".concat(fe, "-end"), Ce === getLastDay(ie,
                            $e) || G === "year" && Number(Ce) % 10 === 9), xe), te($e))),
                    onClick: function () {
                        ye || U($e)
                    },
                    onMouseenter: function () {
                        !ye && ce && ce($e)
                    },
                    onMouseleave: function () {
                        !ye && de && de($e)
                    }
                }, [ae ? ae($e) : createVNode("div", {
                    class: "".concat(fe, "-inner")
                }, [re($e)])]))
            }, be = 0; be < Z; be += 1) _e();
        pe.push(createVNode("tr", {
            key: me,
            class: ee && ee(Se)
        }, [he]))
    }
    return createVNode("div", {
        class: "".concat(H, "-body")
    }, [createVNode("table", {
        class: "".concat(H, "-content")
    }, [le && createVNode("thead", null, [createVNode("tr", null, [le])]), createVNode("tbody", null, [
        pe])])])
}
PanelBody.displayName = "PanelBody";
PanelBody.inheritAttrs = !1;
var DECADE_COL_COUNT = 3,
    DECADE_ROW_COUNT = 4;

function DecadeBody(K) {
    var C = useMergeProps(K),
        H = DECADE_UNIT_DIFF - 1,
        W = C.prefixCls,
        U = C.viewDate,
        G = C.generateConfig,
        X = "".concat(W, "-cell"),
        Z = G.getYear(U),
        Q = Math.floor(Z / DECADE_UNIT_DIFF) * DECADE_UNIT_DIFF,
        ee = Math.floor(Z / DECADE_DISTANCE_COUNT) * DECADE_DISTANCE_COUNT,
        ne = ee + DECADE_DISTANCE_COUNT - 1,
        te = G.setYear(U, ee - Math.ceil((DECADE_COL_COUNT * DECADE_ROW_COUNT * DECADE_UNIT_DIFF -
            DECADE_DISTANCE_COUNT) / 2)),
        re = function (oe) {
            var ie, ue = G.getYear(oe),
                le = ue + H;
            return ie = {}, _defineProperty$V(ie, "".concat(X, "-in-view"), ee <= ue && le <= ne), _defineProperty$V(ie,
                "".concat(X, "-selected"), ue === Q), ie
        };
    return createVNode(PanelBody, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        rowNum: DECADE_ROW_COUNT,
        colNum: DECADE_COL_COUNT,
        baseDate: te,
        getCellText: function (oe) {
            var ie = G.getYear(oe);
            return "".concat(ie, "-").concat(ie + H)
        },
        getCellClassName: re,
        getCellDate: function (oe, ie) {
            return G.addYear(oe, ie * DECADE_UNIT_DIFF)
        }
    }), null)
}
DecadeBody.displayName = "DecadeBody";
DecadeBody.inheritAttrs = !1;
var scrollIds = new Map;

function waitElementReady(K, C) {
    var H;

    function W() {
        isVisible(K) ? C() : H = wrapperRaf(function () {
            W()
        })
    }
    return W(),
        function () {
            wrapperRaf.cancel(H)
        }
}

function scrollTo(K, C, H) {
    if (scrollIds.get(K) && wrapperRaf.cancel(scrollIds.get(K)), H <= 0) {
        scrollIds.set(K, wrapperRaf(function () {
            K.scrollTop = C
        }));
        return
    }
    var W = C - K.scrollTop,
        U = W / H * 10;
    scrollIds.set(K, wrapperRaf(function () {
        K.scrollTop += U, K.scrollTop !== C && scrollTo(K, C, H - 10)
    }))
}

function createKeydownHandler(K, C) {
    var H = C.onLeftRight,
        W = C.onCtrlLeftRight,
        U = C.onUpDown,
        G = C.onPageUpDown,
        X = C.onEnter,
        Z = K.which,
        Q = K.ctrlKey,
        ee = K.metaKey;
    switch (Z) {
        case KeyCode$1.LEFT:
            if (Q || ee) {
                if (W) return W(-1), !0
            } else if (H) return H(-1), !0;
            break;
        case KeyCode$1.RIGHT:
            if (Q || ee) {
                if (W) return W(1), !0
            } else if (H) return H(1), !0;
            break;
        case KeyCode$1.UP:
            if (U) return U(-1), !0;
            break;
        case KeyCode$1.DOWN:
            if (U) return U(1), !0;
            break;
        case KeyCode$1.PAGE_UP:
            if (G) return G(-1), !0;
            break;
        case KeyCode$1.PAGE_DOWN:
            if (G) return G(1), !0;
            break;
        case KeyCode$1.ENTER:
            if (X) return X(), !0;
            break
    }
    return !1
}

function getDefaultFormat(K, C, H, W) {
    var U = K;
    if (!U) switch (C) {
        case "time":
            U = W ? "hh:mm:ss a" : "HH:mm:ss";
            break;
        case "week":
            U = "gggg-wo";
            break;
        case "month":
            U = "YYYY-MM";
            break;
        case "quarter":
            U = "YYYY-[Q]Q";
            break;
        case "year":
            U = "YYYY";
            break;
        default:
            U = H ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD"
    }
    return U
}

function getInputSize(K, C, H) {
    var W = K === "time" ? 8 : 10,
        U = typeof C == "function" ? C(H.getNow()).length : C.length;
    return Math.max(W, U) + 2
}
var globalClickFunc = null,
    clickCallbacks = new Set;

function addGlobalMousedownEvent(K) {
    return !globalClickFunc && typeof window < "u" && window.addEventListener && (globalClickFunc = function (H) {
            _toConsumableArray(clickCallbacks).forEach(function (W) {
                W(H)
            })
        }, window.addEventListener("mousedown", globalClickFunc)), clickCallbacks.add(K),
        function () {
            clickCallbacks.delete(K), clickCallbacks.size === 0 && (window.removeEventListener("mousedown",
                globalClickFunc), globalClickFunc = null)
        }
}

function getTargetFromEvent(K) {
    var C = K.target;
    if (K.composed && C.shadowRoot) {
        var H;
        return ((H = K.composedPath) === null || H === void 0 ? void 0 : H.call(K)[0]) || C
    }
    return C
}
var getYearNextMode = function (C) {
        return C === "month" || C === "date" ? "year" : C
    },
    getMonthNextMode = function (C) {
        return C === "date" ? "month" : C
    },
    getQuarterNextMode = function (C) {
        return C === "month" || C === "date" ? "quarter" : C
    },
    getWeekNextMode = function (C) {
        return C === "date" ? "week" : C
    },
    PickerModeMap = {
        year: getYearNextMode,
        month: getMonthNextMode,
        quarter: getQuarterNextMode,
        week: getWeekNextMode,
        time: null,
        date: null
    };

function elementsContains(K, C) {
    return K.some(function (H) {
        return H && H.contains(C)
    })
}
var DECADE_UNIT_DIFF = 10,
    DECADE_DISTANCE_COUNT = DECADE_UNIT_DIFF * 10;

function DecadePanel(K) {
    var C = useMergeProps(K),
        H = C.prefixCls,
        W = C.onViewDateChange,
        U = C.generateConfig,
        G = C.viewDate,
        X = C.operationRef,
        Z = C.onSelect,
        Q = C.onPanelChange,
        ee = "".concat(H, "-decade-panel");
    X.value = {
        onKeydown: function (ae) {
            return createKeydownHandler(ae, {
                onLeftRight: function (ie) {
                    Z(U.addYear(G, ie * DECADE_UNIT_DIFF), "key")
                },
                onCtrlLeftRight: function (ie) {
                    Z(U.addYear(G, ie * DECADE_DISTANCE_COUNT), "key")
                },
                onUpDown: function (ie) {
                    Z(U.addYear(G, ie * DECADE_UNIT_DIFF * DECADE_COL_COUNT), "key")
                },
                onEnter: function () {
                    Q("year", G)
                }
            })
        }
    };
    var ne = function (ae) {
            var oe = U.addYear(G, ae * DECADE_DISTANCE_COUNT);
            W(oe), Q(null, oe)
        },
        te = function (ae) {
            Z(ae, "mouse"), Q("year", ae)
        };
    return createVNode("div", {
        class: ee
    }, [createVNode(DecadeHeader, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        prefixCls: H,
        onPrevDecades: function () {
            ne(-1)
        },
        onNextDecades: function () {
            ne(1)
        }
    }), null), createVNode(DecadeBody, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        prefixCls: H,
        onSelect: te
    }), null)])
}
DecadePanel.displayName = "DecadePanel";
DecadePanel.inheritAttrs = !1;
var WEEK_DAY_COUNT = 7;

function isNullEqual(K, C) {
    if (!K && !C) return !0;
    if (!K || !C) return !1
}

function isSameDecade(K, C, H) {
    var W = isNullEqual(C, H);
    if (typeof W == "boolean") return W;
    var U = Math.floor(K.getYear(C) / 10),
        G = Math.floor(K.getYear(H) / 10);
    return U === G
}

function isSameYear(K, C, H) {
    var W = isNullEqual(C, H);
    return typeof W == "boolean" ? W : K.getYear(C) === K.getYear(H)
}

function getQuarter(K, C) {
    var H = Math.floor(K.getMonth(C) / 3);
    return H + 1
}

function isSameQuarter(K, C, H) {
    var W = isNullEqual(C, H);
    return typeof W == "boolean" ? W : isSameYear(K, C, H) && getQuarter(K, C) === getQuarter(K, H)
}

function isSameMonth(K, C, H) {
    var W = isNullEqual(C, H);
    return typeof W == "boolean" ? W : isSameYear(K, C, H) && K.getMonth(C) === K.getMonth(H)
}

function isSameDate(K, C, H) {
    var W = isNullEqual(C, H);
    return typeof W == "boolean" ? W : K.getYear(C) === K.getYear(H) && K.getMonth(C) === K.getMonth(H) && K.getDate(C) ===
        K.getDate(H)
}

function isSameTime(K, C, H) {
    var W = isNullEqual(C, H);
    return typeof W == "boolean" ? W : K.getHour(C) === K.getHour(H) && K.getMinute(C) === K.getMinute(H) && K.getSecond(
        C) === K.getSecond(H)
}

function isSameWeek(K, C, H, W) {
    var U = isNullEqual(H, W);
    return typeof U == "boolean" ? U : K.locale.getWeek(C, H) === K.locale.getWeek(C, W)
}

function isEqual(K, C, H) {
    return isSameDate(K, C, H) && isSameTime(K, C, H)
}

function isInRange(K, C, H, W) {
    return !C || !H || !W ? !1 : !isSameDate(K, C, W) && !isSameDate(K, H, W) && K.isAfter(W, C) && K.isAfter(H, W)
}

function getWeekStartDate(K, C, H) {
    var W = C.locale.getWeekFirstDay(K),
        U = C.setDate(H, 1),
        G = C.getWeekDay(U),
        X = C.addDate(U, W - G);
    return C.getMonth(X) === C.getMonth(H) && C.getDate(X) > 1 && (X = C.addDate(X, -7)), X
}

function getClosingViewDate(K, C, H) {
    var W = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    switch (C) {
        case "year":
            return H.addYear(K, W * 10);
        case "quarter":
        case "month":
            return H.addYear(K, W);
        default:
            return H.addMonth(K, W)
    }
}

function formatValue(K, C) {
    var H = C.generateConfig,
        W = C.locale,
        U = C.format;
    return typeof U == "function" ? U(K) : H.locale.format(W.locale, K, U)
}

function parseValue(K, C) {
    var H = C.generateConfig,
        W = C.locale,
        U = C.formatList;
    return !K || typeof U[0] == "function" ? null : H.locale.parse(W.locale, K, U)
}

function getCellDateDisabled(K) {
    var C = K.cellDate,
        H = K.mode,
        W = K.disabledDate,
        U = K.generateConfig;
    if (!W) return !1;
    var G = function (oe, ie, ue) {
        for (var le = ie; le <= ue;) {
            var se = void 0;
            switch (oe) {
                case "date":
                    {
                        if (se = U.setDate(C, le), !W(se)) return !1;
                        break
                    }
                case "month":
                    {
                        if (se = U.setMonth(C, le), !getCellDateDisabled({
                                cellDate: se,
                                mode: "month",
                                generateConfig: U,
                                disabledDate: W
                            })) return !1;
                        break
                    }
                case "year":
                    {
                        if (se = U.setYear(C, le), !getCellDateDisabled({
                                cellDate: se,
                                mode: "year",
                                generateConfig: U,
                                disabledDate: W
                            })) return !1;
                        break
                    }
            }
            le += 1
        }
        return !0
    };
    switch (H) {
        case "date":
        case "week":
            return W(C);
        case "month":
            {
                var X = 1,
                    Z = U.getDate(U.getEndDate(C));
                return G("date", X, Z)
            }
        case "quarter":
            {
                var Q = Math.floor(U.getMonth(C) / 3) * 3,
                    ee = Q + 2;
                return G("month", Q, ee)
            }
        case "year":
            return G("month", 0, 11);
        case "decade":
            {
                var ne = U.getYear(C),
                    te = Math.floor(ne / DECADE_UNIT_DIFF) * DECADE_UNIT_DIFF,
                    re = te + DECADE_UNIT_DIFF - 1;
                return G("year", te, re)
            }
    }
}

function TimeHeader(K) {
    var C = useMergeProps(K),
        H = useInjectPanel(),
        W = H.hideHeader;
    if (W.value) return null;
    var U = C.prefixCls,
        G = C.generateConfig,
        X = C.locale,
        Z = C.value,
        Q = C.format,
        ee = "".concat(U, "-header");
    return createVNode(Header$2, {
        prefixCls: ee
    }, {
        default: function () {
            return [Z ? formatValue(Z, {
                locale: X,
                format: Q,
                generateConfig: G
            }) : " "]
        }
    })
}
TimeHeader.displayName = "TimeHeader";
TimeHeader.inheritAttrs = !1;
const TimeUnitColumn = defineComponent({
    name: "TimeUnitColumn",
    props: ["prefixCls", "units", "onSelect", "value", "active", "hideDisabledOptions"],
    setup: function (C) {
        var H = useInjectPanel(),
            W = H.open,
            U = ref(null),
            G = ref(new Map),
            X = ref();
        return watch(function () {
                return C.value
            }, function () {
                var Z = G.value.get(C.value);
                Z && W.value !== !1 && scrollTo(U.value, Z.offsetTop, 120)
            }), onBeforeUnmount(function () {
                var Z;
                (Z = X.value) === null || Z === void 0 || Z.call(X)
            }), watch(W, function () {
                var Z;
                (Z = X.value) === null || Z === void 0 || Z.call(X), nextTick(function () {
                    if (W.value) {
                        var Q = G.value.get(C.value);
                        Q && (X.value = waitElementReady(Q, function () {
                            scrollTo(U.value, Q.offsetTop, 0)
                        }))
                    }
                })
            }, {
                immediate: !0,
                flush: "post"
            }),
            function () {
                var Z = C.prefixCls,
                    Q = C.units,
                    ee = C.onSelect,
                    ne = C.value,
                    te = C.active,
                    re = C.hideDisabledOptions,
                    ae = "".concat(Z, "-cell");
                return createVNode("ul", {
                    class: classNames("".concat(Z, "-column"), _defineProperty$V({}, "".concat(Z,
                        "-column-active"), te)),
                    ref: U,
                    style: {
                        position: "relative"
                    }
                }, [Q.map(function (oe) {
                    var ie;
                    return re && oe.disabled ? null : createVNode("li", {
                        key: oe.value,
                        ref: function (le) {
                            G.value.set(oe.value, le)
                        },
                        class: classNames(ae, (ie = {}, _defineProperty$V(ie, "".concat(
                                ae, "-disabled"), oe.disabled),
                            _defineProperty$V(ie, "".concat(ae, "-selected"),
                                ne === oe.value), ie)),
                        onClick: function () {
                            oe.disabled || ee(oe.value)
                        }
                    }, [createVNode("div", {
                        class: "".concat(ae, "-inner")
                    }, [oe.label])])
                })])
            }
    }
});

function leftPad(K, C) {
    for (var H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0", W = String(K); W.length < C;) W =
        "".concat(H).concat(K);
    return W
}
var tuple = function () {
    for (var C = arguments.length, H = new Array(C), W = 0; W < C; W++) H[W] = arguments[W];
    return H
};

function toArray$7(K) {
    return K == null ? [] : Array.isArray(K) ? K : [K]
}

function getDataOrAriaProps(K) {
    var C = {};
    return Object.keys(K).forEach(function (H) {
        (H.substr(0, 5) === "data-" || H.substr(0, 5) === "aria-" || H === "role" || H === "name") && H.substr(
            0, 7) !== "data-__" && (C[H] = K[H])
    }), C
}

function getValue$2(K, C) {
    return K ? K[C] : null
}

function updateValues(K, C, H) {
    var W = [getValue$2(K, 0), getValue$2(K, 1)];
    return W[H] = typeof C == "function" ? C(W[H]) : C, !W[0] && !W[1] ? null : W
}

function generateUnits(K, C, H, W) {
    for (var U = [], G = K; G <= C; G += H) U.push({
        label: leftPad(G, 2),
        value: G,
        disabled: (W || []).includes(G)
    });
    return U
}
var TimeBody = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "TimeBody",
    inheritAttrs: !1,
    props: ["generateConfig", "prefixCls", "operationRef", "activeColumnIndex", "value", "showHour",
        "showMinute", "showSecond", "use12Hours", "hourStep", "minuteStep", "secondStep", "disabledHours",
        "disabledMinutes", "disabledSeconds", "disabledTime", "hideDisabledOptions", "onSelect"],
    setup: function (C) {
        var H = computed(function () {
                return C.value ? C.generateConfig.getHour(C.value) : -1
            }),
            W = computed(function () {
                return C.use12Hours ? H.value >= 12 : !1
            }),
            U = computed(function () {
                return C.use12Hours ? H.value % 12 : H.value
            }),
            G = computed(function () {
                return C.value ? C.generateConfig.getMinute(C.value) : -1
            }),
            X = computed(function () {
                return C.value ? C.generateConfig.getSecond(C.value) : -1
            }),
            Z = ref(C.generateConfig.getNow()),
            Q = ref(),
            ee = ref(),
            ne = ref();
        onBeforeUpdate(function () {
            Z.value = C.generateConfig.getNow()
        }), watchEffect(function () {
            if (C.disabledTime) {
                var le = C.disabledTime(Z),
                    se = [le.disabledHours, le.disabledMinutes, le.disabledSeconds];
                Q.value = se[0], ee.value = se[1], ne.value = se[2]
            } else {
                var ce = [C.disabledHours, C.disabledMinutes, C.disabledSeconds];
                Q.value = ce[0], ee.value = ce[1], ne.value = ce[2]
            }
        });
        var te = function (se, ce, de, ve) {
                var fe = C.value || C.generateConfig.getNow(),
                    pe = Math.max(0, ce),
                    me = Math.max(0, de),
                    he = Math.max(0, ve);
                return fe = setTime(C.generateConfig, fe, !C.use12Hours || !se ? pe : pe + 12, me, he), fe
            },
            re = computed(function () {
                var le;
                return generateUnits(0, 23, (le = C.hourStep) !== null && le !== void 0 ? le : 1, Q.value &&
                    Q.value())
            }),
            ae = computed(function () {
                if (!C.use12Hours) return [!1, !1];
                var le = [!0, !0];
                return re.value.forEach(function (se) {
                    var ce = se.disabled,
                        de = se.value;
                    ce || (de >= 12 ? le[1] = !1 : le[0] = !1)
                }), le
            }),
            oe = computed(function () {
                return C.use12Hours ? re.value.filter(W.value ? function (le) {
                    return le.value >= 12
                } : function (le) {
                    return le.value < 12
                }).map(function (le) {
                    var se = le.value % 12,
                        ce = se === 0 ? "12" : leftPad(se, 2);
                    return _objectSpread2$1(_objectSpread2$1({}, le), {}, {
                        label: ce,
                        value: se
                    })
                }) : re.value
            }),
            ie = computed(function () {
                var le;
                return generateUnits(0, 59, (le = C.minuteStep) !== null && le !== void 0 ? le : 1, ee.value &&
                    ee.value(H.value))
            }),
            ue = computed(function () {
                var le;
                return generateUnits(0, 59, (le = C.secondStep) !== null && le !== void 0 ? le : 1, ne.value &&
                    ne.value(H.value, G.value))
            });
        return function () {
            var le = C.prefixCls,
                se = C.operationRef,
                ce = C.activeColumnIndex,
                de = C.showHour,
                ve = C.showMinute,
                fe = C.showSecond,
                pe = C.use12Hours,
                me = C.hideDisabledOptions,
                he = C.onSelect,
                Se = [],
                _e = "".concat(le, "-content"),
                be = "".concat(le, "-time-panel");
            se.value = {
                onUpDown: function ($e) {
                    var ye = Se[ce];
                    if (ye)
                        for (var Ce = ye.units.findIndex(function (Me) {
                                return Me.value === ye.value
                            }), we = ye.units.length, Oe = 1; Oe < we; Oe += 1) {
                            var Ne = ye.units[(Ce + $e * Oe + we) % we];
                            if (Ne.disabled !== !0) {
                                ye.onSelect(Ne.value);
                                break
                            }
                        }
                }
            };

            function ge(Pe, $e, ye, Ce, we) {
                Pe !== !1 && Se.push({
                    node: cloneElement($e, {
                        prefixCls: be,
                        value: ye,
                        active: ce === Se.length,
                        onSelect: we,
                        units: Ce,
                        hideDisabledOptions: me
                    }),
                    onSelect: we,
                    value: ye,
                    units: Ce
                })
            }
            ge(de, createVNode(TimeUnitColumn, {
                key: "hour"
            }, null), U.value, oe.value, function (Pe) {
                he(te(W.value, Pe, G.value, X.value), "mouse")
            }), ge(ve, createVNode(TimeUnitColumn, {
                key: "minute"
            }, null), G.value, ie.value, function (Pe) {
                he(te(W.value, U.value, Pe, X.value), "mouse")
            }), ge(fe, createVNode(TimeUnitColumn, {
                key: "second"
            }, null), X.value, ue.value, function (Pe) {
                he(te(W.value, U.value, G.value, Pe), "mouse")
            });
            var xe = -1;
            return typeof W.value == "boolean" && (xe = W.value ? 1 : 0), ge(pe === !0, createVNode(
                TimeUnitColumn, {
                    key: "12hours"
                }, null), xe, [{
                label: "AM",
                value: 0,
                disabled: ae.value[0]
            }, {
                label: "PM",
                value: 1,
                disabled: ae.value[1]
            }], function (Pe) {
                he(te(!!Pe, U.value, G.value, X.value), "mouse")
            }), createVNode("div", {
                class: _e
            }, [Se.map(function (Pe) {
                var $e = Pe.node;
                return $e
            })])
        }
    }
});
const TimeBody$1 = TimeBody;
var countBoolean = function (C) {
    return C.filter(function (H) {
        return H !== !1
    }).length
};

function TimePanel(K) {
    var C = useMergeProps(K),
        H = C.generateConfig,
        W = C.format,
        U = W === void 0 ? "HH:mm:ss" : W,
        G = C.prefixCls,
        X = C.active,
        Z = C.operationRef,
        Q = C.showHour,
        ee = C.showMinute,
        ne = C.showSecond,
        te = C.use12Hours,
        re = te === void 0 ? !1 : te,
        ae = C.onSelect,
        oe = C.value,
        ie = "".concat(G, "-time-panel"),
        ue = ref(),
        le = ref(-1),
        se = countBoolean([Q, ee, ne, re]);
    return Z.value = {
        onKeydown: function (de) {
            return createKeydownHandler(de, {
                onLeftRight: function (fe) {
                    le.value = (le.value + fe + se) % se
                },
                onUpDown: function (fe) {
                    le.value === -1 ? le.value = 0 : ue.value && ue.value.onUpDown(fe)
                },
                onEnter: function () {
                    ae(oe || H.getNow(), "key"), le.value = -1
                }
            })
        },
        onBlur: function () {
            le.value = -1
        }
    }, createVNode("div", {
        class: classNames(ie, _defineProperty$V({}, "".concat(ie, "-active"), X))
    }, [createVNode(TimeHeader, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        format: U,
        prefixCls: G
    }), null), createVNode(TimeBody$1, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        prefixCls: G,
        activeColumnIndex: le.value,
        operationRef: ue
    }), null)])
}
TimePanel.displayName = "TimePanel";
TimePanel.inheritAttrs = !1;

function useCellClassName(K) {
    var C = K.cellPrefixCls,
        H = K.generateConfig,
        W = K.rangedValue,
        U = K.hoverRangedValue,
        G = K.isInView,
        X = K.isSameCell,
        Z = K.offsetCell,
        Q = K.today,
        ee = K.value;

    function ne(te) {
        var re, ae = Z(te, -1),
            oe = Z(te, 1),
            ie = getValue$2(W, 0),
            ue = getValue$2(W, 1),
            le = getValue$2(U, 0),
            se = getValue$2(U, 1),
            ce = isInRange(H, le, se, te);

        function de(Se) {
            return X(ie, Se)
        }

        function ve(Se) {
            return X(ue, Se)
        }
        var fe = X(le, te),
            pe = X(se, te),
            me = (ce || pe) && (!G(ae) || ve(ae)),
            he = (ce || fe) && (!G(oe) || de(oe));
        return re = {}, _defineProperty$V(re, "".concat(C, "-in-view"), G(te)), _defineProperty$V(re, "".concat(C,
                "-in-range"), isInRange(H, ie, ue, te)), _defineProperty$V(re, "".concat(C, "-range-start"), de(te)),
            _defineProperty$V(re, "".concat(C, "-range-end"), ve(te)), _defineProperty$V(re, "".concat(C,
                "-range-start-single"), de(te) && !ue), _defineProperty$V(re, "".concat(C, "-range-end-single"), ve(te) &&
                !ie), _defineProperty$V(re, "".concat(C, "-range-start-near-hover"), de(te) && (X(ae, le) || isInRange(
                H, le, se, ae))), _defineProperty$V(re, "".concat(C, "-range-end-near-hover"), ve(te) && (X(oe, se) ||
                isInRange(H, le, se, oe))), _defineProperty$V(re, "".concat(C, "-range-hover"), ce), _defineProperty$V(
                re, "".concat(C, "-range-hover-start"), fe), _defineProperty$V(re, "".concat(C, "-range-hover-end"), pe),
            _defineProperty$V(re, "".concat(C, "-range-hover-edge-start"), me), _defineProperty$V(re, "".concat(C,
                "-range-hover-edge-end"), he), _defineProperty$V(re, "".concat(C, "-range-hover-edge-start-near-range"),
                me && X(ae, ue)), _defineProperty$V(re, "".concat(C, "-range-hover-edge-end-near-range"), he && X(oe,
                ie)), _defineProperty$V(re, "".concat(C, "-today"), X(Q, te)), _defineProperty$V(re, "".concat(C,
                "-selected"), X(ee, te)), re
    }
    return ne
}
var RangeContextKey = Symbol("RangeContextProps"),
    useProvideRange = function (C) {
        provide(RangeContextKey, C)
    },
    useInjectRange = function () {
        return inject(RangeContextKey, {
            rangedValue: ref(),
            hoverRangedValue: ref(),
            inRange: ref(),
            panelPosition: ref()
        })
    },
    RangeContextProvider = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "PanelContextProvider",
        inheritAttrs: !1,
        props: {
            value: {
                type: Object,
                default: function () {
                    return {}
                }
            }
        },
        setup: function (C, H) {
            var W = H.slots,
                U = {
                    rangedValue: ref(C.value.rangedValue),
                    hoverRangedValue: ref(C.value.hoverRangedValue),
                    inRange: ref(C.value.inRange),
                    panelPosition: ref(C.value.panelPosition)
                };
            return useProvideRange(U), watch(function () {
                    return C.value
                }, function () {
                    Object.keys(C.value).forEach(function (G) {
                        U[G] && (U[G].value = C.value[G])
                    })
                }),
                function () {
                    var G;
                    return (G = W.default) === null || G === void 0 ? void 0 : G.call(W)
                }
        }
    });

function DateBody(K) {
    var C = useMergeProps(K),
        H = C.prefixCls,
        W = C.generateConfig,
        U = C.prefixColumn,
        G = C.locale,
        X = C.rowCount,
        Z = C.viewDate,
        Q = C.value,
        ee = C.dateRender,
        ne = useInjectRange(),
        te = ne.rangedValue,
        re = ne.hoverRangedValue,
        ae = getWeekStartDate(G.locale, W, Z),
        oe = "".concat(H, "-cell"),
        ie = W.locale.getWeekFirstDay(G.locale),
        ue = W.getNow(),
        le = [],
        se = G.shortWeekDays || (W.locale.getShortWeekDays ? W.locale.getShortWeekDays(G.locale) : []);
    U && le.push(createVNode("th", {
        key: "empty",
        "aria-label": "empty cell"
    }, null));
    for (var ce = 0; ce < WEEK_DAY_COUNT; ce += 1) le.push(createVNode("th", {
        key: ce
    }, [se[(ce + ie) % WEEK_DAY_COUNT]]));
    var de = useCellClassName({
            cellPrefixCls: oe,
            today: ue,
            value: Q,
            generateConfig: W,
            rangedValue: U ? null : te.value,
            hoverRangedValue: U ? null : re.value,
            isSameCell: function (pe, me) {
                return isSameDate(W, pe, me)
            },
            isInView: function (pe) {
                return isSameMonth(W, pe, Z)
            },
            offsetCell: function (pe, me) {
                return W.addDate(pe, me)
            }
        }),
        ve = ee ? function (fe) {
            return ee({
                current: fe,
                today: ue
            })
        } : void 0;
    return createVNode(PanelBody, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        rowNum: X,
        colNum: WEEK_DAY_COUNT,
        baseDate: ae,
        getCellNode: ve,
        getCellText: W.getDate,
        getCellClassName: de,
        getCellDate: W.addDate,
        titleCell: function (pe) {
            return formatValue(pe, {
                locale: G,
                format: "YYYY-MM-DD",
                generateConfig: W
            })
        },
        headerCells: le
    }), null)
}
DateBody.displayName = "DateBody";
DateBody.inheritAttrs = !1;
DateBody.props = ["prefixCls", "generateConfig", "value?", "viewDate", "locale", "rowCount", "onSelect", "dateRender?",
    "disabledDate?", "prefixColumn?", "rowClassName?"];

function DateHeader(K) {
    var C = useMergeProps(K),
        H = C.prefixCls,
        W = C.generateConfig,
        U = C.locale,
        G = C.viewDate,
        X = C.onNextMonth,
        Z = C.onPrevMonth,
        Q = C.onNextYear,
        ee = C.onPrevYear,
        ne = C.onYearClick,
        te = C.onMonthClick,
        re = useInjectPanel(),
        ae = re.hideHeader;
    if (ae.value) return null;
    var oe = "".concat(H, "-header"),
        ie = U.shortMonths || (W.locale.getShortMonths ? W.locale.getShortMonths(U.locale) : []),
        ue = W.getMonth(G),
        le = createVNode("button", {
            type: "button",
            key: "year",
            onClick: ne,
            tabindex: -1,
            class: "".concat(H, "-year-btn")
        }, [formatValue(G, {
            locale: U,
            format: U.yearFormat,
            generateConfig: W
        })]),
        se = createVNode("button", {
            type: "button",
            key: "month",
            onClick: te,
            tabindex: -1,
            class: "".concat(H, "-month-btn")
        }, [U.monthFormat ? formatValue(G, {
            locale: U,
            format: U.monthFormat,
            generateConfig: W
        }) : ie[ue]]),
        ce = U.monthBeforeYear ? [se, le] : [le, se];
    return createVNode(Header$2, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        prefixCls: oe,
        onSuperPrev: ee,
        onPrev: Z,
        onNext: X,
        onSuperNext: Q
    }), {
        default: function () {
            return [ce]
        }
    })
}
DateHeader.displayName = "DateHeader";
DateHeader.inheritAttrs = !1;
var DATE_ROW_COUNT = 6;

function DatePanel(K) {
    var C = useMergeProps(K),
        H = C.prefixCls,
        W = C.panelName,
        U = W === void 0 ? "date" : W,
        G = C.keyboardConfig,
        X = C.active,
        Z = C.operationRef,
        Q = C.generateConfig,
        ee = C.value,
        ne = C.viewDate,
        te = C.onViewDateChange,
        re = C.onPanelChange,
        ae = C.onSelect,
        oe = "".concat(H, "-").concat(U, "-panel");
    Z.value = {
        onKeydown: function (se) {
            return createKeydownHandler(se, _objectSpread2$1({
                onLeftRight: function (de) {
                    ae(Q.addDate(ee || ne, de), "key")
                },
                onCtrlLeftRight: function (de) {
                    ae(Q.addYear(ee || ne, de), "key")
                },
                onUpDown: function (de) {
                    ae(Q.addDate(ee || ne, de * WEEK_DAY_COUNT), "key")
                },
                onPageUpDown: function (de) {
                    ae(Q.addMonth(ee || ne, de), "key")
                }
            }, G))
        }
    };
    var ie = function (se) {
            var ce = Q.addYear(ne, se);
            te(ce), re(null, ce)
        },
        ue = function (se) {
            var ce = Q.addMonth(ne, se);
            te(ce), re(null, ce)
        };
    return createVNode("div", {
        class: classNames(oe, _defineProperty$V({}, "".concat(oe, "-active"), X))
    }, [createVNode(DateHeader, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        prefixCls: H,
        value: ee,
        viewDate: ne,
        onPrevYear: function () {
            ie(-1)
        },
        onNextYear: function () {
            ie(1)
        },
        onPrevMonth: function () {
            ue(-1)
        },
        onNextMonth: function () {
            ue(1)
        },
        onMonthClick: function () {
            re("month", ne)
        },
        onYearClick: function () {
            re("year", ne)
        }
    }), null), createVNode(DateBody, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        onSelect: function (se) {
            return ae(se, "mouse")
        },
        prefixCls: H,
        value: ee,
        viewDate: ne,
        rowCount: DATE_ROW_COUNT
    }), null)])
}
DatePanel.displayName = "DatePanel";
DatePanel.inheritAttrs = !1;
var ACTIVE_PANEL = tuple("date", "time");

function DatetimePanel(K) {
    var C = useMergeProps(K),
        H = C.prefixCls,
        W = C.operationRef,
        U = C.generateConfig,
        G = C.value,
        X = C.defaultValue,
        Z = C.disabledTime,
        Q = C.showTime,
        ee = C.onSelect,
        ne = "".concat(H, "-datetime-panel"),
        te = ref(null),
        re = ref({}),
        ae = ref({}),
        oe = _typeof$2(Q) === "object" ? _objectSpread2$1({}, Q) : {};

    function ie(ce) {
        var de = ACTIVE_PANEL.indexOf(te.value) + ce,
            ve = ACTIVE_PANEL[de] || null;
        return ve
    }
    var ue = function (de) {
        ae.value.onBlur && ae.value.onBlur(de), te.value = null
    };
    W.value = {
        onKeydown: function (de) {
            if (de.which === KeyCode$1.TAB) {
                var ve = ie(de.shiftKey ? -1 : 1);
                return te.value = ve, ve && de.preventDefault(), !0
            }
            if (te.value) {
                var fe = te.value === "date" ? re : ae;
                return fe.value && fe.value.onKeydown && fe.value.onKeydown(de), !0
            }
            return [KeyCode$1.LEFT, KeyCode$1.RIGHT, KeyCode$1.UP, KeyCode$1.DOWN].includes(de.which) ? (te.value =
                "date", !0) : !1
        },
        onBlur: ue,
        onClose: ue
    };
    var le = function (de, ve) {
            var fe = de;
            ve === "date" && !G && oe.defaultValue ? (fe = U.setHour(fe, U.getHour(oe.defaultValue)), fe = U.setMinute(
                    fe, U.getMinute(oe.defaultValue)), fe = U.setSecond(fe, U.getSecond(oe.defaultValue))) : ve ===
                "time" && !G && X && (fe = U.setYear(fe, U.getYear(X)), fe = U.setMonth(fe, U.getMonth(X)), fe = U.setDate(
                    fe, U.getDate(X))), ee && ee(fe, "mouse")
        },
        se = Z ? Z(G || null) : {};
    return createVNode("div", {
        class: classNames(ne, _defineProperty$V({}, "".concat(ne, "-active"), te.value))
    }, [createVNode(DatePanel, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        operationRef: re,
        active: te.value === "date",
        onSelect: function (de) {
            le(setDateTime(U, de, !G && _typeof$2(Q) === "object" ? Q.defaultValue : null),
                "date")
        }
    }), null), createVNode(TimePanel, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({},
        C), {}, {
        format: void 0
    }, oe), se), {}, {
        disabledTime: null,
        defaultValue: void 0,
        operationRef: ae,
        active: te.value === "time",
        onSelect: function (de) {
            le(de, "time")
        }
    }), null)])
}
DatetimePanel.displayName = "DatetimePanel";
DatetimePanel.inheritAttrs = !1;

function WeekPanel(K) {
    var C = useMergeProps(K),
        H = C.prefixCls,
        W = C.generateConfig,
        U = C.locale,
        G = C.value,
        X = "".concat(H, "-cell"),
        Z = function (te) {
            return createVNode("td", {
                key: "week",
                class: classNames(X, "".concat(X, "-week"))
            }, [W.locale.getWeek(U.locale, te)])
        },
        Q = "".concat(H, "-week-panel-row"),
        ee = function (te) {
            return classNames(Q, _defineProperty$V({}, "".concat(Q, "-selected"), isSameWeek(W, U.locale, G, te)))
        };
    return createVNode(DatePanel, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        panelName: "week",
        prefixColumn: Z,
        rowClassName: ee,
        keyboardConfig: {
            onLeftRight: null
        }
    }), null)
}
WeekPanel.displayName = "WeekPanel";
WeekPanel.inheritAttrs = !1;

function MonthHeader(K) {
    var C = useMergeProps(K),
        H = C.prefixCls,
        W = C.generateConfig,
        U = C.locale,
        G = C.viewDate,
        X = C.onNextYear,
        Z = C.onPrevYear,
        Q = C.onYearClick,
        ee = useInjectPanel(),
        ne = ee.hideHeader;
    if (ne.value) return null;
    var te = "".concat(H, "-header");
    return createVNode(Header$2, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        prefixCls: te,
        onSuperPrev: Z,
        onSuperNext: X
    }), {
        default: function () {
            return [createVNode("button", {
                type: "button",
                onClick: Q,
                class: "".concat(H, "-year-btn")
            }, [formatValue(G, {
                locale: U,
                format: U.yearFormat,
                generateConfig: W
            })])]
        }
    })
}
MonthHeader.displayName = "MonthHeader";
MonthHeader.inheritAttrs = !1;
var MONTH_COL_COUNT = 3,
    MONTH_ROW_COUNT = 4;

function MonthBody(K) {
    var C = useMergeProps(K),
        H = C.prefixCls,
        W = C.locale,
        U = C.value,
        G = C.viewDate,
        X = C.generateConfig,
        Z = C.monthCellRender,
        Q = useInjectRange(),
        ee = Q.rangedValue,
        ne = Q.hoverRangedValue,
        te = "".concat(H, "-cell"),
        re = useCellClassName({
            cellPrefixCls: te,
            value: U,
            generateConfig: X,
            rangedValue: ee.value,
            hoverRangedValue: ne.value,
            isSameCell: function (le, se) {
                return isSameMonth(X, le, se)
            },
            isInView: function () {
                return !0
            },
            offsetCell: function (le, se) {
                return X.addMonth(le, se)
            }
        }),
        ae = W.shortMonths || (X.locale.getShortMonths ? X.locale.getShortMonths(W.locale) : []),
        oe = X.setMonth(G, 0),
        ie = Z ? function (ue) {
            return Z({
                current: ue,
                locale: W
            })
        } : void 0;
    return createVNode(PanelBody, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        rowNum: MONTH_ROW_COUNT,
        colNum: MONTH_COL_COUNT,
        baseDate: oe,
        getCellNode: ie,
        getCellText: function (le) {
            return W.monthFormat ? formatValue(le, {
                locale: W,
                format: W.monthFormat,
                generateConfig: X
            }) : ae[X.getMonth(le)]
        },
        getCellClassName: re,
        getCellDate: X.addMonth,
        titleCell: function (le) {
            return formatValue(le, {
                locale: W,
                format: "YYYY-MM",
                generateConfig: X
            })
        }
    }), null)
}
MonthBody.displayName = "MonthBody";
MonthBody.inheritAttrs = !1;

function MonthPanel(K) {
    var C = useMergeProps(K),
        H = C.prefixCls,
        W = C.operationRef,
        U = C.onViewDateChange,
        G = C.generateConfig,
        X = C.value,
        Z = C.viewDate,
        Q = C.onPanelChange,
        ee = C.onSelect,
        ne = "".concat(H, "-month-panel");
    W.value = {
        onKeydown: function (ae) {
            return createKeydownHandler(ae, {
                onLeftRight: function (ie) {
                    ee(G.addMonth(X || Z, ie), "key")
                },
                onCtrlLeftRight: function (ie) {
                    ee(G.addYear(X || Z, ie), "key")
                },
                onUpDown: function (ie) {
                    ee(G.addMonth(X || Z, ie * MONTH_COL_COUNT), "key")
                },
                onEnter: function () {
                    Q("date", X || Z)
                }
            })
        }
    };
    var te = function (ae) {
        var oe = G.addYear(Z, ae);
        U(oe), Q(null, oe)
    };
    return createVNode("div", {
        class: ne
    }, [createVNode(MonthHeader, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        prefixCls: H,
        onPrevYear: function () {
            te(-1)
        },
        onNextYear: function () {
            te(1)
        },
        onYearClick: function () {
            Q("year", Z)
        }
    }), null), createVNode(MonthBody, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        prefixCls: H,
        onSelect: function (ae) {
            ee(ae, "mouse"), Q("date", ae)
        }
    }), null)])
}
MonthPanel.displayName = "MonthPanel";
MonthPanel.inheritAttrs = !1;

function QuarterHeader(K) {
    var C = useMergeProps(K),
        H = C.prefixCls,
        W = C.generateConfig,
        U = C.locale,
        G = C.viewDate,
        X = C.onNextYear,
        Z = C.onPrevYear,
        Q = C.onYearClick,
        ee = useInjectPanel(),
        ne = ee.hideHeader;
    if (ne.value) return null;
    var te = "".concat(H, "-header");
    return createVNode(Header$2, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        prefixCls: te,
        onSuperPrev: Z,
        onSuperNext: X
    }), {
        default: function () {
            return [createVNode("button", {
                type: "button",
                onClick: Q,
                class: "".concat(H, "-year-btn")
            }, [formatValue(G, {
                locale: U,
                format: U.yearFormat,
                generateConfig: W
            })])]
        }
    })
}
QuarterHeader.displayName = "QuarterHeader";
QuarterHeader.inheritAttrs = !1;
var QUARTER_COL_COUNT = 4,
    QUARTER_ROW_COUNT = 1;

function QuarterBody(K) {
    var C = useMergeProps(K),
        H = C.prefixCls,
        W = C.locale,
        U = C.value,
        G = C.viewDate,
        X = C.generateConfig,
        Z = useInjectRange(),
        Q = Z.rangedValue,
        ee = Z.hoverRangedValue,
        ne = "".concat(H, "-cell"),
        te = useCellClassName({
            cellPrefixCls: ne,
            value: U,
            generateConfig: X,
            rangedValue: Q.value,
            hoverRangedValue: ee.value,
            isSameCell: function (oe, ie) {
                return isSameQuarter(X, oe, ie)
            },
            isInView: function () {
                return !0
            },
            offsetCell: function (oe, ie) {
                return X.addMonth(oe, ie * 3)
            }
        }),
        re = X.setDate(X.setMonth(G, 0), 1);
    return createVNode(PanelBody, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        rowNum: QUARTER_ROW_COUNT,
        colNum: QUARTER_COL_COUNT,
        baseDate: re,
        getCellText: function (oe) {
            return formatValue(oe, {
                locale: W,
                format: W.quarterFormat || "[Q]Q",
                generateConfig: X
            })
        },
        getCellClassName: te,
        getCellDate: function (oe, ie) {
            return X.addMonth(oe, ie * 3)
        },
        titleCell: function (oe) {
            return formatValue(oe, {
                locale: W,
                format: "YYYY-[Q]Q",
                generateConfig: X
            })
        }
    }), null)
}
QuarterBody.displayName = "QuarterBody";
QuarterBody.inheritAttrs = !1;

function QuarterPanel(K) {
    var C = useMergeProps(K),
        H = C.prefixCls,
        W = C.operationRef,
        U = C.onViewDateChange,
        G = C.generateConfig,
        X = C.value,
        Z = C.viewDate,
        Q = C.onPanelChange,
        ee = C.onSelect,
        ne = "".concat(H, "-quarter-panel");
    W.value = {
        onKeydown: function (ae) {
            return createKeydownHandler(ae, {
                onLeftRight: function (ie) {
                    ee(G.addMonth(X || Z, ie * 3), "key")
                },
                onCtrlLeftRight: function (ie) {
                    ee(G.addYear(X || Z, ie), "key")
                },
                onUpDown: function (ie) {
                    ee(G.addYear(X || Z, ie), "key")
                }
            })
        }
    };
    var te = function (ae) {
        var oe = G.addYear(Z, ae);
        U(oe), Q(null, oe)
    };
    return createVNode("div", {
        class: ne
    }, [createVNode(QuarterHeader, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        prefixCls: H,
        onPrevYear: function () {
            te(-1)
        },
        onNextYear: function () {
            te(1)
        },
        onYearClick: function () {
            Q("year", Z)
        }
    }), null), createVNode(QuarterBody, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        prefixCls: H,
        onSelect: function (ae) {
            ee(ae, "mouse")
        }
    }), null)])
}
QuarterPanel.displayName = "QuarterPanel";
QuarterPanel.inheritAttrs = !1;

function YearHeader(K) {
    var C = useMergeProps(K),
        H = C.prefixCls,
        W = C.generateConfig,
        U = C.viewDate,
        G = C.onPrevDecade,
        X = C.onNextDecade,
        Z = C.onDecadeClick,
        Q = useInjectPanel(),
        ee = Q.hideHeader;
    if (ee.value) return null;
    var ne = "".concat(H, "-header"),
        te = W.getYear(U),
        re = Math.floor(te / YEAR_DECADE_COUNT) * YEAR_DECADE_COUNT,
        ae = re + YEAR_DECADE_COUNT - 1;
    return createVNode(Header$2, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        prefixCls: ne,
        onSuperPrev: G,
        onSuperNext: X
    }), {
        default: function () {
            return [createVNode("button", {
                type: "button",
                onClick: Z,
                class: "".concat(H, "-decade-btn")
            }, [re, createTextVNode("-"), ae])]
        }
    })
}
YearHeader.displayName = "YearHeader";
YearHeader.inheritAttrs = !1;
var YEAR_COL_COUNT = 3,
    YEAR_ROW_COUNT = 4;

function YearBody(K) {
    var C = useMergeProps(K),
        H = C.prefixCls,
        W = C.value,
        U = C.viewDate,
        G = C.locale,
        X = C.generateConfig,
        Z = useInjectRange(),
        Q = Z.rangedValue,
        ee = Z.hoverRangedValue,
        ne = "".concat(H, "-cell"),
        te = X.getYear(U),
        re = Math.floor(te / YEAR_DECADE_COUNT) * YEAR_DECADE_COUNT,
        ae = re + YEAR_DECADE_COUNT - 1,
        oe = X.setYear(U, re - Math.ceil((YEAR_COL_COUNT * YEAR_ROW_COUNT - YEAR_DECADE_COUNT) / 2)),
        ie = function (se) {
            var ce = X.getYear(se);
            return re <= ce && ce <= ae
        },
        ue = useCellClassName({
            cellPrefixCls: ne,
            value: W,
            generateConfig: X,
            rangedValue: Q.value,
            hoverRangedValue: ee.value,
            isSameCell: function (se, ce) {
                return isSameYear(X, se, ce)
            },
            isInView: ie,
            offsetCell: function (se, ce) {
                return X.addYear(se, ce)
            }
        });
    return createVNode(PanelBody, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        rowNum: YEAR_ROW_COUNT,
        colNum: YEAR_COL_COUNT,
        baseDate: oe,
        getCellText: X.getYear,
        getCellClassName: ue,
        getCellDate: X.addYear,
        titleCell: function (se) {
            return formatValue(se, {
                locale: G,
                format: "YYYY",
                generateConfig: X
            })
        }
    }), null)
}
YearBody.displayName = "YearBody";
YearBody.inheritAttrs = !1;
var YEAR_DECADE_COUNT = 10;

function YearPanel(K) {
    var C = useMergeProps(K),
        H = C.prefixCls,
        W = C.operationRef,
        U = C.onViewDateChange,
        G = C.generateConfig,
        X = C.value,
        Z = C.viewDate,
        Q = C.sourceMode,
        ee = C.onSelect,
        ne = C.onPanelChange,
        te = "".concat(H, "-year-panel");
    W.value = {
        onKeydown: function (oe) {
            return createKeydownHandler(oe, {
                onLeftRight: function (ue) {
                    ee(G.addYear(X || Z, ue), "key")
                },
                onCtrlLeftRight: function (ue) {
                    ee(G.addYear(X || Z, ue * YEAR_DECADE_COUNT), "key")
                },
                onUpDown: function (ue) {
                    ee(G.addYear(X || Z, ue * YEAR_COL_COUNT), "key")
                },
                onEnter: function () {
                    ne(Q === "date" ? "date" : "month", X || Z)
                }
            })
        }
    };
    var re = function (oe) {
        var ie = G.addYear(Z, oe * 10);
        U(ie), ne(null, ie)
    };
    return createVNode("div", {
        class: te
    }, [createVNode(YearHeader, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        prefixCls: H,
        onPrevDecade: function () {
            re(-1)
        },
        onNextDecade: function () {
            re(1)
        },
        onDecadeClick: function () {
            ne("decade", Z)
        }
    }), null), createVNode(YearBody, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        prefixCls: H,
        onSelect: function (oe) {
            ne(Q === "date" ? "date" : "month", oe), ee(oe, "mouse")
        }
    }), null)])
}
YearPanel.displayName = "YearPanel";
YearPanel.inheritAttrs = !1;

function getExtraFooter(K, C, H) {
    return H ? createVNode("div", {
        class: "".concat(K, "-footer-extra")
    }, [H(C)]) : null
}

function getRanges(K) {
    var C = K.prefixCls,
        H = K.rangeList,
        W = H === void 0 ? [] : H,
        U = K.components,
        G = U === void 0 ? {} : U,
        X = K.needConfirmButton,
        Z = K.onNow,
        Q = K.onOk,
        ee = K.okDisabled,
        ne = K.showNow,
        te = K.locale,
        re, ae;
    if (W.length) {
        var oe = G.rangeItem || "span";
        re = createVNode(Fragment, null, [W.map(function (ue) {
            var le = ue.label,
                se = ue.onClick,
                ce = ue.onMouseenter,
                de = ue.onMouseleave;
            return createVNode("li", {
                key: le,
                class: "".concat(C, "-preset")
            }, [createVNode(oe, {
                onClick: se,
                onMouseenter: ce,
                onMouseleave: de
            }, {
                default: function () {
                    return [le]
                }
            })])
        })])
    }
    if (X) {
        var ie = G.button || "button";
        Z && !re && ne !== !1 && (re = createVNode("li", {
            class: "".concat(C, "-now")
        }, [createVNode("a", {
            class: "".concat(C, "-now-btn"),
            onClick: Z
        }, [te.now])])), ae = X && createVNode("li", {
            class: "".concat(C, "-ok")
        }, [createVNode(ie, {
            disabled: ee,
            onClick: Q
        }, {
            default: function () {
                return [te.ok]
            }
        })])
    }
    return !re && !ae ? null : createVNode("ul", {
        class: "".concat(C, "-ranges")
    }, [re, ae])
}

function PickerPanel() {
    return defineComponent({
        name: "PickerPanel",
        inheritAttrs: !1,
        props: {
            prefixCls: String,
            locale: Object,
            generateConfig: Object,
            value: Object,
            defaultValue: Object,
            pickerValue: Object,
            defaultPickerValue: Object,
            disabledDate: Function,
            mode: String,
            picker: {
                type: String,
                default: "date"
            },
            tabindex: {
                type: [Number, String],
                default: 0
            },
            showNow: {
                type: Boolean,
                default: void 0
            },
            showTime: [Boolean, Object],
            showToday: Boolean,
            renderExtraFooter: Function,
            dateRender: Function,
            hideHeader: {
                type: Boolean,
                default: void 0
            },
            onSelect: Function,
            onChange: Function,
            onPanelChange: Function,
            onMousedown: Function,
            onPickerValueChange: Function,
            onOk: Function,
            components: Object,
            direction: String,
            hourStep: {
                type: Number,
                default: 1
            },
            minuteStep: {
                type: Number,
                default: 1
            },
            secondStep: {
                type: Number,
                default: 1
            }
        },
        setup: function (C, H) {
            var W = H.attrs,
                U = computed(function () {
                    return C.picker === "date" && !!C.showTime || C.picker === "time"
                }),
                G = computed(function () {
                    return 24 % C.hourStep === 0
                }),
                X = computed(function () {
                    return 60 % C.minuteStep === 0
                }),
                Z = computed(function () {
                    return 60 % C.secondStep === 0
                }),
                Q = useInjectPanel(),
                ee = Q.operationRef,
                ne = Q.panelRef,
                te = Q.onSelect,
                re = Q.hideRanges,
                ae = Q.defaultOpenValue,
                oe = useInjectRange(),
                ie = oe.inRange,
                ue = oe.panelPosition,
                le = oe.rangedValue,
                se = oe.hoverRangedValue,
                ce = ref({}),
                de = useMergedState(null, {
                    value: toRef(C, "value"),
                    defaultValue: C.defaultValue,
                    postState: function (Re) {
                        return !Re && ae !== null && ae !== void 0 && ae.value && C.picker ===
                            "time" ? ae.value : Re
                    }
                }),
                ve = _slicedToArray$2(de, 2),
                fe = ve[0],
                pe = ve[1],
                me = useMergedState(null, {
                    value: toRef(C, "pickerValue"),
                    defaultValue: C.defaultPickerValue || fe.value,
                    postState: function (Re) {
                        var He = C.generateConfig,
                            je = C.showTime,
                            Fe = C.defaultValue,
                            Le = He.getNow();
                        return Re ? !fe.value && C.showTime ? _typeof$2(je) === "object" ?
                            setDateTime(He, Array.isArray(Re) ? Re[0] : Re, je.defaultValue || Le) :
                            Fe ? setDateTime(He, Array.isArray(Re) ? Re[0] : Re, Fe) : setDateTime(
                                He, Array.isArray(Re) ? Re[0] : Re, Le) : Re : Le
                    }
                }),
                he = _slicedToArray$2(me, 2),
                Se = he[0],
                _e = he[1],
                be = function (Re) {
                    _e(Re), C.onPickerValueChange && C.onPickerValueChange(Re)
                },
                ge = function (Re) {
                    var He = PickerModeMap[C.picker];
                    return He ? He(Re) : Re
                },
                xe = useMergedState(function () {
                    return C.picker === "time" ? "time" : ge("date")
                }, {
                    value: toRef(C, "mode")
                }),
                Pe = _slicedToArray$2(xe, 2),
                $e = Pe[0],
                ye = Pe[1];
            watch(function () {
                return C.picker
            }, function () {
                ye(C.picker)
            });
            var Ce = ref($e.value),
                we = function (Re) {
                    Ce.value = Re
                },
                Oe = function (Re, He) {
                    var je = C.onPanelChange,
                        Fe = C.generateConfig,
                        Le = ge(Re || $e.value);
                    we($e.value), ye(Le), je && ($e.value !== Le || isEqual(Fe, Se.value, Se.value)) && je(
                        He, Le)
                },
                Ne = function (Re, He) {
                    var je = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
                        Fe = C.picker,
                        Le = C.generateConfig,
                        Ie = C.onSelect,
                        Te = C.onChange,
                        De = C.disabledDate;
                    ($e.value === Fe || je) && (pe(Re), Ie && Ie(Re), te && te(Re, He), Te && !isEqual(Le,
                        Re, fe.value) && !(De != null && De(Re)) && Te(Re))
                },
                Me = function (Re) {
                    return ce.value && ce.value.onKeydown ? ([KeyCode$1.LEFT, KeyCode$1.RIGHT, KeyCode$1.UP,
                        KeyCode$1.DOWN, KeyCode$1.PAGE_UP, KeyCode$1.PAGE_DOWN, KeyCode$1.ENTER].includes(
                        Re.which) && Re.preventDefault(), ce.value.onKeydown(Re)) : !1
                },
                Ve = function (Re) {
                    ce.value && ce.value.onBlur && ce.value.onBlur(Re)
                },
                ke = function () {
                    var Re = C.generateConfig,
                        He = C.hourStep,
                        je = C.minuteStep,
                        Fe = C.secondStep,
                        Le = Re.getNow(),
                        Ie = getLowerBoundTime(Re.getHour(Le), Re.getMinute(Le), Re.getSecond(Le), G.value ?
                            He : 1, X.value ? je : 1, Z.value ? Fe : 1),
                        Te = setTime(Re, Le, Ie[0], Ie[1], Ie[2]);
                    Ne(Te, "submit")
                },
                Ee = computed(function () {
                    var Ae, Re = C.prefixCls,
                        He = C.direction;
                    return classNames("".concat(Re, "-panel"), (Ae = {}, _defineProperty$V(Ae, "".concat(
                        Re, "-panel-has-range"), le && le.value && le.value[0] && le.value[
                        1]), _defineProperty$V(Ae, "".concat(Re, "-panel-has-range-hover"),
                        se && se.value && se.value[0] && se.value[1]), _defineProperty$V(Ae,
                        "".concat(Re, "-panel-rtl"), He === "rtl"), Ae))
                });
            return useProvidePanel(_objectSpread2$1(_objectSpread2$1({}, Q), {}, {
                    mode: $e,
                    hideHeader: computed(function () {
                        var Ae;
                        return C.hideHeader !== void 0 ? C.hideHeader : (Ae = Q.hideHeader) ===
                            null || Ae === void 0 ? void 0 : Ae.value
                    }),
                    hidePrevBtn: computed(function () {
                        return ie.value && ue.value === "right"
                    }),
                    hideNextBtn: computed(function () {
                        return ie.value && ue.value === "left"
                    })
                })), watch(function () {
                    return C.value
                }, function () {
                    C.value && _e(C.value)
                }),
                function () {
                    var Ae = C.prefixCls,
                        Re = Ae === void 0 ? "ant-picker" : Ae,
                        He = C.locale,
                        je = C.generateConfig,
                        Fe = C.disabledDate,
                        Le = C.picker,
                        Ie = Le === void 0 ? "date" : Le,
                        Te = C.tabindex,
                        De = Te === void 0 ? 0 : Te,
                        Ke = C.showNow,
                        We = C.showTime,
                        Ue = C.showToday,
                        et = C.renderExtraFooter,
                        Ye = C.onMousedown,
                        ze = C.onOk,
                        Be = C.components;
                    ee && ue.value !== "right" && (ee.value = {
                        onKeydown: Me,
                        onClose: function () {
                            ce.value && ce.value.onClose && ce.value.onClose()
                        }
                    });
                    var Ge, Xe = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, W), C), {}, {
                        operationRef: ce,
                        prefixCls: Re,
                        viewDate: Se.value,
                        value: fe.value,
                        onViewDateChange: be,
                        sourceMode: Ce.value,
                        onPanelChange: Oe,
                        disabledDate: Fe
                    });
                    switch (delete Xe.onChange, delete Xe.onSelect, $e.value) {
                        case "decade":
                            Ge = createVNode(DecadePanel, _objectSpread2$1(_objectSpread2$1({}, Xe), {}, {
                                onSelect: function (st, rt) {
                                    be(st), Ne(st, rt)
                                }
                            }), null);
                            break;
                        case "year":
                            Ge = createVNode(YearPanel, _objectSpread2$1(_objectSpread2$1({}, Xe), {}, {
                                onSelect: function (st, rt) {
                                    be(st), Ne(st, rt)
                                }
                            }), null);
                            break;
                        case "month":
                            Ge = createVNode(MonthPanel, _objectSpread2$1(_objectSpread2$1({}, Xe), {}, {
                                onSelect: function (st, rt) {
                                    be(st), Ne(st, rt)
                                }
                            }), null);
                            break;
                        case "quarter":
                            Ge = createVNode(QuarterPanel, _objectSpread2$1(_objectSpread2$1({}, Xe), {}, {
                                onSelect: function (st, rt) {
                                    be(st), Ne(st, rt)
                                }
                            }), null);
                            break;
                        case "week":
                            Ge = createVNode(WeekPanel, _objectSpread2$1(_objectSpread2$1({}, Xe), {}, {
                                onSelect: function (st, rt) {
                                    be(st), Ne(st, rt)
                                }
                            }), null);
                            break;
                        case "time":
                            delete Xe.showTime, Ge = createVNode(TimePanel, _objectSpread2$1(
                                _objectSpread2$1(_objectSpread2$1({}, Xe), _typeof$2(We) ===
                                    "object" ? We : null), {}, {
                                    onSelect: function (st, rt) {
                                        be(st), Ne(st, rt)
                                    }
                                }), null);
                            break;
                        default:
                            We ? Ge = createVNode(DatetimePanel, _objectSpread2$1(_objectSpread2$1({}, Xe), {}, {
                                onSelect: function (st, rt) {
                                    be(st), Ne(st, rt)
                                }
                            }), null) : Ge = createVNode(DatePanel, _objectSpread2$1(_objectSpread2$1({},
                                Xe), {}, {
                                onSelect: function (st, rt) {
                                    be(st), Ne(st, rt)
                                }
                            }), null)
                    }
                    var nt, it;
                    re != null && re.value || (nt = getExtraFooter(Re, $e.value, et), it = getRanges({
                        prefixCls: Re,
                        components: Be,
                        needConfirmButton: U.value,
                        okDisabled: !fe.value || Fe && Fe(fe.value),
                        locale: He,
                        showNow: Ke,
                        onNow: U.value && ke,
                        onOk: function () {
                            fe.value && (Ne(fe.value, "submit", !0), ze && ze(fe.value))
                        }
                    }));
                    var ft;
                    if (Ue && $e.value === "date" && Ie === "date" && !We) {
                        var pt = je.getNow(),
                            ot = "".concat(Re, "-today-btn"),
                            Ze = Fe && Fe(pt);
                        ft = createVNode("a", {
                            class: classNames(ot, Ze && "".concat(ot, "-disabled")),
                            "aria-disabled": Ze,
                            onClick: function () {
                                Ze || Ne(pt, "mouse", !0)
                            }
                        }, [He.today])
                    }
                    return createVNode("div", {
                        tabindex: De,
                        class: classNames(Ee.value, W.class),
                        style: W.style,
                        onKeydown: Me,
                        onBlur: Ve,
                        onMousedown: Ye,
                        ref: ne
                    }, [Ge, nt || it || ft ? createVNode("div", {
                        class: "".concat(Re, "-footer")
                    }, [nt, it, ft]) : null])
                }
        }
    })
}
var InterPickerPanel = PickerPanel();
const PickerPanel$1 = function (K) {
    return createVNode(InterPickerPanel, K)
};
var BUILT_IN_PLACEMENTS$1 = {
    bottomLeft: {
        points: ["tl", "bl"],
        offset: [0, 4],
        overflow: {
            adjustX: 1,
            adjustY: 1
        }
    },
    bottomRight: {
        points: ["tr", "br"],
        offset: [0, 4],
        overflow: {
            adjustX: 1,
            adjustY: 1
        }
    },
    topLeft: {
        points: ["bl", "tl"],
        offset: [0, -4],
        overflow: {
            adjustX: 0,
            adjustY: 1
        }
    },
    topRight: {
        points: ["br", "tr"],
        offset: [0, -4],
        overflow: {
            adjustX: 0,
            adjustY: 1
        }
    }
};

function PickerTrigger(K, C) {
    var H, W = C.slots,
        U = useMergeProps(K),
        G = U.prefixCls,
        X = U.popupStyle,
        Z = U.visible,
        Q = U.dropdownClassName,
        ee = U.dropdownAlign,
        ne = U.transitionName,
        te = U.getPopupContainer,
        re = U.range,
        ae = U.popupPlacement,
        oe = U.direction,
        ie = "".concat(G, "-dropdown"),
        ue = function () {
            return ae !== void 0 ? ae : oe === "rtl" ? "bottomRight" : "bottomLeft"
        };
    return createVNode(Trigger, {
        showAction: [],
        hideAction: [],
        popupPlacement: ue(),
        builtinPlacements: BUILT_IN_PLACEMENTS$1,
        prefixCls: ie,
        popupTransitionName: ne,
        popupAlign: ee,
        popupVisible: Z,
        popupClassName: classNames(Q, (H = {}, _defineProperty$V(H, "".concat(ie, "-range"), re),
            _defineProperty$V(H, "".concat(ie, "-rtl"), oe === "rtl"), H)),
        popupStyle: X,
        getPopupContainer: te,
        tryPopPortal: !0
    }, {
        default: W.default,
        popup: W.popupElement
    })
}

function usePickerInput(K) {
    var C = K.open,
        H = K.value,
        W = K.isClickOutside,
        U = K.triggerOpen,
        G = K.forwardKeydown,
        X = K.onKeydown,
        Z = K.blurToCancel,
        Q = K.onSubmit,
        ee = K.onCancel,
        ne = K.onFocus,
        te = K.onBlur,
        re = ref(!1),
        ae = ref(!1),
        oe = ref(!1),
        ie = ref(!1),
        ue = ref(!1),
        le = computed(function () {
            return {
                onMousedown: function () {
                    re.value = !0, U(!0)
                },
                onKeydown: function (de) {
                    var ve = function () {
                        ue.value = !0
                    };
                    if (X(de, ve), !ue.value) {
                        switch (de.which) {
                            case KeyCode$1.ENTER:
                                {
                                    C.value ? Q() !== !1 && (re.value = !0) : U(!0),
                                    de.preventDefault();
                                    return
                                }
                            case KeyCode$1.TAB:
                                {
                                    re.value && C.value && !de.shiftKey ? (re.value = !1, de.preventDefault()) :
                                        !re.value && C.value && !G(de) && de.shiftKey && (re.value = !0, de.preventDefault());
                                    return
                                }
                            case KeyCode$1.ESC:
                                {
                                    re.value = !0,
                                    ee();
                                    return
                                }
                        }!C.value && ![KeyCode$1.SHIFT].includes(de.which) ? U(!0) : re.value || G(de)
                    }
                },
                onFocus: function (de) {
                    re.value = !0, ae.value = !0, ne && ne(de)
                },
                onBlur: function (de) {
                    if (oe.value || !W(document.activeElement)) {
                        oe.value = !1;
                        return
                    }
                    Z.value ? setTimeout(function () {
                        for (var ve = document, fe = ve.activeElement; fe && fe.shadowRoot;) fe = fe.shadowRoot
                            .activeElement;
                        W(fe) && ee()
                    }, 0) : C.value && (U(!1), ie.value && Q()), ae.value = !1, te && te(de)
                }
            }
        });
    watch(C, function () {
        ie.value = !1
    }), watch(H, function () {
        ie.value = !0
    });
    var se = ref();
    return onMounted(function () {
        se.value = addGlobalMousedownEvent(function (ce) {
            var de = getTargetFromEvent(ce);
            if (C.value) {
                var ve = W(de);
                ve ? (!ae.value || ve) && U(!1) : (oe.value = !0, wrapperRaf(function () {
                    oe.value = !1
                }))
            }
        })
    }), onBeforeUnmount(function () {
        se.value && se.value()
    }), [le, {
        focused: ae,
        typing: re
    }]
}

function useTextValueMapping(K) {
    var C = K.valueTexts,
        H = K.onTextChange,
        W = ref("");

    function U(X) {
        W.value = X, H(X)
    }

    function G() {
        W.value = C.value[0]
    }
    return watch(function () {
        return _toConsumableArray(C.value)
    }, function (X) {
        var Z = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        X.join("||") !== Z.join("||") && C.value.every(function (Q) {
            return Q !== W.value
        }) && G()
    }, {
        immediate: !0
    }), [W, U, G]
}

function useValueTexts(K, C) {
    var H = C.formatList,
        W = C.generateConfig,
        U = C.locale,
        G = useMemo(function () {
            if (!K.value) return [[""], ""];
            for (var Q = "", ee = [], ne = 0; ne < H.value.length; ne += 1) {
                var te = H.value[ne],
                    re = formatValue(K.value, {
                        generateConfig: W.value,
                        locale: U.value,
                        format: te
                    });
                ee.push(re), ne === 0 && (Q = re)
            }
            return [ee, Q]
        }, [K, H], function (Q, ee) {
            return ee[0] !== Q[0] || !shallowequal(ee[1], Q[1])
        }),
        X = computed(function () {
            return G.value[0]
        }),
        Z = computed(function () {
            return G.value[1]
        });
    return [X, Z]
}

function useHoverValue(K, C) {
    var H = C.formatList,
        W = C.generateConfig,
        U = C.locale,
        G = ref(null),
        X;

    function Z(ae) {
        var oe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
        if (wrapperRaf.cancel(X), oe) {
            G.value = ae;
            return
        }
        X = wrapperRaf(function () {
            G.value = ae
        })
    }
    var Q = useValueTexts(G, {
            formatList: H,
            generateConfig: W,
            locale: U
        }),
        ee = _slicedToArray$2(Q, 2),
        ne = ee[1];

    function te(ae) {
        Z(ae)
    }

    function re() {
        var ae = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
        Z(null, ae)
    }
    return watch(K, function () {
        re(!0)
    }), onBeforeUnmount(function () {
        wrapperRaf.cancel(X)
    }), [ne, te, re]
}

function Picker() {
    return defineComponent({
        name: "Picker",
        inheritAttrs: !1,
        props: ["prefixCls", "id", "tabindex", "dropdownClassName", "dropdownAlign", "popupStyle",
            "transitionName", "generateConfig", "locale", "inputReadOnly", "allowClear", "autofocus",
            "showTime", "showNow", "showHour", "showMinute", "showSecond", "picker", "format", "use12Hours",
            "value", "defaultValue", "open", "defaultOpen", "defaultOpenValue", "suffixIcon", "clearIcon",
            "disabled", "disabledDate", "placeholder", "getPopupContainer", "panelRender", "inputRender",
            "onChange", "onOpenChange", "onFocus", "onBlur", "onMousedown", "onMouseup", "onMouseenter",
            "onMouseleave", "onContextmenu", "onClick", "onKeydown", "onSelect", "direction",
            "autocomplete", "showToday", "renderExtraFooter", "dateRender", "minuteStep", "hourStep",
            "secondStep", "hideDisabledOptions"],
        setup: function (C, H) {
            var W = H.attrs,
                U = H.expose,
                G = ref(null),
                X = computed(function () {
                    var Te;
                    return (Te = C.picker) !== null && Te !== void 0 ? Te : "date"
                }),
                Z = computed(function () {
                    return X.value === "date" && !!C.showTime || X.value === "time"
                }),
                Q = computed(function () {
                    return toArray$7(getDefaultFormat(C.format, X.value, C.showTime, C.use12Hours))
                }),
                ee = ref(null),
                ne = ref(null),
                te = ref(null),
                re = useMergedState(null, {
                    value: toRef(C, "value"),
                    defaultValue: C.defaultValue
                }),
                ae = _slicedToArray$2(re, 2),
                oe = ae[0],
                ie = ae[1],
                ue = ref(oe.value),
                le = function (De) {
                    ue.value = De
                },
                se = ref(null),
                ce = useMergedState(!1, {
                    value: toRef(C, "open"),
                    defaultValue: C.defaultOpen,
                    postState: function (De) {
                        return C.disabled ? !1 : De
                    },
                    onChange: function (De) {
                        C.onOpenChange && C.onOpenChange(De), !De && se.value && se.value.onClose &&
                            se.value.onClose()
                    }
                }),
                de = _slicedToArray$2(ce, 2),
                ve = de[0],
                fe = de[1],
                pe = useValueTexts(ue, {
                    formatList: Q,
                    generateConfig: toRef(C, "generateConfig"),
                    locale: toRef(C, "locale")
                }),
                me = _slicedToArray$2(pe, 2),
                he = me[0],
                Se = me[1],
                _e = useTextValueMapping({
                    valueTexts: he,
                    onTextChange: function (De) {
                        var Ke = parseValue(De, {
                            locale: C.locale,
                            formatList: Q.value,
                            generateConfig: C.generateConfig
                        });
                        Ke && (!C.disabledDate || !C.disabledDate(Ke)) && le(Ke)
                    }
                }),
                be = _slicedToArray$2(_e, 3),
                ge = be[0],
                xe = be[1],
                Pe = be[2],
                $e = function (De) {
                    var Ke = C.onChange,
                        We = C.generateConfig,
                        Ue = C.locale;
                    le(De), ie(De), Ke && !isEqual(We, oe.value, De) && Ke(De, De ? formatValue(De, {
                        generateConfig: We,
                        locale: Ue,
                        format: Q.value[0]
                    }) : "")
                },
                ye = function (De) {
                    C.disabled && De || fe(De)
                },
                Ce = function (De) {
                    return ve.value && se.value && se.value.onKeydown ? se.value.onKeydown(De) : !1
                },
                we = function () {
                    C.onMouseup && C.onMouseup.apply(C, arguments), G.value && (G.value.focus(), ye(!0))
                },
                Oe = usePickerInput({
                    blurToCancel: Z,
                    open: ve,
                    value: ge,
                    triggerOpen: ye,
                    forwardKeydown: Ce,
                    isClickOutside: function (De) {
                        return !elementsContains([ee.value, ne.value, te.value], De)
                    },
                    onSubmit: function () {
                        return !ue.value || C.disabledDate && C.disabledDate(ue.value) ? !1 : ($e(
                            ue.value), ye(!1), Pe(), !0)
                    },
                    onCancel: function () {
                        ye(!1), le(oe.value), Pe()
                    },
                    onKeydown: function (De, Ke) {
                        var We;
                        (We = C.onKeydown) === null || We === void 0 || We.call(C, De, Ke)
                    },
                    onFocus: function (De) {
                        var Ke;
                        (Ke = C.onFocus) === null || Ke === void 0 || Ke.call(C, De)
                    },
                    onBlur: function (De) {
                        var Ke;
                        (Ke = C.onBlur) === null || Ke === void 0 || Ke.call(C, De)
                    }
                }),
                Ne = _slicedToArray$2(Oe, 2),
                Me = Ne[0],
                Ve = Ne[1],
                ke = Ve.focused,
                Ee = Ve.typing;
            watch([ve, he], function () {
                ve.value || (le(oe.value), !he.value.length || he.value[0] === "" ? xe("") : Se.value !==
                    ge.value && Pe())
            }), watch(X, function () {
                ve.value || Pe()
            }), watch(oe, function () {
                le(oe.value)
            });
            var Ae = useHoverValue(ge, {
                    formatList: Q,
                    generateConfig: toRef(C, "generateConfig"),
                    locale: toRef(C, "locale")
                }),
                Re = _slicedToArray$2(Ae, 3),
                He = Re[0],
                je = Re[1],
                Fe = Re[2],
                Le = function (De, Ke) {
                    (Ke === "submit" || Ke !== "key" && !Z.value) && ($e(De), ye(!1))
                };
            useProvidePanel({
                operationRef: se,
                hideHeader: computed(function () {
                    return X.value === "time"
                }),
                panelRef: ee,
                onSelect: Le,
                open: ve,
                defaultOpenValue: toRef(C, "defaultOpenValue"),
                onDateMouseenter: je,
                onDateMouseleave: Fe
            }), U({
                focus: function () {
                    G.value && G.value.focus()
                },
                blur: function () {
                    G.value && G.value.blur()
                }
            });
            var Ie = useProviderTrigger();
            return function () {
                var Te, De = C.prefixCls,
                    Ke = De === void 0 ? "rc-picker" : De,
                    We = C.id,
                    Ue = C.tabindex,
                    et = C.dropdownClassName,
                    Ye = C.dropdownAlign,
                    ze = C.popupStyle,
                    Be = C.transitionName,
                    Ge = C.generateConfig,
                    Xe = C.locale,
                    nt = C.inputReadOnly,
                    it = C.allowClear,
                    ft = C.autofocus,
                    pt = C.picker,
                    ot = pt === void 0 ? "date" : pt;
                C.defaultOpenValue;
                var Ze = C.suffixIcon,
                    ut = C.clearIcon,
                    st = C.disabled,
                    rt = C.placeholder,
                    qe = C.getPopupContainer,
                    Je = C.panelRender,
                    Qe = C.onMousedown,
                    lt = C.onMouseenter,
                    ct = C.onMouseleave,
                    dt = C.onContextmenu,
                    tt = C.onClick,
                    at = C.onSelect,
                    vt = C.direction,
                    gt = C.autocomplete,
                    mt = gt === void 0 ? "off" : gt,
                    ht = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, C), W), {}, {
                        class: classNames(_defineProperty$V({}, "".concat(Ke, "-panel-focused"), !
                            Ee.value)),
                        style: void 0,
                        pickerValue: void 0,
                        onPickerValueChange: void 0,
                        onChange: null
                    }),
                    yt = createVNode(PickerPanel$1, _objectSpread2$1(_objectSpread2$1({}, ht), {}, {
                        generateConfig: Ge,
                        value: ue.value,
                        locale: Xe,
                        tabindex: -1,
                        onSelect: function (Nt) {
                            at == null || at(Nt), le(Nt)
                        },
                        direction: vt,
                        onPanelChange: function (Nt, Rt) {
                            var It = C.onPanelChange;
                            Fe(!0), It == null || It(Nt, Rt)
                        }
                    }), null);
                Je && (yt = Je(yt));
                var St = createVNode("div", {
                        class: "".concat(Ke, "-panel-container"),
                        onMousedown: function (Nt) {
                            Nt.preventDefault()
                        }
                    }, [yt]),
                    Ct;
                Ze && (Ct = createVNode("span", {
                    class: "".concat(Ke, "-suffix")
                }, [Ze]));
                var _t;
                it && oe.value && !st && (_t = createVNode("span", {
                    onMousedown: function (Nt) {
                        Nt.preventDefault(), Nt.stopPropagation()
                    },
                    onMouseup: function (Nt) {
                        Nt.preventDefault(), Nt.stopPropagation(), $e(null), ye(!1)
                    },
                    class: "".concat(Ke, "-clear"),
                    role: "button"
                }, [ut || createVNode("span", {
                    class: "".concat(Ke, "-clear-btn")
                }, null)]));
                var wt = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                        id: We,
                        tabindex: Ue,
                        disabled: st,
                        readonly: nt || typeof Q.value[0] == "function" || !Ee.value,
                        value: He.value || ge.value,
                        onInput: function (Nt) {
                            xe(Nt.target.value)
                        },
                        autofocus: ft,
                        placeholder: rt,
                        ref: G,
                        title: ge.value
                    }, Me.value), {}, {
                        size: getInputSize(ot, Q.value[0], Ge)
                    }, getDataOrAriaProps(C)), {}, {
                        autocomplete: mt
                    }),
                    Et = C.inputRender ? C.inputRender(wt) : createVNode("input", wt, null),
                    xt = vt === "rtl" ? "bottomRight" : "bottomLeft";
                return createVNode(PickerTrigger, {
                    visible: ve.value,
                    popupStyle: ze,
                    prefixCls: Ke,
                    dropdownClassName: et,
                    dropdownAlign: Ye,
                    getPopupContainer: qe,
                    transitionName: Be,
                    popupPlacement: xt,
                    direction: vt
                }, {
                    default: function () {
                        return [createVNode("div", {
                            ref: te,
                            class: classNames(Ke, W.class, (Te = {},
                                _defineProperty$V(Te, "".concat(Ke,
                                    "-disabled"), st),
                                _defineProperty$V(Te, "".concat(Ke,
                                    "-focused"), ke.value),
                                _defineProperty$V(Te, "".concat(Ke,
                                    "-rtl"), vt === "rtl"), Te)),
                            style: W.style,
                            onMousedown: Qe,
                            onMouseup: we,
                            onMouseenter: lt,
                            onMouseleave: ct,
                            onContextmenu: dt,
                            onClick: tt
                        }, [createVNode("div", {
                            class: classNames("".concat(Ke, "-input"),
                                _defineProperty$V({}, "".concat(Ke,
                                        "-input-placeholder"), !!He
                                    .value)),
                            ref: ne
                        }, [Et, Ct, _t]), Ie()])]
                    },
                    popupElement: function () {
                        return St
                    }
                })
            }
        }
    })
}
const Picker$1 = Picker();

function useRangeDisabled(K, C) {
    var H = K.picker,
        W = K.locale,
        U = K.selectedValue,
        G = K.disabledDate,
        X = K.disabled,
        Z = K.generateConfig,
        Q = computed(function () {
            return getValue$2(U.value, 0)
        }),
        ee = computed(function () {
            return getValue$2(U.value, 1)
        });

    function ne(ie) {
        return Z.value.locale.getWeekFirstDate(W.value.locale, ie)
    }

    function te(ie) {
        var ue = Z.value.getYear(ie),
            le = Z.value.getMonth(ie);
        return ue * 100 + le
    }

    function re(ie) {
        var ue = Z.value.getYear(ie),
            le = getQuarter(Z.value, ie);
        return ue * 10 + le
    }
    var ae = function (ue) {
            var le;
            if (G && G !== null && G !== void 0 && (le = G.value) !== null && le !== void 0 && le.call(G, ue)) return !
                0;
            if (X[1] && ee) return !isSameDate(Z.value, ue, ee.value) && Z.value.isAfter(ue, ee.value);
            if (C.value[1] && ee.value) switch (H.value) {
                case "quarter":
                    return re(ue) > re(ee.value);
                case "month":
                    return te(ue) > te(ee.value);
                case "week":
                    return ne(ue) > ne(ee.value);
                default:
                    return !isSameDate(Z.value, ue, ee.value) && Z.value.isAfter(ue, ee.value)
            }
            return !1
        },
        oe = function (ue) {
            var le;
            if ((le = G.value) !== null && le !== void 0 && le.call(G, ue)) return !0;
            if (X[0] && Q) return !isSameDate(Z.value, ue, ee.value) && Z.value.isAfter(Q.value, ue);
            if (C.value[0] && Q.value) switch (H.value) {
                case "quarter":
                    return re(ue) < re(Q.value);
                case "month":
                    return te(ue) < te(Q.value);
                case "week":
                    return ne(ue) < ne(Q.value);
                default:
                    return !isSameDate(Z.value, ue, Q.value) && Z.value.isAfter(Q.value, ue)
            }
            return !1
        };
    return [ae, oe]
}

function getStartEndDistance(K, C, H, W) {
    var U = getClosingViewDate(K, H, W, 1);

    function G(X) {
        return X(K, C) ? "same" : X(U, C) ? "closing" : "far"
    }
    switch (H) {
        case "year":
            return G(function (X, Z) {
                return isSameDecade(W, X, Z)
            });
        case "quarter":
        case "month":
            return G(function (X, Z) {
                return isSameYear(W, X, Z)
            });
        default:
            return G(function (X, Z) {
                return isSameMonth(W, X, Z)
            })
    }
}

function getRangeViewDate(K, C, H, W) {
    var U = getValue$2(K, 0),
        G = getValue$2(K, 1);
    if (C === 0) return U;
    if (U && G) {
        var X = getStartEndDistance(U, G, H, W);
        switch (X) {
            case "same":
                return U;
            case "closing":
                return U;
            default:
                return getClosingViewDate(G, H, W, -1)
        }
    }
    return U
}

function useRangeViewDates(K) {
    var C = K.values,
        H = K.picker,
        W = K.defaultDates,
        U = K.generateConfig,
        G = ref([getValue$2(W, 0), getValue$2(W, 1)]),
        X = ref(null),
        Z = computed(function () {
            return getValue$2(C.value, 0)
        }),
        Q = computed(function () {
            return getValue$2(C.value, 1)
        }),
        ee = function (oe) {
            return G.value[oe] ? G.value[oe] : getValue$2(X.value, oe) || getRangeViewDate(C.value, oe, H.value, U.value) ||
                Z.value || Q.value || U.value.getNow()
        },
        ne = ref(null),
        te = ref(null);
    watchEffect(function () {
        ne.value = ee(0), te.value = ee(1)
    });

    function re(ae, oe) {
        if (ae) {
            var ie = updateValues(X.value, ae, oe);
            G.value = updateValues(G.value, null, oe) || [null, null];
            var ue = (oe + 1) % 2;
            getValue$2(C.value, ue) || (ie = updateValues(ie, ae, ue)), X.value = ie
        } else(Z.value || Q.value) && (X.value = null)
    }
    return [ne, te, re]
}

function tryOnScopeDispose(K) {
    return getCurrentScope() ? (onScopeDispose(K), !0) : !1
}

function resolveUnref(K) {
    return typeof K == "function" ? K() : unref(K)
}

function unrefElement(K) {
    var C, H = resolveUnref(K);
    return (C = H == null ? void 0 : H.$el) !== null && C !== void 0 ? C : H
}

function tryOnMounted(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    getCurrentInstance() ? onMounted(K) : C ? K() : nextTick(K)
}

function useSupported(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
        H = ref(),
        W = function () {
            return H.value = !!K()
        };
    return W(), tryOnMounted(W, C), H
}
var _window, _window$navigator, isClient = typeof window < "u";
isClient && (!((_window = window) === null || _window === void 0 || (_window$navigator = _window.navigator) === null ||
    _window$navigator === void 0) && _window$navigator.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
var defaultWindow = isClient ? window : void 0,
    _excluded$L = ["window"];

function useResizeObserver(K, C) {
    var H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
        W = H.window,
        U = W === void 0 ? defaultWindow : W,
        G = _objectWithoutProperties$2(H, _excluded$L),
        X, Z = useSupported(function () {
            return U && "ResizeObserver" in U
        }),
        Q = function () {
            X && (X.disconnect(), X = void 0)
        },
        ee = watch(function () {
            return unrefElement(K)
        }, function (te) {
            Q(), Z.value && U && te && (X = new ResizeObserver(C), X.observe(te, G))
        }, {
            immediate: !0,
            flush: "post"
        }),
        ne = function () {
            Q(), ee()
        };
    return tryOnScopeDispose(ne), {
        isSupported: Z,
        stop: ne
    }
}

function useElementSize(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            width: 0,
            height: 0
        },
        H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
        W = H.box,
        U = W === void 0 ? "content-box" : W,
        G = ref(C.width),
        X = ref(C.height);
    return useResizeObserver(K, function (Z) {
        var Q = _slicedToArray$2(Z, 1),
            ee = Q[0],
            ne = U === "border-box" ? ee.borderBoxSize : U === "content-box" ? ee.contentBoxSize : ee.devicePixelContentBoxSize;
        ne ? (G.value = ne.reduce(function (te, re) {
            var ae = re.inlineSize;
            return te + ae
        }, 0), X.value = ne.reduce(function (te, re) {
            var ae = re.blockSize;
            return te + ae
        }, 0)) : (G.value = ee.contentRect.width, X.value = ee.contentRect.height)
    }, H), watch(function () {
        return unrefElement(K)
    }, function (Z) {
        G.value = Z ? C.width : 0, X.value = Z ? C.height : 0
    }), {
        width: G,
        height: X
    }
}

function reorderValues(K, C) {
    return K && K[0] && K[1] && C.isAfter(K[0], K[1]) ? [K[1], K[0]] : K
}

function canValueTrigger(K, C, H, W) {
    return !!(K || W && W[C] || H[(C + 1) % 2])
}

function RangerPicker() {
    return defineComponent({
        name: "RangerPicker",
        inheritAttrs: !1,
        props: ["prefixCls", "id", "popupStyle", "dropdownClassName", "transitionName", "dropdownAlign",
            "getPopupContainer", "generateConfig", "locale", "placeholder", "autofocus", "disabled",
            "format", "picker", "showTime", "showNow", "showHour", "showMinute", "showSecond", "use12Hours",
            "separator", "value", "defaultValue", "defaultPickerValue", "open", "defaultOpen",
            "disabledDate", "disabledTime", "dateRender", "panelRender", "ranges", "allowEmpty",
            "allowClear", "suffixIcon", "clearIcon", "pickerRef", "inputReadOnly", "mode",
            "renderExtraFooter", "onChange", "onOpenChange", "onPanelChange", "onCalendarChange", "onFocus",
            "onBlur", "onMousedown", "onMouseup", "onMouseenter", "onMouseleave", "onClick", "onOk",
            "onKeydown", "components", "order", "direction", "activePickerIndex", "autocomplete",
            "minuteStep", "hourStep", "secondStep", "hideDisabledOptions", "disabledMinutes"],
        setup: function (C, H) {
            var W = H.attrs,
                U = H.expose,
                G = computed(function () {
                    return C.picker === "date" && !!C.showTime || C.picker === "time"
                }),
                X = useProviderTrigger(),
                Z = ref({}),
                Q = ref(null),
                ee = ref(null),
                ne = ref(null),
                te = ref(null),
                re = ref(null),
                ae = ref(null),
                oe = ref(null),
                ie = ref(null),
                ue = computed(function () {
                    return toArray$7(getDefaultFormat(C.format, C.picker, C.showTime, C.use12Hours))
                }),
                le = useMergedState(0, {
                    value: toRef(C, "activePickerIndex")
                }),
                se = _slicedToArray$2(le, 2),
                ce = se[0],
                de = se[1],
                ve = ref(null),
                fe = computed(function () {
                    var Tt = C.disabled;
                    return Array.isArray(Tt) ? Tt : [Tt || !1, Tt || !1]
                }),
                pe = useMergedState(null, {
                    value: toRef(C, "value"),
                    defaultValue: C.defaultValue,
                    postState: function (bt) {
                        return C.picker === "time" && !C.order ? bt : reorderValues(bt, C.generateConfig)
                    }
                }),
                me = _slicedToArray$2(pe, 2),
                he = me[0],
                Se = me[1],
                _e = useRangeViewDates({
                    values: he,
                    picker: toRef(C, "picker"),
                    defaultDates: C.defaultPickerValue,
                    generateConfig: toRef(C, "generateConfig")
                }),
                be = _slicedToArray$2(_e, 3),
                ge = be[0],
                xe = be[1],
                Pe = be[2],
                $e = useMergedState(he.value, {
                    postState: function (bt) {
                        var $t = bt;
                        if (fe.value[0] && fe.value[1]) return $t;
                        for (var Pt = 0; Pt < 2; Pt += 1) fe[Pt] && !getValue$2($t, Pt) && !
                            getValue$2(C.allowEmpty, Pt) && ($t = updateValues($t, C.generateConfig
                                .getNow(), Pt));
                        return $t
                    }
                }),
                ye = _slicedToArray$2($e, 2),
                Ce = ye[0],
                we = ye[1],
                Oe = useMergedState([C.picker, C.picker], {
                    value: toRef(C, "mode")
                }),
                Ne = _slicedToArray$2(Oe, 2),
                Me = Ne[0],
                Ve = Ne[1];
            watch(function () {
                return C.picker
            }, function () {
                Ve([C.picker, C.picker])
            });
            var ke = function (bt, $t) {
                    var Pt;
                    Ve(bt), (Pt = C.onPanelChange) === null || Pt === void 0 || Pt.call(C, $t, bt)
                },
                Ee = useRangeDisabled({
                    picker: toRef(C, "picker"),
                    selectedValue: Ce,
                    locale: toRef(C, "locale"),
                    disabled: fe,
                    disabledDate: toRef(C, "disabledDate"),
                    generateConfig: toRef(C, "generateConfig")
                }, Z),
                Ae = _slicedToArray$2(Ee, 2),
                Re = Ae[0],
                He = Ae[1],
                je = useMergedState(!1, {
                    value: toRef(C, "open"),
                    defaultValue: C.defaultOpen,
                    postState: function (bt) {
                        return fe.value[ce.value] ? !1 : bt
                    },
                    onChange: function (bt) {
                        var $t;
                        ($t = C.onOpenChange) === null || $t === void 0 || $t.call(C, bt), !bt &&
                            ve.value && ve.value.onClose && ve.value.onClose()
                    }
                }),
                Fe = _slicedToArray$2(je, 2),
                Le = Fe[0],
                Ie = Fe[1],
                Te = computed(function () {
                    return Le.value && ce.value === 0
                }),
                De = computed(function () {
                    return Le.value && ce.value === 1
                }),
                Ke = ref(0),
                We = ref(0),
                Ue = ref(0),
                et = useElementSize(Q),
                Ye = et.width;
            watch([Le, Ye], function () {
                !Le.value && Q.value && (Ue.value = Ye.value)
            });
            var ze = useElementSize(ee),
                Be = ze.width,
                Ge = useElementSize(ie),
                Xe = Ge.width,
                nt = useElementSize(ne),
                it = nt.width,
                ft = useElementSize(re),
                pt = ft.width;
            watch([ce, Le, Be, Xe, it, pt, function () {
                return C.direction
            }], function () {
                We.value = 0, Le.value && ce.value ? ne.value && re.value && ee.value && (We.value =
                    it.value + pt.value, Be.value && Xe.value && We.value > Be.value - Xe.value -
                    (C.direction === "rtl" || ie.value.offsetLeft > We.value ? 0 : ie.value.offsetLeft) &&
                    (Ke.value = We.value)) : ce.value === 0 && (Ke.value = 0)
            }, {
                immediate: !0
            });
            var ot = ref();

            function Ze(Tt, bt) {
                if (Tt) clearTimeout(ot.value), Z.value[bt] = !0, de(bt), Ie(Tt), Le.value || Pe(null, bt);
                else if (ce.value === bt) {
                    Ie(Tt);
                    var $t = Z.value;
                    ot.value = setTimeout(function () {
                        $t === Z.value && (Z.value = {})
                    })
                }
            }

            function ut(Tt) {
                Ze(!0, Tt), setTimeout(function () {
                    var bt = [ae, oe][Tt];
                    bt.value && bt.value.focus()
                }, 0)
            }

            function st(Tt, bt) {
                var $t = Tt,
                    Pt = getValue$2($t, 0),
                    Ot = getValue$2($t, 1),
                    Bt = C.generateConfig,
                    on = C.locale,
                    Jt = C.picker,
                    cn = C.order,
                    un = C.onCalendarChange,
                    sn = C.allowEmpty,
                    rn = C.onChange,
                    dn = C.showTime;
                Pt && Ot && Bt.isAfter(Pt, Ot) && (Jt === "week" && !isSameWeek(Bt, on.locale, Pt, Ot) ||
                    Jt === "quarter" && !isSameQuarter(Bt, Pt, Ot) || Jt !== "week" && Jt !== "quarter" &&
                    Jt !== "time" && !(dn ? isEqual(Bt, Pt, Ot) : isSameDate(Bt, Pt, Ot)) ? (bt === 0 ?
                        ($t = [Pt, null], Ot = null) : (Pt = null, $t = [null, Ot]), Z.value =
                        _defineProperty$V({}, bt, !0)) : (Jt !== "time" || cn !== !1) && ($t =
                        reorderValues($t, Bt))), we($t);
                var Qt = $t && $t[0] ? formatValue($t[0], {
                        generateConfig: Bt,
                        locale: on,
                        format: ue.value[0]
                    }) : "",
                    Xt = $t && $t[1] ? formatValue($t[1], {
                        generateConfig: Bt,
                        locale: on,
                        format: ue.value[0]
                    }) : "";
                if (un) {
                    var en = {
                        range: bt === 0 ? "start" : "end"
                    };
                    un($t, [Qt, Xt], en)
                }
                var Gt = canValueTrigger(Pt, 0, fe.value, sn),
                    mn = canValueTrigger(Ot, 1, fe.value, sn),
                    pn = $t === null || Gt && mn;
                pn && (Se($t), rn && (!isEqual(Bt, getValue$2(he.value, 0), Pt) || !isEqual(Bt, getValue$2(
                    he.value, 1), Ot)) && rn($t, [Qt, Xt]));
                var an = null;
                bt === 0 && !fe.value[1] ? an = 1 : bt === 1 && !fe.value[0] && (an = 0), an !== null && an !==
                    ce.value && (!Z.value[an] || !getValue$2($t, an)) && getValue$2($t, bt) ? ut(an) : Ze(!
                        1, bt)
            }
            var rt = function (bt) {
                    return Le && ve.value && ve.value.onKeydown ? ve.value.onKeydown(bt) : !1
                },
                qe = {
                    formatList: ue,
                    generateConfig: toRef(C, "generateConfig"),
                    locale: toRef(C, "locale")
                },
                Je = useValueTexts(computed(function () {
                    return getValue$2(Ce.value, 0)
                }), qe),
                Qe = _slicedToArray$2(Je, 2),
                lt = Qe[0],
                ct = Qe[1],
                dt = useValueTexts(computed(function () {
                    return getValue$2(Ce.value, 1)
                }), qe),
                tt = _slicedToArray$2(dt, 2),
                at = tt[0],
                vt = tt[1],
                gt = function (bt, $t) {
                    var Pt = parseValue(bt, {
                            locale: C.locale,
                            formatList: ue.value,
                            generateConfig: C.generateConfig
                        }),
                        Ot = $t === 0 ? Re : He;
                    Pt && !Ot(Pt) && (we(updateValues(Ce.value, Pt, $t)), Pe(Pt, $t))
                },
                mt = useTextValueMapping({
                    valueTexts: lt,
                    onTextChange: function (bt) {
                        return gt(bt, 0)
                    }
                }),
                ht = _slicedToArray$2(mt, 3),
                yt = ht[0],
                St = ht[1],
                Ct = ht[2],
                _t = useTextValueMapping({
                    valueTexts: at,
                    onTextChange: function (bt) {
                        return gt(bt, 1)
                    }
                }),
                wt = _slicedToArray$2(_t, 3),
                Et = wt[0],
                xt = wt[1],
                kt = wt[2],
                Nt = useState(null),
                Rt = _slicedToArray$2(Nt, 2),
                It = Rt[0],
                Lt = Rt[1],
                jt = useState(null),
                Mt = _slicedToArray$2(jt, 2),
                Vt = Mt[0],
                Dt = Mt[1],
                zt = useHoverValue(yt, qe),
                At = _slicedToArray$2(zt, 3),
                Wt = At[0],
                Yt = At[1],
                Zt = At[2],
                Kt = useHoverValue(Et, qe),
                Ht = _slicedToArray$2(Kt, 3),
                Ft = Ht[0],
                Ut = Ht[1],
                nn = Ht[2],
                Wn = function (bt) {
                    Dt(updateValues(Ce.value, bt, ce.value)), ce.value === 0 ? Yt(bt) : Ut(bt)
                },
                zn = function () {
                    Dt(updateValues(Ce.value, null, ce.value)), ce.value === 0 ? Zt() : nn()
                },
                $n = function (bt, $t) {
                    return {
                        forwardKeydown: rt,
                        onBlur: function (Ot) {
                            var Bt;
                            (Bt = C.onBlur) === null || Bt === void 0 || Bt.call(C, Ot)
                        },
                        isClickOutside: function (Ot) {
                            return !elementsContains([ee.value, ne.value, te.value, Q.value], Ot)
                        },
                        onFocus: function (Ot) {
                            var Bt;
                            de(bt), (Bt = C.onFocus) === null || Bt === void 0 || Bt.call(C, Ot)
                        },
                        triggerOpen: function (Ot) {
                            Ze(Ot, bt)
                        },
                        onSubmit: function () {
                            if (!Ce.value || C.disabledDate && C.disabledDate(Ce.value[bt])) return !1;
                            st(Ce.value, bt), $t()
                        },
                        onCancel: function () {
                            Ze(!1, bt), we(he.value), $t()
                        }
                    }
                },
                Un = usePickerInput(_objectSpread2$1(_objectSpread2$1({}, $n(0, Ct)), {}, {
                    blurToCancel: G,
                    open: Te,
                    value: yt,
                    onKeydown: function (bt, $t) {
                        var Pt;
                        (Pt = C.onKeydown) === null || Pt === void 0 || Pt.call(C, bt, $t)
                    }
                })),
                _n = _slicedToArray$2(Un, 2),
                Yn = _n[0],
                wn = _n[1],
                Pn = wn.focused,
                xn = wn.typing,
                Gn = usePickerInput(_objectSpread2$1(_objectSpread2$1({}, $n(1, kt)), {}, {
                    blurToCancel: G,
                    open: De,
                    value: Et,
                    onKeydown: function (bt, $t) {
                        var Pt;
                        (Pt = C.onKeydown) === null || Pt === void 0 || Pt.call(C, bt, $t)
                    }
                })),
                Tn = _slicedToArray$2(Gn, 2),
                qn = Tn[0],
                Nn = Tn[1],
                On = Nn.focused,
                kn = Nn.typing,
                Xn = function (bt) {
                    var $t;
                    ($t = C.onClick) === null || $t === void 0 || $t.call(C, bt), !Le.value && !ae.value.contains(
                        bt.target) && !oe.value.contains(bt.target) && (fe.value[0] ? fe.value[1] || ut(
                        1) : ut(0))
                },
                Zn = function (bt) {
                    var $t;
                    ($t = C.onMousedown) === null || $t === void 0 || $t.call(C, bt), Le.value && (Pn.value ||
                            On.value) && !ae.value.contains(bt.target) && !oe.value.contains(bt.target) &&
                        bt.preventDefault()
                },
                Jn = computed(function () {
                    var Tt;
                    return (Tt = he.value) !== null && Tt !== void 0 && Tt[0] ? formatValue(he.value[0], {
                        locale: C.locale,
                        format: "YYYYMMDDHHmmss",
                        generateConfig: C.generateConfig
                    }) : ""
                }),
                Qn = computed(function () {
                    var Tt;
                    return (Tt = he.value) !== null && Tt !== void 0 && Tt[1] ? formatValue(he.value[1], {
                        locale: C.locale,
                        format: "YYYYMMDDHHmmss",
                        generateConfig: C.generateConfig
                    }) : ""
                });
            watch([Le, lt, at], function () {
                Le.value || (we(he.value), !lt.value.length || lt.value[0] === "" ? St("") : ct.value !==
                    yt.value && Ct(), !at.value.length || at.value[0] === "" ? xt("") : vt.value !==
                    Et.value && kt())
            }), watch([Jn, Qn], function () {
                we(he.value)
            }), U({
                focus: function () {
                    ae.value && ae.value.focus()
                },
                blur: function () {
                    ae.value && ae.value.blur(), oe.value && oe.value.blur()
                }
            });
            var er = computed(function () {
                    return Object.keys(C.ranges || {}).map(function (Tt) {
                        var bt = C.ranges[Tt],
                            $t = typeof bt == "function" ? bt() : bt;
                        return {
                            label: Tt,
                            onClick: function () {
                                st($t, null), Ze(!1, ce.value)
                            },
                            onMouseenter: function () {
                                Lt($t)
                            },
                            onMouseleave: function () {
                                Lt(null)
                            }
                        }
                    })
                }),
                tr = computed(function () {
                    return Le.value && Vt.value && Vt.value[0] && Vt.value[1] && C.generateConfig.isAfter(
                        Vt.value[1], Vt.value[0]) ? Vt.value : null
                });

            function hn() {
                var Tt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1,
                    bt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                    $t = C.generateConfig,
                    Pt = C.showTime,
                    Ot = C.dateRender,
                    Bt = C.direction,
                    on = C.disabledTime,
                    Jt = C.prefixCls,
                    cn = C.locale,
                    un = Pt;
                if (Pt && _typeof$2(Pt) === "object" && Pt.defaultValue) {
                    var sn = Pt.defaultValue;
                    un = _objectSpread2$1(_objectSpread2$1({}, Pt), {}, {
                        defaultValue: getValue$2(sn, ce.value) || void 0
                    })
                }
                var rn = null;
                return Ot && (rn = function (Qt) {
                    var Xt = Qt.current,
                        en = Qt.today;
                    return Ot({
                        current: Xt,
                        today: en,
                        info: {
                            range: ce.value ? "end" : "start"
                        }
                    })
                }), createVNode(RangeContextProvider, {
                    value: {
                        inRange: !0,
                        panelPosition: Tt,
                        rangedValue: It.value || Ce.value,
                        hoverRangedValue: tr.value
                    }
                }, {
                    default: function () {
                        return [createVNode(PickerPanel$1, _objectSpread2$1(_objectSpread2$1(
                            _objectSpread2$1({}, C), bt), {}, {
                            dateRender: rn,
                            showTime: un,
                            mode: Me.value[ce.value],
                            generateConfig: $t,
                            style: void 0,
                            direction: Bt,
                            disabledDate: ce.value === 0 ? Re : He,
                            disabledTime: function (Xt) {
                                return on ? on(Xt, ce.value === 0 ? "start" :
                                    "end") : !1
                            },
                            class: classNames(_defineProperty$V({}, "".concat(
                                    Jt, "-panel-focused"), ce.value ===
                                0 ? !xn.value : !kn.value)),
                            value: getValue$2(Ce.value, ce.value),
                            locale: cn,
                            tabIndex: -1,
                            onPanelChange: function (Xt, en) {
                                ce.value === 0 && Zt(!0), ce.value === 1 &&
                                    nn(!0), ke(updateValues(Me.value, en,
                                        ce.value), updateValues(Ce.value,
                                        Xt, ce.value));
                                var Gt = Xt;
                                Tt === "right" && Me.value[ce.value] === en &&
                                    (Gt = getClosingViewDate(Gt, en, $t, -1)),
                                    Pe(Gt, ce.value)
                            },
                            onOk: null,
                            onSelect: void 0,
                            onChange: void 0,
                            defaultValue: ce.value === 0 ? getValue$2(Ce.value,
                                1) : getValue$2(Ce.value, 0)
                        }), null)]
                    }
                })
            }
            var nr = function (bt, $t) {
                var Pt = updateValues(Ce.value, bt, ce.value);
                $t === "submit" || $t !== "key" && !G.value ? (st(Pt, ce.value), ce.value === 0 ? Zt() :
                    nn()) : we(Pt)
            };
            return useProvidePanel({
                    operationRef: ve,
                    hideHeader: computed(function () {
                        return C.picker === "time"
                    }),
                    onDateMouseenter: Wn,
                    onDateMouseleave: zn,
                    hideRanges: computed(function () {
                        return !0
                    }),
                    onSelect: nr,
                    open: Le
                }),
                function () {
                    var Tt, bt, $t, Pt = C.prefixCls,
                        Ot = Pt === void 0 ? "rc-picker" : Pt,
                        Bt = C.id,
                        on = C.popupStyle,
                        Jt = C.dropdownClassName,
                        cn = C.transitionName,
                        un = C.dropdownAlign,
                        sn = C.getPopupContainer,
                        rn = C.generateConfig,
                        dn = C.locale,
                        Qt = C.placeholder,
                        Xt = C.autofocus,
                        en = C.picker,
                        Gt = en === void 0 ? "date" : en,
                        mn = C.showTime,
                        pn = C.separator,
                        an = pn === void 0 ? "~" : pn,
                        En = C.disabledDate,
                        In = C.panelRender,
                        rr = C.allowClear,
                        Mn = C.suffixIcon,
                        ar = C.clearIcon,
                        Vn = C.inputReadOnly,
                        or = C.renderExtraFooter,
                        ir = C.onMouseenter,
                        lr = C.onMouseleave,
                        ur = C.onMouseup,
                        An = C.onOk,
                        sr = C.components,
                        fn = C.direction,
                        Rn = C.autocomplete,
                        Dn = Rn === void 0 ? "off" : Rn,
                        cr = fn === "rtl" ? {
                            right: "".concat(We.value, "px")
                        } : {
                            left: "".concat(We.value, "px")
                        };

                    function dr() {
                        var ln, tn = getExtraFooter(Ot, Me.value[ce.value], or),
                            qt = getRanges({
                                prefixCls: Ot,
                                components: sr,
                                needConfirmButton: G.value,
                                okDisabled: !getValue$2(Ce.value, ce.value) || En && En(Ce.value[ce.value]),
                                locale: dn,
                                rangeList: er.value,
                                onOk: function () {
                                    getValue$2(Ce.value, ce.value) && (st(Ce.value, ce.value), An &&
                                        An(Ce.value))
                                }
                            });
                        if (Gt !== "time" && !mn) {
                            var Bn = ce.value === 0 ? ge.value : xe.value,
                                pr = getClosingViewDate(Bn, Gt, rn),
                                hr = Me.value[ce.value],
                                bn = hr === Gt,
                                Kn = hn(bn ? "left" : !1, {
                                    pickerValue: Bn,
                                    onPickerValueChange: function (vn) {
                                        Pe(vn, ce.value)
                                    }
                                }),
                                Hn = hn("right", {
                                    pickerValue: pr,
                                    onPickerValueChange: function (vn) {
                                        Pe(getClosingViewDate(vn, Gt, rn, -1), ce.value)
                                    }
                                });
                            fn === "rtl" ? ln = createVNode(Fragment, null, [Hn, bn && Kn]) : ln =
                                createVNode(Fragment, null, [Kn, bn && Hn])
                        } else ln = hn();
                        var Cn = createVNode(Fragment, null, [createVNode("div", {
                            class: "".concat(Ot, "-panels")
                        }, [ln]), (tn || qt) && createVNode("div", {
                            class: "".concat(Ot, "-footer")
                        }, [tn, qt])]);
                        return In && (Cn = In(Cn)), createVNode("div", {
                            class: "".concat(Ot, "-panel-container"),
                            style: {
                                marginLeft: "".concat(Ke.value, "px")
                            },
                            ref: ee,
                            onMousedown: function (vn) {
                                vn.preventDefault()
                            }
                        }, [Cn])
                    }
                    var fr = createVNode("div", {
                            class: classNames("".concat(Ot, "-range-wrapper"), "".concat(Ot, "-").concat(
                                Gt, "-range-wrapper")),
                            style: {
                                minWidth: "".concat(Ue.value, "px")
                            }
                        }, [createVNode("div", {
                            ref: ie,
                            class: "".concat(Ot, "-range-arrow"),
                            style: cr
                        }, null), dr()]),
                        jn;
                    Mn && (jn = createVNode("span", {
                        class: "".concat(Ot, "-suffix")
                    }, [Mn]));
                    var Fn;
                    rr && (getValue$2(he.value, 0) && !fe.value[0] || getValue$2(he.value, 1) && !fe.value[
                        1]) && (Fn = createVNode("span", {
                        onMousedown: function (tn) {
                            tn.preventDefault(), tn.stopPropagation()
                        },
                        onMouseup: function (tn) {
                            tn.preventDefault(), tn.stopPropagation();
                            var qt = he.value;
                            fe.value[0] || (qt = updateValues(qt, null, 0)), fe.value[1] ||
                                (qt = updateValues(qt, null, 1)), st(qt, null), Ze(!1, ce.value)
                        },
                        class: "".concat(Ot, "-clear")
                    }, [ar || createVNode("span", {
                        class: "".concat(Ot, "-clear-btn")
                    }, null)]));
                    var Ln = {
                            size: getInputSize(Gt, ue.value[0], rn)
                        },
                        gn = 0,
                        yn = 0;
                    ne.value && te.value && re.value && (ce.value === 0 ? yn = ne.value.offsetWidth : (gn =
                        We.value, yn = te.value.offsetWidth));
                    var vr = fn === "rtl" ? {
                        right: "".concat(gn, "px")
                    } : {
                        left: "".concat(gn, "px")
                    };
                    return createVNode(PickerTrigger, {
                        visible: Le.value,
                        popupStyle: on,
                        prefixCls: Ot,
                        dropdownClassName: Jt,
                        dropdownAlign: un,
                        getPopupContainer: sn,
                        transitionName: cn,
                        range: !0,
                        direction: fn
                    }, {
                        default: function () {
                            return [createVNode("div", _objectSpread2$1({
                                ref: Q,
                                class: classNames(Ot, "".concat(Ot, "-range"),
                                    W.class, (Tt = {}, _defineProperty$V(Tt,
                                            "".concat(Ot, "-disabled"), fe.value[
                                                0] && fe.value[1]),
                                        _defineProperty$V(Tt, "".concat(Ot,
                                                "-focused"), ce.value ===
                                            0 ? Pn.value : On.value),
                                        _defineProperty$V(Tt, "".concat(Ot,
                                            "-rtl"), fn === "rtl"), Tt)),
                                style: W.style,
                                onClick: Xn,
                                onMouseenter: ir,
                                onMouseleave: lr,
                                onMousedown: Zn,
                                onMouseup: ur
                            }, getDataOrAriaProps(C)), [createVNode("div", {
                                class: classNames("".concat(Ot, "-input"),
                                    (bt = {}, _defineProperty$V(bt, "".concat(
                                                Ot, "-input-active"),
                                            ce.value === 0),
                                        _defineProperty$V(bt, "".concat(
                                                Ot,
                                                "-input-placeholder"),
                                            !!Wt.value), bt)),
                                ref: ne
                            }, [createVNode("input", _objectSpread2$1(
                                _objectSpread2$1(_objectSpread2$1({
                                    id: Bt,
                                    disabled: fe.value[0],
                                    readonly: Vn || typeof ue
                                        .value[0] ==
                                        "function" || !xn.value,
                                    value: Wt.value || yt.value,
                                    onInput: function (qt) {
                                        St(qt.target.value)
                                    },
                                    autofocus: Xt,
                                    placeholder: getValue$2(
                                        Qt, 0) || "",
                                    ref: ae
                                }, Yn.value), Ln), {}, {
                                    autocomplete: Dn
                                }), null)]), createVNode("div", {
                                class: "".concat(Ot, "-range-separator"),
                                ref: re
                            }, [an]), createVNode("div", {
                                class: classNames("".concat(Ot, "-input"),
                                    ($t = {}, _defineProperty$V($t, "".concat(
                                                Ot, "-input-active"),
                                            ce.value === 1),
                                        _defineProperty$V($t, "".concat(
                                                Ot,
                                                "-input-placeholder"),
                                            !!Ft.value), $t)),
                                ref: te
                            }, [createVNode("input", _objectSpread2$1(
                                _objectSpread2$1(_objectSpread2$1({
                                    disabled: fe.value[1],
                                    readonly: Vn || typeof ue
                                        .value[0] ==
                                        "function" || !kn.value,
                                    value: Ft.value || Et.value,
                                    onInput: function (qt) {
                                        xt(qt.target.value)
                                    },
                                    placeholder: getValue$2(
                                        Qt, 1) || "",
                                    ref: oe
                                }, qn.value), Ln), {}, {
                                    autocomplete: Dn
                                }), null)]), createVNode("div", {
                                class: "".concat(Ot, "-active-bar"),
                                style: _objectSpread2$1(_objectSpread2$1({},
                                    vr), {}, {
                                    width: "".concat(yn, "px"),
                                    position: "absolute"
                                })
                            }, null), jn, Fn, X()])]
                        },
                        popupElement: function () {
                            return fr
                        }
                    })
                }
        }
    })
}
var InterRangerPicker = RangerPicker();
const VCRangePicker = InterRangerPicker;
var _excluded$K = ["prefixCls", "name", "id", "type", "disabled", "readonly", "tabindex", "autofocus", "value",
        "required"],
    checkboxProps$1 = {
        prefixCls: String,
        name: String,
        id: String,
        type: String,
        defaultChecked: {
            type: [Boolean, Number],
            default: void 0
        },
        checked: {
            type: [Boolean, Number],
            default: void 0
        },
        disabled: Boolean,
        tabindex: {
            type: [Number, String]
        },
        readonly: Boolean,
        autofocus: Boolean,
        value: PropTypes$1.any,
        required: Boolean
    };
const VcCheckbox = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Checkbox",
    inheritAttrs: !1,
    props: initDefaultProps$1(checkboxProps$1, {
        prefixCls: "rc-checkbox",
        type: "checkbox",
        defaultChecked: !1
    }),
    emits: ["click", "change"],
    setup: function (C, H) {
        var W = H.attrs,
            U = H.emit,
            G = H.expose,
            X = ref(C.checked === void 0 ? C.defaultChecked : C.checked),
            Z = ref();
        watch(function () {
            return C.checked
        }, function () {
            X.value = C.checked
        }), G({
            focus: function () {
                var re;
                (re = Z.value) === null || re === void 0 || re.focus()
            },
            blur: function () {
                var re;
                (re = Z.value) === null || re === void 0 || re.blur()
            }
        });
        var Q = ref(),
            ee = function (re) {
                if (!C.disabled) {
                    C.checked === void 0 && (X.value = re.target.checked), re.shiftKey = Q.value;
                    var ae = {
                        target: _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                            checked: re.target.checked
                        }),
                        stopPropagation: function () {
                            re.stopPropagation()
                        },
                        preventDefault: function () {
                            re.preventDefault()
                        },
                        nativeEvent: re
                    };
                    C.checked !== void 0 && (Z.value.checked = !!C.checked), U("change", ae), Q.value = !1
                }
            },
            ne = function (re) {
                U("click", re), Q.value = re.shiftKey
            };
        return function () {
            var te, re = C.prefixCls,
                ae = C.name,
                oe = C.id,
                ie = C.type,
                ue = C.disabled,
                le = C.readonly,
                se = C.tabindex,
                ce = C.autofocus,
                de = C.value,
                ve = C.required,
                fe = _objectWithoutProperties$2(C, _excluded$K),
                pe = W.class,
                me = W.onFocus,
                he = W.onBlur,
                Se = W.onKeydown,
                _e = W.onKeypress,
                be = W.onKeyup,
                ge = _objectSpread2$1(_objectSpread2$1({}, fe), W),
                xe = Object.keys(ge).reduce(function (ye, Ce) {
                    return (Ce.substr(0, 5) === "aria-" || Ce.substr(0, 5) === "data-" || Ce ===
                        "role") && (ye[Ce] = ge[Ce]), ye
                }, {}),
                Pe = classNames(re, pe, (te = {}, _defineProperty$V(te, "".concat(re, "-checked"), X.value),
                    _defineProperty$V(te, "".concat(re, "-disabled"), ue), te)),
                $e = _objectSpread2$1(_objectSpread2$1({
                    name: ae,
                    id: oe,
                    type: ie,
                    readonly: le,
                    disabled: ue,
                    tabindex: se,
                    class: "".concat(re, "-input"),
                    checked: !!X.value,
                    autofocus: ce,
                    value: de
                }, xe), {}, {
                    onChange: ee,
                    onClick: ne,
                    onFocus: me,
                    onBlur: he,
                    onKeydown: Se,
                    onKeypress: _e,
                    onKeyup: be,
                    required: ve
                });
            return createVNode("span", {
                class: Pe
            }, [createVNode("input", _objectSpread2$1({
                ref: Z
            }, $e), null), createVNode("span", {
                class: "".concat(re, "-inner")
            }, null)])
        }
    }
});
var _excluded$J = ["prefixCls", "id"],
    radioProps = function () {
        return {
            prefixCls: String,
            checked: {
                type: Boolean,
                default: void 0
            },
            disabled: {
                type: Boolean,
                default: void 0
            },
            isGroup: {
                type: Boolean,
                default: void 0
            },
            value: PropTypes$1.any,
            name: String,
            id: String,
            autofocus: {
                type: Boolean,
                default: void 0
            },
            onChange: Function,
            onFocus: Function,
            onBlur: Function,
            onClick: Function,
            "onUpdate:checked": Function,
            "onUpdate:value": Function
        }
    };
const Radio = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ARadio",
    props: radioProps(),
    setup: function (C, H) {
        var W = H.emit,
            U = H.expose,
            G = H.slots,
            X = useInjectFormItemContext(),
            Z = ref(),
            Q = inject("radioGroupContext", void 0),
            ee = useConfigInject("radio", C),
            ne = ee.prefixCls,
            te = ee.direction,
            re = function () {
                Z.value.focus()
            },
            ae = function () {
                Z.value.blur()
            };
        U({
            focus: re,
            blur: ae
        });
        var oe = function (le) {
                var se = le.target.checked;
                W("update:checked", se), W("update:value", se), W("change", le), X.onFieldChange()
            },
            ie = function (le) {
                W("change", le), Q && Q.onRadioChange && Q.onRadioChange(le)
            };
        return function () {
            var ue, le = Q;
            C.prefixCls;
            var se = C.id,
                ce = se === void 0 ? X.id.value : se,
                de = _objectWithoutProperties$2(C, _excluded$J),
                ve = _objectSpread2$1({
                    prefixCls: ne.value,
                    id: ce
                }, omit$2(de, ["onUpdate:checked", "onUpdate:value"]));
            le ? (ve.name = le.props.name, ve.onChange = ie, ve.checked = C.value === le.stateValue.value,
                ve.disabled = C.disabled || le.props.disabled) : ve.onChange = oe;
            var fe = classNames((ue = {}, _defineProperty$V(ue, "".concat(ne.value, "-wrapper"), !0),
                _defineProperty$V(ue, "".concat(ne.value, "-wrapper-checked"), ve.checked),
                _defineProperty$V(ue, "".concat(ne.value, "-wrapper-disabled"), ve.disabled),
                _defineProperty$V(ue, "".concat(ne.value, "-wrapper-rtl"), te.value === "rtl"),
                ue));
            return createVNode("label", {
                class: fe
            }, [createVNode(VcCheckbox, _objectSpread2$1(_objectSpread2$1({}, ve), {}, {
                type: "radio",
                ref: Z
            }), null), G.default && createVNode("span", null, [G.default()])])
        }
    }
});
var RadioGroupSizeTypes = tuple$1("large", "default", "small"),
    radioGroupProps = function () {
        return {
            prefixCls: String,
            value: PropTypes$1.any,
            size: PropTypes$1.oneOf(RadioGroupSizeTypes),
            options: {
                type: Array
            },
            disabled: {
                type: Boolean,
                default: void 0
            },
            name: String,
            buttonStyle: {
                type: String,
                default: "outline"
            },
            id: String,
            optionType: {
                type: String,
                default: "default"
            },
            onChange: Function,
            "onUpdate:value": Function
        }
    };
const Group$2 = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ARadioGroup",
        props: radioGroupProps(),
        setup: function (C, H) {
            var W = H.slots,
                U = H.emit,
                G = useInjectFormItemContext(),
                X = useConfigInject("radio", C),
                Z = X.prefixCls,
                Q = X.direction,
                ee = X.size,
                ne = ref(C.value),
                te = ref(!1);
            watch(function () {
                return C.value
            }, function (ae) {
                ne.value = ae, te.value = !1
            });
            var re = function (oe) {
                var ie = ne.value,
                    ue = oe.target.value;
                "value" in C || (ne.value = ue), !te.value && ue !== ie && (te.value = !0, U("update:value",
                    ue), U("change", oe), G.onFieldChange()), nextTick(function () {
                    te.value = !1
                })
            };
            return provide("radioGroupContext", {
                    onRadioChange: re,
                    stateValue: ne,
                    props: C
                }),
                function () {
                    var ae, oe = C.options,
                        ie = C.optionType,
                        ue = C.buttonStyle,
                        le = C.id,
                        se = le === void 0 ? G.id.value : le,
                        ce = "".concat(Z.value, "-group"),
                        de = classNames(ce, "".concat(ce, "-").concat(ue), (ae = {}, _defineProperty$V(ae, "".concat(
                            ce, "-").concat(ee.value), ee.value), _defineProperty$V(ae, "".concat(ce,
                            "-rtl"), Q.value === "rtl"), ae)),
                        ve = null;
                    if (oe && oe.length > 0) {
                        var fe = ie === "button" ? "".concat(Z.value, "-button") : Z.value;
                        ve = oe.map(function (me) {
                            if (typeof me == "string" || typeof me == "number") return createVNode(
                                Radio, {
                                    key: me,
                                    prefixCls: fe,
                                    disabled: C.disabled,
                                    value: me,
                                    checked: ne.value === me
                                }, {
                                    default: function () {
                                        return [me]
                                    }
                                });
                            var he = me.value,
                                Se = me.disabled,
                                _e = me.label;
                            return createVNode(Radio, {
                                key: "radio-group-value-options-".concat(he),
                                prefixCls: fe,
                                disabled: Se || C.disabled,
                                value: he,
                                checked: ne.value === he
                            }, {
                                default: function () {
                                    return [_e]
                                }
                            })
                        })
                    } else {
                        var pe;
                        ve = (pe = W.default) === null || pe === void 0 ? void 0 : pe.call(W)
                    }
                    return createVNode("div", {
                        class: de,
                        id: se
                    }, [ve])
                }
        }
    }),
    Button = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ARadioButton",
        props: radioProps(),
        setup: function (C, H) {
            var W = H.slots,
                U = useConfigInject("radio-button", C),
                G = U.prefixCls,
                X = inject("radioGroupContext", void 0);
            return function () {
                var Z, Q = _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                    prefixCls: G.value
                });
                return X && (Q.onChange = X.onRadioChange, Q.checked = Q.value === X.stateValue.value, Q.disabled =
                    Q.disabled || X.props.disabled), createVNode(Radio, Q, {
                    default: function () {
                        return [(Z = W.default) === null || Z === void 0 ? void 0 : Z.call(W)]
                    }
                })
            }
        }
    });
Radio.Group = Group$2;
Radio.Button = Button;
Radio.install = function (K) {
    return K.component(Radio.name, Radio), K.component(Radio.Group.name, Radio.Group), K.component(Radio.Button.name,
        Radio.Button), K
};
var YearSelectOffset = 10,
    YearSelectTotal = 20;

function YearSelect(K) {
    var C = K.fullscreen,
        H = K.validRange,
        W = K.generateConfig,
        U = K.locale,
        G = K.prefixCls,
        X = K.value,
        Z = K.onChange,
        Q = K.divRef,
        ee = W.getYear(X || W.getNow()),
        ne = ee - YearSelectOffset,
        te = ne + YearSelectTotal;
    H && (ne = W.getYear(H[0]), te = W.getYear(H[1]) + 1);
    for (var re = U && U.year === "" ? "" : "", ae = [], oe = ne; oe < te; oe++) ae.push({
        label: "".concat(oe).concat(re),
        value: oe
    });
    return createVNode(VcSelect, {
        size: C ? void 0 : "small",
        options: ae,
        value: ee,
        class: "".concat(G, "-year-select"),
        onChange: function (ue) {
            var le = W.setYear(X, ue);
            if (H) {
                var se = _slicedToArray$2(H, 2),
                    ce = se[0],
                    de = se[1],
                    ve = W.getYear(le),
                    fe = W.getMonth(le);
                ve === W.getYear(de) && fe > W.getMonth(de) && (le = W.setMonth(le, W.getMonth(de))), ve ===
                    W.getYear(ce) && fe < W.getMonth(ce) && (le = W.setMonth(le, W.getMonth(ce)))
            }
            Z(le)
        },
        getPopupContainer: function () {
            return Q.value
        }
    }, null)
}
YearSelect.inheritAttrs = !1;

function MonthSelect(K) {
    var C = K.prefixCls,
        H = K.fullscreen,
        W = K.validRange,
        U = K.value,
        G = K.generateConfig,
        X = K.locale,
        Z = K.onChange,
        Q = K.divRef,
        ee = G.getMonth(U || G.getNow()),
        ne = 0,
        te = 11;
    if (W) {
        var re = _slicedToArray$2(W, 2),
            ae = re[0],
            oe = re[1],
            ie = G.getYear(U);
        G.getYear(oe) === ie && (te = G.getMonth(oe)), G.getYear(ae) === ie && (ne = G.getMonth(ae))
    }
    for (var ue = X.shortMonths || G.locale.getShortMonths(X.locale), le = [], se = ne; se <= te; se += 1) le.push({
        label: ue[se],
        value: se
    });
    return createVNode(VcSelect, {
        size: H ? void 0 : "small",
        class: "".concat(C, "-month-select"),
        value: ee,
        options: le,
        onChange: function (de) {
            Z(G.setMonth(U, de))
        },
        getPopupContainer: function () {
            return Q.value
        }
    }, null)
}
MonthSelect.inheritAttrs = !1;

function ModeSwitch(K) {
    var C = K.prefixCls,
        H = K.locale,
        W = K.mode,
        U = K.fullscreen,
        G = K.onModeChange;
    return createVNode(Group$2, {
        onChange: function (Z) {
            var Q = Z.target.value;
            G(Q)
        },
        value: W,
        size: U ? void 0 : "small",
        class: "".concat(C, "-mode-switch")
    }, {
        default: function () {
            return [createVNode(Button, {
                value: "month"
            }, {
                default: function () {
                    return [H.month]
                }
            }), createVNode(Button, {
                value: "year"
            }, {
                default: function () {
                    return [H.year]
                }
            })]
        }
    })
}
ModeSwitch.inheritAttrs = !1;
const CalendarHeader = defineComponent({
    name: "CalendarHeader",
    inheritAttrs: !1,
    props: ["mode", "prefixCls", "value", "validRange", "generateConfig", "locale", "mode", "fullscreen"],
    setup: function (C, H) {
        var W = H.attrs,
            U = ref(null);
        return function () {
            var G = _objectSpread2$1(_objectSpread2$1({}, C), W),
                X = G.prefixCls,
                Z = G.fullscreen,
                Q = G.mode,
                ee = G.onChange,
                ne = G.onModeChange,
                te = _objectSpread2$1(_objectSpread2$1({}, G), {}, {
                    onChange: ee,
                    fullscreen: Z,
                    divRef: U
                });
            return createVNode("div", {
                class: "".concat(X, "-header"),
                ref: U
            }, [createVNode(YearSelect, te, null), Q === "month" && createVNode(MonthSelect, te,
                null), createVNode(ModeSwitch, _objectSpread2$1(_objectSpread2$1({}, te), {}, {
                onModeChange: ne
            }), null)])
        }
    }
});

function generateCalendar(K) {
    function C(G, X) {
        return G && X && K.getYear(G) === K.getYear(X)
    }

    function H(G, X) {
        return C(G, X) && K.getMonth(G) === K.getMonth(X)
    }

    function W(G, X) {
        return H(G, X) && K.getDate(G) === K.getDate(X)
    }
    var U = defineComponent({
        name: "ACalendar",
        inheritAttrs: !1,
        props: ["prefixCls", "locale", "validRange", "disabledDate", "dateFullCellRender", "dateCellRender",
            "monthFullCellRender", "monthCellRender", "headerRender", "value", "defaultValue", "mode",
            "fullscreen", "onChange", "onPanelChange", "onSelect", "valueFormat"],
        slots: ["dateFullCellRender", "dateCellRender", "monthFullCellRender", "monthCellRender",
            "headerRender"],
        setup: function (X, Z) {
            var Q = Z.emit,
                ee = Z.slots,
                ne = Z.attrs,
                te = useConfigInject("picker", X),
                re = te.prefixCls,
                ae = te.direction,
                oe = computed(function () {
                    return "".concat(re.value, "-calendar")
                }),
                ie = function (Ne) {
                    return X.valueFormat ? K.toString(Ne, X.valueFormat) : Ne
                },
                ue = computed(function () {
                    return X.value ? X.valueFormat ? K.toDate(X.value, X.valueFormat) : X.value : X.value ===
                        "" ? void 0 : X.value
                }),
                le = computed(function () {
                    return X.defaultValue ? X.valueFormat ? K.toDate(X.defaultValue, X.valueFormat) : X
                        .defaultValue : X.defaultValue === "" ? void 0 : X.defaultValue
                }),
                se = useMergedState(function () {
                    return ue.value || K.getNow()
                }, {
                    defaultValue: le.value,
                    value: ue
                }),
                ce = _slicedToArray$2(se, 2),
                de = ce[0],
                ve = ce[1],
                fe = useMergedState("month", {
                    value: toRef(X, "mode")
                }),
                pe = _slicedToArray$2(fe, 2),
                me = pe[0],
                he = pe[1],
                Se = computed(function () {
                    return me.value === "year" ? "month" : "date"
                }),
                _e = computed(function () {
                    return function (Oe) {
                        var Ne, Me = X.validRange ? K.isAfter(X.validRange[0], Oe) || K.isAfter(Oe,
                            X.validRange[1]) : !1;
                        return Me || !!((Ne = X.disabledDate) !== null && Ne !== void 0 && Ne.call(
                            X, Oe))
                    }
                }),
                be = function (Ne, Me) {
                    Q("panelChange", ie(Ne), Me)
                },
                ge = function (Ne) {
                    if (ve(Ne), !W(Ne, de.value)) {
                        (Se.value === "date" && !H(Ne, de.value) || Se.value === "month" && !C(Ne, de.value)) &&
                        be(Ne, me.value);
                        var Me = ie(Ne);
                        Q("update:value", Me), Q("change", Me)
                    }
                },
                xe = function (Ne) {
                    he(Ne), be(de.value, Ne)
                },
                Pe = function (Ne) {
                    ge(Ne), Q("select", ie(Ne))
                },
                $e = computed(function () {
                    var Oe = X.locale,
                        Ne = _objectSpread2$1(_objectSpread2$1({}, enUS), Oe);
                    return Ne.lang = _objectSpread2$1(_objectSpread2$1({}, Ne.lang), (Oe || {}).lang),
                        Ne
                }),
                ye = useLocaleReceiver("Calendar", $e),
                Ce = _slicedToArray$2(ye, 1),
                we = Ce[0];
            return function () {
                var Oe, Ne = K.getNow(),
                    Me = X.dateFullCellRender,
                    Ve = Me === void 0 ? ee == null ? void 0 : ee.dateFullCellRender : Me,
                    ke = X.dateCellRender,
                    Ee = ke === void 0 ? ee == null ? void 0 : ee.dateCellRender : ke,
                    Ae = X.monthFullCellRender,
                    Re = Ae === void 0 ? ee == null ? void 0 : ee.monthFullCellRender : Ae,
                    He = X.monthCellRender,
                    je = He === void 0 ? ee == null ? void 0 : ee.monthCellRender : He,
                    Fe = X.headerRender,
                    Le = Fe === void 0 ? ee == null ? void 0 : ee.headerRender : Fe,
                    Ie = X.fullscreen,
                    Te = Ie === void 0 ? !0 : Ie,
                    De = X.validRange,
                    Ke = function (et) {
                        var Ye = et.current;
                        return Ve ? Ve({
                            current: Ye
                        }) : createVNode("div", {
                            class: classNames("".concat(re.value, "-cell-inner"), "".concat(oe.value,
                                "-date"), _defineProperty$V({}, "".concat(oe.value,
                                "-date-today"), W(Ne, Ye)))
                        }, [createVNode("div", {
                            class: "".concat(oe.value, "-date-value")
                        }, [padStart(String(K.getDate(Ye)), 2, "0")]), createVNode("div", {
                            class: "".concat(oe.value, "-date-content")
                        }, [Ee && Ee({
                            current: Ye
                        })])])
                    },
                    We = function (et, Ye) {
                        var ze = et.current;
                        if (Re) return Re({
                            current: ze
                        });
                        var Be = Ye.shortMonths || K.locale.getShortMonths(Ye.locale);
                        return createVNode("div", {
                            class: classNames("".concat(re.value, "-cell-inner"), "".concat(oe.value,
                                "-date"), _defineProperty$V({}, "".concat(oe.value,
                                "-date-today"), H(Ne, ze)))
                        }, [createVNode("div", {
                            class: "".concat(oe.value, "-date-value")
                        }, [Be[K.getMonth(ze)]]), createVNode("div", {
                            class: "".concat(oe.value, "-date-content")
                        }, [je && je({
                            current: ze
                        })])])
                    };
                return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, ne), {}, {
                    class: classNames(oe.value, (Oe = {}, _defineProperty$V(Oe, "".concat(
                        oe.value, "-full"), Te), _defineProperty$V(Oe, "".concat(
                        oe.value, "-mini"), !Te), _defineProperty$V(Oe, "".concat(
                        oe.value, "-rtl"), ae.value === "rtl"), Oe), ne.class)
                }), [Le ? Le({
                    value: de.value,
                    type: me.value,
                    onChange: Pe,
                    onTypeChange: xe
                }) : createVNode(CalendarHeader, {
                    prefixCls: oe.value,
                    value: de.value,
                    generateConfig: K,
                    mode: me.value,
                    fullscreen: Te,
                    locale: we.value.lang,
                    validRange: De,
                    onChange: Pe,
                    onModeChange: xe
                }, null), createVNode(PickerPanel$1, {
                    value: de.value,
                    prefixCls: re.value,
                    locale: we.value.lang,
                    generateConfig: K,
                    dateRender: Ke,
                    monthCellRender: function (et) {
                        return We(et, we.value.lang)
                    },
                    onSelect: Pe,
                    mode: Se.value,
                    picker: Se.value,
                    disabledDate: _e.value,
                    hideHeader: !0
                }, null)])
            }
        }
    });
    return U.install = function (G) {
        return G.component(U.name, U), G
    }, U
}
var Calendar = generateCalendar(dayjsGenerateConfig);
const Calendar$1 = withInstall(Calendar);

function useRaf(K) {
    var C = ref(),
        H = ref(!1);

    function W() {
        for (var U = arguments.length, G = new Array(U), X = 0; X < U; X++) G[X] = arguments[X];
        H.value || (wrapperRaf.cancel(C.value), C.value = wrapperRaf(function () {
            K.apply(void 0, G)
        }))
    }
    return onBeforeUnmount(function () {
        H.value = !0, wrapperRaf.cancel(C.value)
    }), W
}

function useRafState(K) {
    var C = ref([]),
        H = ref(typeof K == "function" ? K() : K),
        W = useRaf(function () {
            var G = H.value;
            C.value.forEach(function (X) {
                G = X(G)
            }), C.value = [], H.value = G
        });

    function U(G) {
        C.value.push(G), W()
    }
    return [H, U]
}
const TabNode = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "TabNode",
    props: {
        id: {
            type: String
        },
        prefixCls: {
            type: String
        },
        tab: {
            type: Object
        },
        active: {
            type: Boolean
        },
        closable: {
            type: Boolean
        },
        editable: {
            type: Object
        },
        onClick: {
            type: Function
        },
        onResize: {
            type: Function
        },
        renderWrapper: {
            type: Function
        },
        removeAriaLabel: {
            type: String
        },
        onFocus: {
            type: Function
        }
    },
    emits: ["click", "resize", "remove", "focus"],
    setup: function (C, H) {
        var W = H.expose,
            U = H.attrs,
            G = ref();

        function X(ee) {
            var ne;
            (ne = C.tab) !== null && ne !== void 0 && ne.disabled || C.onClick(ee)
        }
        W({
            domRef: G
        });

        function Z(ee) {
            var ne;
            ee.preventDefault(), ee.stopPropagation(), C.editable.onEdit("remove", {
                key: (ne = C.tab) === null || ne === void 0 ? void 0 : ne.key,
                event: ee
            })
        }
        var Q = computed(function () {
            var ee;
            return C.editable && C.closable !== !1 && !((ee = C.tab) !== null && ee !== void 0 &&
                ee.disabled)
        });
        return function () {
            var ee, ne, te = C.prefixCls,
                re = C.id,
                ae = C.active,
                oe = C.tab,
                ie = oe.key,
                ue = oe.tab,
                le = oe.disabled,
                se = oe.closeIcon,
                ce = C.renderWrapper,
                de = C.removeAriaLabel,
                ve = C.editable,
                fe = C.onFocus,
                pe = "".concat(te, "-tab"),
                me = createVNode("div", {
                    key: ie,
                    ref: G,
                    class: classNames(pe, (ee = {}, _defineProperty$V(ee, "".concat(pe,
                        "-with-remove"), Q.value), _defineProperty$V(ee, "".concat(pe,
                        "-active"), ae), _defineProperty$V(ee, "".concat(pe,
                        "-disabled"), le), ee)),
                    style: U.style,
                    onClick: X
                }, [createVNode("div", {
                    role: "tab",
                    "aria-selected": ae,
                    id: re && "".concat(re, "-tab-").concat(ie),
                    class: "".concat(pe, "-btn"),
                    "aria-controls": re && "".concat(re, "-panel-").concat(ie),
                    "aria-disabled": le,
                    tabindex: le ? null : 0,
                    onClick: function (Se) {
                        Se.stopPropagation(), X(Se)
                    },
                    onKeydown: function (Se) {
                        [KeyCode$1.SPACE, KeyCode$1.ENTER].includes(Se.which) && (Se.preventDefault(),
                            X(Se))
                    },
                    onFocus: fe
                }, [typeof ue == "function" ? ue() : ue]), Q.value && createVNode("button", {
                    type: "button",
                    "aria-label": de || "remove",
                    tabindex: 0,
                    class: "".concat(pe, "-remove"),
                    onClick: function (Se) {
                        Se.stopPropagation(), Z(Se)
                    }
                }, [(se == null ? void 0 : se()) || ((ne = ve.removeIcon) === null || ne ===
                    void 0 ? void 0 : ne.call(ve)) || ""])]);
            return ce ? ce(me) : me
        }
    }
});
var DEFAULT_SIZE$1 = {
    width: 0,
    height: 0,
    left: 0,
    top: 0
};

function useOffsets(K, C) {
    var H = ref(new Map);
    return watchEffect(function () {
        for (var W, U = new Map, G = K.value, X = C.value.get((W = G[0]) === null || W === void 0 ? void 0 : W.key) ||
                DEFAULT_SIZE$1, Z = X.left + X.width, Q = 0; Q < G.length; Q += 1) {
            var ee = G[Q].key,
                ne = C.value.get(ee);
            if (!ne) {
                var te;
                ne = C.value.get((te = G[Q - 1]) === null || te === void 0 ? void 0 : te.key) || DEFAULT_SIZE$1
            }
            var re = U.get(ee) || _objectSpread2$1({}, ne);
            re.right = Z - re.left - re.width, U.set(ee, re)
        }
        H.value = new Map(U)
    }), H
}
const AddButton = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AddButton",
    inheritAttrs: !1,
    props: {
        prefixCls: String,
        editable: {
            type: Object
        },
        locale: {
            type: Object,
            default: void 0
        }
    },
    setup: function (C, H) {
        var W = H.expose,
            U = H.attrs,
            G = ref();
        return W({
                domRef: G
            }),
            function () {
                var X = C.prefixCls,
                    Z = C.editable,
                    Q = C.locale;
                return !Z || Z.showAdd === !1 ? null : createVNode("button", {
                    ref: G,
                    type: "button",
                    class: "".concat(X, "-nav-add"),
                    style: U.style,
                    "aria-label": (Q == null ? void 0 : Q.addAriaLabel) || "Add tab",
                    onClick: function (ne) {
                        Z.onEdit("add", {
                            event: ne
                        })
                    }
                }, [Z.addIcon ? Z.addIcon() : "+"])
            }
    }
});
var operationNodeProps = {
    prefixCls: {
        type: String
    },
    id: {
        type: String
    },
    tabs: {
        type: Object
    },
    rtl: {
        type: Boolean
    },
    tabBarGutter: {
        type: Number
    },
    activeKey: {
        type: [String, Number]
    },
    mobile: {
        type: Boolean
    },
    moreIcon: PropTypes$1.any,
    moreTransitionName: {
        type: String
    },
    editable: {
        type: Object
    },
    locale: {
        type: Object,
        default: void 0
    },
    removeAriaLabel: String,
    onTabClick: {
        type: Function
    }
};
const OperationNode = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "OperationNode",
    inheritAttrs: !1,
    props: operationNodeProps,
    emits: ["tabClick"],
    slots: ["moreIcon"],
    setup: function (C, H) {
        var W = H.attrs,
            U = H.slots,
            G = useState(!1),
            X = _slicedToArray$2(G, 2),
            Z = X[0],
            Q = X[1],
            ee = useState(null),
            ne = _slicedToArray$2(ee, 2),
            te = ne[0],
            re = ne[1],
            ae = function (ce) {
                for (var de = C.tabs.filter(function (he) {
                        return !he.disabled
                    }), ve = de.findIndex(function (he) {
                        return he.key === te.value
                    }) || 0, fe = de.length, pe = 0; pe < fe; pe += 1) {
                    ve = (ve + ce + fe) % fe;
                    var me = de[ve];
                    if (!me.disabled) {
                        re(me.key);
                        return
                    }
                }
            },
            oe = function (ce) {
                var de = ce.which;
                if (!Z.value) {
                    [KeyCode$1.DOWN, KeyCode$1.SPACE, KeyCode$1.ENTER].includes(de) && (Q(!0), ce.preventDefault());
                    return
                }
                switch (de) {
                    case KeyCode$1.UP:
                        ae(-1), ce.preventDefault();
                        break;
                    case KeyCode$1.DOWN:
                        ae(1), ce.preventDefault();
                        break;
                    case KeyCode$1.ESC:
                        Q(!1);
                        break;
                    case KeyCode$1.SPACE:
                    case KeyCode$1.ENTER:
                        te.value !== null && C.onTabClick(te.value, ce);
                        break
                }
            },
            ie = computed(function () {
                return "".concat(C.id, "-more-popup")
            }),
            ue = computed(function () {
                return te.value !== null ? "".concat(ie.value, "-").concat(te.value) : null
            }),
            le = function (ce, de) {
                ce.preventDefault(), ce.stopPropagation(), C.editable.onEdit("remove", {
                    key: de,
                    event: ce
                })
            };
        return onMounted(function () {
                watch(te, function () {
                    var se = document.getElementById(ue.value);
                    se && se.scrollIntoView && se.scrollIntoView(!1)
                }, {
                    flush: "post",
                    immediate: !0
                })
            }), watch(Z, function () {
                Z.value || re(null)
            }),
            function () {
                var se, ce = C.prefixCls,
                    de = C.id,
                    ve = C.tabs,
                    fe = C.locale,
                    pe = C.mobile,
                    me = C.moreIcon,
                    he = me === void 0 ? ((se = U.moreIcon) === null || se === void 0 ? void 0 : se.call(U)) ||
                    createVNode(EllipsisOutlined$1, null, null) : me,
                    Se = C.moreTransitionName,
                    _e = C.editable,
                    be = C.tabBarGutter,
                    ge = C.rtl,
                    xe = C.onTabClick,
                    Pe = "".concat(ce, "-dropdown"),
                    $e = fe == null ? void 0 : fe.dropdownAriaLabel,
                    ye = _defineProperty$V({}, ge ? "marginRight" : "marginLeft", be);
                ve.length || (ye.visibility = "hidden", ye.order = 1);
                var Ce = classNames(_defineProperty$V({}, "".concat(Pe, "-rtl"), ge)),
                    we = pe ? null : createVNode(Dropdown$2, {
                        prefixCls: Pe,
                        trigger: ["hover"],
                        visible: Z.value,
                        transitionName: Se,
                        onVisibleChange: Q,
                        overlayClassName: Ce,
                        mouseEnterDelay: .1,
                        mouseLeaveDelay: .1
                    }, {
                        overlay: function () {
                            return createVNode(Menu, {
                                onClick: function (Me) {
                                    var Ve = Me.key,
                                        ke = Me.domEvent;
                                    xe(Ve, ke), Q(!1)
                                },
                                id: ie.value,
                                tabindex: -1,
                                role: "listbox",
                                "aria-activedescendant": ue.value,
                                selectedKeys: [te.value],
                                "aria-label": $e !== void 0 ? $e : "expanded dropdown"
                            }, {
                                default: function () {
                                    return [ve.map(function (Me) {
                                        var Ve, ke, Ee = _e && Me.closable !==
                                            !1 && !Me.disabled;
                                        return createVNode(MenuItem$1, {
                                            key: Me.key,
                                            id: "".concat(ie.value,
                                                "-").concat(Me.key),
                                            role: "option",
                                            "aria-controls": de &&
                                                "".concat(de,
                                                    "-panel-").concat(
                                                    Me.key),
                                            disabled: Me.disabled
                                        }, {
                                            default: function () {
                                                return [
                                                    createVNode(
                                                        "span",
                                                        null,
                                                        [
                                                            typeof Me
                                                            .tab ==
                                                            "function" ?
                                                            Me
                                                            .tab() :
                                                            Me
                                                            .tab
                                                            ]
                                                    ), Ee &&
                                                    createVNode(
                                                        "button", {
                                                            type: "button",
                                                            "aria-label": C
                                                                .removeAriaLabel ||
                                                                "remove",
                                                            tabindex: 0,
                                                            class: ""
                                                                .concat(
                                                                    Pe,
                                                                    "-menu-item-remove"
                                                                ),
                                                            onClick: function (
                                                                He
                                                            ) {
                                                                He
                                                                    .stopPropagation(),
                                                                    le(
                                                                        He,
                                                                        Me
                                                                        .key
                                                                    )
                                                            }
                                                        },
                                                        [((
                                                                    Ve =
                                                                    Me
                                                                    .closeIcon
                                                                ) ===
                                                                null ||
                                                                Ve ===
                                                                void 0 ?
                                                                void 0 :
                                                                Ve
                                                                .call(
                                                                    Me
                                                                )
                                                            ) ||
                                                            (
                                                                (
                                                                    ke =
                                                                    _e
                                                                    .removeIcon
                                                                ) ===
                                                                null ||
                                                                ke ===
                                                                void 0 ?
                                                                void 0 :
                                                                ke
                                                                .call(
                                                                    _e
                                                                )
                                                            ) ||
                                                            ""
                                                            ]
                                                    )]
                                            }
                                        })
                                    })]
                                }
                            })
                        },
                        default: function () {
                            return createVNode("button", {
                                type: "button",
                                class: "".concat(ce, "-nav-more"),
                                style: ye,
                                tabindex: -1,
                                "aria-hidden": "true",
                                "aria-haspopup": "listbox",
                                "aria-controls": ie.value,
                                id: "".concat(de, "-more"),
                                "aria-expanded": Z.value,
                                onKeydown: oe
                            }, [he])
                        }
                    });
                return createVNode("div", {
                    class: classNames("".concat(ce, "-nav-operations"), W.class),
                    style: W.style
                }, [we, createVNode(AddButton, {
                    prefixCls: ce,
                    locale: fe,
                    editable: _e
                }, null)])
            }
    }
});
var TabsContextKey = Symbol("tabsContextKey"),
    useProvideTabs = function (C) {
        provide(TabsContextKey, C)
    },
    useInjectTabs = function () {
        return inject(TabsContextKey, {
            tabs: ref([]),
            prefixCls: ref()
        })
    };
defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "TabsContextProvider",
    inheritAttrs: !1,
    props: {
        tabs: {
            type: Object,
            default: void 0
        },
        prefixCls: {
            type: String,
            default: void 0
        }
    },
    setup: function (C, H) {
        var W = H.slots;
        return useProvideTabs(toRefs(C)),
            function () {
                var U;
                return (U = W.default) === null || U === void 0 ? void 0 : U.call(W)
            }
    }
});
var MIN_SWIPE_DISTANCE = .1,
    STOP_SWIPE_DISTANCE = .01,
    REFRESH_INTERVAL$1 = 20,
    SPEED_OFF_MULTIPLE = Math.pow(.995, REFRESH_INTERVAL$1);

function useTouchMove(K, C) {
    var H = useState(),
        W = _slicedToArray$2(H, 2),
        U = W[0],
        G = W[1],
        X = useState(0),
        Z = _slicedToArray$2(X, 2),
        Q = Z[0],
        ee = Z[1],
        ne = useState(0),
        te = _slicedToArray$2(ne, 2),
        re = te[0],
        ae = te[1],
        oe = useState(),
        ie = _slicedToArray$2(oe, 2),
        ue = ie[0],
        le = ie[1],
        se = ref();

    function ce(ge) {
        var xe = ge.touches[0],
            Pe = xe.screenX,
            $e = xe.screenY;
        G({
            x: Pe,
            y: $e
        }), clearInterval(se.value)
    }

    function de(ge) {
        if (U.value) {
            ge.preventDefault();
            var xe = ge.touches[0],
                Pe = xe.screenX,
                $e = xe.screenY,
                ye = Pe - U.value.x,
                Ce = $e - U.value.y;
            C(ye, Ce), G({
                x: Pe,
                y: $e
            });
            var we = Date.now();
            ae(we - Q.value), ee(we), le({
                x: ye,
                y: Ce
            })
        }
    }

    function ve() {
        if (U.value) {
            var ge = ue.value;
            if (G(null), le(null), ge) {
                var xe = ge.x / re.value,
                    Pe = ge.y / re.value,
                    $e = Math.abs(xe),
                    ye = Math.abs(Pe);
                if (Math.max($e, ye) < MIN_SWIPE_DISTANCE) return;
                var Ce = xe,
                    we = Pe;
                se.value = setInterval(function () {
                    if (Math.abs(Ce) < STOP_SWIPE_DISTANCE && Math.abs(we) < STOP_SWIPE_DISTANCE) {
                        clearInterval(se.value);
                        return
                    }
                    Ce *= SPEED_OFF_MULTIPLE, we *= SPEED_OFF_MULTIPLE, C(Ce * REFRESH_INTERVAL$1, we *
                        REFRESH_INTERVAL$1)
                }, REFRESH_INTERVAL$1)
            }
        }
    }
    var fe = ref();

    function pe(ge) {
        var xe = ge.deltaX,
            Pe = ge.deltaY,
            $e = 0,
            ye = Math.abs(xe),
            Ce = Math.abs(Pe);
        ye === Ce ? $e = fe.value === "x" ? xe : Pe : ye > Ce ? ($e = xe, fe.value = "x") : ($e = Pe, fe.value = "y"),
            C(-$e, -$e) && ge.preventDefault()
    }
    var me = ref({
        onTouchStart: ce,
        onTouchMove: de,
        onTouchEnd: ve,
        onWheel: pe
    });

    function he(ge) {
        me.value.onTouchStart(ge)
    }

    function Se(ge) {
        me.value.onTouchMove(ge)
    }

    function _e(ge) {
        me.value.onTouchEnd(ge)
    }

    function be(ge) {
        me.value.onWheel(ge)
    }
    onMounted(function () {
        var ge, xe;
        document.addEventListener("touchmove", Se, {
            passive: !1
        }), document.addEventListener("touchend", _e, {
            passive: !1
        }), (ge = K.value) === null || ge === void 0 || ge.addEventListener("touchstart", he, {
            passive: !1
        }), (xe = K.value) === null || xe === void 0 || xe.addEventListener("wheel", be, {
            passive: !1
        })
    }), onBeforeUnmount(function () {
        document.removeEventListener("touchmove", Se), document.removeEventListener("touchend", _e)
    })
}

function useSyncState(K, C) {
    var H = ref(K);

    function W(U) {
        var G = typeof U == "function" ? U(H.value) : U;
        G !== H.value && C(G, H.value), H.value = G
    }
    return [H, W]
}
var useRefs = function () {
    var C = ref(new Map),
        H = function (U) {
            return function (G) {
                C.value.set(U, G)
            }
        };
    return onBeforeUpdate(function () {
        C.value = new Map
    }), [H, C]
};
const useRefs$1 = useRefs;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

function isKey(K, C) {
    if (isArray$2(K)) return !1;
    var H = typeof K;
    return H == "number" || H == "symbol" || H == "boolean" || K == null || isSymbol(K) ? !0 : reIsPlainProp.test(K) ||
        !reIsDeepProp.test(K) || C != null && K in Object(C)
}
var FUNC_ERROR_TEXT$1 = "Expected a function";

function memoize(K, C) {
    if (typeof K != "function" || C != null && typeof C != "function") throw new TypeError(FUNC_ERROR_TEXT$1);
    var H = function () {
        var W = arguments,
            U = C ? C.apply(this, W) : W[0],
            G = H.cache;
        if (G.has(U)) return G.get(U);
        var X = K.apply(this, W);
        return H.cache = G.set(U, X) || G, X
    };
    return H.cache = new(memoize.Cache || MapCache), H
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;

function memoizeCapped(K) {
    var C = memoize(K, function (W) {
            return H.size === MAX_MEMOIZE_SIZE && H.clear(), W
        }),
        H = C.cache;
    return C
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
    reEscapeChar = /\\(\\)?/g,
    stringToPath = memoizeCapped(function (K) {
        var C = [];
        return K.charCodeAt(0) === 46 && C.push(""), K.replace(rePropName, function (H, W, U, G) {
            C.push(U ? G.replace(reEscapeChar, "$1") : W || H)
        }), C
    });
const stringToPath$1 = stringToPath;

function castPath(K, C) {
    return isArray$2(K) ? K : isKey(K, C) ? [K] : stringToPath$1(toString$1(K))
}
var INFINITY = 1 / 0;

function toKey(K) {
    if (typeof K == "string" || isSymbol(K)) return K;
    var C = K + "";
    return C == "0" && 1 / K == -INFINITY ? "-0" : C
}

function baseGet(K, C) {
    C = castPath(C, K);
    for (var H = 0, W = C.length; K != null && H < W;) K = K[toKey(C[H++])];
    return H && H == W ? K : void 0
}
var defineProperty = function () {
    try {
        var K = getNative(Object, "defineProperty");
        return K({}, "", {}), K
    } catch {}
}();
const defineProperty$1 = defineProperty;

function baseAssignValue(K, C, H) {
    C == "__proto__" && defineProperty$1 ? defineProperty$1(K, C, {
        configurable: !0,
        enumerable: !0,
        value: H,
        writable: !0
    }) : K[C] = H
}
var objectProto$2 = Object.prototype,
    hasOwnProperty$2 = objectProto$2.hasOwnProperty;

function assignValue(K, C, H) {
    var W = K[C];
    (!(hasOwnProperty$2.call(K, C) && eq(W, H)) || H === void 0 && !(C in K)) && baseAssignValue(K, C, H)
}

function baseSet(K, C, H, W) {
    if (!isObject$2(K)) return K;
    C = castPath(C, K);
    for (var U = -1, G = C.length, X = G - 1, Z = K; Z != null && ++U < G;) {
        var Q = toKey(C[U]),
            ee = H;
        if (Q === "__proto__" || Q === "constructor" || Q === "prototype") return K;
        if (U != X) {
            var ne = Z[Q];
            ee = W ? W(ne, Q, Z) : void 0, ee === void 0 && (ee = isObject$2(ne) ? ne : isIndex(C[U + 1]) ? [] : {})
        }
        assignValue(Z, Q, ee), Z = Z[Q]
    }
    return K
}

function basePickBy(K, C, H) {
    for (var W = -1, U = C.length, G = {}; ++W < U;) {
        var X = C[W],
            Z = baseGet(K, X);
        H(Z, X) && baseSet(G, castPath(X, K), Z)
    }
    return G
}

function baseHasIn(K, C) {
    return K != null && C in Object(K)
}

function hasPath(K, C, H) {
    C = castPath(C, K);
    for (var W = -1, U = C.length, G = !1; ++W < U;) {
        var X = toKey(C[W]);
        if (!(G = K != null && H(K, X))) break;
        K = K[X]
    }
    return G || ++W != U ? G : (U = K == null ? 0 : K.length, !!U && isLength(U) && isIndex(X, U) && (isArray$2(K) ||
        isArguments$1(K)))
}

function hasIn(K, C) {
    return K != null && hasPath(K, C, baseHasIn)
}

function basePick(K, C) {
    return basePickBy(K, C, function (H, W) {
        return hasIn(K, W)
    })
}
var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;

function isFlattenable(K) {
    return isArray$2(K) || isArguments$1(K) || !!(spreadableSymbol && K && K[spreadableSymbol])
}

function baseFlatten(K, C, H, W, U) {
    var G = -1,
        X = K.length;
    for (H || (H = isFlattenable), U || (U = []); ++G < X;) {
        var Z = K[G];
        C > 0 && H(Z) ? C > 1 ? baseFlatten(Z, C - 1, H, W, U) : arrayPush(U, Z) : W || (U[U.length] = Z)
    }
    return U
}

function flatten(K) {
    var C = K == null ? 0 : K.length;
    return C ? baseFlatten(K, 1) : []
}

function apply(K, C, H) {
    switch (H.length) {
        case 0:
            return K.call(C);
        case 1:
            return K.call(C, H[0]);
        case 2:
            return K.call(C, H[0], H[1]);
        case 3:
            return K.call(C, H[0], H[1], H[2])
    }
    return K.apply(C, H)
}
var nativeMax$2 = Math.max;

function overRest(K, C, H) {
    return C = nativeMax$2(C === void 0 ? K.length - 1 : C, 0),
        function () {
            for (var W = arguments, U = -1, G = nativeMax$2(W.length - C, 0), X = Array(G); ++U < G;) X[U] = W[C + U];
            U = -1;
            for (var Z = Array(C + 1); ++U < C;) Z[U] = W[U];
            return Z[C] = H(X), apply(K, this, Z)
        }
}

function constant(K) {
    return function () {
        return K
    }
}

function identity(K) {
    return K
}
var baseSetToString = defineProperty$1 ? function (K, C) {
    return defineProperty$1(K, "toString", {
        configurable: !0,
        enumerable: !1,
        value: constant(C),
        writable: !0
    })
} : identity;
const baseSetToString$1 = baseSetToString;
var HOT_COUNT = 800,
    HOT_SPAN = 16,
    nativeNow = Date.now;

function shortOut(K) {
    var C = 0,
        H = 0;
    return function () {
        var W = nativeNow(),
            U = HOT_SPAN - (W - H);
        if (H = W, U > 0) {
            if (++C >= HOT_COUNT) return arguments[0]
        } else C = 0;
        return K.apply(void 0, arguments)
    }
}
var setToString = shortOut(baseSetToString$1);
const setToString$1 = setToString;

function flatRest(K) {
    return setToString$1(overRest(K, void 0, flatten), K + "")
}
var pick = flatRest(function (K, C) {
    return K == null ? {} : basePick(K, C)
});
const pick$1 = pick;
var DEFAULT_SIZE = {
        width: 0,
        height: 0,
        left: 0,
        top: 0,
        right: 0
    },
    tabNavListProps = function () {
        return {
            id: {
                type: String
            },
            tabPosition: {
                type: String
            },
            activeKey: {
                type: [String, Number]
            },
            rtl: {
                type: Boolean
            },
            animated: {
                type: Object,
                default: void 0
            },
            editable: {
                type: Object
            },
            moreIcon: PropTypes$1.any,
            moreTransitionName: {
                type: String
            },
            mobile: {
                type: Boolean
            },
            tabBarGutter: {
                type: Number
            },
            renderTabBar: {
                type: Function
            },
            locale: {
                type: Object,
                default: void 0
            },
            onTabClick: {
                type: Function
            },
            onTabScroll: {
                type: Function
            }
        }
    };
const TabNavList = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "TabNavList",
        inheritAttrs: !1,
        props: tabNavListProps(),
        slots: ["moreIcon", "leftExtra", "rightExtra", "tabBarExtraContent"],
        emits: ["tabClick", "tabScroll"],
        setup: function (C, H) {
            var W = H.attrs,
                U = H.slots,
                G = useInjectTabs(),
                X = G.tabs,
                Z = G.prefixCls,
                Q = ref(),
                ee = ref(),
                ne = ref(),
                te = ref(),
                re = useRefs$1(),
                ae = _slicedToArray$2(re, 2),
                oe = ae[0],
                ie = ae[1],
                ue = computed(function () {
                    return C.tabPosition === "top" || C.tabPosition === "bottom"
                }),
                le = useSyncState(0, function (mt, ht) {
                    ue.value && C.onTabScroll && C.onTabScroll({
                        direction: mt > ht ? "left" : "right"
                    })
                }),
                se = _slicedToArray$2(le, 2),
                ce = se[0],
                de = se[1],
                ve = useSyncState(0, function (mt, ht) {
                    !ue.value && C.onTabScroll && C.onTabScroll({
                        direction: mt > ht ? "top" : "bottom"
                    })
                }),
                fe = _slicedToArray$2(ve, 2),
                pe = fe[0],
                me = fe[1],
                he = useState(0),
                Se = _slicedToArray$2(he, 2),
                _e = Se[0],
                be = Se[1],
                ge = useState(0),
                xe = _slicedToArray$2(ge, 2),
                Pe = xe[0],
                $e = xe[1],
                ye = useState(null),
                Ce = _slicedToArray$2(ye, 2),
                we = Ce[0],
                Oe = Ce[1],
                Ne = useState(null),
                Me = _slicedToArray$2(Ne, 2),
                Ve = Me[0],
                ke = Me[1],
                Ee = useState(0),
                Ae = _slicedToArray$2(Ee, 2),
                Re = Ae[0],
                He = Ae[1],
                je = useState(0),
                Fe = _slicedToArray$2(je, 2),
                Le = Fe[0],
                Ie = Fe[1],
                Te = useRafState(new Map),
                De = _slicedToArray$2(Te, 2),
                Ke = De[0],
                We = De[1],
                Ue = useOffsets(X, Ke),
                et = computed(function () {
                    return "".concat(Z.value, "-nav-operations-hidden")
                }),
                Ye = ref(0),
                ze = ref(0);
            watchEffect(function () {
                ue.value ? C.rtl ? (Ye.value = 0, ze.value = Math.max(0, _e.value - we.value)) : (Ye.value =
                    Math.min(0, we.value - _e.value), ze.value = 0) : (Ye.value = Math.min(0, Ve.value -
                    Pe.value), ze.value = 0)
            });
            var Be = function (ht) {
                    return ht < Ye.value ? Ye.value : ht > ze.value ? ze.value : ht
                },
                Ge = ref(),
                Xe = useState(),
                nt = _slicedToArray$2(Xe, 2),
                it = nt[0],
                ft = nt[1],
                pt = function () {
                    ft(Date.now())
                },
                ot = function () {
                    clearTimeout(Ge.value)
                },
                Ze = function (ht, yt) {
                    ht(function (St) {
                        var Ct = Be(St + yt);
                        return Ct
                    })
                };
            useTouchMove(Q, function (mt, ht) {
                if (ue.value) {
                    if (we.value >= _e.value) return !1;
                    Ze(de, mt)
                } else {
                    if (Ve.value >= Pe.value) return !1;
                    Ze(me, ht)
                }
                return ot(), pt(), !0
            }), watch(it, function () {
                ot(), it.value && (Ge.value = setTimeout(function () {
                    ft(0)
                }, 100))
            });
            var ut = function () {
                    var ht = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : C.activeKey,
                        yt = Ue.value.get(ht) || {
                            width: 0,
                            height: 0,
                            left: 0,
                            right: 0,
                            top: 0
                        };
                    if (ue.value) {
                        var St = ce.value;
                        C.rtl ? yt.right < ce.value ? St = yt.right : yt.right + yt.width > ce.value + we.value &&
                            (St = yt.right + yt.width - we.value) : yt.left < -ce.value ? St = -yt.left : yt.left +
                            yt.width > -ce.value + we.value && (St = -(yt.left + yt.width - we.value)), me(0),
                            de(Be(St))
                    } else {
                        var Ct = pe.value;
                        yt.top < -pe.value ? Ct = -yt.top : yt.top + yt.height > -pe.value + Ve.value && (Ct = -
                            (yt.top + yt.height - Ve.value)), de(0), me(Be(Ct))
                    }
                },
                st = ref(0),
                rt = ref(0);
            watchEffect(function () {
                var mt, ht, yt, St, Ct, _t, wt, Et = Ue.value;
                ["top", "bottom"].includes(C.tabPosition) ? (ht = "width", Ct = we.value, _t = _e.value,
                    wt = Re.value, yt = C.rtl ? "right" : "left", St = Math.abs(ce.value)) : (ht =
                    "height", Ct = Ve.value, _t = _e.value, wt = Le.value, yt = "top", St = -pe.value
                );
                var xt = Ct;
                _t + wt > Ct && _t < Ct && (xt = Ct - wt);
                var kt = X.value;
                if (!kt.length) {
                    var Nt;
                    return Nt = [0, 0], st.value = Nt[0], rt.value = Nt[1], Nt
                }
                for (var Rt = kt.length, It = Rt, Lt = 0; Lt < Rt; Lt += 1) {
                    var jt = Et.get(kt[Lt].key) || DEFAULT_SIZE;
                    if (jt[yt] + jt[ht] > St + xt) {
                        It = Lt - 1;
                        break
                    }
                }
                for (var Mt = 0, Vt = Rt - 1; Vt >= 0; Vt -= 1) {
                    var Dt = Et.get(kt[Vt].key) || DEFAULT_SIZE;
                    if (Dt[yt] < St) {
                        Mt = Vt + 1;
                        break
                    }
                }
                return mt = [Mt, It], st.value = mt[0], rt.value = mt[1], mt
            });
            var qe = function () {
                    var ht, yt, St, Ct, _t, wt = ((ht = Q.value) === null || ht === void 0 ? void 0 : ht.offsetWidth) ||
                        0,
                        Et = ((yt = Q.value) === null || yt === void 0 ? void 0 : yt.offsetHeight) || 0,
                        xt = ((St = te.value) === null || St === void 0 ? void 0 : St.$el) || {},
                        kt = xt.offsetWidth || 0,
                        Nt = xt.offsetHeight || 0;
                    Oe(wt), ke(Et), He(kt), Ie(Nt);
                    var Rt = (((Ct = ee.value) === null || Ct === void 0 ? void 0 : Ct.offsetWidth) || 0) - kt,
                        It = (((_t = ee.value) === null || _t === void 0 ? void 0 : _t.offsetHeight) || 0) - Nt;
                    be(Rt), $e(It), We(function () {
                        var Lt = new Map;
                        return X.value.forEach(function (jt) {
                            var Mt = jt.key,
                                Vt = ie.value.get(Mt),
                                Dt = (Vt == null ? void 0 : Vt.$el) || Vt;
                            Dt && Lt.set(Mt, {
                                width: Dt.offsetWidth,
                                height: Dt.offsetHeight,
                                left: Dt.offsetLeft,
                                top: Dt.offsetTop
                            })
                        }), Lt
                    })
                },
                Je = computed(function () {
                    return [].concat(_toConsumableArray(X.value.slice(0, st.value)), _toConsumableArray(X.value
                        .slice(rt.value + 1)))
                }),
                Qe = useState(),
                lt = _slicedToArray$2(Qe, 2),
                ct = lt[0],
                dt = lt[1],
                tt = computed(function () {
                    return Ue.value.get(C.activeKey)
                }),
                at = ref(),
                vt = function () {
                    wrapperRaf.cancel(at.value)
                };
            watch([tt, ue, function () {
                return C.rtl
            }], function () {
                var mt = {};
                tt.value && (ue.value ? (C.rtl ? mt.right = toPx(tt.value.right) : mt.left = toPx(tt.value
                    .left), mt.width = toPx(tt.value.width)) : (mt.top = toPx(tt.value.top), mt
                    .height = toPx(tt.value.height))), vt(), at.value = wrapperRaf(function () {
                    dt(mt)
                })
            }), watch([function () {
                return C.activeKey
            }, tt, Ue, ue], function () {
                ut()
            }, {
                flush: "post"
            }), watch([function () {
                return C.rtl
            }, function () {
                return C.tabBarGutter
            }, function () {
                return C.activeKey
            }, function () {
                return X.value
            }], function () {
                qe()
            }, {
                flush: "post"
            });
            var gt = function (ht) {
                var yt = ht.position,
                    St = ht.prefixCls,
                    Ct = ht.extra;
                if (!Ct) return null;
                var _t = Ct == null ? void 0 : Ct({
                    position: yt
                });
                return _t ? createVNode("div", {
                    class: "".concat(St, "-extra-content")
                }, [_t]) : null
            };
            return onBeforeUnmount(function () {
                    ot(), vt()
                }),
                function () {
                    var mt, ht = C.id,
                        yt = C.animated,
                        St = C.activeKey,
                        Ct = C.rtl,
                        _t = C.editable,
                        wt = C.locale,
                        Et = C.tabPosition,
                        xt = C.tabBarGutter,
                        kt = C.onTabClick,
                        Nt = W.class,
                        Rt = W.style,
                        It = Z.value,
                        Lt = !!Je.value.length,
                        jt = "".concat(It, "-nav-wrap"),
                        Mt, Vt, Dt, zt;
                    ue.value ? Ct ? (Vt = ce.value > 0, Mt = ce.value + we.value < _e.value) : (Mt = ce.value <
                        0, Vt = -ce.value + we.value < _e.value) : (Dt = pe.value < 0, zt = -pe.value + Ve.value <
                        Pe.value);
                    var At = {};
                    Et === "top" || Et === "bottom" ? At[Ct ? "marginRight" : "marginLeft"] = typeof xt ==
                        "number" ? "".concat(xt, "px") : xt : At.marginTop = typeof xt == "number" ? "".concat(
                            xt, "px") : xt;
                    var Wt = X.value.map(function (Yt, Zt) {
                        var Kt = Yt.key;
                        return createVNode(TabNode, {
                            id: ht,
                            prefixCls: It,
                            key: Kt,
                            tab: Yt,
                            style: Zt === 0 ? void 0 : At,
                            closable: Yt.closable,
                            editable: _t,
                            active: Kt === St,
                            removeAriaLabel: wt == null ? void 0 : wt.removeAriaLabel,
                            ref: oe(Kt),
                            onClick: function (Ft) {
                                kt(Kt, Ft)
                            },
                            onFocus: function () {
                                ut(Kt), pt(), Q.value && (Ct || (Q.value.scrollLeft = 0), Q
                                    .value.scrollTop = 0)
                            }
                        }, U)
                    });
                    return createVNode("div", {
                        role: "tablist",
                        class: classNames("".concat(It, "-nav"), Nt),
                        style: Rt,
                        onKeydown: function () {
                            pt()
                        }
                    }, [createVNode(gt, {
                        position: "left",
                        prefixCls: It,
                        extra: U.leftExtra
                    }, null), createVNode(ResizeObserver$1, {
                        onResize: qe
                    }, {
                        default: function () {
                            return [createVNode("div", {
                                class: classNames(jt, (mt = {},
                                    _defineProperty$V(mt, "".concat(jt,
                                        "-ping-left"), Mt),
                                    _defineProperty$V(mt, "".concat(jt,
                                        "-ping-right"), Vt),
                                    _defineProperty$V(mt, "".concat(jt,
                                        "-ping-top"), Dt),
                                    _defineProperty$V(mt, "".concat(jt,
                                        "-ping-bottom"), zt), mt)),
                                ref: Q
                            }, [createVNode(ResizeObserver$1, {
                                onResize: qe
                            }, {
                                default: function () {
                                    return [createVNode("div", {
                                        ref: ee,
                                        class: "".concat(
                                            It,
                                            "-nav-list"
                                        ),
                                        style: {
                                            transform: "translate("
                                                .concat(
                                                    ce.value,
                                                    "px, "
                                                ).concat(
                                                    pe.value,
                                                    "px)"
                                                ),
                                            transition: it
                                                .value ?
                                                "none" :
                                                void 0
                                        }
                                    }, [Wt, createVNode(
                                            AddButton, {
                                                ref: te,
                                                prefixCls: It,
                                                locale: wt,
                                                editable: _t,
                                                style: _objectSpread2$1(
                                                    _objectSpread2$1({},
                                                        Wt
                                                        .length ===
                                                        0 ?
                                                        void 0 :
                                                        At
                                                    ), {}, {
                                                        visibility: Lt ?
                                                            "hidden" :
                                                            null
                                                    }
                                                )
                                            }, null),
                                        createVNode(
                                            "div", {
                                                class: classNames(
                                                    ""
                                                    .concat(
                                                        It,
                                                        "-ink-bar"
                                                    ),
                                                    _defineProperty$V({},
                                                        ""
                                                        .concat(
                                                            It,
                                                            "-ink-bar-animated"
                                                        ),
                                                        yt
                                                        .inkBar
                                                    )
                                                ),
                                                style: ct
                                                    .value
                                            }, null)])]
                                }
                            })])]
                        }
                    }), createVNode(OperationNode, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                        removeAriaLabel: wt == null ? void 0 : wt.removeAriaLabel,
                        ref: ne,
                        prefixCls: It,
                        tabs: Je.value,
                        class: !Lt && et.value
                    }), pick$1(U, ["moreIcon"])), createVNode(gt, {
                        position: "right",
                        prefixCls: It,
                        extra: U.rightExtra
                    }, null), createVNode(gt, {
                        position: "right",
                        prefixCls: It,
                        extra: U.tabBarExtraContent
                    }, null)])
                }
        }
    }),
    TabPanelList = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "TabPanelList",
        inheritAttrs: !1,
        props: {
            activeKey: {
                type: [String, Number]
            },
            id: {
                type: String
            },
            rtl: {
                type: Boolean
            },
            animated: {
                type: Object,
                default: void 0
            },
            tabPosition: {
                type: String
            },
            destroyInactiveTabPane: {
                type: Boolean
            }
        },
        setup: function (C) {
            var H = useInjectTabs(),
                W = H.tabs,
                U = H.prefixCls;
            return function () {
                var G = C.id,
                    X = C.activeKey,
                    Z = C.animated,
                    Q = C.tabPosition,
                    ee = C.rtl,
                    ne = C.destroyInactiveTabPane,
                    te = Z.tabPane,
                    re = U.value,
                    ae = W.value.findIndex(function (oe) {
                        return oe.key === X
                    });
                return createVNode("div", {
                    class: "".concat(re, "-content-holder")
                }, [createVNode("div", {
                    class: ["".concat(re, "-content"), "".concat(re, "-content-").concat(Q),
                        _defineProperty$V({}, "".concat(re, "-content-animated"), te)],
                    style: ae && te ? _defineProperty$V({}, ee ? "marginRight" :
                        "marginLeft", "-".concat(ae, "00%")) : null
                }, [W.value.map(function (oe) {
                    return cloneElement(oe.node, {
                        key: oe.key,
                        prefixCls: re,
                        tabKey: oe.key,
                        id: G,
                        animated: te,
                        active: oe.key === X,
                        destroyInactiveTabPane: ne
                    })
                })])])
            }
        }
    });
var PlusOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "defs",
            attrs: {},
            children: [{
                tag: "style",
                attrs: {}
            }]
        }, {
            tag: "path",
            attrs: {
                d: "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z"
            }
        }, {
            tag: "path",
            attrs: {
                d: "M176 474h672q8 0 8 8v60q0 8-8 8H176q-8 0-8-8v-60q0-8 8-8z"
            }
        }]
    },
    name: "plus",
    theme: "outlined"
};
const PlusOutlinedSvg = PlusOutlined$2;

function _objectSpread$A(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$A(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$A(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var PlusOutlined = function (C, H) {
    var W = _objectSpread$A({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$A({}, W, {
        icon: PlusOutlinedSvg
    }), null)
};
PlusOutlined.displayName = "PlusOutlined";
PlusOutlined.inheritAttrs = !1;
const PlusOutlined$1 = PlusOutlined;
var uuid$3 = 0,
    tabsProps = function () {
        return {
            prefixCls: {
                type: String
            },
            id: {
                type: String
            },
            activeKey: {
                type: [String, Number]
            },
            defaultActiveKey: {
                type: [String, Number]
            },
            direction: {
                type: String
            },
            animated: {
                type: [Boolean, Object]
            },
            renderTabBar: {
                type: Function
            },
            tabBarGutter: {
                type: Number
            },
            tabBarStyle: {
                type: Object
            },
            tabPosition: {
                type: String
            },
            destroyInactiveTabPane: {
                type: Boolean
            },
            hideAdd: Boolean,
            type: {
                type: String
            },
            size: {
                type: String
            },
            centered: Boolean,
            onEdit: {
                type: Function
            },
            onChange: {
                type: Function
            },
            onTabClick: {
                type: Function
            },
            onTabScroll: {
                type: Function
            },
            "onUpdate:activeKey": {
                type: Function
            },
            locale: {
                type: Object,
                default: void 0
            },
            onPrevClick: Function,
            onNextClick: Function,
            tabBarExtraContent: PropTypes$1.any
        }
    };

function parseTabList(K) {
    return K.map(function (C) {
        if (isValidElement(C)) {
            for (var H = _objectSpread2$1({}, C.props || {}), W = 0, U = Object.entries(H); W < U.length; W++) {
                var G = _slicedToArray$2(U[W], 2),
                    X = G[0],
                    Z = G[1];
                delete H[X], H[camelize$1(X)] = Z
            }
            var Q = C.children || {},
                ee = C.key !== void 0 ? C.key : void 0,
                ne = H.tab,
                te = ne === void 0 ? Q.tab : ne,
                re = H.disabled,
                ae = H.forceRender,
                oe = H.closable,
                ie = H.animated,
                ue = H.active,
                le = H.destroyInactiveTabPane;
            return _objectSpread2$1(_objectSpread2$1({
                key: ee
            }, H), {}, {
                node: C,
                closeIcon: Q.closeIcon,
                tab: te,
                disabled: re === "" || re,
                forceRender: ae === "" || ae,
                closable: oe === "" || oe,
                animated: ie === "" || ie,
                active: ue === "" || ue,
                destroyInactiveTabPane: le === "" || le
            })
        }
        return null
    }).filter(function (C) {
        return C
    })
}
var InternalTabs = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "InternalTabs",
    inheritAttrs: !1,
    props: _objectSpread2$1(_objectSpread2$1({}, initDefaultProps$1(tabsProps(), {
        tabPosition: "top",
        animated: {
            inkBar: !0,
            tabPane: !1
        }
    })), {}, {
        tabs: {
            type: Array
        }
    }),
    slots: ["tabBarExtraContent", "leftExtra", "rightExtra", "moreIcon", "addIcon", "removeIcon",
        "renderTabBar"],
    setup: function (C, H) {
        var W = H.attrs,
            U = H.slots;
        devWarning(C.onPrevClick === void 0 && C.onNextClick === void 0, "Tabs",
                "`onPrevClick / @prevClick` and `onNextClick / @nextClick` has been removed. Please use `onTabScroll / @tabScroll` instead."
            ), devWarning(C.tabBarExtraContent === void 0, "Tabs",
                "`tabBarExtraContent` prop has been removed. Please use `rightExtra` slot instead."),
            devWarning(U.tabBarExtraContent === void 0, "Tabs",
                "`tabBarExtraContent` slot is deprecated. Please use `rightExtra` slot instead.");
        var G = useConfigInject("tabs", C),
            X = G.prefixCls,
            Z = G.direction,
            Q = G.size,
            ee = G.rootPrefixCls,
            ne = computed(function () {
                return Z.value === "rtl"
            }),
            te = computed(function () {
                var xe = C.animated,
                    Pe = C.tabPosition;
                return xe === !1 || ["left", "right"].includes(Pe) ? {
                    inkBar: !1,
                    tabPane: !1
                } : xe === !0 ? {
                    inkBar: !0,
                    tabPane: !0
                } : _objectSpread2$1({
                    inkBar: !0,
                    tabPane: !1
                }, _typeof$2(xe) === "object" ? xe : {})
            }),
            re = useState(!1),
            ae = _slicedToArray$2(re, 2),
            oe = ae[0],
            ie = ae[1];
        onMounted(function () {
            ie(isMobile$2())
        });
        var ue = useMergedState(function () {
                var xe;
                return (xe = C.tabs[0]) === null || xe === void 0 ? void 0 : xe.key
            }, {
                value: computed(function () {
                    return C.activeKey
                }),
                defaultValue: C.defaultActiveKey
            }),
            le = _slicedToArray$2(ue, 2),
            se = le[0],
            ce = le[1],
            de = useState(function () {
                return C.tabs.findIndex(function (xe) {
                    return xe.key === se.value
                })
            }),
            ve = _slicedToArray$2(de, 2),
            fe = ve[0],
            pe = ve[1];
        watchEffect(function () {
            var xe = C.tabs.findIndex(function ($e) {
                return $e.key === se.value
            });
            if (xe === -1) {
                var Pe;
                xe = Math.max(0, Math.min(fe.value, C.tabs.length - 1)), ce((Pe = C.tabs[xe]) ===
                    null || Pe === void 0 ? void 0 : Pe.key)
            }
            pe(xe)
        });
        var me = useMergedState(null, {
                value: computed(function () {
                    return C.id
                })
            }),
            he = _slicedToArray$2(me, 2),
            Se = he[0],
            _e = he[1],
            be = computed(function () {
                return oe.value && !["left", "right"].includes(C.tabPosition) ? "top" : C.tabPosition
            });
        onMounted(function () {
            C.id || (_e("rc-tabs-".concat(uuid$3)), uuid$3 += 1)
        });
        var ge = function (Pe, $e) {
            var ye;
            (ye = C.onTabClick) === null || ye === void 0 || ye.call(C, Pe, $e);
            var Ce = Pe !== se.value;
            if (ce(Pe), Ce) {
                var we;
                (we = C.onChange) === null || we === void 0 || we.call(C, Pe)
            }
        };
        return useProvideTabs({
                tabs: computed(function () {
                    return C.tabs
                }),
                prefixCls: X
            }),
            function () {
                var xe, Pe = C.id,
                    $e = C.type,
                    ye = C.tabBarGutter,
                    Ce = C.tabBarStyle,
                    we = C.locale,
                    Oe = C.destroyInactiveTabPane,
                    Ne = C.renderTabBar,
                    Me = Ne === void 0 ? U.renderTabBar : Ne,
                    Ve = C.onTabScroll,
                    ke = C.hideAdd,
                    Ee = C.centered,
                    Ae = {
                        id: Se.value,
                        activeKey: se.value,
                        animated: te.value,
                        tabPosition: be.value,
                        rtl: ne.value,
                        mobile: oe.value
                    },
                    Re;
                $e === "editable-card" && (Re = {
                    onEdit: function (Ie, Te) {
                        var De, Ke = Te.key,
                            We = Te.event;
                        (De = C.onEdit) === null || De === void 0 || De.call(C, Ie === "add" ?
                            We : Ke, Ie)
                    },
                    removeIcon: function () {
                        return createVNode(CloseOutlined$1, null, null)
                    },
                    addIcon: U.addIcon ? U.addIcon : function () {
                        return createVNode(PlusOutlined$1, null, null)
                    },
                    showAdd: ke !== !0
                });
                var He, je = _objectSpread2$1(_objectSpread2$1({}, Ae), {}, {
                    moreTransitionName: "".concat(ee.value, "-slide-up"),
                    editable: Re,
                    locale: we,
                    tabBarGutter: ye,
                    onTabClick: ge,
                    onTabScroll: Ve,
                    style: Ce
                });
                Me ? He = Me(_objectSpread2$1(_objectSpread2$1({}, je), {}, {
                    DefaultTabBar: TabNavList
                })) : He = createVNode(TabNavList, je, pick$1(U, ["moreIcon", "leftExtra", "rightExtra",
                    "tabBarExtraContent"]));
                var Fe = X.value;
                return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, W), {}, {
                    id: Pe,
                    class: classNames(Fe, "".concat(Fe, "-").concat(be.value), (xe = {},
                        _defineProperty$V(xe, "".concat(Fe, "-").concat(Q.value), Q.value),
                        _defineProperty$V(xe, "".concat(Fe, "-card"), ["card",
                            "editable-card"].includes($e)), _defineProperty$V(xe, "".concat(
                            Fe, "-editable-card"), $e === "editable-card"),
                        _defineProperty$V(xe, "".concat(Fe, "-centered"), Ee),
                        _defineProperty$V(xe, "".concat(Fe, "-mobile"), oe.value),
                        _defineProperty$V(xe, "".concat(Fe, "-editable"), $e ===
                            "editable-card"), _defineProperty$V(xe, "".concat(Fe,
                            "-rtl"), ne.value), xe), W.class)
                }), [He, createVNode(TabPanelList, _objectSpread2$1(_objectSpread2$1({
                    destroyInactiveTabPane: Oe
                }, Ae), {}, {
                    animated: te.value
                }), null)])
            }
    }
});
const Tabs = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ATabs",
    inheritAttrs: !1,
    props: initDefaultProps$1(tabsProps(), {
        tabPosition: "top",
        animated: {
            inkBar: !0,
            tabPane: !1
        }
    }),
    slots: ["tabBarExtraContent", "leftExtra", "rightExtra", "moreIcon", "addIcon", "removeIcon",
        "renderTabBar"],
    setup: function (C, H) {
        var W = H.attrs,
            U = H.slots,
            G = H.emit,
            X = function (Q) {
                G("update:activeKey", Q), G("change", Q)
            };
        return function () {
            var Z, Q = parseTabList(flattenChildren((Z = U.default) === null || Z === void 0 ? void 0 :
                Z.call(U)));
            return createVNode(InternalTabs, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({},
                omit$2(C, ["onUpdate:activeKey"])), W), {}, {
                onChange: X,
                tabs: Q
            }), U)
        }
    }
});
var tabPaneProps = function () {
    return {
        tab: PropTypes$1.any,
        disabled: {
            type: Boolean
        },
        forceRender: {
            type: Boolean
        },
        closable: {
            type: Boolean
        },
        animated: {
            type: Boolean
        },
        active: {
            type: Boolean
        },
        destroyInactiveTabPane: {
            type: Boolean
        },
        prefixCls: {
            type: String
        },
        tabKey: {
            type: [String, Number]
        },
        id: {
            type: String
        }
    }
};
const TabPane$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ATabPane",
    inheritAttrs: !1,
    __ANT_TAB_PANE: !0,
    props: tabPaneProps(),
    slots: ["closeIcon", "tab"],
    setup: function (C, H) {
        var W = H.attrs,
            U = H.slots,
            G = ref(C.forceRender);
        watch([function () {
            return C.active
        }, function () {
            return C.destroyInactiveTabPane
        }], function () {
            C.active ? G.value = !0 : C.destroyInactiveTabPane && (G.value = !1)
        }, {
            immediate: !0
        });
        var X = computed(function () {
            return C.active ? {} : C.animated ? {
                visibility: "hidden",
                height: 0,
                overflowY: "hidden"
            } : {
                display: "none"
            }
        });
        return function () {
            var Z, Q = C.prefixCls,
                ee = C.forceRender,
                ne = C.id,
                te = C.active,
                re = C.tabKey;
            return createVNode("div", {
                id: ne && "".concat(ne, "-panel-").concat(re),
                role: "tabpanel",
                tabindex: te ? 0 : -1,
                "aria-labelledby": ne && "".concat(ne, "-tab-").concat(re),
                "aria-hidden": !te,
                style: [X.value, W.style],
                class: ["".concat(Q, "-tabpane"), te && "".concat(Q, "-tabpane-active"), W.class]
            }, [(te || G.value || ee) && ((Z = U.default) === null || Z === void 0 ? void 0 : Z
                .call(U))])
        }
    }
});
Tabs.TabPane = TabPane$1;
Tabs.install = function (K) {
    return K.component(Tabs.name, Tabs), K.component(TabPane$1.name, TabPane$1), K
};
var canUseDocElement = function () {
        return canUseDom() && window.document.documentElement
    },
    isStyleNameSupport = function (C) {
        if (canUseDom() && window.document.documentElement) {
            var H = Array.isArray(C) ? C : [C],
                W = window.document.documentElement;
            return H.some(function (U) {
                return U in W.style
            })
        }
        return !1
    },
    isStyleValueSupport = function (C, H) {
        if (!isStyleNameSupport(C)) return !1;
        var W = document.createElement("div"),
            U = W.style[C];
        return W.style[C] = H, W.style[C] !== U
    };

function isStyleSupport(K, C) {
    return !Array.isArray(K) && C !== void 0 ? isStyleValueSupport(K, C) : isStyleNameSupport(K)
}
var flexGapSupported, detectFlexGapSupported = function () {
    if (!canUseDocElement()) return !1;
    if (flexGapSupported !== void 0) return flexGapSupported;
    var C = document.createElement("div");
    return C.style.display = "flex", C.style.flexDirection = "column", C.style.rowGap = "1px", C.appendChild(
        document.createElement("div")), C.appendChild(document.createElement("div")), document.body.appendChild(
        C), flexGapSupported = C.scrollHeight === 1, document.body.removeChild(C), flexGapSupported
};
const useFlexGapSupport = function () {
    var K = ref(!1);
    return onMounted(function () {
        K.value = detectFlexGapSupported()
    }), K
};
var RowContextKey = Symbol("rowContextKey"),
    useProvideRow = function (C) {
        provide(RowContextKey, C)
    },
    useInjectRow = function () {
        return inject(RowContextKey, {
            gutter: computed(function () {}),
            wrap: computed(function () {}),
            supportFlexGap: computed(function () {})
        })
    };
tuple$1("top", "middle", "bottom", "stretch");
tuple$1("start", "end", "center", "space-around", "space-between");
var rowProps = function () {
        return {
            align: String,
            justify: String,
            prefixCls: String,
            gutter: {
                type: [Number, Array, Object],
                default: 0
            },
            wrap: {
                type: Boolean,
                default: void 0
            }
        }
    },
    ARow = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ARow",
        props: rowProps(),
        setup: function (C, H) {
            var W = H.slots,
                U = useConfigInject("row", C),
                G = U.prefixCls,
                X = U.direction,
                Z, Q = ref({
                    xs: !0,
                    sm: !0,
                    md: !0,
                    lg: !0,
                    xl: !0,
                    xxl: !0,
                    xxxl: !0
                }),
                ee = useFlexGapSupport();
            onMounted(function () {
                Z = ResponsiveObserve.subscribe(function (ae) {
                    var oe = C.gutter || 0;
                    (!Array.isArray(oe) && _typeof$2(oe) === "object" || Array.isArray(oe) && (
                        _typeof$2(oe[0]) === "object" || _typeof$2(oe[1]) === "object")) && (Q.value =
                        ae)
                })
            }), onBeforeUnmount(function () {
                ResponsiveObserve.unsubscribe(Z)
            });
            var ne = computed(function () {
                var ae = [0, 0],
                    oe = C.gutter,
                    ie = oe === void 0 ? 0 : oe,
                    ue = Array.isArray(ie) ? ie : [ie, 0];
                return ue.forEach(function (le, se) {
                    if (_typeof$2(le) === "object")
                        for (var ce = 0; ce < responsiveArray.length; ce++) {
                            var de = responsiveArray[ce];
                            if (Q.value[de] && le[de] !== void 0) {
                                ae[se] = le[de];
                                break
                            }
                        } else ae[se] = le || 0
                }), ae
            });
            useProvideRow({
                gutter: ne,
                supportFlexGap: ee,
                wrap: computed(function () {
                    return C.wrap
                })
            });
            var te = computed(function () {
                    var ae;
                    return classNames(G.value, (ae = {}, _defineProperty$V(ae, "".concat(G.value,
                        "-no-wrap"), C.wrap === !1), _defineProperty$V(ae, "".concat(G.value,
                        "-").concat(C.justify), C.justify), _defineProperty$V(ae, "".concat(G.value,
                        "-").concat(C.align), C.align), _defineProperty$V(ae, "".concat(G.value,
                        "-rtl"), X.value === "rtl"), ae))
                }),
                re = computed(function () {
                    var ae = ne.value,
                        oe = {},
                        ie = ae[0] > 0 ? "".concat(ae[0] / -2, "px") : void 0,
                        ue = ae[1] > 0 ? "".concat(ae[1] / -2, "px") : void 0;
                    return ie && (oe.marginLeft = ie, oe.marginRight = ie), ee.value ? oe.rowGap = "".concat(
                        ae[1], "px") : ue && (oe.marginTop = ue, oe.marginBottom = ue), oe
                });
            return function () {
                var ae;
                return createVNode("div", {
                    class: te.value,
                    style: re.value
                }, [(ae = W.default) === null || ae === void 0 ? void 0 : ae.call(W)])
            }
        }
    });
const Row$3 = ARow;

function parseFlex(K) {
    return typeof K == "number" ? "".concat(K, " ").concat(K, " auto") : /^\d+(\.\d+)?(px|em|rem|%)$/.test(K) ? "0 0 ".concat(
        K) : K
}
var colProps = function () {
    return {
        span: [String, Number],
        order: [String, Number],
        offset: [String, Number],
        push: [String, Number],
        pull: [String, Number],
        xs: {
            type: [String, Number, Object],
            default: void 0
        },
        sm: {
            type: [String, Number, Object],
            default: void 0
        },
        md: {
            type: [String, Number, Object],
            default: void 0
        },
        lg: {
            type: [String, Number, Object],
            default: void 0
        },
        xl: {
            type: [String, Number, Object],
            default: void 0
        },
        xxl: {
            type: [String, Number, Object],
            default: void 0
        },
        xxxl: {
            type: [String, Number, Object],
            default: void 0
        },
        prefixCls: String,
        flex: [String, Number]
    }
};
const Col$1 = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ACol",
        props: colProps(),
        setup: function (C, H) {
            var W = H.slots,
                U = useInjectRow(),
                G = U.gutter,
                X = U.supportFlexGap,
                Z = U.wrap,
                Q = useConfigInject("col", C),
                ee = Q.prefixCls,
                ne = Q.direction,
                te = computed(function () {
                    var ae, oe = C.span,
                        ie = C.order,
                        ue = C.offset,
                        le = C.push,
                        se = C.pull,
                        ce = ee.value,
                        de = {};
                    return ["xs", "sm", "md", "lg", "xl", "xxl", "xxxl"].forEach(function (ve) {
                        var fe, pe = {},
                            me = C[ve];
                        typeof me == "number" ? pe.span = me : _typeof$2(me) === "object" && (pe =
                            me || {}), de = _objectSpread2$1(_objectSpread2$1({}, de), {}, (fe = {},
                            _defineProperty$V(fe, "".concat(ce, "-").concat(ve, "-").concat(
                                pe.span), pe.span !== void 0), _defineProperty$V(fe, "".concat(
                                    ce, "-").concat(ve, "-order-").concat(pe.order), pe.order ||
                                pe.order === 0), _defineProperty$V(fe, "".concat(ce, "-").concat(
                                    ve, "-offset-").concat(pe.offset), pe.offset || pe.offset ===
                                0), _defineProperty$V(fe, "".concat(ce, "-").concat(ve,
                                "-push-").concat(pe.push), pe.push || pe.push === 0),
                            _defineProperty$V(fe, "".concat(ce, "-").concat(ve, "-pull-").concat(
                                pe.pull), pe.pull || pe.pull === 0), _defineProperty$V(fe,
                                "".concat(ce, "-rtl"), ne.value === "rtl"), fe))
                    }), classNames(ce, (ae = {}, _defineProperty$V(ae, "".concat(ce, "-").concat(oe),
                            oe !== void 0), _defineProperty$V(ae, "".concat(ce, "-order-").concat(
                            ie), ie), _defineProperty$V(ae, "".concat(ce, "-offset-").concat(ue),
                            ue), _defineProperty$V(ae, "".concat(ce, "-push-").concat(le), le),
                        _defineProperty$V(ae, "".concat(ce, "-pull-").concat(se), se), ae), de)
                }),
                re = computed(function () {
                    var ae = C.flex,
                        oe = G.value,
                        ie = {};
                    if (oe && oe[0] > 0) {
                        var ue = "".concat(oe[0] / 2, "px");
                        ie.paddingLeft = ue, ie.paddingRight = ue
                    }
                    if (oe && oe[1] > 0 && !X.value) {
                        var le = "".concat(oe[1] / 2, "px");
                        ie.paddingTop = le, ie.paddingBottom = le
                    }
                    return ae && (ie.flex = parseFlex(ae), Z.value === !1 && !ie.minWidth && (ie.minWidth =
                        0)), ie
                });
            return function () {
                var ae;
                return createVNode("div", {
                    class: te.value,
                    style: re.value
                }, [(ae = W.default) === null || ae === void 0 ? void 0 : ae.call(W)])
            }
        }
    }),
    index$j = {
        useBreakpoint
    },
    Row$2 = withInstall(Row$3),
    Col = withInstall(Col$1);
var TabPane = Tabs.TabPane,
    cardProps = function () {
        return {
            prefixCls: String,
            title: PropTypes$1.any,
            extra: PropTypes$1.any,
            bordered: {
                type: Boolean,
                default: !0
            },
            bodyStyle: {
                type: Object,
                default: void 0
            },
            headStyle: {
                type: Object,
                default: void 0
            },
            loading: {
                type: Boolean,
                default: !1
            },
            hoverable: {
                type: Boolean,
                default: !1
            },
            type: {
                type: String
            },
            size: {
                type: String
            },
            actions: PropTypes$1.any,
            tabList: {
                type: Array
            },
            tabBarExtraContent: PropTypes$1.any,
            activeTabKey: String,
            defaultActiveTabKey: String,
            cover: PropTypes$1.any,
            onTabChange: {
                type: Function
            }
        }
    },
    Card = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ACard",
        props: cardProps(),
        slots: ["title", "extra", "tabBarExtraContent", "actions", "cover", "customTab"],
        setup: function (C, H) {
            var W = H.slots,
                U = useConfigInject("card", C),
                G = U.prefixCls,
                X = U.direction,
                Z = U.size,
                Q = function (re) {
                    var ae = re.map(function (oe, ie) {
                        return isVNode(oe) && !isEmptyElement(oe) || !isVNode(oe) ? createVNode("li", {
                            style: {
                                width: "".concat(100 / re.length, "%")
                            },
                            key: "action-".concat(ie)
                        }, [createVNode("span", null, [oe])]) : null
                    });
                    return ae
                },
                ee = function (re) {
                    var ae;
                    (ae = C.onTabChange) === null || ae === void 0 || ae.call(C, re)
                },
                ne = function () {
                    var re = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
                        ae;
                    return re.forEach(function (oe) {
                        oe && isPlainObject(oe.type) && oe.type.__ANT_CARD_GRID && (ae = !0)
                    }), ae
                };
            return function () {
                var te, re, ae, oe, ie, ue, le, se, ce = C.headStyle,
                    de = ce === void 0 ? {} : ce,
                    ve = C.bodyStyle,
                    fe = ve === void 0 ? {} : ve,
                    pe = C.loading,
                    me = C.bordered,
                    he = me === void 0 ? !0 : me,
                    Se = C.type,
                    _e = C.tabList,
                    be = C.hoverable,
                    ge = C.activeTabKey,
                    xe = C.defaultActiveTabKey,
                    Pe = C.tabBarExtraContent,
                    $e = Pe === void 0 ? filterEmptyWithUndefined((te = W.tabBarExtraContent) === null ||
                        te === void 0 ? void 0 : te.call(W)) : Pe,
                    ye = C.title,
                    Ce = ye === void 0 ? filterEmptyWithUndefined((re = W.title) === null || re === void 0 ?
                        void 0 : re.call(W)) : ye,
                    we = C.extra,
                    Oe = we === void 0 ? filterEmptyWithUndefined((ae = W.extra) === null || ae === void 0 ?
                        void 0 : ae.call(W)) : we,
                    Ne = C.actions,
                    Me = Ne === void 0 ? filterEmptyWithUndefined((oe = W.actions) === null || oe === void 0 ?
                        void 0 : oe.call(W)) : Ne,
                    Ve = C.cover,
                    ke = Ve === void 0 ? filterEmptyWithUndefined((ie = W.cover) === null || ie === void 0 ?
                        void 0 : ie.call(W)) : Ve,
                    Ee = flattenChildren((ue = W.default) === null || ue === void 0 ? void 0 : ue.call(W)),
                    Ae = G.value,
                    Re = (le = {}, _defineProperty$V(le, "".concat(Ae), !0), _defineProperty$V(le, "".concat(
                            Ae, "-loading"), pe), _defineProperty$V(le, "".concat(Ae, "-bordered"), he),
                        _defineProperty$V(le, "".concat(Ae, "-hoverable"), !!be), _defineProperty$V(le, "".concat(
                            Ae, "-contain-grid"), ne(Ee)), _defineProperty$V(le, "".concat(Ae,
                            "-contain-tabs"), _e && _e.length), _defineProperty$V(le, "".concat(Ae, "-").concat(
                            Z.value), Z.value), _defineProperty$V(le, "".concat(Ae, "-type-").concat(Se), !
                            !Se), _defineProperty$V(le, "".concat(Ae, "-rtl"), X.value === "rtl"), le),
                    He = fe.padding === 0 || fe.padding === "0px" ? {
                        padding: "24px"
                    } : void 0,
                    je = createVNode("div", {
                        class: "".concat(Ae, "-loading-block")
                    }, null),
                    Fe = createVNode("div", {
                        class: "".concat(Ae, "-loading-content"),
                        style: He
                    }, [createVNode(Row$2, {
                        gutter: 8
                    }, {
                        default: function () {
                            return [createVNode(Col, {
                                span: 22
                            }, {
                                default: function () {
                                    return [je]
                                }
                            })]
                        }
                    }), createVNode(Row$2, {
                        gutter: 8
                    }, {
                        default: function () {
                            return [createVNode(Col, {
                                span: 8
                            }, {
                                default: function () {
                                    return [je]
                                }
                            }), createVNode(Col, {
                                span: 15
                            }, {
                                default: function () {
                                    return [je]
                                }
                            })]
                        }
                    }), createVNode(Row$2, {
                        gutter: 8
                    }, {
                        default: function () {
                            return [createVNode(Col, {
                                span: 6
                            }, {
                                default: function () {
                                    return [je]
                                }
                            }), createVNode(Col, {
                                span: 18
                            }, {
                                default: function () {
                                    return [je]
                                }
                            })]
                        }
                    }), createVNode(Row$2, {
                        gutter: 8
                    }, {
                        default: function () {
                            return [createVNode(Col, {
                                span: 13
                            }, {
                                default: function () {
                                    return [je]
                                }
                            }), createVNode(Col, {
                                span: 9
                            }, {
                                default: function () {
                                    return [je]
                                }
                            })]
                        }
                    }), createVNode(Row$2, {
                        gutter: 8
                    }, {
                        default: function () {
                            return [createVNode(Col, {
                                span: 4
                            }, {
                                default: function () {
                                    return [je]
                                }
                            }), createVNode(Col, {
                                span: 3
                            }, {
                                default: function () {
                                    return [je]
                                }
                            }), createVNode(Col, {
                                span: 16
                            }, {
                                default: function () {
                                    return [je]
                                }
                            })]
                        }
                    })]),
                    Le = ge !== void 0,
                    Ie = (se = {
                            size: "large"
                        }, _defineProperty$V(se, Le ? "activeKey" : "defaultActiveKey", Le ? ge : xe),
                        _defineProperty$V(se, "onChange", ee), _defineProperty$V(se, "class", "".concat(Ae,
                            "-head-tabs")), se),
                    Te, De = _e && _e.length ? createVNode(Tabs, Ie, {
                        default: function () {
                            return [_e.map(function (Ye) {
                                var ze = Ye.tab,
                                    Be = Ye.slots,
                                    Ge = Be == null ? void 0 : Be.tab;
                                devWarning(!Be, "Card",
                                    "tabList slots is deprecated, Please use `customTab` instead."
                                );
                                var Xe = ze !== void 0 ? ze : W[Ge] ? W[Ge](Ye) : null;
                                return Xe = renderSlot(W, "customTab", Ye, function () {
                                    return [Xe]
                                }), createVNode(TabPane, {
                                    tab: Xe,
                                    key: Ye.key,
                                    disabled: Ye.disabled
                                }, null)
                            })]
                        },
                        rightExtra: $e ? function () {
                            return $e
                        } : null
                    }) : null;
                (Ce || Oe || De) && (Te = createVNode("div", {
                    class: "".concat(Ae, "-head"),
                    style: de
                }, [createVNode("div", {
                    class: "".concat(Ae, "-head-wrapper")
                }, [Ce && createVNode("div", {
                    class: "".concat(Ae, "-head-title")
                }, [Ce]), Oe && createVNode("div", {
                    class: "".concat(Ae, "-extra")
                }, [Oe])]), De]));
                var Ke = ke ? createVNode("div", {
                        class: "".concat(Ae, "-cover")
                    }, [ke]) : null,
                    We = createVNode("div", {
                        class: "".concat(Ae, "-body"),
                        style: fe
                    }, [pe ? Fe : Ee]),
                    Ue = Me && Me.length ? createVNode("ul", {
                        class: "".concat(Ae, "-actions")
                    }, [Q(Me)]) : null;
                return createVNode("div", {
                    class: Re,
                    ref: "cardContainerRef"
                }, [Te, Ke, Ee && Ee.length ? We : null, Ue])
            }
        }
    });
const Card$1 = Card;
var cardMetaProps = function () {
    return {
        prefixCls: String,
        title: PropTypes$1.any,
        description: PropTypes$1.any,
        avatar: PropTypes$1.any
    }
};
const Meta = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ACardMeta",
    props: cardMetaProps(),
    slots: ["title", "description", "avatar"],
    setup: function (C, H) {
        var W = H.slots,
            U = useConfigInject("card", C),
            G = U.prefixCls;
        return function () {
            var X = _defineProperty$V({}, "".concat(G.value, "-meta"), !0),
                Z = getPropsSlot(W, C, "avatar"),
                Q = getPropsSlot(W, C, "title"),
                ee = getPropsSlot(W, C, "description"),
                ne = Z ? createVNode("div", {
                    class: "".concat(G.value, "-meta-avatar")
                }, [Z]) : null,
                te = Q ? createVNode("div", {
                    class: "".concat(G.value, "-meta-title")
                }, [Q]) : null,
                re = ee ? createVNode("div", {
                    class: "".concat(G.value, "-meta-description")
                }, [ee]) : null,
                ae = te || re ? createVNode("div", {
                    class: "".concat(G.value, "-meta-detail")
                }, [te, re]) : null;
            return createVNode("div", {
                class: X
            }, [ne, ae])
        }
    }
});
var cardGridProps = function () {
    return {
        prefixCls: String,
        hoverable: {
            type: Boolean,
            default: !0
        }
    }
};
const Grid = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ACardGrid",
    __ANT_CARD_GRID: !0,
    props: cardGridProps(),
    setup: function (C, H) {
        var W = H.slots,
            U = useConfigInject("card", C),
            G = U.prefixCls,
            X = computed(function () {
                var Z;
                return Z = {}, _defineProperty$V(Z, "".concat(G.value, "-grid"), !0), _defineProperty$V(
                    Z, "".concat(G.value, "-grid-hoverable"), C.hoverable), Z
            });
        return function () {
            var Z;
            return createVNode("div", {
                class: X.value
            }, [(Z = W.default) === null || Z === void 0 ? void 0 : Z.call(W)])
        }
    }
});
Card$1.Meta = Meta;
Card$1.Grid = Grid;
Card$1.install = function (K) {
    return K.component(Card$1.name, Card$1), K.component(Meta.name, Meta), K.component(Grid.name, Grid), K
};
var collapseProps = function () {
        return {
            prefixCls: String,
            activeKey: {
                type: [Array, Number, String]
            },
            defaultActiveKey: {
                type: [Array, Number, String]
            },
            accordion: {
                type: Boolean,
                default: void 0
            },
            destroyInactivePanel: {
                type: Boolean,
                default: void 0
            },
            bordered: {
                type: Boolean,
                default: void 0
            },
            expandIcon: Function,
            openAnimation: PropTypes$1.object,
            expandIconPosition: PropTypes$1.oneOf(tuple$1("left", "right")),
            collapsible: {
                type: String
            },
            ghost: {
                type: Boolean,
                default: void 0
            },
            onChange: Function,
            "onUpdate:activeKey": Function
        }
    },
    collapsePanelProps = function () {
        return {
            openAnimation: PropTypes$1.object,
            prefixCls: String,
            header: PropTypes$1.any,
            headerClass: String,
            showArrow: {
                type: Boolean,
                default: void 0
            },
            isActive: {
                type: Boolean,
                default: void 0
            },
            destroyInactivePanel: {
                type: Boolean,
                default: void 0
            },
            disabled: {
                type: Boolean,
                default: void 0
            },
            accordion: {
                type: Boolean,
                default: void 0
            },
            forceRender: {
                type: Boolean,
                default: void 0
            },
            expandIcon: Function,
            extra: PropTypes$1.any,
            panelKey: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number]),
            collapsible: {
                type: String
            },
            role: String,
            onItemClick: {
                type: Function
            }
        }
    };

function getActiveKeysArray(K) {
    var C = K;
    if (!Array.isArray(C)) {
        var H = _typeof$2(C);
        C = H === "number" || H === "string" ? [C] : []
    }
    return C.map(function (W) {
        return String(W)
    })
}
const Collapse = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ACollapse",
        inheritAttrs: !1,
        props: initDefaultProps$1(collapseProps(), {
            accordion: !1,
            destroyInactivePanel: !1,
            bordered: !0,
            openAnimation: collapseMotion$1("ant-motion-collapse", !1),
            expandIconPosition: "left"
        }),
        slots: ["expandIcon"],
        setup: function (C, H) {
            var W = H.attrs,
                U = H.slots,
                G = H.emit,
                X = ref(getActiveKeysArray(firstNotUndefined([C.activeKey, C.defaultActiveKey])));
            watch(function () {
                return C.activeKey
            }, function () {
                X.value = getActiveKeysArray(C.activeKey)
            }, {
                deep: !0
            });
            var Z = useConfigInject("collapse", C),
                Q = Z.prefixCls,
                ee = Z.direction,
                ne = computed(function () {
                    var ue = C.expandIconPosition;
                    return ue !== void 0 ? ue : ee.value === "rtl" ? "right" : "left"
                }),
                te = function (le) {
                    var se = C.expandIcon,
                        ce = se === void 0 ? U.expandIcon : se,
                        de = ce ? ce(le) : createVNode(RightOutlined$1, {
                            rotate: le.isActive ? 90 : void 0
                        }, null);
                    return createVNode("div", null, [isValidElement(Array.isArray(ce) ? de[0] : de) ?
                        cloneElement(de, {
                            class: "".concat(Q.value, "-arrow")
                        }, !1) : de])
                },
                re = function (le) {
                    C.activeKey === void 0 && (X.value = le);
                    var se = C.accordion ? le[0] : le;
                    G("update:activeKey", se), G("change", se)
                },
                ae = function (le) {
                    var se = X.value;
                    if (C.accordion) se = se[0] === le ? [] : [le];
                    else {
                        se = _toConsumableArray(se);
                        var ce = se.indexOf(le),
                            de = ce > -1;
                        de ? se.splice(ce, 1) : se.push(le)
                    }
                    re(se)
                },
                oe = function (le, se) {
                    var ce, de, ve;
                    if (!isEmptyElement(le)) {
                        var fe = X.value,
                            pe = C.accordion,
                            me = C.destroyInactivePanel,
                            he = C.collapsible,
                            Se = C.openAnimation,
                            _e = String((ce = le.key) !== null && ce !== void 0 ? ce : se),
                            be = le.props || {},
                            ge = be.header,
                            xe = ge === void 0 ? (de = le.children) === null || de === void 0 || (ve = de.header) ===
                            null || ve === void 0 ? void 0 : ve.call(de) : ge,
                            Pe = be.headerClass,
                            $e = be.collapsible,
                            ye = be.disabled,
                            Ce = !1;
                        pe ? Ce = fe[0] === _e : Ce = fe.indexOf(_e) > -1;
                        var we = $e || he;
                        (ye || ye === "") && (we = "disabled");
                        var Oe = {
                            key: _e,
                            panelKey: _e,
                            header: xe,
                            headerClass: Pe,
                            isActive: Ce,
                            prefixCls: Q.value,
                            destroyInactivePanel: me,
                            openAnimation: Se,
                            accordion: pe,
                            onItemClick: we === "disabled" ? null : ae,
                            expandIcon: te,
                            collapsible: we
                        };
                        return cloneElement(le, Oe)
                    }
                },
                ie = function () {
                    var le;
                    return flattenChildren((le = U.default) === null || le === void 0 ? void 0 : le.call(U)).map(
                        oe)
                };
            return function () {
                var ue, le = C.accordion,
                    se = C.bordered,
                    ce = C.ghost,
                    de = classNames((ue = {}, _defineProperty$V(ue, Q.value, !0), _defineProperty$V(ue, "".concat(
                        Q.value, "-borderless"), !se), _defineProperty$V(ue, "".concat(Q.value,
                        "-icon-position-").concat(ne.value), !0), _defineProperty$V(ue, "".concat(Q
                        .value, "-rtl"), ee.value === "rtl"), _defineProperty$V(ue, "".concat(Q.value,
                        "-ghost"), !!ce), _defineProperty$V(ue, W.class, !!W.class), ue));
                return createVNode("div", _objectSpread2$1(_objectSpread2$1({
                    class: de
                }, getDataAndAriaProps(W)), {}, {
                    style: W.style,
                    role: le ? "tablist" : null
                }), [ie()])
            }
        }
    }),
    PanelContent = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "PanelContent",
        props: collapsePanelProps(),
        setup: function (C, H) {
            var W = H.slots,
                U = ref(!1);
            return watchEffect(function () {
                    (C.isActive || C.forceRender) && (U.value = !0)
                }),
                function () {
                    var G, X;
                    if (!U.value) return null;
                    var Z = C.prefixCls,
                        Q = C.isActive,
                        ee = C.role;
                    return createVNode("div", {
                        ref,
                        class: classNames("".concat(Z, "-content"), (G = {}, _defineProperty$V(G, "".concat(
                            Z, "-content-active"), Q), _defineProperty$V(G, "".concat(Z,
                            "-content-inactive"), !Q), G)),
                        role: ee
                    }, [createVNode("div", {
                        class: "".concat(Z, "-content-box")
                    }, [(X = W.default) === null || X === void 0 ? void 0 : X.call(W)])])
                }
        }
    }),
    CollapsePanel = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ACollapsePanel",
        inheritAttrs: !1,
        props: initDefaultProps$1(collapsePanelProps(), {
            showArrow: !0,
            isActive: !1,
            onItemClick: function () {},
            headerClass: "",
            forceRender: !1
        }),
        slots: ["expandIcon", "extra", "header"],
        setup: function (C, H) {
            var W = H.slots,
                U = H.emit,
                G = H.attrs;
            devWarning(C.disabled === void 0, "Collapse.Panel",
                '`disabled` is deprecated. Please use `collapsible="disabled"` instead.');
            var X = useConfigInject("collapse", C),
                Z = X.prefixCls,
                Q = function () {
                    U("itemClick", C.panelKey)
                },
                ee = function (te) {
                    (te.key === "Enter" || te.keyCode === 13 || te.which === 13) && Q()
                };
            return function () {
                var ne, te, re, ae, oe = C.header,
                    ie = oe === void 0 ? (ne = W.header) === null || ne === void 0 ? void 0 : ne.call(W) :
                    oe,
                    ue = C.headerClass,
                    le = C.isActive,
                    se = C.showArrow,
                    ce = C.destroyInactivePanel,
                    de = C.accordion,
                    ve = C.forceRender,
                    fe = C.openAnimation,
                    pe = C.expandIcon,
                    me = pe === void 0 ? W.expandIcon : pe,
                    he = C.extra,
                    Se = he === void 0 ? (te = W.extra) === null || te === void 0 ? void 0 : te.call(W) :
                    he,
                    _e = C.collapsible,
                    be = _e === "disabled",
                    ge = Z.value,
                    xe = classNames("".concat(ge, "-header"), (re = {}, _defineProperty$V(re, ue, ue),
                        _defineProperty$V(re, "".concat(ge, "-header-collapsible-only"), _e ===
                            "header"), re)),
                    Pe = classNames((ae = {}, _defineProperty$V(ae, "".concat(ge, "-item"), !0),
                        _defineProperty$V(ae, "".concat(ge, "-item-active"), le), _defineProperty$V(ae,
                            "".concat(ge, "-item-disabled"), be), _defineProperty$V(ae, "".concat(ge,
                            "-no-arrow"), !se), _defineProperty$V(ae, "".concat(G.class), !!G.class),
                        ae)),
                    $e = createVNode("i", {
                        class: "arrow"
                    }, null);
                se && typeof me == "function" && ($e = me(C));
                var ye = withDirectives(createVNode(PanelContent, {
                        prefixCls: ge,
                        isActive: le,
                        forceRender: ve,
                        role: de ? "tabpanel" : null
                    }, {
                        default: W.default
                    }), [[vShow, le]]),
                    Ce = _objectSpread2$1({
                        appear: !1,
                        css: !1
                    }, fe);
                return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, G), {}, {
                    class: Pe
                }), [createVNode("div", {
                    class: xe,
                    onClick: function () {
                        return _e !== "header" && Q()
                    },
                    role: de ? "tab" : "button",
                    tabindex: be ? -1 : 0,
                    "aria-expanded": le,
                    onKeypress: ee
                }, [se && $e, _e === "header" ? createVNode("span", {
                    onClick: Q,
                    class: "".concat(ge, "-header-text")
                }, [ie]) : ie, Se && createVNode("div", {
                    class: "".concat(ge, "-extra")
                }, [Se])]), createVNode(Transition, Ce, {
                    default: function () {
                        return [!ce || le ? ye : null]
                    }
                })])
            }
        }
    });
Collapse.Panel = CollapsePanel;
Collapse.install = function (K) {
    return K.component(Collapse.name, Collapse), K.component(CollapsePanel.name, CollapsePanel), K
};
var camel2hyphen = function (C) {
        return C.replace(/[A-Z]/g, function (H) {
            return "-" + H.toLowerCase()
        }).toLowerCase()
    },
    isDimension = function (C) {
        var H = /[height|width]$/;
        return H.test(C)
    },
    obj2mq = function (C) {
        var H = "",
            W = Object.keys(C);
        return W.forEach(function (U, G) {
            var X = C[U];
            U = camel2hyphen(U), isDimension(U) && typeof X == "number" && (X = X + "px"), X === !0 ? H += U :
                X === !1 ? H += "not " + U : H += "(" + U + ": " + X + ")", G < W.length - 1 && (H += " and ")
        }), H
    };

function json2mq(K) {
    var C = "";
    return typeof K == "string" ? K : K instanceof Array ? (K.forEach(function (H, W) {
        C += obj2mq(H), W < K.length - 1 && (C += ", ")
    }), C) : obj2mq(K)
}
var now$2 = function () {
    return root$2.Date.now()
};
const now$3 = now$2;
var FUNC_ERROR_TEXT = "Expected a function",
    nativeMax$1 = Math.max,
    nativeMin$1 = Math.min;

function debounce(K, C, H) {
    var W, U, G, X, Z, Q, ee = 0,
        ne = !1,
        te = !1,
        re = !0;
    if (typeof K != "function") throw new TypeError(FUNC_ERROR_TEXT);
    C = toNumber(C) || 0, isObject$2(H) && (ne = !!H.leading, te = "maxWait" in H, G = te ? nativeMax$1(toNumber(H.maxWait) ||
        0, C) : G, re = "trailing" in H ? !!H.trailing : re);

    function ae(fe) {
        var pe = W,
            me = U;
        return W = U = void 0, ee = fe, X = K.apply(me, pe), X
    }

    function oe(fe) {
        return ee = fe, Z = setTimeout(le, C), ne ? ae(fe) : X
    }

    function ie(fe) {
        var pe = fe - Q,
            me = fe - ee,
            he = C - pe;
        return te ? nativeMin$1(he, G - me) : he
    }

    function ue(fe) {
        var pe = fe - Q,
            me = fe - ee;
        return Q === void 0 || pe >= C || pe < 0 || te && me >= G
    }

    function le() {
        var fe = now$3();
        if (ue(fe)) return se(fe);
        Z = setTimeout(le, ie(fe))
    }

    function se(fe) {
        return Z = void 0, re && W ? ae(fe) : (W = U = void 0, X)
    }

    function ce() {
        Z !== void 0 && clearTimeout(Z), ee = 0, W = Q = U = Z = void 0
    }

    function de() {
        return Z === void 0 ? X : se(now$3())
    }

    function ve() {
        var fe = now$3(),
            pe = ue(fe);
        if (W = arguments, U = this, Q = fe, pe) {
            if (Z === void 0) return oe(Q);
            if (te) return clearTimeout(Z), Z = setTimeout(le, C), ae(Q)
        }
        return Z === void 0 && (Z = setTimeout(le, C)), X
    }
    return ve.cancel = ce, ve.flush = de, ve
}
var defaultProps$2 = {
    accessibility: {
        type: Boolean,
        default: !0
    },
    adaptiveHeight: {
        type: Boolean,
        default: !1
    },
    afterChange: PropTypes$1.any.def(null),
    arrows: {
        type: Boolean,
        default: !0
    },
    autoplay: {
        type: Boolean,
        default: !1
    },
    autoplaySpeed: PropTypes$1.number.def(3e3),
    beforeChange: PropTypes$1.any.def(null),
    centerMode: {
        type: Boolean,
        default: !1
    },
    centerPadding: PropTypes$1.string.def("50px"),
    cssEase: PropTypes$1.string.def("ease"),
    dots: {
        type: Boolean,
        default: !1
    },
    dotsClass: PropTypes$1.string.def("slick-dots"),
    draggable: {
        type: Boolean,
        default: !0
    },
    unslick: {
        type: Boolean,
        default: !1
    },
    easing: PropTypes$1.string.def("linear"),
    edgeFriction: PropTypes$1.number.def(.35),
    fade: {
        type: Boolean,
        default: !1
    },
    focusOnSelect: {
        type: Boolean,
        default: !1
    },
    infinite: {
        type: Boolean,
        default: !0
    },
    initialSlide: PropTypes$1.number.def(0),
    lazyLoad: PropTypes$1.any.def(null),
    verticalSwiping: {
        type: Boolean,
        default: !1
    },
    asNavFor: PropTypes$1.any.def(null),
    pauseOnDotsHover: {
        type: Boolean,
        default: !1
    },
    pauseOnFocus: {
        type: Boolean,
        default: !1
    },
    pauseOnHover: {
        type: Boolean,
        default: !0
    },
    responsive: PropTypes$1.array,
    rows: PropTypes$1.number.def(1),
    rtl: {
        type: Boolean,
        default: !1
    },
    slide: PropTypes$1.string.def("div"),
    slidesPerRow: PropTypes$1.number.def(1),
    slidesToScroll: PropTypes$1.number.def(1),
    slidesToShow: PropTypes$1.number.def(1),
    speed: PropTypes$1.number.def(500),
    swipe: {
        type: Boolean,
        default: !0
    },
    swipeEvent: PropTypes$1.any.def(null),
    swipeToSlide: {
        type: Boolean,
        default: !1
    },
    touchMove: {
        type: Boolean,
        default: !0
    },
    touchThreshold: PropTypes$1.number.def(5),
    useCSS: {
        type: Boolean,
        default: !0
    },
    useTransform: {
        type: Boolean,
        default: !0
    },
    variableWidth: {
        type: Boolean,
        default: !1
    },
    vertical: {
        type: Boolean,
        default: !1
    },
    waitForAnimate: {
        type: Boolean,
        default: !0
    },
    children: PropTypes$1.array,
    __propsSymbol__: PropTypes$1.any
};
const defaultProps$3 = defaultProps$2;
var initialState = {
    animating: !1,
    autoplaying: null,
    currentDirection: 0,
    currentLeft: null,
    currentSlide: 0,
    direction: 1,
    dragging: !1,
    edgeDragged: !1,
    initialized: !1,
    lazyLoadedList: [],
    listHeight: null,
    listWidth: null,
    scrolling: !1,
    slideCount: null,
    slideHeight: null,
    slideWidth: null,
    swipeLeft: null,
    swiped: !1,
    swiping: !1,
    touchObject: {
        startX: 0,
        startY: 0,
        curX: 0,
        curY: 0
    },
    trackStyle: {},
    trackWidth: 0,
    targetSlide: 0
};
const initialState$1 = initialState;

function clamp(K, C, H) {
    return Math.max(C, Math.min(K, H))
}
var safePreventDefault = function (C) {
        var H = ["touchstart", "touchmove", "wheel"];
        H.includes(C.type) || C.preventDefault()
    },
    getOnDemandLazySlides = function (C) {
        for (var H = [], W = lazyStartIndex(C), U = lazyEndIndex(C), G = W; G < U; G++) C.lazyLoadedList.indexOf(G) < 0 &&
            H.push(G);
        return H
    },
    lazyStartIndex = function (C) {
        return C.currentSlide - lazySlidesOnLeft(C)
    },
    lazyEndIndex = function (C) {
        return C.currentSlide + lazySlidesOnRight(C)
    },
    lazySlidesOnLeft = function (C) {
        return C.centerMode ? Math.floor(C.slidesToShow / 2) + (parseInt(C.centerPadding) > 0 ? 1 : 0) : 0
    },
    lazySlidesOnRight = function (C) {
        return C.centerMode ? Math.floor((C.slidesToShow - 1) / 2) + 1 + (parseInt(C.centerPadding) > 0 ? 1 : 0) : C.slidesToShow
    },
    getWidth = function (C) {
        return C && C.offsetWidth || 0
    },
    getHeight = function (C) {
        return C && C.offsetHeight || 0
    },
    getSwipeDirection = function (C) {
        var H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
            W, U = C.startX - C.curX,
            G = C.startY - C.curY,
            X = Math.atan2(G, U);
        return W = Math.round(X * 180 / Math.PI), W < 0 && (W = 360 - Math.abs(W)), W <= 45 && W >= 0 || W <= 360 && W >=
            315 ? "left" : W >= 135 && W <= 225 ? "right" : H === !0 ? W >= 35 && W <= 135 ? "up" : "down" : "vertical"
    },
    canGoNext = function (C) {
        var H = !0;
        return C.infinite || (C.centerMode && C.currentSlide >= C.slideCount - 1 || C.slideCount <= C.slidesToShow || C
            .currentSlide >= C.slideCount - C.slidesToShow) && (H = !1), H
    },
    extractObject = function (C, H) {
        var W = {};
        return H.forEach(function (U) {
            return W[U] = C[U]
        }), W
    },
    initializedState = function (C) {
        var H = C.children.length,
            W = C.listRef,
            U = Math.ceil(getWidth(W)),
            G = C.trackRef,
            X = Math.ceil(getWidth(G)),
            Z;
        if (C.vertical) Z = U;
        else {
            var Q = C.centerMode && parseInt(C.centerPadding) * 2;
            typeof C.centerPadding == "string" && C.centerPadding.slice(-1) === "%" && (Q *= U / 100), Z = Math.ceil((U -
                Q) / C.slidesToShow)
        }
        var ee = W && getHeight(W.querySelector('[data-index="0"]')),
            ne = ee * C.slidesToShow,
            te = C.currentSlide === void 0 ? C.initialSlide : C.currentSlide;
        C.rtl && C.currentSlide === void 0 && (te = H - 1 - C.initialSlide);
        var re = C.lazyLoadedList || [],
            ae = getOnDemandLazySlides(_objectSpread2$1(_objectSpread2$1({}, C), {}, {
                currentSlide: te,
                lazyLoadedList: re
            }));
        re = re.concat(ae);
        var oe = {
            slideCount: H,
            slideWidth: Z,
            listWidth: U,
            trackWidth: X,
            currentSlide: te,
            slideHeight: ee,
            listHeight: ne,
            lazyLoadedList: re
        };
        return C.autoplaying === null && C.autoplay && (oe.autoplaying = "playing"), oe
    },
    slideHandler = function (C) {
        var H = C.waitForAnimate,
            W = C.animating,
            U = C.fade,
            G = C.infinite,
            X = C.index,
            Z = C.slideCount,
            Q = C.lazyLoad,
            ee = C.currentSlide,
            ne = C.centerMode,
            te = C.slidesToScroll,
            re = C.slidesToShow,
            ae = C.useCSS,
            oe = C.lazyLoadedList;
        if (H && W) return {};
        var ie = X,
            ue, le, se, ce = {},
            de = {},
            ve = G ? X : clamp(X, 0, Z - 1);
        if (U) {
            if (!G && (X < 0 || X >= Z)) return {};
            X < 0 ? ie = X + Z : X >= Z && (ie = X - Z), Q && oe.indexOf(ie) < 0 && (oe = oe.concat(ie)), ce = {
                animating: !0,
                currentSlide: ie,
                lazyLoadedList: oe,
                targetSlide: ie
            }, de = {
                animating: !1,
                targetSlide: ie
            }
        } else ue = ie, ie < 0 ? (ue = ie + Z, G ? Z % te !== 0 && (ue = Z - Z % te) : ue = 0) : !canGoNext(C) && ie >
            ee ? ie = ue = ee : ne && ie >= Z ? (ie = G ? Z : Z - 1, ue = G ? 0 : Z - 1) : ie >= Z && (ue = ie - Z, G ?
                Z % te !== 0 && (ue = 0) : ue = Z - re), !G && ie + re >= Z && (ue = Z - re), le = getTrackLeft(
                _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                    slideIndex: ie
                })), se = getTrackLeft(_objectSpread2$1(_objectSpread2$1({}, C), {}, {
                slideIndex: ue
            })), G || (le === se && (ie = ue), le = se), Q && (oe = oe.concat(getOnDemandLazySlides(_objectSpread2$1(
                _objectSpread2$1({}, C), {}, {
                    currentSlide: ie
                })))), ae ? (ce = {
                animating: !0,
                currentSlide: ue,
                trackStyle: getTrackAnimateCSS(_objectSpread2$1(_objectSpread2$1({}, C), {}, {
                    left: le
                })),
                lazyLoadedList: oe,
                targetSlide: ve
            }, de = {
                animating: !1,
                currentSlide: ue,
                trackStyle: getTrackCSS(_objectSpread2$1(_objectSpread2$1({}, C), {}, {
                    left: se
                })),
                swipeLeft: null,
                targetSlide: ve
            }) : ce = {
                currentSlide: ue,
                trackStyle: getTrackCSS(_objectSpread2$1(_objectSpread2$1({}, C), {}, {
                    left: se
                })),
                lazyLoadedList: oe,
                targetSlide: ve
            };
        return {
            state: ce,
            nextState: de
        }
    },
    changeSlide = function (C, H) {
        var W, U, G, X = C.slidesToScroll,
            Z = C.slidesToShow,
            Q = C.slideCount,
            ee = C.currentSlide,
            ne = C.targetSlide,
            te = C.lazyLoad,
            re = C.infinite,
            ae = Q % X !== 0,
            oe = ae ? 0 : (Q - ee) % X;
        if (H.message === "previous") U = oe === 0 ? X : Z - oe, G = ee - U, te && !re && (W = ee - U, G = W === -1 ? Q -
            1 : W), re || (G = ne - X);
        else if (H.message === "next") U = oe === 0 ? X : oe, G = ee + U, te && !re && (G = (ee + X) % Q + oe), re || (
            G = ne + X);
        else if (H.message === "dots") G = H.index * H.slidesToScroll;
        else if (H.message === "children") {
            if (G = H.index, re) {
                var ie = siblingDirection(_objectSpread2$1(_objectSpread2$1({}, C), {}, {
                    targetSlide: G
                }));
                G > H.currentSlide && ie === "left" ? G = G - Q : G < H.currentSlide && ie === "right" && (G = G + Q)
            }
        } else H.message === "index" && (G = Number(H.index));
        return G
    },
    keyHandler = function (C, H, W) {
        return C.target.tagName.match("TEXTAREA|INPUT|SELECT") || !H ? "" : C.keyCode === 37 ? W ? "next" : "previous" :
            C.keyCode === 39 ? W ? "previous" : "next" : ""
    },
    swipeStart = function (C, H, W) {
        return C.target.tagName === "IMG" && safePreventDefault(C), !H || !W && C.type.indexOf("mouse") !== -1 ? "" : {
            dragging: !0,
            touchObject: {
                startX: C.touches ? C.touches[0].pageX : C.clientX,
                startY: C.touches ? C.touches[0].pageY : C.clientY,
                curX: C.touches ? C.touches[0].pageX : C.clientX,
                curY: C.touches ? C.touches[0].pageY : C.clientY
            }
        }
    },
    swipeMove = function (C, H) {
        var W = H.scrolling,
            U = H.animating,
            G = H.vertical,
            X = H.swipeToSlide,
            Z = H.verticalSwiping,
            Q = H.rtl,
            ee = H.currentSlide,
            ne = H.edgeFriction,
            te = H.edgeDragged,
            re = H.onEdge,
            ae = H.swiped,
            oe = H.swiping,
            ie = H.slideCount,
            ue = H.slidesToScroll,
            le = H.infinite,
            se = H.touchObject,
            ce = H.swipeEvent,
            de = H.listHeight,
            ve = H.listWidth;
        if (!W) {
            if (U) return safePreventDefault(C);
            G && X && Z && safePreventDefault(C);
            var fe, pe = {},
                me = getTrackLeft(H);
            se.curX = C.touches ? C.touches[0].pageX : C.clientX, se.curY = C.touches ? C.touches[0].pageY : C.clientY,
                se.swipeLength = Math.round(Math.sqrt(Math.pow(se.curX - se.startX, 2)));
            var he = Math.round(Math.sqrt(Math.pow(se.curY - se.startY, 2)));
            if (!Z && !oe && he > 10) return {
                scrolling: !0
            };
            Z && (se.swipeLength = he);
            var Se = (Q ? -1 : 1) * (se.curX > se.startX ? 1 : -1);
            Z && (Se = se.curY > se.startY ? 1 : -1);
            var _e = Math.ceil(ie / ue),
                be = getSwipeDirection(H.touchObject, Z),
                ge = se.swipeLength;
            return le || (ee === 0 && (be === "right" || be === "down") || ee + 1 >= _e && (be === "left" || be ===
                    "up") || !canGoNext(H) && (be === "left" || be === "up")) && (ge = se.swipeLength * ne, te === !1 &&
                    re && (re(be), pe.edgeDragged = !0)), !ae && ce && (ce(be), pe.swiped = !0), G ? fe = me + ge * (de /
                    ve) * Se : Q ? fe = me - ge * Se : fe = me + ge * Se, Z && (fe = me + ge * Se), pe =
                _objectSpread2$1(_objectSpread2$1({}, pe), {}, {
                    touchObject: se,
                    swipeLeft: fe,
                    trackStyle: getTrackCSS(_objectSpread2$1(_objectSpread2$1({}, H), {}, {
                        left: fe
                    }))
                }), Math.abs(se.curX - se.startX) < Math.abs(se.curY - se.startY) * .8 || se.swipeLength > 10 && (pe.swiping = !
                    0, safePreventDefault(C)), pe
        }
    },
    swipeEnd = function (C, H) {
        var W = H.dragging,
            U = H.swipe,
            G = H.touchObject,
            X = H.listWidth,
            Z = H.touchThreshold,
            Q = H.verticalSwiping,
            ee = H.listHeight,
            ne = H.swipeToSlide,
            te = H.scrolling,
            re = H.onSwipe,
            ae = H.targetSlide,
            oe = H.currentSlide,
            ie = H.infinite;
        if (!W) return U && safePreventDefault(C), {};
        var ue = Q ? ee / Z : X / Z,
            le = getSwipeDirection(G, Q),
            se = {
                dragging: !1,
                edgeDragged: !1,
                scrolling: !1,
                swiping: !1,
                swiped: !1,
                swipeLeft: null,
                touchObject: {}
            };
        if (te || !G.swipeLength) return se;
        if (G.swipeLength > ue) {
            safePreventDefault(C), re && re(le);
            var ce, de, ve = ie ? oe : ae;
            switch (le) {
                case "left":
                case "up":
                    de = ve + getSlideCount(H), ce = ne ? checkNavigable(H, de) : de, se.currentDirection = 0;
                    break;
                case "right":
                case "down":
                    de = ve - getSlideCount(H), ce = ne ? checkNavigable(H, de) : de, se.currentDirection = 1;
                    break;
                default:
                    ce = ve
            }
            se.triggerSlideHandler = ce
        } else {
            var fe = getTrackLeft(H);
            se.trackStyle = getTrackAnimateCSS(_objectSpread2$1(_objectSpread2$1({}, H), {}, {
                left: fe
            }))
        }
        return se
    },
    getNavigableIndexes = function (C) {
        for (var H = C.infinite ? C.slideCount * 2 : C.slideCount, W = C.infinite ? C.slidesToShow * -1 : 0, U = C.infinite ?
                C.slidesToShow * -1 : 0, G = []; W < H;) G.push(W), W = U + C.slidesToScroll, U += Math.min(C.slidesToScroll,
            C.slidesToShow);
        return G
    },
    checkNavigable = function (C, H) {
        var W = getNavigableIndexes(C),
            U = 0;
        if (H > W[W.length - 1]) H = W[W.length - 1];
        else
            for (var G in W) {
                if (H < W[G]) {
                    H = U;
                    break
                }
                U = W[G]
            }
        return H
    },
    getSlideCount = function (C) {
        var H = C.centerMode ? C.slideWidth * Math.floor(C.slidesToShow / 2) : 0;
        if (C.swipeToSlide) {
            var W, U = C.listRef,
                G = U.querySelectorAll && U.querySelectorAll(".slick-slide") || [];
            if (Array.from(G).every(function (Q) {
                    if (C.vertical) {
                        if (Q.offsetTop + getHeight(Q) / 2 > C.swipeLeft * -1) return W = Q, !1
                    } else if (Q.offsetLeft - H + getWidth(Q) / 2 > C.swipeLeft * -1) return W = Q, !1;
                    return !0
                }), !W) return 0;
            var X = C.rtl === !0 ? C.slideCount - C.currentSlide : C.currentSlide,
                Z = Math.abs(W.dataset.index - X) || 1;
            return Z
        } else return C.slidesToScroll
    },
    checkSpecKeys = function (C, H) {
        return H.reduce(function (W, U) {
            return W && C.hasOwnProperty(U)
        }, !0) ? null : console.error("Keys Missing:", C)
    },
    getTrackCSS = function (C) {
        checkSpecKeys(C, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth"]);
        var H, W, U = C.slideCount + 2 * C.slidesToShow;
        C.vertical ? W = U * C.slideHeight : H = getTotalSlides(C) * C.slideWidth;
        var G = {
            opacity: 1,
            transition: "",
            WebkitTransition: ""
        };
        if (C.useTransform) {
            var X = C.vertical ? "translate3d(0px, " + C.left + "px, 0px)" : "translate3d(" + C.left + "px, 0px, 0px)",
                Z = C.vertical ? "translate3d(0px, " + C.left + "px, 0px)" : "translate3d(" + C.left + "px, 0px, 0px)",
                Q = C.vertical ? "translateY(" + C.left + "px)" : "translateX(" + C.left + "px)";
            G = _objectSpread2$1(_objectSpread2$1({}, G), {}, {
                WebkitTransform: X,
                transform: Z,
                msTransform: Q
            })
        } else C.vertical ? G.top = C.left : G.left = C.left;
        return C.fade && (G = {
                opacity: 1
            }), H && (G.width = H + "px"), W && (G.height = W + "px"), window && !window.addEventListener && window.attachEvent &&
            (C.vertical ? G.marginTop = C.left + "px" : G.marginLeft = C.left + "px"), G
    },
    getTrackAnimateCSS = function (C) {
        checkSpecKeys(C, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth", "speed", "cssEase"]);
        var H = getTrackCSS(C);
        return C.useTransform ? (H.WebkitTransition = "-webkit-transform " + C.speed + "ms " + C.cssEase, H.transition =
                "transform " + C.speed + "ms " + C.cssEase) : C.vertical ? H.transition = "top " + C.speed + "ms " + C.cssEase :
            H.transition = "left " + C.speed + "ms " + C.cssEase, H
    },
    getTrackLeft = function (C) {
        if (C.unslick) return 0;
        checkSpecKeys(C, ["slideIndex", "trackRef", "infinite", "centerMode", "slideCount", "slidesToShow",
            "slidesToScroll", "slideWidth", "listWidth", "variableWidth", "slideHeight"]);
        var H = C.slideIndex,
            W = C.trackRef,
            U = C.infinite,
            G = C.centerMode,
            X = C.slideCount,
            Z = C.slidesToShow,
            Q = C.slidesToScroll,
            ee = C.slideWidth,
            ne = C.listWidth,
            te = C.variableWidth,
            re = C.slideHeight,
            ae = C.fade,
            oe = C.vertical,
            ie = 0,
            ue, le, se = 0;
        if (ae || C.slideCount === 1) return 0;
        var ce = 0;
        if (U ? (ce = -getPreClones(C), X % Q !== 0 && H + Q > X && (ce = -(H > X ? Z - (H - X) : X % Q)), G && (ce +=
                parseInt(Z / 2))) : (X % Q !== 0 && H + Q > X && (ce = Z - X % Q), G && (ce = parseInt(Z / 2))), ie =
            ce * ee, se = ce * re, oe ? ue = H * re * -1 + se : ue = H * ee * -1 + ie, te === !0) {
            var de, ve = W;
            if (de = H + getPreClones(C), le = ve && ve.childNodes[de], ue = le ? le.offsetLeft * -1 : 0, G === !0) {
                de = U ? H + getPreClones(C) : H, le = ve && ve.children[de], ue = 0;
                for (var fe = 0; fe < de; fe++) ue -= ve && ve.children[fe] && ve.children[fe].offsetWidth;
                ue -= parseInt(C.centerPadding), ue += le && (ne - le.offsetWidth) / 2
            }
        }
        return ue
    },
    getPreClones = function (C) {
        return C.unslick || !C.infinite ? 0 : C.variableWidth ? C.slideCount : C.slidesToShow + (C.centerMode ? 1 : 0)
    },
    getPostClones = function (C) {
        return C.unslick || !C.infinite ? 0 : C.slideCount
    },
    getTotalSlides = function (C) {
        return C.slideCount === 1 ? 1 : getPreClones(C) + C.slideCount + getPostClones(C)
    },
    siblingDirection = function (C) {
        return C.targetSlide > C.currentSlide ? C.targetSlide > C.currentSlide + slidesOnRight(C) ? "left" : "right" :
            C.targetSlide < C.currentSlide - slidesOnLeft(C) ? "right" : "left"
    },
    slidesOnRight = function (C) {
        var H = C.slidesToShow,
            W = C.centerMode,
            U = C.rtl,
            G = C.centerPadding;
        if (W) {
            var X = (H - 1) / 2 + 1;
            return parseInt(G) > 0 && (X += 1), U && H % 2 === 0 && (X += 1), X
        }
        return U ? 0 : H - 1
    },
    slidesOnLeft = function (C) {
        var H = C.slidesToShow,
            W = C.centerMode,
            U = C.rtl,
            G = C.centerPadding;
        if (W) {
            var X = (H - 1) / 2 + 1;
            return parseInt(G) > 0 && (X += 1), !U && H % 2 === 0 && (X += 1), X
        }
        return U ? H - 1 : 0
    },
    canUseDOM = function () {
        return !!(typeof window < "u" && window.document && window.document.createElement)
    },
    getSlideClasses = function (C) {
        var H, W, U, G;
        C.rtl ? G = C.slideCount - 1 - C.index : G = C.index;
        var X = G < 0 || G >= C.slideCount;
        C.centerMode ? (U = Math.floor(C.slidesToShow / 2), W = (G - C.currentSlide) % C.slideCount === 0, G > C.currentSlide -
            U - 1 && G <= C.currentSlide + U && (H = !0)) : H = C.currentSlide <= G && G < C.currentSlide + C.slidesToShow;
        var Z;
        C.targetSlide < 0 ? Z = C.targetSlide + C.slideCount : C.targetSlide >= C.slideCount ? Z = C.targetSlide - C.slideCount :
            Z = C.targetSlide;
        var Q = G === Z;
        return {
            "slick-slide": !0,
            "slick-active": H,
            "slick-center": W,
            "slick-cloned": X,
            "slick-current": Q
        }
    },
    getSlideStyle = function (C) {
        var H = {};
        return (C.variableWidth === void 0 || C.variableWidth === !1) && (H.width = C.slideWidth + (typeof C.slideWidth ==
            "number" ? "px" : "")), C.fade && (H.position = "relative", C.vertical ? H.top = -C.index * parseInt(C.slideHeight) +
            "px" : H.left = -C.index * parseInt(C.slideWidth) + "px", H.opacity = C.currentSlide === C.index ? 1 :
            0, C.useCSS && (H.transition = "opacity " + C.speed + "ms " + C.cssEase + ", visibility " + C.speed +
                "ms " + C.cssEase)), H
    },
    getKey$1 = function (C, H) {
        return C.key + "-" + H
    },
    renderSlides = function (C, H) {
        var W, U = [],
            G = [],
            X = [],
            Z = H.length,
            Q = lazyStartIndex(C),
            ee = lazyEndIndex(C);
        return H.forEach(function (ne, te) {
            var re, ae = {
                message: "children",
                index: te,
                slidesToScroll: C.slidesToScroll,
                currentSlide: C.currentSlide
            };
            !C.lazyLoad || C.lazyLoad && C.lazyLoadedList.indexOf(te) >= 0 ? re = ne : re = createVNode("div");
            var oe = getSlideStyle(_objectSpread2$1(_objectSpread2$1({}, C), {}, {
                    index: te
                })),
                ie = re.props.class || "",
                ue = getSlideClasses(_objectSpread2$1(_objectSpread2$1({}, C), {}, {
                    index: te
                }));
            if (U.push(deepCloneElement(re, {
                    key: "original" + getKey$1(re, te),
                    tabindex: "-1",
                    "data-index": te,
                    "aria-hidden": !ue["slick-active"],
                    class: classNames(ue, ie),
                    style: _objectSpread2$1(_objectSpread2$1({
                        outline: "none"
                    }, re.props.style || {}), oe),
                    onClick: function () {
                        C.focusOnSelect && C.focusOnSelect(ae)
                    }
                })), C.infinite && C.fade === !1) {
                var le = Z - te;
                le <= getPreClones(C) && Z !== C.slidesToShow && (W = -le, W >= Q && (re = ne), ue =
                    getSlideClasses(_objectSpread2$1(_objectSpread2$1({}, C), {}, {
                        index: W
                    })), G.push(deepCloneElement(re, {
                        key: "precloned" + getKey$1(re, W),
                        class: classNames(ue, ie),
                        tabindex: "-1",
                        "data-index": W,
                        "aria-hidden": !ue["slick-active"],
                        style: _objectSpread2$1(_objectSpread2$1({}, re.props.style || {}), oe),
                        onClick: function () {
                            C.focusOnSelect && C.focusOnSelect(ae)
                        }
                    }))), Z !== C.slidesToShow && (W = Z + te, W < ee && (re = ne), ue = getSlideClasses(
                    _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                        index: W
                    })), X.push(deepCloneElement(re, {
                    key: "postcloned" + getKey$1(re, W),
                    tabindex: "-1",
                    "data-index": W,
                    "aria-hidden": !ue["slick-active"],
                    class: classNames(ue, ie),
                    style: _objectSpread2$1(_objectSpread2$1({}, re.props.style || {}), oe),
                    onClick: function () {
                        C.focusOnSelect && C.focusOnSelect(ae)
                    }
                })))
            }
        }), C.rtl ? G.concat(U, X).reverse() : G.concat(U, X)
    },
    Track$2 = function (C, H) {
        var W = H.attrs,
            U = H.slots,
            G = renderSlides(W, flattenChildren(U == null ? void 0 : U.default())),
            X = W.onMouseenter,
            Z = W.onMouseover,
            Q = W.onMouseleave,
            ee = {
                onMouseenter: X,
                onMouseover: Z,
                onMouseleave: Q
            },
            ne = _objectSpread2$1({
                class: "slick-track",
                style: W.trackStyle
            }, ee);
        return createVNode("div", ne, [G])
    };
Track$2.inheritAttrs = !1;
const Track$3 = Track$2;
var getDotCount = function (C) {
        var H;
        return C.infinite ? H = Math.ceil(C.slideCount / C.slidesToScroll) : H = Math.ceil((C.slideCount - C.slidesToShow) /
            C.slidesToScroll) + 1, H
    },
    Dots = function (C, H) {
        for (var W = H.attrs, U = W.slideCount, G = W.slidesToScroll, X = W.slidesToShow, Z = W.infinite, Q = W.currentSlide,
                ee = W.appendDots, ne = W.customPaging, te = W.clickHandler, re = W.dotsClass, ae = W.onMouseenter, oe =
                W.onMouseover, ie = W.onMouseleave, ue = getDotCount({
                    slideCount: U,
                    slidesToScroll: G,
                    slidesToShow: X,
                    infinite: Z
                }), le = {
                    onMouseenter: ae,
                    onMouseover: oe,
                    onMouseleave: ie
                }, se = [], ce = function () {
                    var fe = (de + 1) * G - 1,
                        pe = Z ? fe : clamp(fe, 0, U - 1),
                        me = pe - (G - 1),
                        he = Z ? me : clamp(me, 0, U - 1),
                        Se = classNames({
                            "slick-active": Z ? Q >= he && Q <= pe : Q === he
                        }),
                        _e = {
                            message: "dots",
                            index: de,
                            slidesToScroll: G,
                            currentSlide: Q
                        };

                    function be(ge) {
                        ge && ge.preventDefault(), te(_e)
                    }
                    se = se.concat(createVNode("li", {
                        key: de,
                        class: Se
                    }, [cloneElement(ne({
                        i: de
                    }), {
                        onClick: be
                    })]))
                }, de = 0; de < ue; de++) ce();
        return cloneElement(ee({
            dots: se
        }), _objectSpread2$1({
            class: re
        }, le))
    };
Dots.inheritAttrs = !1;
const Dots$1 = Dots;

function noop$9() {}

function handler(K, C, H) {
    H && H.preventDefault(), C(K, H)
}
var PrevArrow = function (C, H) {
    var W = H.attrs,
        U = W.clickHandler,
        G = W.infinite,
        X = W.currentSlide,
        Z = W.slideCount,
        Q = W.slidesToShow,
        ee = {
            "slick-arrow": !0,
            "slick-prev": !0
        },
        ne = function (ie) {
            handler({
                message: "previous"
            }, U, ie)
        };
    !G && (X === 0 || Z <= Q) && (ee["slick-disabled"] = !0, ne = noop$9);
    var te = {
            key: "0",
            "data-role": "none",
            class: ee,
            style: {
                display: "block"
            },
            onClick: ne
        },
        re = {
            currentSlide: X,
            slideCount: Z
        },
        ae;
    return W.prevArrow ? ae = cloneElement(W.prevArrow(_objectSpread2$1(_objectSpread2$1({}, te), re)), {
        key: "0",
        class: ee,
        style: {
            display: "block"
        },
        onClick: ne
    }, !1) : ae = createVNode("button", _objectSpread2$1({
        key: "0",
        type: "button"
    }, te), [" ", createTextVNode("Previous")]), ae
};
PrevArrow.inheritAttrs = !1;
var NextArrow = function (C, H) {
    var W = H.attrs,
        U = W.clickHandler,
        G = W.currentSlide,
        X = W.slideCount,
        Z = {
            "slick-arrow": !0,
            "slick-next": !0
        },
        Q = function (ae) {
            handler({
                message: "next"
            }, U, ae)
        };
    canGoNext(W) || (Z["slick-disabled"] = !0, Q = noop$9);
    var ee = {
            key: "1",
            "data-role": "none",
            class: classNames(Z),
            style: {
                display: "block"
            },
            onClick: Q
        },
        ne = {
            currentSlide: G,
            slideCount: X
        },
        te;
    return W.nextArrow ? te = cloneElement(W.nextArrow(_objectSpread2$1(_objectSpread2$1({}, ee), ne)), {
        key: "1",
        class: classNames(Z),
        style: {
            display: "block"
        },
        onClick: Q
    }, !1) : te = createVNode("button", _objectSpread2$1({
        key: "1",
        type: "button"
    }, ee), [" ", createTextVNode("Next")]), te
};
NextArrow.inheritAttrs = !1;
var _excluded$I = ["animating"];

function noop$8() {}
const InnerSlider = {
        name: "InnerSlider",
        mixins: [BaseMixin],
        inheritAttrs: !1,
        props: _objectSpread2$1({}, defaultProps$3),
        data: function () {
            this.preProps = _objectSpread2$1({}, this.$props), this.list = null, this.track = null, this.callbackTimers = [],
                this.clickable = !0, this.debouncedResize = null;
            var C = this.ssrInit();
            return _objectSpread2$1(_objectSpread2$1({}, initialState$1), {}, {
                currentSlide: this.initialSlide,
                slideCount: this.children.length
            }, C)
        },
        watch: {
            __propsSymbol__: function () {
                for (var C = this, H = this.$props, W = _objectSpread2$1(_objectSpread2$1({
                        listRef: this.list,
                        trackRef: this.track
                    }, H), this.$data), U = !1, G = 0, X = Object.keys(this.preProps); G < X.length; G++) {
                    var Z = X[G];
                    if (!H.hasOwnProperty(Z)) {
                        U = !0;
                        break
                    }
                    if (!(_typeof$2(H[Z]) === "object" || typeof H[Z] == "function" || _typeof$2(H[Z]) === "symbol") &&
                        H[Z] !== this.preProps[Z]) {
                        U = !0;
                        break
                    }
                }
                this.updateState(W, U, function () {
                    C.currentSlide >= H.children.length && C.changeSlide({
                            message: "index",
                            index: H.children.length - H.slidesToShow,
                            currentSlide: C.currentSlide
                        }), !C.preProps.autoplay && H.autoplay ? C.handleAutoPlay("playing") : H.autoplay ?
                        C.handleAutoPlay("update") : C.pause("paused")
                }), this.preProps = _objectSpread2$1({}, H)
            }
        },
        mounted: function () {
            var C = this;
            if (this.__emit("init"), this.lazyLoad) {
                var H = getOnDemandLazySlides(_objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data));
                H.length > 0 && (this.setState(function (W) {
                    return {
                        lazyLoadedList: W.lazyLoadedList.concat(H)
                    }
                }), this.__emit("lazyLoad", H))
            }
            this.$nextTick(function () {
                var W = _objectSpread2$1({
                    listRef: C.list,
                    trackRef: C.track,
                    children: C.children
                }, C.$props);
                C.updateState(W, !0, function () {
                        C.adaptHeight(), C.autoplay && C.handleAutoPlay("playing")
                    }), C.lazyLoad === "progressive" && (C.lazyLoadTimer = setInterval(C.progressiveLazyLoad,
                        1e3)), C.ro = new ResizeObserver$3(function () {
                        C.animating ? (C.onWindowResized(!1), C.callbackTimers.push(setTimeout(function () {
                            return C.onWindowResized()
                        }, C.speed))) : C.onWindowResized()
                    }), C.ro.observe(C.list), document.querySelectorAll && Array.prototype.forEach.call(
                        document.querySelectorAll(".slick-slide"),
                        function (U) {
                            U.onfocus = C.$props.pauseOnFocus ? C.onSlideFocus : null, U.onblur = C.$props.pauseOnFocus ?
                                C.onSlideBlur : null
                        }), window.addEventListener ? window.addEventListener("resize", C.onWindowResized) :
                    window.attachEvent("onresize", C.onWindowResized)
            })
        },
        beforeUnmount: function () {
            var C;
            this.animationEndCallback && clearTimeout(this.animationEndCallback), this.lazyLoadTimer &&
                clearInterval(this.lazyLoadTimer), this.callbackTimers.length && (this.callbackTimers.forEach(
                    function (H) {
                        return clearTimeout(H)
                    }), this.callbackTimers = []), window.addEventListener ? window.removeEventListener("resize",
                    this.onWindowResized) : window.detachEvent("onresize", this.onWindowResized), this.autoplayTimer &&
                clearInterval(this.autoplayTimer), (C = this.ro) === null || C === void 0 || C.disconnect()
        },
        updated: function () {
            if (this.checkImagesLoad(), this.__emit("reInit"), this.lazyLoad) {
                var C = getOnDemandLazySlides(_objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data));
                C.length > 0 && (this.setState(function (H) {
                    return {
                        lazyLoadedList: H.lazyLoadedList.concat(C)
                    }
                }), this.__emit("lazyLoad"))
            }
            this.adaptHeight()
        },
        methods: {
            listRefHandler: function (C) {
                this.list = C
            },
            trackRefHandler: function (C) {
                this.track = C
            },
            adaptHeight: function () {
                if (this.adaptiveHeight && this.list) {
                    var C = this.list.querySelector('[data-index="'.concat(this.currentSlide, '"]'));
                    this.list.style.height = getHeight(C) + "px"
                }
            },
            onWindowResized: function (C) {
                var H = this;
                this.debouncedResize && this.debouncedResize.cancel(), this.debouncedResize = debounce(function () {
                    return H.resizeWindow(C)
                }, 50), this.debouncedResize()
            },
            resizeWindow: function () {
                var C = this,
                    H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0,
                    W = !!this.track;
                if (W) {
                    var U = _objectSpread2$1(_objectSpread2$1({
                        listRef: this.list,
                        trackRef: this.track,
                        children: this.children
                    }, this.$props), this.$data);
                    this.updateState(U, H, function () {
                        C.autoplay ? C.handleAutoPlay("update") : C.pause("paused")
                    }), this.setState({
                        animating: !1
                    }), clearTimeout(this.animationEndCallback), delete this.animationEndCallback
                }
            },
            updateState: function (C, H, W) {
                var U = initializedState(C);
                C = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, C), U), {}, {
                    slideIndex: U.currentSlide
                });
                var G = getTrackLeft(C);
                C = _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                    left: G
                });
                var X = getTrackCSS(C);
                (H || this.children.length !== C.children.length) && (U.trackStyle = X), this.setState(U, W)
            },
            ssrInit: function () {
                var C = this.children;
                if (this.variableWidth) {
                    var H = 0,
                        W = 0,
                        U = [],
                        G = getPreClones(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data), {}, {
                            slideCount: C.length
                        })),
                        X = getPostClones(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, this.$props), this
                            .$data), {}, {
                            slideCount: C.length
                        }));
                    C.forEach(function (ce) {
                        var de, ve, fe = ((de = ce.props.style) === null || de === void 0 || (ve = de.width) ===
                            null || ve === void 0 ? void 0 : ve.split("px")[0]) || 0;
                        U.push(fe), H += fe
                    });
                    for (var Z = 0; Z < G; Z++) W += U[U.length - 1 - Z], H += U[U.length - 1 - Z];
                    for (var Q = 0; Q < X; Q++) H += U[Q];
                    for (var ee = 0; ee < this.currentSlide; ee++) W += U[ee];
                    var ne = {
                        width: H + "px",
                        left: -W + "px"
                    };
                    if (this.centerMode) {
                        var te = "".concat(U[this.currentSlide], "px");
                        ne.left = "calc(".concat(ne.left, " + (100% - ").concat(te, ") / 2 ) ")
                    }
                    return {
                        trackStyle: ne
                    }
                }
                var re = C.length,
                    ae = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data), {}, {
                        slideCount: re
                    }),
                    oe = getPreClones(ae) + getPostClones(ae) + re,
                    ie = 100 / this.slidesToShow * oe,
                    ue = 100 / oe,
                    le = -ue * (getPreClones(ae) + this.currentSlide) * ie / 100;
                this.centerMode && (le += (100 - ue * ie / 100) / 2);
                var se = {
                    width: ie + "%",
                    left: le + "%"
                };
                return {
                    slideWidth: ue + "%",
                    trackStyle: se
                }
            },
            checkImagesLoad: function () {
                var C = this,
                    H = this.list && this.list.querySelectorAll && this.list.querySelectorAll(".slick-slide img") ||
                    [],
                    W = H.length,
                    U = 0;
                Array.prototype.forEach.call(H, function (G) {
                    var X = function () {
                        return ++U && U >= W && C.onWindowResized()
                    };
                    if (!G.onclick) G.onclick = function () {
                        return G.parentNode.focus()
                    };
                    else {
                        var Z = G.onclick;
                        G.onclick = function () {
                            Z(), G.parentNode.focus()
                        }
                    }
                    G.onload || (C.$props.lazyLoad ? G.onload = function () {
                        C.adaptHeight(), C.callbackTimers.push(setTimeout(C.onWindowResized, C.speed))
                    } : (G.onload = X, G.onerror = function () {
                        X(), C.__emit("lazyLoadError")
                    }))
                })
            },
            progressiveLazyLoad: function () {
                for (var C = [], H = _objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data), W = this.currentSlide; W <
                    this.slideCount + getPostClones(H); W++)
                    if (this.lazyLoadedList.indexOf(W) < 0) {
                        C.push(W);
                        break
                    } for (var U = this.currentSlide - 1; U >= -getPreClones(H); U--)
                    if (this.lazyLoadedList.indexOf(U) < 0) {
                        C.push(U);
                        break
                    } C.length > 0 ? (this.setState(function (G) {
                    return {
                        lazyLoadedList: G.lazyLoadedList.concat(C)
                    }
                }), this.__emit("lazyLoad", C)) : this.lazyLoadTimer && (clearInterval(this.lazyLoadTimer),
                    delete this.lazyLoadTimer)
            },
            slideHandler: function (C) {
                var H = this,
                    W = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
                    U = this.$props,
                    G = U.asNavFor,
                    X = U.currentSlide,
                    Z = U.beforeChange,
                    Q = U.speed,
                    ee = U.afterChange,
                    ne = slideHandler(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                        index: C
                    }, this.$props), this.$data), {}, {
                        trackRef: this.track,
                        useCSS: this.useCSS && !W
                    })),
                    te = ne.state,
                    re = ne.nextState;
                if (te) {
                    Z && Z(X, te.currentSlide);
                    var ae = te.lazyLoadedList.filter(function (oe) {
                        return H.lazyLoadedList.indexOf(oe) < 0
                    });
                    this.$attrs.onLazyLoad && ae.length > 0 && this.__emit("lazyLoad", ae), !this.$props.waitForAnimate &&
                        this.animationEndCallback && (clearTimeout(this.animationEndCallback), ee && ee(X), delete this
                            .animationEndCallback), this.setState(te, function () {
                            G && H.asNavForIndex !== C && (H.asNavForIndex = C, G.innerSlider.slideHandler(C)),
                                re && (H.animationEndCallback = setTimeout(function () {
                                    var oe = re.animating,
                                        ie = _objectWithoutProperties$2(re, _excluded$I);
                                    H.setState(ie, function () {
                                        H.callbackTimers.push(setTimeout(function () {
                                            return H.setState({
                                                animating: oe
                                            })
                                        }, 10)), ee && ee(te.currentSlide), delete H.animationEndCallback
                                    })
                                }, Q))
                        })
                }
            },
            changeSlide: function (C) {
                var H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
                    W = _objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data),
                    U = changeSlide(W, C);
                if (!(U !== 0 && !U) && (H === !0 ? this.slideHandler(U, H) : this.slideHandler(U), this.$props.autoplay &&
                        this.handleAutoPlay("update"), this.$props.focusOnSelect)) {
                    var G = this.list.querySelectorAll(".slick-current");
                    G[0] && G[0].focus()
                }
            },
            clickHandler: function (C) {
                this.clickable === !1 && (C.stopPropagation(), C.preventDefault()), this.clickable = !0
            },
            keyHandler: function (C) {
                var H = keyHandler(C, this.accessibility, this.rtl);
                H !== "" && this.changeSlide({
                    message: H
                })
            },
            selectHandler: function (C) {
                this.changeSlide(C)
            },
            disableBodyScroll: function () {
                var C = function (W) {
                    W = W || window.event, W.preventDefault && W.preventDefault(), W.returnValue = !1
                };
                window.ontouchmove = C
            },
            enableBodyScroll: function () {
                window.ontouchmove = null
            },
            swipeStart: function (C) {
                this.verticalSwiping && this.disableBodyScroll();
                var H = swipeStart(C, this.swipe, this.draggable);
                H !== "" && this.setState(H)
            },
            swipeMove: function (C) {
                var H = swipeMove(C, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data), {}, {
                    trackRef: this.track,
                    listRef: this.list,
                    slideIndex: this.currentSlide
                }));
                H && (H.swiping && (this.clickable = !1), this.setState(H))
            },
            swipeEnd: function (C) {
                var H = swipeEnd(C, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data), {}, {
                    trackRef: this.track,
                    listRef: this.list,
                    slideIndex: this.currentSlide
                }));
                if (H) {
                    var W = H.triggerSlideHandler;
                    delete H.triggerSlideHandler, this.setState(H), W !== void 0 && (this.slideHandler(W), this.$props
                        .verticalSwiping && this.enableBodyScroll())
                }
            },
            touchEnd: function (C) {
                this.swipeEnd(C), this.clickable = !0
            },
            slickPrev: function () {
                var C = this;
                this.callbackTimers.push(setTimeout(function () {
                    return C.changeSlide({
                        message: "previous"
                    })
                }, 0))
            },
            slickNext: function () {
                var C = this;
                this.callbackTimers.push(setTimeout(function () {
                    return C.changeSlide({
                        message: "next"
                    })
                }, 0))
            },
            slickGoTo: function (C) {
                var H = this,
                    W = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
                if (C = Number(C), isNaN(C)) return "";
                this.callbackTimers.push(setTimeout(function () {
                    return H.changeSlide({
                        message: "index",
                        index: C,
                        currentSlide: H.currentSlide
                    }, W)
                }, 0))
            },
            play: function () {
                var C;
                if (this.rtl) C = this.currentSlide - this.slidesToScroll;
                else if (canGoNext(_objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data))) C = this.currentSlide +
                    this.slidesToScroll;
                else return !1;
                this.slideHandler(C)
            },
            handleAutoPlay: function (C) {
                this.autoplayTimer && clearInterval(this.autoplayTimer);
                var H = this.autoplaying;
                if (C === "update") {
                    if (H === "hovered" || H === "focused" || H === "paused") return
                } else if (C === "leave") {
                    if (H === "paused" || H === "focused") return
                } else if (C === "blur" && (H === "paused" || H === "hovered")) return;
                this.autoplayTimer = setInterval(this.play, this.autoplaySpeed + 50), this.setState({
                    autoplaying: "playing"
                })
            },
            pause: function (C) {
                this.autoplayTimer && (clearInterval(this.autoplayTimer), this.autoplayTimer = null);
                var H = this.autoplaying;
                C === "paused" ? this.setState({
                    autoplaying: "paused"
                }) : C === "focused" ? (H === "hovered" || H === "playing") && this.setState({
                    autoplaying: "focused"
                }) : H === "playing" && this.setState({
                    autoplaying: "hovered"
                })
            },
            onDotsOver: function () {
                this.autoplay && this.pause("hovered")
            },
            onDotsLeave: function () {
                this.autoplay && this.autoplaying === "hovered" && this.handleAutoPlay("leave")
            },
            onTrackOver: function () {
                this.autoplay && this.pause("hovered")
            },
            onTrackLeave: function () {
                this.autoplay && this.autoplaying === "hovered" && this.handleAutoPlay("leave")
            },
            onSlideFocus: function () {
                this.autoplay && this.pause("focused")
            },
            onSlideBlur: function () {
                this.autoplay && this.autoplaying === "focused" && this.handleAutoPlay("blur")
            },
            customPaging: function (C) {
                var H = C.i;
                return createVNode("button", null, [H + 1])
            },
            appendDots: function (C) {
                var H = C.dots;
                return createVNode("ul", {
                    style: {
                        display: "block"
                    }
                }, [H])
            }
        },
        render: function () {
            var C, H = this,
                W = classNames("slick-slider", this.$attrs.class, {
                    "slick-vertical": this.vertical, "slick-initialized": !0
                }),
                U = _objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data),
                G = extractObject(U, ["fade", "cssEase", "speed", "infinite", "centerMode", "focusOnSelect",
                    "currentSlide", "lazyLoad", "lazyLoadedList", "rtl", "slideWidth", "slideHeight",
                    "listHeight", "vertical", "slidesToShow", "slidesToScroll", "slideCount", "trackStyle",
                    "variableWidth", "unslick", "centerPadding", "targetSlide", "useCSS"]),
                X = this.$props.pauseOnHover;
            G = _objectSpread2$1(_objectSpread2$1({}, G), {}, {
                focusOnSelect: this.focusOnSelect && this.clickable ? this.selectHandler : null,
                ref: this.trackRefHandler,
                onMouseleave: X ? this.onTrackLeave : noop$8,
                onMouseover: X ? this.onTrackOver : noop$8
            });
            var Z;
            if (this.dots === !0 && this.slideCount >= this.slidesToShow) {
                var Q = extractObject(U, ["dotsClass", "slideCount", "slidesToShow", "currentSlide",
                    "slidesToScroll", "clickHandler", "children", "infinite", "appendDots"]);
                Q.customPaging = this.customPaging, Q.appendDots = this.appendDots;
                var ee = this.$slots,
                    ne = ee.customPaging,
                    te = ee.appendDots;
                ne && (Q.customPaging = ne), te && (Q.appendDots = te);
                var re = this.$props.pauseOnDotsHover;
                Q = _objectSpread2$1(_objectSpread2$1({}, Q), {}, {
                    clickHandler: this.changeSlide,
                    onMouseover: re ? this.onDotsOver : noop$8,
                    onMouseleave: re ? this.onDotsLeave : noop$8
                }), Z = createVNode(Dots$1, Q, null)
            }
            var ae, oe, ie = extractObject(U, ["infinite", "centerMode", "currentSlide", "slideCount",
                "slidesToShow"]);
            ie.clickHandler = this.changeSlide;
            var ue = this.$slots,
                le = ue.prevArrow,
                se = ue.nextArrow;
            le && (ie.prevArrow = le), se && (ie.nextArrow = se), this.arrows && (ae = createVNode(PrevArrow, ie,
                null), oe = createVNode(NextArrow, ie, null));
            var ce = null;
            this.vertical && (ce = {
                height: typeof this.listHeight == "number" ? "".concat(this.listHeight, "px") : this.listHeight
            });
            var de = null;
            this.vertical === !1 ? this.centerMode === !0 && (de = {
                padding: "0px " + this.centerPadding
            }) : this.centerMode === !0 && (de = {
                padding: this.centerPadding + " 0px"
            });
            var ve = _objectSpread2$1(_objectSpread2$1({}, ce), de),
                fe = this.touchMove,
                pe = (C = {
                        ref: this.listRefHandler,
                        class: "slick-list",
                        style: ve,
                        onClick: this.clickHandler,
                        onMousedown: fe ? this.swipeStart : noop$8,
                        onMousemove: this.dragging && fe ? this.swipeMove : noop$8,
                        onMouseup: fe ? this.swipeEnd : noop$8,
                        onMouseleave: this.dragging && fe ? this.swipeEnd : noop$8
                    }, _defineProperty$V(C, supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart", fe ? this.swipeStart :
                        noop$8), _defineProperty$V(C, supportsPassive$1 ? "onTouchmovePassive" : "onTouchmove",
                        this.dragging && fe ? this.swipeMove : noop$8), _defineProperty$V(C, "onTouchend", fe ?
                        this.touchEnd : noop$8), _defineProperty$V(C, "onTouchcancel", this.dragging && fe ? this.swipeEnd :
                        noop$8), _defineProperty$V(C, "onKeydown", this.accessibility ? this.keyHandler : noop$8),
                    C),
                me = {
                    class: W,
                    dir: "ltr",
                    style: this.$attrs.style
                };
            return this.unslick && (pe = {
                class: "slick-list",
                ref: this.listRefHandler
            }, me = {
                class: W
            }), createVNode("div", me, [this.unslick ? "" : ae, createVNode("div", pe, [createVNode(Track$3, G, {
                default: function () {
                    return [H.children]
                }
            })]), this.unslick ? "" : oe, this.unslick ? "" : Z])
        }
    },
    Slider$2 = defineComponent({
        name: "Slider",
        mixins: [BaseMixin],
        inheritAttrs: !1,
        props: _objectSpread2$1({}, defaultProps$3),
        data: function () {
            return this._responsiveMediaHandlers = [], {
                breakpoint: null
            }
        },
        mounted: function () {
            var C = this;
            if (this.responsive) {
                var H = this.responsive.map(function (U) {
                    return U.breakpoint
                });
                H.sort(function (U, G) {
                    return U - G
                }), H.forEach(function (U, G) {
                    var X;
                    G === 0 ? X = json2mq({
                        minWidth: 0,
                        maxWidth: U
                    }) : X = json2mq({
                        minWidth: H[G - 1] + 1,
                        maxWidth: U
                    }), canUseDOM() && C.media(X, function () {
                        C.setState({
                            breakpoint: U
                        })
                    })
                });
                var W = json2mq({
                    minWidth: H.slice(-1)[0]
                });
                canUseDOM() && this.media(W, function () {
                    C.setState({
                        breakpoint: null
                    })
                })
            }
        },
        beforeUnmount: function () {
            this._responsiveMediaHandlers.forEach(function (C) {
                C.mql.removeListener(C.listener)
            })
        },
        methods: {
            innerSliderRefHandler: function (C) {
                this.innerSlider = C
            },
            media: function (C, H) {
                var W = window.matchMedia(C),
                    U = function (X) {
                        var Z = X.matches;
                        Z && H()
                    };
                W.addListener(U), U(W), this._responsiveMediaHandlers.push({
                    mql: W,
                    query: C,
                    listener: U
                })
            },
            slickPrev: function () {
                var C;
                (C = this.innerSlider) === null || C === void 0 || C.slickPrev()
            },
            slickNext: function () {
                var C;
                (C = this.innerSlider) === null || C === void 0 || C.slickNext()
            },
            slickGoTo: function (C) {
                var H, W = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
                (H = this.innerSlider) === null || H === void 0 || H.slickGoTo(C, W)
            },
            slickPause: function () {
                var C;
                (C = this.innerSlider) === null || C === void 0 || C.pause("paused")
            },
            slickPlay: function () {
                var C;
                (C = this.innerSlider) === null || C === void 0 || C.handleAutoPlay("play")
            }
        },
        render: function () {
            var C = this,
                H, W;
            this.breakpoint ? (W = this.responsive.filter(function (ie) {
                return ie.breakpoint === C.breakpoint
            }), H = W[0].settings === "unslick" ? "unslick" : _objectSpread2$1(_objectSpread2$1({},
                this.$props), W[0].settings)) : H = _objectSpread2$1({}, this.$props), H.centerMode && (H.slidesToScroll >
                1, H.slidesToScroll = 1), H.fade && (H.slidesToShow > 1, H.slidesToScroll > 1, H.slidesToShow =
                1, H.slidesToScroll = 1);
            var U = getSlot(this) || [];
            U = U.filter(function (ie) {
                return typeof ie == "string" ? !!ie.trim() : !!ie
            }), H.variableWidth && (H.rows > 1 || H.slidesPerRow > 1) && (console.warn(
                    "variableWidth is not supported in case of rows > 1 or slidesPerRow > 1"), H.variableWidth = !
                1);
            for (var G = [], X = null, Z = 0; Z < U.length; Z += H.rows * H.slidesPerRow) {
                for (var Q = [], ee = Z; ee < Z + H.rows * H.slidesPerRow; ee += H.slidesPerRow) {
                    for (var ne = [], te = ee; te < ee + H.slidesPerRow; te += 1) {
                        var re;
                        if (H.variableWidth && (re = U[te].props) !== null && re !== void 0 && re.style && (X =
                                U[te].props.style.width), te >= U.length) break;
                        ne.push(cloneElement(U[te], {
                            key: 100 * Z + 10 * ee + te,
                            tabindex: -1,
                            style: {
                                width: "".concat(100 / H.slidesPerRow, "%"),
                                display: "inline-block"
                            }
                        }))
                    }
                    Q.push(createVNode("div", {
                        key: 10 * Z + ee
                    }, [ne]))
                }
                H.variableWidth ? G.push(createVNode("div", {
                    key: Z,
                    style: {
                        width: X
                    }
                }, [Q])) : G.push(createVNode("div", {
                    key: Z
                }, [Q]))
            }
            if (H === "unslick") {
                var ae = "regular slider " + (this.className || "");
                return createVNode("div", {
                    class: ae
                }, [U])
            } else G.length <= H.slidesToShow && (H.unslick = !0);
            var oe = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, this.$attrs), H), {}, {
                children: G,
                ref: this.innerSliderRefHandler
            });
            return createVNode(InnerSlider, _objectSpread2$1(_objectSpread2$1({}, oe), {}, {
                __propsSymbol__: []
            }), this.$slots)
        }
    });
var _excluded$H = ["class", "style"],
    carouselProps = function () {
        return {
            effect: String,
            dots: {
                type: Boolean,
                default: !0
            },
            vertical: {
                type: Boolean,
                default: void 0
            },
            autoplay: {
                type: Boolean,
                default: void 0
            },
            easing: String,
            beforeChange: Function,
            afterChange: Function,
            prefixCls: String,
            accessibility: {
                type: Boolean,
                default: void 0
            },
            nextArrow: PropTypes$1.any,
            prevArrow: PropTypes$1.any,
            pauseOnHover: {
                type: Boolean,
                default: void 0
            },
            adaptiveHeight: {
                type: Boolean,
                default: void 0
            },
            arrows: {
                type: Boolean,
                default: !1
            },
            autoplaySpeed: Number,
            centerMode: {
                type: Boolean,
                default: void 0
            },
            centerPadding: String,
            cssEase: String,
            dotsClass: String,
            draggable: {
                type: Boolean,
                default: !1
            },
            fade: {
                type: Boolean,
                default: void 0
            },
            focusOnSelect: {
                type: Boolean,
                default: void 0
            },
            infinite: {
                type: Boolean,
                default: void 0
            },
            initialSlide: Number,
            lazyLoad: String,
            rtl: {
                type: Boolean,
                default: void 0
            },
            slide: String,
            slidesToShow: Number,
            slidesToScroll: Number,
            speed: Number,
            swipe: {
                type: Boolean,
                default: void 0
            },
            swipeToSlide: {
                type: Boolean,
                default: void 0
            },
            swipeEvent: Function,
            touchMove: {
                type: Boolean,
                default: void 0
            },
            touchThreshold: Number,
            variableWidth: {
                type: Boolean,
                default: void 0
            },
            useCSS: {
                type: Boolean,
                default: void 0
            },
            slickGoTo: Number,
            responsive: Array,
            dotPosition: {
                type: String,
                default: void 0
            },
            verticalSwiping: {
                type: Boolean,
                default: !1
            }
        }
    },
    Carousel = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ACarousel",
        inheritAttrs: !1,
        props: carouselProps(),
        setup: function (C, H) {
            var W = H.slots,
                U = H.attrs,
                G = H.expose,
                X = ref(),
                Z = function (ie) {
                    var ue, le = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
                    (ue = X.value) === null || ue === void 0 || ue.slickGoTo(ie, le)
                };
            G({
                goTo: Z,
                autoplay: function (ie) {
                    var ue, le;
                    (ue = X.value) === null || ue === void 0 || (le = ue.innerSlider) === null ||
                        le === void 0 || le.handleAutoPlay(ie)
                },
                prev: function () {
                    var ie;
                    (ie = X.value) === null || ie === void 0 || ie.slickPrev()
                },
                next: function () {
                    var ie;
                    (ie = X.value) === null || ie === void 0 || ie.slickNext()
                },
                innerSlider: computed(function () {
                    var oe;
                    return (oe = X.value) === null || oe === void 0 ? void 0 : oe.innerSlider
                })
            }), watchEffect(function () {
                warning$2(C.vertical === void 0, "Carousel",
                    "`vertical` is deprecated, please use `dotPosition` instead.")
            });
            var Q = useConfigInject("carousel", C),
                ee = Q.prefixCls,
                ne = Q.direction,
                te = computed(function () {
                    return C.dotPosition ? C.dotPosition : C.vertical !== void 0 && C.vertical ? "right" :
                        "bottom"
                }),
                re = computed(function () {
                    return te.value === "left" || te.value === "right"
                }),
                ae = computed(function () {
                    var oe, ie = "slick-dots";
                    return classNames((oe = {}, _defineProperty$V(oe, ie, !0), _defineProperty$V(oe, "".concat(
                        ie, "-").concat(te.value), !0), _defineProperty$V(oe, "".concat(C.dotsClass),
                        !!C.dotsClass), oe))
                });
            return function () {
                var oe, ie = C.dots,
                    ue = C.arrows,
                    le = C.draggable,
                    se = C.effect,
                    ce = U.class,
                    de = U.style,
                    ve = _objectWithoutProperties$2(U, _excluded$H),
                    fe = se === "fade" ? !0 : C.fade,
                    pe = classNames(ee.value, (oe = {}, _defineProperty$V(oe, "".concat(ee.value, "-rtl"),
                        ne.value === "rtl"), _defineProperty$V(oe, "".concat(ee.value, "-vertical"),
                        re.value), _defineProperty$V(oe, "".concat(ce), !!ce), oe));
                return createVNode("div", {
                    class: pe,
                    style: de
                }, [createVNode(Slider$2, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                    ref: X
                }, C), ve), {}, {
                    dots: !!ie,
                    dotsClass: ae.value,
                    arrows: ue,
                    draggable: le,
                    fade: fe,
                    vertical: re.value
                }), W)])
            }
        }
    });
const index$i = withInstall(Carousel);
var VALUE_SPLIT = "__RC_CASCADER_SPLIT__",
    SHOW_PARENT$1 = "SHOW_PARENT",
    SHOW_CHILD$1 = "SHOW_CHILD";

function toPathKey(K) {
    return K.join(VALUE_SPLIT)
}

function toPathKeys(K) {
    return K.map(toPathKey)
}

function toPathValueStr(K) {
    return K.split(VALUE_SPLIT)
}

function fillFieldNames$2(K) {
    var C = K || {},
        H = C.label,
        W = C.value,
        U = C.children,
        G = W || "value";
    return {
        label: H || "label",
        value: G,
        key: G,
        children: U || "children"
    }
}

function isLeaf(K, C) {
    var H, W;
    return (H = K.isLeaf) !== null && H !== void 0 ? H : !((W = K[C.children]) !== null && W !== void 0 && W.length)
}

function scrollIntoParentView(K) {
    var C = K.parentElement;
    if (C) {
        var H = K.offsetTop - C.offsetTop;
        H - C.scrollTop < 0 ? C.scrollTo({
            top: H
        }) : H + K.offsetHeight - C.scrollTop > C.offsetHeight && C.scrollTo({
            top: H + K.offsetHeight - C.offsetHeight
        })
    }
}
var TreeContextKey = Symbol("TreeContextKey"),
    TreeContext = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "TreeContext",
        props: {
            value: {
                type: Object
            }
        },
        setup: function (C, H) {
            var W = H.slots;
            return provide(TreeContextKey, computed(function () {
                    return C.value
                })),
                function () {
                    var U;
                    return (U = W.default) === null || U === void 0 ? void 0 : U.call(W)
                }
        }
    }),
    useInjectTreeContext = function () {
        return inject(TreeContextKey, computed(function () {
            return {}
        }))
    },
    KeysStateKey = Symbol("KeysStateKey"),
    useProvideKeysState = function (C) {
        provide(KeysStateKey, C)
    },
    useInjectKeysState = function () {
        return inject(KeysStateKey, {
            expandedKeys: shallowRef([]),
            selectedKeys: shallowRef([]),
            loadedKeys: shallowRef([]),
            loadingKeys: shallowRef([]),
            checkedKeys: shallowRef([]),
            halfCheckedKeys: shallowRef([]),
            expandedKeysSet: computed(function () {
                return new Set
            }),
            selectedKeysSet: computed(function () {
                return new Set
            }),
            loadedKeysSet: computed(function () {
                return new Set
            }),
            loadingKeysSet: computed(function () {
                return new Set
            }),
            checkedKeysSet: computed(function () {
                return new Set
            }),
            halfCheckedKeysSet: computed(function () {
                return new Set
            }),
            flattenNodes: shallowRef([])
        })
    },
    Indent = function (C) {
        for (var H = C.prefixCls, W = C.level, U = C.isStart, G = C.isEnd, X = "".concat(H, "-indent-unit"), Z = [], Q =
                0; Q < W; Q += 1) {
            var ee;
            Z.push(createVNode("span", {
                key: Q,
                class: (ee = {}, _defineProperty$V(ee, X, !0), _defineProperty$V(ee, "".concat(X, "-start"),
                    U[Q]), _defineProperty$V(ee, "".concat(X, "-end"), G[Q]), ee)
            }, null))
        }
        return createVNode("span", {
            "aria-hidden": "true",
            class: "".concat(H, "-indent")
        }, [Z])
    };
const Indent$1 = Indent;
var treeNodeProps = {
        eventKey: [String, Number],
        prefixCls: String,
        title: PropTypes$1.any,
        data: {
            type: Object,
            default: void 0
        },
        parent: {
            type: Object,
            default: void 0
        },
        isStart: {
            type: Array
        },
        isEnd: {
            type: Array
        },
        active: {
            type: Boolean,
            default: void 0
        },
        onMousemove: {
            type: Function
        },
        isLeaf: {
            type: Boolean,
            default: void 0
        },
        checkable: {
            type: Boolean,
            default: void 0
        },
        selectable: {
            type: Boolean,
            default: void 0
        },
        disabled: {
            type: Boolean,
            default: void 0
        },
        disableCheckbox: {
            type: Boolean,
            default: void 0
        },
        icon: PropTypes$1.any,
        switcherIcon: PropTypes$1.any,
        domRef: {
            type: Function
        }
    },
    nodeListProps = {
        prefixCls: {
            type: String
        },
        motion: {
            type: Object
        },
        focusable: {
            type: Boolean
        },
        activeItem: {
            type: Object
        },
        focused: {
            type: Boolean
        },
        tabindex: {
            type: Number
        },
        checkable: {
            type: Boolean
        },
        selectable: {
            type: Boolean
        },
        disabled: {
            type: Boolean
        },
        height: {
            type: Number
        },
        itemHeight: {
            type: Number
        },
        virtual: {
            type: Boolean
        },
        onScroll: {
            type: Function
        },
        onKeydown: {
            type: Function
        },
        onFocus: {
            type: Function
        },
        onBlur: {
            type: Function
        },
        onActiveChange: {
            type: Function
        },
        onContextmenu: {
            type: Function
        },
        onListChangeStart: {
            type: Function
        },
        onListChangeEnd: {
            type: Function
        }
    },
    treeProps$1 = function () {
        return {
            prefixCls: String,
            focusable: {
                type: Boolean,
                default: void 0
            },
            activeKey: [Number, String],
            tabindex: Number,
            children: PropTypes$1.any,
            treeData: {
                type: Array
            },
            fieldNames: {
                type: Object
            },
            showLine: {
                type: [Boolean, Object],
                default: void 0
            },
            showIcon: {
                type: Boolean,
                default: void 0
            },
            icon: PropTypes$1.any,
            selectable: {
                type: Boolean,
                default: void 0
            },
            disabled: {
                type: Boolean,
                default: void 0
            },
            multiple: {
                type: Boolean,
                default: void 0
            },
            checkable: {
                type: Boolean,
                default: void 0
            },
            checkStrictly: {
                type: Boolean,
                default: void 0
            },
            draggable: {
                type: [Function, Boolean]
            },
            defaultExpandParent: {
                type: Boolean,
                default: void 0
            },
            autoExpandParent: {
                type: Boolean,
                default: void 0
            },
            defaultExpandAll: {
                type: Boolean,
                default: void 0
            },
            defaultExpandedKeys: {
                type: Array
            },
            expandedKeys: {
                type: Array
            },
            defaultCheckedKeys: {
                type: Array
            },
            checkedKeys: {
                type: [Object, Array]
            },
            defaultSelectedKeys: {
                type: Array
            },
            selectedKeys: {
                type: Array
            },
            allowDrop: {
                type: Function
            },
            dropIndicatorRender: {
                type: Function
            },
            onFocus: {
                type: Function
            },
            onBlur: {
                type: Function
            },
            onKeydown: {
                type: Function
            },
            onContextmenu: {
                type: Function
            },
            onClick: {
                type: Function
            },
            onDblclick: {
                type: Function
            },
            onScroll: {
                type: Function
            },
            onExpand: {
                type: Function
            },
            onCheck: {
                type: Function
            },
            onSelect: {
                type: Function
            },
            onLoad: {
                type: Function
            },
            loadData: {
                type: Function
            },
            loadedKeys: {
                type: Array
            },
            onMouseenter: {
                type: Function
            },
            onMouseleave: {
                type: Function
            },
            onRightClick: {
                type: Function
            },
            onDragstart: {
                type: Function
            },
            onDragenter: {
                type: Function
            },
            onDragover: {
                type: Function
            },
            onDragleave: {
                type: Function
            },
            onDragend: {
                type: Function
            },
            onDrop: {
                type: Function
            },
            onActiveChange: {
                type: Function
            },
            filterTreeNode: {
                type: Function
            },
            motion: PropTypes$1.any,
            switcherIcon: PropTypes$1.any,
            height: Number,
            itemHeight: Number,
            virtual: {
                type: Boolean,
                default: void 0
            },
            direction: {
                type: String
            }
        }
    },
    _excluded$G = ["eventKey", "isLeaf", "isStart", "isEnd", "domRef", "active", "data", "onMousemove", "selectable"],
    ICON_OPEN = "open",
    ICON_CLOSE = "close",
    defaultTitle = "---";
const VcTreeNode = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "TreeNode",
    inheritAttrs: !1,
    props: treeNodeProps,
    isTreeNode: 1,
    slots: ["title", "icon", "switcherIcon"],
    setup: function (C, H) {
        var W = H.attrs,
            U = H.slots,
            G = H.expose;
        "slots" in C.data, "treeData slots is deprecated, please use ".concat(Object.keys(C.data.slots || {})
            .map(function (ot) {
                return "`v-slot:" + ot + "` "
            }), "instead");
        var X = ref(!1),
            Z = useInjectTreeContext(),
            Q = useInjectKeysState(),
            ee = Q.expandedKeysSet,
            ne = Q.selectedKeysSet,
            te = Q.loadedKeysSet,
            re = Q.loadingKeysSet,
            ae = Q.checkedKeysSet,
            oe = Q.halfCheckedKeysSet,
            ie = Z.value,
            ue = ie.dragOverNodeKey,
            le = ie.dropPosition,
            se = ie.keyEntities,
            ce = computed(function () {
                return getTreeNodeProps(C.eventKey, {
                    expandedKeysSet: ee.value,
                    selectedKeysSet: ne.value,
                    loadedKeysSet: te.value,
                    loadingKeysSet: re.value,
                    checkedKeysSet: ae.value,
                    halfCheckedKeysSet: oe.value,
                    dragOverNodeKey: ue,
                    dropPosition: le,
                    keyEntities: se
                })
            }),
            de = eagerComputed(function () {
                return ce.value.expanded
            }),
            ve = eagerComputed(function () {
                return ce.value.selected
            }),
            fe = eagerComputed(function () {
                return ce.value.checked
            }),
            pe = eagerComputed(function () {
                return ce.value.loaded
            }),
            me = eagerComputed(function () {
                return ce.value.loading
            }),
            he = eagerComputed(function () {
                return ce.value.halfChecked
            }),
            Se = eagerComputed(function () {
                return ce.value.dragOver
            }),
            _e = eagerComputed(function () {
                return ce.value.dragOverGapTop
            }),
            be = eagerComputed(function () {
                return ce.value.dragOverGapBottom
            }),
            ge = eagerComputed(function () {
                return ce.value.pos
            }),
            xe = ref(),
            Pe = computed(function () {
                var ot = C.eventKey,
                    Ze = Z.value.keyEntities,
                    ut = Ze[ot] || {},
                    st = ut.children;
                return !!(st || []).length
            }),
            $e = computed(function () {
                var ot = C.isLeaf,
                    Ze = Z.value.loadData,
                    ut = Pe.value;
                return ot === !1 ? !1 : ot || !Ze && !ut || Ze && pe.value && !ut
            }),
            ye = computed(function () {
                return $e.value ? null : de.value ? ICON_OPEN : ICON_CLOSE
            }),
            Ce = computed(function () {
                var ot = C.disabled,
                    Ze = Z.value.disabled;
                return !!(Ze || ot)
            }),
            we = computed(function () {
                var ot = C.checkable,
                    Ze = Z.value.checkable;
                return !Ze || ot === !1 ? !1 : Ze
            }),
            Oe = computed(function () {
                var ot = C.selectable,
                    Ze = Z.value.selectable;
                return typeof ot == "boolean" ? ot : Ze
            }),
            Ne = computed(function () {
                var ot = C.data,
                    Ze = C.active,
                    ut = C.checkable,
                    st = C.disableCheckbox,
                    rt = C.disabled,
                    qe = C.selectable;
                return _objectSpread2$1(_objectSpread2$1({
                    active: Ze,
                    checkable: ut,
                    disableCheckbox: st,
                    disabled: rt,
                    selectable: qe
                }, ot), {}, {
                    dataRef: ot,
                    data: ot,
                    isLeaf: $e.value,
                    checked: fe.value,
                    expanded: de.value,
                    loading: me.value,
                    selected: ve.value,
                    halfChecked: he.value
                })
            }),
            Me = getCurrentInstance(),
            Ve = computed(function () {
                var ot = C.eventKey,
                    Ze = Z.value.keyEntities,
                    ut = Ze[ot] || {},
                    st = ut.parent;
                return _objectSpread2$1(_objectSpread2$1({}, convertNodePropsToEventData(_extends$1({},
                    C, ce.value))), {}, {
                    parent: st
                })
            }),
            ke = reactive({
                eventData: Ve,
                eventKey: computed(function () {
                    return C.eventKey
                }),
                selectHandle: xe,
                pos: ge,
                key: Me.vnode.key
            });
        G(ke);
        var Ee = function (Ze) {
                var ut = Z.value.onNodeDoubleClick;
                ut(Ze, Ve.value)
            },
            Ae = function (Ze) {
                if (!Ce.value) {
                    var ut = Z.value.onNodeSelect;
                    Ze.preventDefault(), ut(Ze, Ve.value)
                }
            },
            Re = function (Ze) {
                if (!Ce.value) {
                    var ut = C.disableCheckbox,
                        st = Z.value.onNodeCheck;
                    if (!(!we.value || ut)) {
                        Ze.preventDefault();
                        var rt = !fe.value;
                        st(Ze, Ve.value, rt)
                    }
                }
            },
            He = function (Ze) {
                var ut = Z.value.onNodeClick;
                ut(Ze, Ve.value), Oe.value ? Ae(Ze) : Re(Ze)
            },
            je = function (Ze) {
                var ut = Z.value.onNodeMouseEnter;
                ut(Ze, Ve.value)
            },
            Fe = function (Ze) {
                var ut = Z.value.onNodeMouseLeave;
                ut(Ze, Ve.value)
            },
            Le = function (Ze) {
                var ut = Z.value.onNodeContextMenu;
                ut(Ze, Ve.value)
            },
            Ie = function (Ze) {
                var ut = Z.value.onNodeDragStart;
                Ze.stopPropagation(), X.value = !0, ut(Ze, ke);
                try {
                    Ze.dataTransfer.setData("text/plain", "")
                } catch {}
            },
            Te = function (Ze) {
                var ut = Z.value.onNodeDragEnter;
                Ze.preventDefault(), Ze.stopPropagation(), ut(Ze, ke)
            },
            De = function (Ze) {
                var ut = Z.value.onNodeDragOver;
                Ze.preventDefault(), Ze.stopPropagation(), ut(Ze, ke)
            },
            Ke = function (Ze) {
                var ut = Z.value.onNodeDragLeave;
                Ze.stopPropagation(), ut(Ze, ke)
            },
            We = function (Ze) {
                var ut = Z.value.onNodeDragEnd;
                Ze.stopPropagation(), X.value = !1, ut(Ze, ke)
            },
            Ue = function (Ze) {
                var ut = Z.value.onNodeDrop;
                Ze.preventDefault(), Ze.stopPropagation(), X.value = !1, ut(Ze, ke)
            },
            et = function (Ze) {
                var ut = Z.value.onNodeExpand;
                me.value || ut(Ze, Ve.value)
            },
            Ye = function () {
                var Ze = C.data,
                    ut = Z.value.draggable;
                return !!(ut && (!ut.nodeDraggable || ut.nodeDraggable(Ze)))
            },
            ze = function () {
                var Ze = Z.value,
                    ut = Ze.draggable,
                    st = Ze.prefixCls;
                return ut != null && ut.icon ? createVNode("span", {
                    class: "".concat(st, "-draggable-icon")
                }, [ut.icon]) : null
            },
            Be = function () {
                var Ze, ut, st, rt = C.switcherIcon,
                    qe = rt === void 0 ? U.switcherIcon || ((Ze = Z.value.slots) === null || Ze === void 0 ?
                        void 0 : Ze[(ut = C.data) === null || ut === void 0 || (st = ut.slots) === null ||
                            st === void 0 ? void 0 : st.switcherIcon]) : rt,
                    Je = Z.value.switcherIcon,
                    Qe = qe || Je;
                return typeof Qe == "function" ? Qe(Ne.value) : Qe
            },
            Ge = function () {
                var Ze = Z.value,
                    ut = Ze.loadData,
                    st = Ze.onNodeLoad;
                me.value || ut && de.value && !$e.value && !Pe.value && !pe.value && st(Ve.value)
            };
        onMounted(function () {
            Ge()
        }), onUpdated(function () {
            Ge()
        });
        var Xe = function () {
                var Ze = Z.value.prefixCls,
                    ut = Be();
                if ($e.value) return ut !== !1 ? createVNode("span", {
                    class: classNames("".concat(Ze, "-switcher"), "".concat(Ze,
                        "-switcher-noop"))
                }, [ut]) : null;
                var st = classNames("".concat(Ze, "-switcher"), "".concat(Ze, "-switcher_").concat(de.value ?
                    ICON_OPEN : ICON_CLOSE));
                return ut !== !1 ? createVNode("span", {
                    onClick: et,
                    class: st
                }, [ut]) : null
            },
            nt = function () {
                var Ze, ut, st = C.disableCheckbox,
                    rt = Z.value.prefixCls,
                    qe = Ce.value,
                    Je = we.value;
                return Je ? createVNode("span", {
                    class: classNames("".concat(rt, "-checkbox"), fe.value && "".concat(rt,
                        "-checkbox-checked"), !fe.value && he.value && "".concat(rt,
                        "-checkbox-indeterminate"), (qe || st) && "".concat(rt,
                        "-checkbox-disabled")),
                    onClick: Re
                }, [(Ze = (ut = Z.value).customCheckable) === null || Ze === void 0 ? void 0 : Ze.call(
                    ut)]) : null
            },
            it = function () {
                var Ze = Z.value.prefixCls;
                return createVNode("span", {
                    class: classNames("".concat(Ze, "-iconEle"), "".concat(Ze, "-icon__").concat(ye
                        .value || "docu"), me.value && "".concat(Ze, "-icon_loading"))
                }, null)
            },
            ft = function () {
                var Ze = C.disabled,
                    ut = C.eventKey,
                    st = Z.value,
                    rt = st.draggable,
                    qe = st.dropLevelOffset,
                    Je = st.dropPosition,
                    Qe = st.prefixCls,
                    lt = st.indent,
                    ct = st.dropIndicatorRender,
                    dt = st.dragOverNodeKey,
                    tt = st.direction,
                    at = rt !== !1,
                    vt = !Ze && at && dt === ut;
                return vt ? ct({
                    dropPosition: Je,
                    dropLevelOffset: qe,
                    indent: lt,
                    prefixCls: Qe,
                    direction: tt
                }) : null
            },
            pt = function () {
                var Ze, ut, st, rt, qe = C.icon,
                    Je = qe === void 0 ? U.icon : qe,
                    Qe = C.data,
                    lt = U.title || ((Ze = Z.value.slots) === null || Ze === void 0 ? void 0 : Ze[(ut = C.data) ===
                        null || ut === void 0 || (st = ut.slots) === null || st === void 0 ? void 0 :
                        st.title]) || ((rt = Z.value.slots) === null || rt === void 0 ? void 0 : rt.title) ||
                    C.title,
                    ct = Z.value,
                    dt = ct.prefixCls,
                    tt = ct.showIcon,
                    at = ct.icon,
                    vt = ct.loadData,
                    gt = Ce.value,
                    mt = "".concat(dt, "-node-content-wrapper"),
                    ht;
                if (tt) {
                    var yt, St, Ct = Je || ((yt = Z.value.slots) === null || yt === void 0 ? void 0 : yt[Qe ==
                        null || (St = Qe.slots) === null || St === void 0 ? void 0 : St.icon]) || at;
                    ht = Ct ? createVNode("span", {
                        class: classNames("".concat(dt, "-iconEle"), "".concat(dt,
                            "-icon__customize"))
                    }, [typeof Ct == "function" ? Ct(Ne.value) : Ct]) : it()
                } else vt && me.value && (ht = it());
                var _t;
                typeof lt == "function" ? _t = lt(Ne.value) : _t = lt, _t = _t === void 0 ? defaultTitle :
                    _t;
                var wt = createVNode("span", {
                    class: "".concat(dt, "-title")
                }, [_t]);
                return createVNode("span", {
                    ref: xe,
                    title: typeof lt == "string" ? lt : "",
                    class: classNames("".concat(mt), "".concat(mt, "-").concat(ye.value || "normal"),
                        !gt && (ve.value || X.value) && "".concat(dt, "-node-selected")),
                    onMouseenter: je,
                    onMouseleave: Fe,
                    onContextmenu: Le,
                    onClick: He,
                    onDblclick: Ee
                }, [ht, wt, ft()])
            };
        return function () {
            var ot, Ze = _objectSpread2$1(_objectSpread2$1({}, C), W),
                ut = Ze.eventKey,
                st = Ze.isLeaf,
                rt = Ze.isStart,
                qe = Ze.isEnd,
                Je = Ze.domRef,
                Qe = Ze.active;
            Ze.data;
            var lt = Ze.onMousemove,
                ct = Ze.selectable,
                dt = _objectWithoutProperties$2(Ze, _excluded$G),
                tt = Z.value,
                at = tt.prefixCls,
                vt = tt.filterTreeNode,
                gt = tt.keyEntities,
                mt = tt.dropContainerKey,
                ht = tt.dropTargetKey,
                yt = tt.draggingNodeKey,
                St = Ce.value,
                Ct = pickAttrs(dt, {
                    aria: !0,
                    data: !0
                }),
                _t = gt[ut] || {},
                wt = _t.level,
                Et = qe[qe.length - 1],
                xt = Ye(),
                kt = !St && xt,
                Nt = yt === ut,
                Rt = ct !== void 0 ? {
                    "aria-selected": !!ct
                } : void 0;
            return createVNode("div", _objectSpread2$1(_objectSpread2$1({
                ref: Je,
                class: classNames(W.class, "".concat(at, "-treenode"), (ot = {},
                    _defineProperty$V(ot, "".concat(at, "-treenode-disabled"),
                        St), _defineProperty$V(ot, "".concat(at,
                        "-treenode-switcher-").concat(de.value ? "open" :
                        "close"), !st), _defineProperty$V(ot, "".concat(at,
                        "-treenode-checkbox-checked"), fe.value),
                    _defineProperty$V(ot, "".concat(at,
                        "-treenode-checkbox-indeterminate"), he.value),
                    _defineProperty$V(ot, "".concat(at, "-treenode-selected"),
                        ve.value), _defineProperty$V(ot, "".concat(at,
                        "-treenode-loading"), me.value), _defineProperty$V(ot,
                        "".concat(at, "-treenode-active"), Qe),
                    _defineProperty$V(ot, "".concat(at, "-treenode-leaf-last"),
                        Et), _defineProperty$V(ot, "".concat(at,
                        "-treenode-draggable"), kt), _defineProperty$V(ot,
                        "dragging", Nt), _defineProperty$V(ot, "drop-target",
                        ht === ut), _defineProperty$V(ot, "drop-container", mt ===
                        ut), _defineProperty$V(ot, "drag-over", !St && Se.value),
                    _defineProperty$V(ot, "drag-over-gap-top", !St && _e.value),
                    _defineProperty$V(ot, "drag-over-gap-bottom", !St && be.value),
                    _defineProperty$V(ot, "filter-node", vt && vt(Ve.value)),
                    ot)),
                style: W.style,
                draggable: kt,
                "aria-grabbed": Nt,
                onDragstart: kt ? Ie : void 0,
                onDragenter: xt ? Te : void 0,
                onDragover: xt ? De : void 0,
                onDragleave: xt ? Ke : void 0,
                onDrop: xt ? Ue : void 0,
                onDragend: xt ? We : void 0,
                onMousemove: lt
            }, Rt), Ct), [createVNode(Indent$1, {
                prefixCls: at,
                level: wt,
                isStart: rt,
                isEnd: qe
            }, null), ze(), Xe(), nt(), pt()])
        }
    }
});

function arrDel(K, C) {
    if (!K) return [];
    var H = K.slice(),
        W = H.indexOf(C);
    return W >= 0 && H.splice(W, 1), H
}

function arrAdd(K, C) {
    var H = (K || []).slice();
    return H.indexOf(C) === -1 && H.push(C), H
}

function posToArr(K) {
    return K.split("-")
}

function getPosition(K, C) {
    return "".concat(K, "-").concat(C)
}

function isTreeNode(K) {
    return K && K.type && K.type.isTreeNode
}

function getDragChildrenKeys(K, C) {
    var H = [],
        W = C[K];

    function U() {
        var G = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        G.forEach(function (X) {
            var Z = X.key,
                Q = X.children;
            H.push(Z), U(Q)
        })
    }
    return U(W.children), H
}

function isLastChild(K) {
    if (K.parent) {
        var C = posToArr(K.pos);
        return Number(C[C.length - 1]) === K.parent.children.length - 1
    }
    return !1
}

function isFirstChild(K) {
    var C = posToArr(K.pos);
    return Number(C[C.length - 1]) === 0
}

function calcDropPosition(K, C, H, W, U, G, X, Z, Q, ee) {
    var ne, te = K.clientX,
        re = K.clientY,
        ae = K.target.getBoundingClientRect(),
        oe = ae.top,
        ie = ae.height,
        ue = (ee === "rtl" ? -1 : 1) * (((U == null ? void 0 : U.x) || 0) - te),
        le = (ue - 12) / W,
        se = Z[H.eventKey];
    if (re < oe + ie / 2) {
        var ce = X.findIndex(function (Pe) {
                return Pe.key === se.key
            }),
            de = ce <= 0 ? 0 : ce - 1,
            ve = X[de].key;
        se = Z[ve]
    }
    var fe = se.key,
        pe = se,
        me = se.key,
        he = 0,
        Se = 0;
    if (!Q.has(fe))
        for (var _e = 0; _e < le && isLastChild(se); _e += 1) se = se.parent, Se += 1;
    var be = C.eventData,
        ge = se.node,
        xe = !0;
    return isFirstChild(se) && se.level === 0 && re < oe + ie / 2 && G({
        dragNode: be,
        dropNode: ge,
        dropPosition: -1
    }) && se.key === H.eventKey ? he = -1 : (pe.children || []).length && Q.has(me) ? G({
        dragNode: be,
        dropNode: ge,
        dropPosition: 0
    }) ? he = 0 : xe = !1 : Se === 0 ? le > -1.5 ? G({
        dragNode: be,
        dropNode: ge,
        dropPosition: 1
    }) ? he = 1 : xe = !1 : G({
        dragNode: be,
        dropNode: ge,
        dropPosition: 0
    }) ? he = 0 : G({
        dragNode: be,
        dropNode: ge,
        dropPosition: 1
    }) ? he = 1 : xe = !1 : G({
        dragNode: be,
        dropNode: ge,
        dropPosition: 1
    }) ? he = 1 : xe = !1, {
        dropPosition: he,
        dropLevelOffset: Se,
        dropTargetKey: se.key,
        dropTargetPos: se.pos,
        dragOverNodeKey: me,
        dropContainerKey: he === 0 ? null : ((ne = se.parent) === null || ne === void 0 ? void 0 : ne.key) || null,
        dropAllowed: xe
    }
}

function calcSelectedKeys(K, C) {
    if (K) {
        var H = C.multiple;
        return H ? K.slice() : K.length ? [K[0]] : K
    }
}

function parseCheckedKeys(K) {
    if (!K) return null;
    var C;
    if (Array.isArray(K)) C = {
        checkedKeys: K,
        halfCheckedKeys: void 0
    };
    else if (_typeof$2(K) === "object") C = {
        checkedKeys: K.checked || void 0,
        halfCheckedKeys: K.halfChecked || void 0
    };
    else return null;
    return C
}

function conductExpandParent(K, C) {
    var H = new Set;

    function W(U) {
        if (!H.has(U)) {
            var G = C[U];
            if (G) {
                H.add(U);
                var X = G.parent,
                    Z = G.node;
                Z.disabled || X && W(X.key)
            }
        }
    }
    return (K || []).forEach(function (U) {
        W(U)
    }), _toConsumableArray(H)
}
var _excluded$F = ["title", "icon", "switcherIcon"];

function getKey(K, C) {
    return K || C
}

function fillFieldNames$1(K) {
    var C = K || {},
        H = C.title,
        W = C._title,
        U = C.key,
        G = C.children,
        X = H || "title";
    return {
        title: X,
        _title: W || [X],
        key: U || "key",
        children: G || "children"
    }
}

function convertTreeToData(K) {
    function C() {
        var H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
            W = filterEmpty(H);
        return W.map(function (U) {
            var G, X, Z, Q;
            if (!isTreeNode(U)) return null;
            for (var ee = U.children || {}, ne = U.key, te = {}, re = 0, ae = Object.entries(U.props); re < ae.length; re++) {
                var oe = _slicedToArray$2(ae[re], 2),
                    ie = oe[0],
                    ue = oe[1];
                te[camelize$1(ie)] = ue
            }
            var le = te.isLeaf,
                se = te.checkable,
                ce = te.selectable,
                de = te.disabled,
                ve = te.disableCheckbox,
                fe = {
                    isLeaf: le || le === "" || void 0,
                    checkable: se || se === "" || void 0,
                    selectable: ce || ce === "" || void 0,
                    disabled: de || de === "" || void 0,
                    disableCheckbox: ve || ve === "" || void 0
                },
                pe = _objectSpread2$1(_objectSpread2$1({}, te), fe),
                me = te.title,
                he = me === void 0 ? (G = ee.title) === null || G === void 0 ? void 0 : G.call(ee, pe) : me,
                Se = te.icon,
                _e = Se === void 0 ? (X = ee.icon) === null || X === void 0 ? void 0 : X.call(ee, pe) : Se,
                be = te.switcherIcon,
                ge = be === void 0 ? (Z = ee.switcherIcon) === null || Z === void 0 ? void 0 : Z.call(ee, pe) :
                be,
                xe = _objectWithoutProperties$2(te, _excluded$F),
                Pe = (Q = ee.default) === null || Q === void 0 ? void 0 : Q.call(ee),
                $e = _objectSpread2$1(_objectSpread2$1({}, xe), {}, {
                    title: he,
                    icon: _e,
                    switcherIcon: ge,
                    key: ne,
                    isLeaf: le
                }, fe),
                ye = C(Pe);
            return ye.length && ($e.children = ye), $e
        })
    }
    return C(K)
}

function flattenTreeData(K, C, H) {
    var W = fillFieldNames$1(H),
        U = W._title,
        G = W.key,
        X = W.children,
        Z = new Set(C === !0 ? [] : C),
        Q = [];

    function ee(ne) {
        var te = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        return ne.map(function (re, ae) {
            for (var oe = getPosition(te ? te.pos : "0", ae), ie = getKey(re[G], oe), ue, le = 0; le < U.length; le +=
                1) {
                var se = U[le];
                if (re[se] !== void 0) {
                    ue = re[se];
                    break
                }
            }
            var ce = _objectSpread2$1(_objectSpread2$1({}, omit$2(re, [].concat(_toConsumableArray(U), [G, X]))), {}, {
                title: ue,
                key: ie,
                parent: te,
                pos: oe,
                children: null,
                data: re,
                isStart: [].concat(_toConsumableArray(te ? te.isStart : []), [ae === 0]),
                isEnd: [].concat(_toConsumableArray(te ? te.isEnd : []), [ae === ne.length - 1])
            });
            return Q.push(ce), C === !0 || Z.has(ie) ? ce.children = ee(re[X] || [], ce) : ce.children = [], ce
        })
    }
    return ee(K), Q
}

function traverseDataNodes(K, C, H) {
    var W = {};
    _typeof$2(H) === "object" ? W = H : W = {
        externalGetKey: H
    }, W = W || {};
    var U = W,
        G = U.childrenPropName,
        X = U.externalGetKey,
        Z = U.fieldNames,
        Q = fillFieldNames$1(Z),
        ee = Q.key,
        ne = Q.children,
        te = G || ne,
        re;
    X ? typeof X == "string" ? re = function (ie) {
        return ie[X]
    } : typeof X == "function" && (re = function (ie) {
        return X(ie)
    }) : re = function (ie, ue) {
        return getKey(ie[ee], ue)
    };

    function ae(oe, ie, ue, le) {
        var se = oe ? oe[te] : K,
            ce = oe ? getPosition(ue.pos, ie) : "0",
            de = oe ? [].concat(_toConsumableArray(le), [oe]) : [];
        if (oe) {
            var ve = re(oe, ce),
                fe = {
                    node: oe,
                    index: ie,
                    pos: ce,
                    key: ve,
                    parentPos: ue.node ? ue.pos : null,
                    level: ue.level + 1,
                    nodes: de
                };
            C(fe)
        }
        se && se.forEach(function (pe, me) {
            ae(pe, me, {
                node: oe,
                pos: ce,
                level: ue ? ue.level + 1 : -1
            }, de)
        })
    }
    ae(null)
}

function convertDataToEntities(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        H = C.initWrapper,
        W = C.processEntity,
        U = C.onProcessFinished,
        G = C.externalGetKey,
        X = C.childrenPropName,
        Z = C.fieldNames,
        Q = arguments.length > 2 ? arguments[2] : void 0,
        ee = G || Q,
        ne = {},
        te = {},
        re = {
            posEntities: ne,
            keyEntities: te
        };
    return H && (re = H(re) || re), traverseDataNodes(K, function (ae) {
        var oe = ae.node,
            ie = ae.index,
            ue = ae.pos,
            le = ae.key,
            se = ae.parentPos,
            ce = ae.level,
            de = ae.nodes,
            ve = {
                node: oe,
                nodes: de,
                index: ie,
                key: le,
                pos: ue,
                level: ce
            },
            fe = getKey(le, ue);
        ne[ue] = ve, te[fe] = ve, ve.parent = ne[se], ve.parent && (ve.parent.children = ve.parent.children ||
            [], ve.parent.children.push(ve)), W && W(ve, re)
    }, {
        externalGetKey: ee,
        childrenPropName: X,
        fieldNames: Z
    }), U && U(re), re
}

function getTreeNodeProps(K, C) {
    var H = C.expandedKeysSet,
        W = C.selectedKeysSet,
        U = C.loadedKeysSet,
        G = C.loadingKeysSet,
        X = C.checkedKeysSet,
        Z = C.halfCheckedKeysSet,
        Q = C.dragOverNodeKey,
        ee = C.dropPosition,
        ne = C.keyEntities,
        te = ne[K],
        re = {
            eventKey: K,
            expanded: H.has(K),
            selected: W.has(K),
            loaded: U.has(K),
            loading: G.has(K),
            checked: X.has(K),
            halfChecked: Z.has(K),
            pos: String(te ? te.pos : ""),
            parent: te.parent,
            dragOver: Q === K && ee === 0,
            dragOverGapTop: Q === K && ee === -1,
            dragOverGapBottom: Q === K && ee === 1
        };
    return re
}

function convertNodePropsToEventData(K) {
    var C = K.data,
        H = K.expanded,
        W = K.selected,
        U = K.checked,
        G = K.loaded,
        X = K.loading,
        Z = K.halfChecked,
        Q = K.dragOver,
        ee = K.dragOverGapTop,
        ne = K.dragOverGapBottom,
        te = K.pos,
        re = K.active,
        ae = K.eventKey,
        oe = _objectSpread2$1(_objectSpread2$1({
            dataRef: C
        }, C), {}, {
            expanded: H,
            selected: W,
            checked: U,
            loaded: G,
            loading: X,
            halfChecked: Z,
            dragOver: Q,
            dragOverGapTop: ee,
            dragOverGapBottom: ne,
            pos: te,
            active: re,
            eventKey: ae,
            key: ae
        });
    return "props" in oe || Object.defineProperty(oe, "props", {
        get: function () {
            return K
        }
    }), oe
}
const useEntities = function (K, C) {
    var H = computed(function () {
        return convertDataToEntities(K.value, {
            fieldNames: C.value,
            initWrapper: function (U) {
                return _objectSpread2$1(_objectSpread2$1({}, U), {}, {
                    pathKeyEntities: {}
                })
            },
            processEntity: function (U, G) {
                var X = U.nodes.map(function (Z) {
                    return Z[C.value.value]
                }).join(VALUE_SPLIT);
                G.pathKeyEntities[X] = U, U.key = X
            }
        }).pathKeyEntities
    });
    return H
};

function useSearchConfig(K) {
    var C = ref(!1),
        H = ref({});
    return watchEffect(function () {
        if (!K.value) {
            C.value = !1, H.value = {};
            return
        }
        var W = {
            matchInputWidth: !0,
            limit: 50
        };
        K.value && _typeof$2(K.value) === "object" && (W = _objectSpread2$1(_objectSpread2$1({}, W), K.value)),
            W.limit <= 0 && delete W.limit, C.value = !0, H.value = W
    }), {
        showSearch: C,
        searchConfig: H
    }
}
var SEARCH_MARK = "__rc_cascader_search_mark__",
    defaultFilter = function (C, H, W) {
        var U = W.label;
        return H.some(function (G) {
            return String(G[U]).toLowerCase().includes(C.toLowerCase())
        })
    },
    defaultRender$1 = function (C) {
        var H = C.path,
            W = C.fieldNames;
        return H.map(function (U) {
            return U[W.label]
        }).join(" / ")
    };
const useSearchOptions = function (K, C, H, W, U, G) {
    return computed(function () {
        var X = U.value,
            Z = X.filter,
            Q = Z === void 0 ? defaultFilter : Z,
            ee = X.render,
            ne = ee === void 0 ? defaultRender$1 : ee,
            te = X.limit,
            re = te === void 0 ? 50 : te,
            ae = X.sort,
            oe = [];
        if (!K.value) return [];

        function ie(ue, le) {
            ue.forEach(function (se) {
                if (!(!ae && re > 0 && oe.length >= re)) {
                    var ce = [].concat(_toConsumableArray(le), [se]),
                        de = se[H.value.children];
                    if ((!de || de.length === 0 || G.value) && Q(K.value, ce, {
                            label: H.value.label
                        })) {
                        var ve;
                        oe.push(_objectSpread2$1(_objectSpread2$1({}, se), {}, (ve = {},
                            _defineProperty$V(ve, H.value.label, ne({
                                inputValue: K.value,
                                path: ce,
                                prefixCls: W.value,
                                fieldNames: H.value
                            })), _defineProperty$V(ve, SEARCH_MARK, ce), ve)))
                    }
                    de && ie(se[H.value.children], ce)
                }
            })
        }
        return ie(C.value, []), ae && oe.sort(function (ue, le) {
            return ae(ue[SEARCH_MARK], le[SEARCH_MARK], K.value, H.value)
        }), re > 0 ? oe.slice(0, re) : oe
    })
};

function formatStrategyValues$1(K, C, H) {
    var W = new Set(K);
    return K.filter(function (U) {
        var G = C[U],
            X = G ? G.parent : null,
            Z = G ? G.children : null;
        return H === SHOW_CHILD$1 ? !(Z && Z.some(function (Q) {
            return Q.key && W.has(Q.key)
        })) : !(X && !X.node.disabled && W.has(X.key))
    })
}

function toPathOptions(K, C, H) {
    for (var W = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, U = C, G = [], X = function () {
            var ee, ne, te, re = K[Z],
                ae = (ee = U) === null || ee === void 0 ? void 0 : ee.findIndex(function (ie) {
                    var ue = ie[H.value];
                    return W ? String(ue) === String(re) : ue === re
                }),
                oe = ae !== -1 ? (ne = U) === null || ne === void 0 ? void 0 : ne[ae] : null;
            G.push({
                value: (te = oe == null ? void 0 : oe[H.value]) !== null && te !== void 0 ? te : re,
                index: ae,
                option: oe
            }), U = oe == null ? void 0 : oe[H.children]
        }, Z = 0; Z < K.length; Z += 1) X();
    return G
}
const useMissingValues = function (K, C, H) {
    return computed(function () {
        var W = [],
            U = [];
        return H.value.forEach(function (G) {
            var X = toPathOptions(G, K.value, C.value);
            X.every(function (Z) {
                return Z.option
            }) ? U.push(G) : W.push(G)
        }), [U, W]
    })
};

function removeFromCheckedKeys(K, C) {
    var H = new Set;
    return K.forEach(function (W) {
        C.has(W) || H.add(W)
    }), H
}

function isCheckDisabled$1(K) {
    var C = K || {},
        H = C.disabled,
        W = C.disableCheckbox,
        U = C.checkable;
    return !!(H || W) || U === !1
}

function fillConductCheck(K, C, H, W) {
    for (var U = new Set(K), G = new Set, X = 0; X <= H; X += 1) {
        var Z = C.get(X) || new Set;
        Z.forEach(function (te) {
            var re = te.key,
                ae = te.node,
                oe = te.children,
                ie = oe === void 0 ? [] : oe;
            U.has(re) && !W(ae) && ie.filter(function (ue) {
                return !W(ue.node)
            }).forEach(function (ue) {
                U.add(ue.key)
            })
        })
    }
    for (var Q = new Set, ee = H; ee >= 0; ee -= 1) {
        var ne = C.get(ee) || new Set;
        ne.forEach(function (te) {
            var re = te.parent,
                ae = te.node;
            if (!(W(ae) || !te.parent || Q.has(te.parent.key))) {
                if (W(te.parent.node)) {
                    Q.add(re.key);
                    return
                }
                var oe = !0,
                    ie = !1;
                (re.children || []).filter(function (ue) {
                    return !W(ue.node)
                }).forEach(function (ue) {
                    var le = ue.key,
                        se = U.has(le);
                    oe && !se && (oe = !1), !ie && (se || G.has(le)) && (ie = !0)
                }), oe && U.add(re.key), ie && G.add(re.key), Q.add(re.key)
            }
        })
    }
    return {
        checkedKeys: Array.from(U),
        halfCheckedKeys: Array.from(removeFromCheckedKeys(G, U))
    }
}

function cleanConductCheck(K, C, H, W, U) {
    for (var G = new Set(K), X = new Set(C), Z = 0; Z <= W; Z += 1) {
        var Q = H.get(Z) || new Set;
        Q.forEach(function (re) {
            var ae = re.key,
                oe = re.node,
                ie = re.children,
                ue = ie === void 0 ? [] : ie;
            !G.has(ae) && !X.has(ae) && !U(oe) && ue.filter(function (le) {
                return !U(le.node)
            }).forEach(function (le) {
                G.delete(le.key)
            })
        })
    }
    X = new Set;
    for (var ee = new Set, ne = W; ne >= 0; ne -= 1) {
        var te = H.get(ne) || new Set;
        te.forEach(function (re) {
            var ae = re.parent,
                oe = re.node;
            if (!(U(oe) || !re.parent || ee.has(re.parent.key))) {
                if (U(re.parent.node)) {
                    ee.add(ae.key);
                    return
                }
                var ie = !0,
                    ue = !1;
                (ae.children || []).filter(function (le) {
                    return !U(le.node)
                }).forEach(function (le) {
                    var se = le.key,
                        ce = G.has(se);
                    ie && !ce && (ie = !1), !ue && (ce || X.has(se)) && (ue = !0)
                }), ie || G.delete(ae.key), ue && X.add(ae.key), ee.add(ae.key)
            }
        })
    }
    return {
        checkedKeys: Array.from(G),
        halfCheckedKeys: Array.from(removeFromCheckedKeys(X, G))
    }
}

function conductCheck(K, C, H, W, U, G) {
    var X;
    G ? X = G : X = isCheckDisabled$1;
    var Z = new Set(K.filter(function (ee) {
            var ne = !!H[ee];
            return ne
        })),
        Q;
    return C === !0 ? Q = fillConductCheck(Z, U, W, X) : Q = cleanConductCheck(Z, C.halfCheckedKeys, U, W, X), Q
}
const useDisplayValues = function (K, C, H, W, U) {
    return computed(function () {
        var G = U.value || function (X) {
            var Z = X.labels,
                Q = W.value ? Z.slice(-1) : Z,
                ee = " / ";
            return Q.every(function (ne) {
                return ["string", "number"].includes(_typeof$2(ne))
            }) ? Q.join(ee) : Q.reduce(function (ne, te, re) {
                var ae = isValidElement(te) ? cloneElement(te, {
                    key: re
                }) : te;
                return re === 0 ? [ae] : [].concat(_toConsumableArray(ne), [ee, ae])
            }, [])
        };
        return K.value.map(function (X) {
            var Z = toPathOptions(X, C.value, H.value),
                Q = G({
                    labels: Z.map(function (ne) {
                        var te, re = ne.option,
                            ae = ne.value;
                        return (te = re == null ? void 0 : re[H.value.label]) !== null &&
                            te !== void 0 ? te : ae
                    }),
                    selectedOptions: Z.map(function (ne) {
                        var te = ne.option;
                        return te
                    })
                }),
                ee = toPathKey(X);
            return {
                label: Q,
                value: ee,
                key: ee,
                valueCells: X
            }
        })
    })
};
var CascaderContextKey = Symbol("CascaderContextKey"),
    useProvideCascader = function (C) {
        provide(CascaderContextKey, C)
    },
    useInjectCascader = function () {
        return inject(CascaderContextKey)
    };
const useActive = function () {
        var K = useBaseProps(),
            C = useInjectCascader(),
            H = C.values,
            W = useState([]),
            U = _slicedToArray$2(W, 2),
            G = U[0],
            X = U[1];
        return watch(function () {
            return K.open
        }, function () {
            if (K.open && !K.multiple) {
                var Z = H.value[0];
                X(Z || [])
            }
        }, {
            immediate: !0
        }), [G, X]
    },
    useKeyboard = function (K, C, H, W, U, G) {
        var X = useBaseProps(),
            Z = computed(function () {
                return X.direction === "rtl"
            }),
            Q = [ref([]), ref(), ref([])],
            ee = Q[0],
            ne = Q[1],
            te = Q[2];
        watchEffect(function () {
            for (var ue = -1, le = C.value, se = [], ce = [], de = W.value.length, ve = function (be) {
                    var ge = le.findIndex(function (xe) {
                        return xe[H.value.value] === W.value[be]
                    });
                    if (ge === -1) return "break";
                    ue = ge, se.push(ue), ce.push(W.value[be]), le = le[ue][H.value.children]
                }, fe = 0; fe < de && le; fe += 1) {
                var pe = ve(fe);
                if (pe === "break") break
            }
            for (var me = C.value, he = 0; he < se.length - 1; he += 1) me = me[se[he]][H.value.children];
            var Se = [ce, ue, me];
            ee.value = Se[0], ne.value = Se[1], te.value = Se[2]
        });
        var re = function (le) {
                U(le)
            },
            ae = function (le) {
                var se = te.value.length,
                    ce = ne.value;
                ce === -1 && le < 0 && (ce = se);
                for (var de = 0; de < se; de += 1) {
                    ce = (ce + le + se) % se;
                    var ve = te.value[ce];
                    if (ve && !ve.disabled) {
                        var fe = ve[H.value.value],
                            pe = ee.value.slice(0, -1).concat(fe);
                        re(pe);
                        return
                    }
                }
            },
            oe = function () {
                if (ee.value.length > 1) {
                    var le = ee.value.slice(0, -1);
                    re(le)
                } else X.toggleOpen(!1)
            },
            ie = function () {
                var le, se = ((le = te.value[ne.value]) === null || le === void 0 ? void 0 : le[H.value.children]) || [],
                    ce = se.find(function (ve) {
                        return !ve.disabled
                    });
                if (ce) {
                    var de = [].concat(_toConsumableArray(ee.value), [ce[H.value.value]]);
                    re(de)
                }
            };
        K.expose({
            onKeydown: function (le) {
                var se = le.which;
                switch (se) {
                    case KeyCode$1.UP:
                    case KeyCode$1.DOWN:
                        {
                            var ce = 0;se === KeyCode$1.UP ? ce = -1 : se === KeyCode$1.DOWN && (ce = 1),
                            ce !== 0 && ae(ce);
                            break
                        }
                    case KeyCode$1.LEFT:
                        {
                            Z.value ? ie() : oe();
                            break
                        }
                    case KeyCode$1.RIGHT:
                        {
                            Z.value ? oe() : ie();
                            break
                        }
                    case KeyCode$1.BACKSPACE:
                        {
                            X.searchValue || oe();
                            break
                        }
                    case KeyCode$1.ENTER:
                        {
                            if (ee.value.length) {
                                var de = te.value[ne.value],
                                    ve = (de == null ? void 0 : de[SEARCH_MARK]) || [];
                                ve.length ? G(ve.map(function (fe) {
                                    return fe[H.value.value]
                                }), ve[ve.length - 1]) : G(ee.value, de)
                            }
                            break
                        }
                    case KeyCode$1.ESC:
                        X.toggleOpen(!1), open && le.stopPropagation()
                }
            },
            onKeyup: function () {}
        })
    };

function Checkbox$1(K) {
    var C, H = K.prefixCls,
        W = K.checked,
        U = K.halfChecked,
        G = K.disabled,
        X = K.onClick,
        Z = useInjectCascader(),
        Q = Z.customSlots,
        ee = Z.checkable,
        ne = ee.value !== !1 ? Q.value.checkable : ee.value,
        te = typeof ne == "function" ? ne() : typeof ne == "boolean" ? null : ne;
    return createVNode("span", {
        class: (C = {}, _defineProperty$V(C, H, !0), _defineProperty$V(C, "".concat(H, "-checked"), W),
            _defineProperty$V(C, "".concat(H, "-indeterminate"), !W && U), _defineProperty$V(C, "".concat(H,
                "-disabled"), G), C),
        onClick: X
    }, [te])
}
Checkbox$1.props = ["prefixCls", "checked", "halfChecked", "disabled", "onClick"];
Checkbox$1.displayName = "Checkbox";
Checkbox$1.inheritAttrs = !1;
var FIX_LABEL = "__cascader_fix_label__";

function Column$1(K) {
    var C, H, W, U, G, X, Z = K.prefixCls,
        Q = K.multiple,
        ee = K.options,
        ne = K.activeValue,
        te = K.prevValuePath,
        re = K.onToggleOpen,
        ae = K.onSelect,
        oe = K.onActive,
        ie = K.checkedSet,
        ue = K.halfCheckedSet,
        le = K.loadingKeys,
        se = K.isSelectable,
        ce = "".concat(Z, "-menu"),
        de = "".concat(Z, "-menu-item"),
        ve = useInjectCascader(),
        fe = ve.fieldNames,
        pe = ve.changeOnSelect,
        me = ve.expandTrigger,
        he = ve.expandIcon,
        Se = ve.loadingIcon,
        _e = ve.dropdownMenuColumnStyle,
        be = ve.customSlots,
        ge = (C = he.value) !== null && C !== void 0 ? C : (H = (W = be.value).expandIcon) === null || H === void 0 ?
        void 0 : H.call(W),
        xe = (U = Se.value) !== null && U !== void 0 ? U : (G = (X = be.value).loadingIcon) === null || G === void 0 ?
        void 0 : G.call(X),
        Pe = me.value === "hover";
    return createVNode("ul", {
        class: ce,
        role: "menu"
    }, [ee.map(function ($e) {
        var ye, Ce, we = $e.disabled,
            Oe = $e[SEARCH_MARK],
            Ne = (ye = $e[FIX_LABEL]) !== null && ye !== void 0 ? ye : $e[fe.value.label],
            Me = $e[fe.value.value],
            Ve = isLeaf($e, fe.value),
            ke = Oe ? Oe.map(function (Ie) {
                return Ie[fe.value.value]
            }) : [].concat(_toConsumableArray(te), [Me]),
            Ee = toPathKey(ke),
            Ae = le.includes(Ee),
            Re = ie.has(Ee),
            He = ue.has(Ee),
            je = function () {
                !we && (!Pe || !Ve) && oe(ke)
            },
            Fe = function () {
                se($e) && ae(ke, Ve)
            },
            Le;
        return typeof $e.title == "string" ? Le = $e.title : typeof Ne == "string" && (Le = Ne),
            createVNode("li", {
                key: Ee,
                class: [de, (Ce = {}, _defineProperty$V(Ce, "".concat(de, "-expand"), !Ve),
                    _defineProperty$V(Ce, "".concat(de, "-active"), ne === Me),
                    _defineProperty$V(Ce, "".concat(de, "-disabled"), we),
                    _defineProperty$V(Ce, "".concat(de, "-loading"), Ae), Ce)],
                style: _e.value,
                role: "menuitemcheckbox",
                title: Le,
                "aria-checked": Re,
                "data-path-key": Ee,
                onClick: function () {
                    je(), (!Q || Ve) && Fe()
                },
                onDblclick: function () {
                    pe.value && re(!1)
                },
                onMouseenter: function () {
                    Pe && je()
                },
                onMousedown: function (Te) {
                    Te.preventDefault()
                }
            }, [Q && createVNode(Checkbox$1, {
                prefixCls: "".concat(Z, "-checkbox"),
                checked: Re,
                halfChecked: He,
                disabled: we,
                onClick: function (Te) {
                    Te.stopPropagation(), Fe()
                }
            }, null), createVNode("div", {
                class: "".concat(de, "-content")
            }, [Ne]), !Ae && ge && !Ve && createVNode("div", {
                class: "".concat(de, "-expand-icon")
            }, [ge]), Ae && xe && createVNode("div", {
                class: "".concat(de, "-loading-icon")
            }, [xe])])
    })])
}
Column$1.props = ["prefixCls", "multiple", "options", "activeValue", "prevValuePath", "onToggleOpen", "onSelect",
    "onActive", "checkedSet", "halfCheckedSet", "loadingKeys", "isSelectable"];
Column$1.displayName = "Column";
Column$1.inheritAttrs = !1;
const OptionList$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "OptionList",
    inheritAttrs: !1,
    setup: function (C, H) {
        var W = H.attrs,
            U = H.slots,
            G = useBaseProps(),
            X = ref(),
            Z = computed(function () {
                return G.direction === "rtl"
            }),
            Q = useInjectCascader(),
            ee = Q.options,
            ne = Q.values,
            te = Q.halfValues,
            re = Q.fieldNames,
            ae = Q.changeOnSelect,
            oe = Q.onSelect,
            ie = Q.searchOptions,
            ue = Q.dropdownPrefixCls,
            le = Q.loadData,
            se = Q.expandTrigger,
            ce = Q.customSlots,
            de = computed(function () {
                return ue.value || G.prefixCls
            }),
            ve = shallowRef([]),
            fe = function (Ne) {
                if (!(!le.value || G.searchValue)) {
                    var Me = toPathOptions(Ne, ee.value, re.value),
                        Ve = Me.map(function (Ae) {
                            var Re = Ae.option;
                            return Re
                        }),
                        ke = Ve[Ve.length - 1];
                    if (ke && !isLeaf(ke, re.value)) {
                        var Ee = toPathKey(Ne);
                        ve.value = [].concat(_toConsumableArray(ve.value), [Ee]), le.value(Ve)
                    }
                }
            };
        watchEffect(function () {
            ve.value.length && ve.value.forEach(function (Oe) {
                var Ne = toPathValueStr(Oe),
                    Me = toPathOptions(Ne, ee.value, re.value, !0).map(function (ke) {
                        var Ee = ke.option;
                        return Ee
                    }),
                    Ve = Me[Me.length - 1];
                (!Ve || Ve[re.value.children] || isLeaf(Ve, re.value)) && (ve.value = ve.value
                    .filter(function (ke) {
                        return ke !== Oe
                    }))
            })
        });
        var pe = computed(function () {
                return new Set(toPathKeys(ne.value))
            }),
            me = computed(function () {
                return new Set(toPathKeys(te.value))
            }),
            he = useActive(),
            Se = _slicedToArray$2(he, 2),
            _e = Se[0],
            be = Se[1],
            ge = function (Ne) {
                be(Ne), fe(Ne)
            },
            xe = function (Ne) {
                var Me = Ne.disabled,
                    Ve = isLeaf(Ne, re.value);
                return !Me && (Ve || ae.value || G.multiple)
            },
            Pe = function (Ne, Me) {
                var Ve = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
                oe(Ne), !G.multiple && (Me || ae.value && (se.value === "hover" || Ve)) && G.toggleOpen(!1)
            },
            $e = computed(function () {
                return G.searchValue ? ie.value : ee.value
            }),
            ye = computed(function () {
                for (var Oe = [{
                        options: $e.value
                    }], Ne = $e.value, Me = function () {
                        var Ae = _e.value[Ve],
                            Re = Ne.find(function (je) {
                                return je[re.value.value] === Ae
                            }),
                            He = Re == null ? void 0 : Re[re.value.children];
                        if (!(He != null && He.length)) return "break";
                        Ne = He, Oe.push({
                            options: He
                        })
                    }, Ve = 0; Ve < _e.value.length; Ve += 1) {
                    var ke = Me();
                    if (ke === "break") break
                }
                return Oe
            }),
            Ce = function (Ne, Me) {
                xe(Me) && Pe(Ne, isLeaf(Me, re.value), !0)
            };
        useKeyboard(H, $e, re, _e, ge, Ce);
        var we = function (Ne) {
            Ne.preventDefault()
        };
        return onMounted(function () {
                watch(_e, function (Oe) {
                    for (var Ne = 0; Ne < Oe.length; Ne += 1) {
                        var Me, Ve = Oe.slice(0, Ne + 1),
                            ke = toPathKey(Ve),
                            Ee = (Me = X.value) === null || Me === void 0 ? void 0 : Me.querySelector(
                                'li[data-path-key="'.concat(ke.replace(/\\{0,2}"/g, '\\"'),
                                    '"]'));
                        Ee && scrollIntoParentView(Ee)
                    }
                }, {
                    flush: "post",
                    immediate: !0
                })
            }),
            function () {
                var Oe, Ne, Me, Ve, ke, Ee, Ae, Re = G.notFoundContent,
                    He = Re === void 0 ? ((Oe = U.notFoundContent) === null || Oe === void 0 ? void 0 : Oe.call(
                        U)) || ((Ne = (Me = ce.value).notFoundContent) === null || Ne === void 0 ? void 0 :
                        Ne.call(Me)) : Re,
                    je = G.multiple,
                    Fe = G.toggleOpen,
                    Le = !((Ve = ye.value[0]) !== null && Ve !== void 0 && (ke = Ve.options) !== null && ke !==
                        void 0 && ke.length),
                    Ie = [(Ee = {}, _defineProperty$V(Ee, re.value.value, "__EMPTY__"), _defineProperty$V(
                        Ee, FIX_LABEL, He), _defineProperty$V(Ee, "disabled", !0), Ee)],
                    Te = _objectSpread2$1(_objectSpread2$1({}, W), {}, {
                        multiple: !Le && je,
                        onSelect: Pe,
                        onActive: ge,
                        onToggleOpen: Fe,
                        checkedSet: pe.value,
                        halfCheckedSet: me.value,
                        loadingKeys: ve.value,
                        isSelectable: xe
                    }),
                    De = Le ? [{
                        options: Ie
                    }] : ye.value,
                    Ke = De.map(function (We, Ue) {
                        var et = _e.value.slice(0, Ue),
                            Ye = _e.value[Ue];
                        return createVNode(Column$1, _objectSpread2$1(_objectSpread2$1({
                            key: Ue
                        }, Te), {}, {
                            prefixCls: de.value,
                            options: We.options,
                            prevValuePath: et,
                            activeValue: Ye
                        }), null)
                    });
                return createVNode("div", {
                    class: ["".concat(de.value, "-menus"), (Ae = {}, _defineProperty$V(Ae, "".concat(
                        de.value, "-menu-empty"), Le), _defineProperty$V(Ae, "".concat(
                        de.value, "-rtl"), Z.value), Ae)],
                    onMousedown: we,
                    ref: X
                }, [Ke])
            }
    }
});

function useMaxLevel(K) {
    var C = ref(0),
        H = shallowRef();
    return watchEffect(function () {
        var W = new Map,
            U = 0,
            G = K.value || {};
        for (var X in G)
            if (Object.prototype.hasOwnProperty.call(G, X)) {
                var Z = G[X],
                    Q = Z.level,
                    ee = W.get(Q);
                ee || (ee = new Set, W.set(Q, ee)), ee.add(Z), U = Math.max(U, Q)
            } C.value = U, H.value = W
    }), {
        maxLevel: C,
        levelEntities: H
    }
}

function baseCascaderProps() {
    return _objectSpread2$1(_objectSpread2$1({}, omit$2(baseSelectPropsWithoutPrivate(), ["tokenSeparators", "mode",
        "showSearch"])), {}, {
        id: String,
        prefixCls: String,
        fieldNames: Object,
        children: Array,
        value: {
            type: [String, Number, Array]
        },
        defaultValue: {
            type: [String, Number, Array]
        },
        changeOnSelect: {
            type: Boolean,
            default: void 0
        },
        displayRender: Function,
        checkable: {
            type: Boolean,
            default: void 0
        },
        showCheckedStrategy: {
            type: String,
            default: SHOW_PARENT$1
        },
        showSearch: {
            type: [Boolean, Object],
            default: void 0
        },
        searchValue: String,
        onSearch: Function,
        expandTrigger: String,
        options: Array,
        dropdownPrefixCls: String,
        loadData: Function,
        popupVisible: {
            type: Boolean,
            default: void 0
        },
        popupClassName: String,
        dropdownClassName: String,
        dropdownMenuColumnStyle: {
            type: Object,
            default: void 0
        },
        popupStyle: {
            type: Object,
            default: void 0
        },
        dropdownStyle: {
            type: Object,
            default: void 0
        },
        popupPlacement: String,
        placement: String,
        onPopupVisibleChange: Function,
        onDropdownVisibleChange: Function,
        expandIcon: PropTypes$1.any,
        loadingIcon: PropTypes$1.any
    })
}

function internalCascaderProps() {
    return _objectSpread2$1(_objectSpread2$1({}, baseCascaderProps()), {}, {
        onChange: Function,
        customSlots: Object
    })
}

function isMultipleValue(K) {
    return Array.isArray(K) && Array.isArray(K[0])
}

function toRawValues(K) {
    return K ? isMultipleValue(K) ? K : (K.length === 0 ? [] : [K]).map(function (C) {
        return Array.isArray(C) ? C : [C]
    }) : []
}
const Cascader$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Cascader",
    inheritAttrs: !1,
    props: initDefaultProps$1(internalCascaderProps(), {}),
    setup: function (C, H) {
        var W = H.attrs,
            U = H.expose,
            G = H.slots,
            X = useId(toRef(C, "id")),
            Z = computed(function () {
                return !!C.checkable
            }),
            Q = useMergedState(C.defaultValue, {
                value: computed(function () {
                    return C.value
                }),
                postState: toRawValues
            }),
            ee = _slicedToArray$2(Q, 2),
            ne = ee[0],
            te = ee[1],
            re = computed(function () {
                return fillFieldNames$2(C.fieldNames)
            }),
            ae = computed(function () {
                return C.options || []
            }),
            oe = useEntities(ae, re),
            ie = function (ze) {
                var Be = oe.value;
                return ze.map(function (Ge) {
                    var Xe = Be[Ge].nodes;
                    return Xe.map(function (nt) {
                        return nt[re.value.value]
                    })
                })
            },
            ue = useMergedState("", {
                value: computed(function () {
                    return C.searchValue
                }),
                postState: function (ze) {
                    return ze || ""
                }
            }),
            le = _slicedToArray$2(ue, 2),
            se = le[0],
            ce = le[1],
            de = function (ze, Be) {
                ce(ze), Be.source !== "blur" && C.onSearch && C.onSearch(ze)
            },
            ve = useSearchConfig(toRef(C, "showSearch")),
            fe = ve.showSearch,
            pe = ve.searchConfig,
            me = useSearchOptions(se, ae, re, computed(function () {
                return C.dropdownPrefixCls || C.prefixCls
            }), pe, toRef(C, "changeOnSelect")),
            he = useMissingValues(ae, re, ne),
            Se = [ref([]), ref([]), ref([])],
            _e = Se[0],
            be = Se[1],
            ge = Se[2],
            xe = useMaxLevel(oe),
            Pe = xe.maxLevel,
            $e = xe.levelEntities;
        watchEffect(function () {
            var Ye = _slicedToArray$2(he.value, 2),
                ze = Ye[0],
                Be = Ye[1];
            if (!Z.value || !ne.value.length) {
                var Ge = [ze, [], Be];
                _e.value = Ge[0], be.value = Ge[1], ge.value = Ge[2];
                return
            }
            var Xe = toPathKeys(ze),
                nt = oe.value,
                it = conductCheck(Xe, !0, nt, Pe.value, $e.value),
                ft = it.checkedKeys,
                pt = it.halfCheckedKeys,
                ot = [ie(ft), ie(pt), Be];
            _e.value = ot[0], be.value = ot[1], ge.value = ot[2]
        });
        var ye = computed(function () {
                var Ye = toPathKeys(_e.value),
                    ze = formatStrategyValues$1(Ye, oe.value, C.showCheckedStrategy);
                return [].concat(_toConsumableArray(ge.value), _toConsumableArray(ie(ze)))
            }),
            Ce = useDisplayValues(ye, ae, re, Z, toRef(C, "displayRender")),
            we = function (ze) {
                if (te(ze), C.onChange) {
                    var Be = toRawValues(ze),
                        Ge = Be.map(function (it) {
                            return toPathOptions(it, ae.value, re.value).map(function (ft) {
                                return ft.option
                            })
                        }),
                        Xe = Z.value ? Be : Be[0],
                        nt = Z.value ? Ge : Ge[0];
                    C.onChange(Xe, nt)
                }
            },
            Oe = function (ze) {
                if (ce(""), !Z.value) we(ze);
                else {
                    var Be = toPathKey(ze),
                        Ge = toPathKeys(_e.value),
                        Xe = toPathKeys(be.value),
                        nt = Ge.includes(Be),
                        it = ge.value.some(function (qe) {
                            return toPathKey(qe) === Be
                        }),
                        ft = _e.value,
                        pt = ge.value;
                    if (it && !nt) pt = ge.value.filter(function (qe) {
                        return toPathKey(qe) !== Be
                    });
                    else {
                        var ot = nt ? Ge.filter(function (qe) {
                                return qe !== Be
                            }) : [].concat(_toConsumableArray(Ge), [Be]),
                            Ze;
                        if (nt) {
                            var ut = conductCheck(ot, {
                                checked: !1,
                                halfCheckedKeys: Xe
                            }, oe.value, Pe.value, $e.value);
                            Ze = ut.checkedKeys
                        } else {
                            var st = conductCheck(ot, !0, oe.value, Pe.value, $e.value);
                            Ze = st.checkedKeys
                        }
                        var rt = formatStrategyValues$1(Ze, oe.value, C.showCheckedStrategy);
                        ft = ie(rt)
                    }
                    we([].concat(_toConsumableArray(pt), _toConsumableArray(ft)))
                }
            },
            Ne = function (ze, Be) {
                if (Be.type === "clear") {
                    we([]);
                    return
                }
                var Ge = Be.values[0].valueCells;
                Oe(Ge)
            },
            Me = computed(function () {
                return C.open !== void 0 ? C.open : C.popupVisible
            }),
            Ve = computed(function () {
                return C.dropdownClassName || C.popupClassName
            }),
            ke = computed(function () {
                return C.dropdownStyle || C.popupStyle || {}
            }),
            Ee = computed(function () {
                return C.placement || C.popupPlacement
            }),
            Ae = function (ze) {
                var Be, Ge;
                (Be = C.onDropdownVisibleChange) === null || Be === void 0 || Be.call(C, ze), (Ge = C.onPopupVisibleChange) ===
                    null || Ge === void 0 || Ge.call(C, ze)
            },
            Re = toRefs(C),
            He = Re.changeOnSelect,
            je = Re.checkable,
            Fe = Re.dropdownPrefixCls,
            Le = Re.loadData,
            Ie = Re.expandTrigger,
            Te = Re.expandIcon,
            De = Re.loadingIcon,
            Ke = Re.dropdownMenuColumnStyle,
            We = Re.customSlots;
        useProvideCascader({
            options: ae,
            fieldNames: re,
            values: _e,
            halfValues: be,
            changeOnSelect: He,
            onSelect: Oe,
            checkable: je,
            searchOptions: me,
            dropdownPrefixCls: Fe,
            loadData: Le,
            expandTrigger: Ie,
            expandIcon: Te,
            loadingIcon: De,
            dropdownMenuColumnStyle: Ke,
            customSlots: We
        });
        var Ue = ref();
        U({
            focus: function () {
                var ze;
                (ze = Ue.value) === null || ze === void 0 || ze.focus()
            },
            blur: function () {
                var ze;
                (ze = Ue.value) === null || ze === void 0 || ze.blur()
            },
            scrollTo: function (ze) {
                var Be;
                (Be = Ue.value) === null || Be === void 0 || Be.scrollTo(ze)
            }
        });
        var et = computed(function () {
            return omit$2(C, ["id", "prefixCls", "fieldNames", "defaultValue", "value",
                "changeOnSelect", "onChange", "displayRender", "checkable", "searchValue",
                "onSearch", "showSearch", "expandTrigger", "options", "dropdownPrefixCls",
                "loadData", "popupVisible", "open", "popupClassName", "dropdownClassName",
                "dropdownMenuColumnStyle", "popupPlacement", "placement",
                "onDropdownVisibleChange", "onPopupVisibleChange", "expandIcon",
                "loadingIcon", "customSlots", "showCheckedStrategy", "children"])
        });
        return function () {
            var Ye = !(se.value ? me.value : ae.value).length,
                ze = C.dropdownMatchSelectWidth,
                Be = ze === void 0 ? !1 : ze,
                Ge = se.value && pe.value.matchInputWidth || Ye ? {} : {
                    minWidth: "auto"
                };
            return createVNode(BaseSelect, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, et.value),
                W), {}, {
                ref: Ue,
                id: X,
                prefixCls: C.prefixCls,
                dropdownMatchSelectWidth: Be,
                dropdownStyle: _objectSpread2$1(_objectSpread2$1({}, ke.value), Ge),
                displayValues: Ce.value,
                onDisplayValuesChange: Ne,
                mode: Z.value ? "multiple" : void 0,
                searchValue: se.value,
                onSearch: de,
                showSearch: fe.value,
                OptionList: OptionList$1,
                emptyOptions: Ye,
                open: Me.value,
                dropdownClassName: Ve.value,
                placement: Ee.value,
                onDropdownVisibleChange: Ae,
                getRawInputElement: function () {
                    var nt;
                    return (nt = G.default) === null || nt === void 0 ? void 0 : nt.call(
                        G)
                }
            }), G)
        }
    }
});
var LeftOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"
            }
        }]
    },
    name: "left",
    theme: "outlined"
};
const LeftOutlinedSvg = LeftOutlined$2;

function _objectSpread$z(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$z(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$z(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var LeftOutlined = function (C, H) {
    var W = _objectSpread$z({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$z({}, W, {
        icon: LeftOutlinedSvg
    }), null)
};
LeftOutlined.displayName = "LeftOutlined";
LeftOutlined.inheritAttrs = !1;
const LeftOutlined$1 = LeftOutlined;

function arrayEach(K, C) {
    for (var H = -1, W = K == null ? 0 : K.length; ++H < W && C(K[H], H, K) !== !1;);
    return K
}

function copyObject(K, C, H, W) {
    var U = !H;
    H || (H = {});
    for (var G = -1, X = C.length; ++G < X;) {
        var Z = C[G],
            Q = W ? W(H[Z], K[Z], Z, H, K) : void 0;
        Q === void 0 && (Q = K[Z]), U ? baseAssignValue(H, Z, Q) : assignValue(H, Z, Q)
    }
    return H
}

function baseAssign(K, C) {
    return K && copyObject(C, keys$1(C), K)
}

function nativeKeysIn(K) {
    var C = [];
    if (K != null)
        for (var H in Object(K)) C.push(H);
    return C
}
var objectProto$1 = Object.prototype,
    hasOwnProperty$1 = objectProto$1.hasOwnProperty;

function baseKeysIn(K) {
    if (!isObject$2(K)) return nativeKeysIn(K);
    var C = isPrototype(K),
        H = [];
    for (var W in K) W == "constructor" && (C || !hasOwnProperty$1.call(K, W)) || H.push(W);
    return H
}

function keysIn(K) {
    return isArrayLike(K) ? arrayLikeKeys(K, !0) : baseKeysIn(K)
}

function baseAssignIn(K, C) {
    return K && copyObject(C, keysIn(C), K)
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports,
    freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module,
    moduleExports = freeModule && freeModule.exports === freeExports,
    Buffer = moduleExports ? root$2.Buffer : void 0,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;

function cloneBuffer(K, C) {
    if (C) return K.slice();
    var H = K.length,
        W = allocUnsafe ? allocUnsafe(H) : new K.constructor(H);
    return K.copy(W), W
}

function copyArray(K, C) {
    var H = -1,
        W = K.length;
    for (C || (C = Array(W)); ++H < W;) C[H] = K[H];
    return C
}

function copySymbols(K, C) {
    return copyObject(K, getSymbols$1(K), C)
}
var nativeGetSymbols = Object.getOwnPropertySymbols,
    getSymbolsIn = nativeGetSymbols ? function (K) {
        for (var C = []; K;) arrayPush(C, getSymbols$1(K)), K = getPrototype$1(K);
        return C
    } : stubArray;
const getSymbolsIn$1 = getSymbolsIn;

function copySymbolsIn(K, C) {
    return copyObject(K, getSymbolsIn$1(K), C)
}

function getAllKeysIn(K) {
    return baseGetAllKeys(K, keysIn, getSymbolsIn$1)
}
var objectProto = Object.prototype,
    hasOwnProperty = objectProto.hasOwnProperty;

function initCloneArray(K) {
    var C = K.length,
        H = new K.constructor(C);
    return C && typeof K[0] == "string" && hasOwnProperty.call(K, "index") && (H.index = K.index, H.input = K.input), H
}

function cloneArrayBuffer(K) {
    var C = new K.constructor(K.byteLength);
    return new Uint8Array$2(C).set(new Uint8Array$2(K)), C
}

function cloneDataView(K, C) {
    var H = C ? cloneArrayBuffer(K.buffer) : K.buffer;
    return new K.constructor(H, K.byteOffset, K.byteLength)
}
var reFlags = /\w*$/;

function cloneRegExp(K) {
    var C = new K.constructor(K.source, reFlags.exec(K));
    return C.lastIndex = K.lastIndex, C
}
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0,
    symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;

function cloneSymbol(K) {
    return symbolValueOf ? Object(symbolValueOf.call(K)) : {}
}

function cloneTypedArray(K, C) {
    var H = C ? cloneArrayBuffer(K.buffer) : K.buffer;
    return new K.constructor(H, K.byteOffset, K.length)
}
var boolTag$1 = "[object Boolean]",
    dateTag$1 = "[object Date]",
    mapTag$2 = "[object Map]",
    numberTag$2 = "[object Number]",
    regexpTag$1 = "[object RegExp]",
    setTag$2 = "[object Set]",
    stringTag$1 = "[object String]",
    symbolTag$1 = "[object Symbol]",
    arrayBufferTag$1 = "[object ArrayBuffer]",
    dataViewTag$1 = "[object DataView]",
    float32Tag$1 = "[object Float32Array]",
    float64Tag$1 = "[object Float64Array]",
    int8Tag$1 = "[object Int8Array]",
    int16Tag$1 = "[object Int16Array]",
    int32Tag$1 = "[object Int32Array]",
    uint8Tag$1 = "[object Uint8Array]",
    uint8ClampedTag$1 = "[object Uint8ClampedArray]",
    uint16Tag$1 = "[object Uint16Array]",
    uint32Tag$1 = "[object Uint32Array]";

function initCloneByTag(K, C, H) {
    var W = K.constructor;
    switch (C) {
        case arrayBufferTag$1:
            return cloneArrayBuffer(K);
        case boolTag$1:
        case dateTag$1:
            return new W(+K);
        case dataViewTag$1:
            return cloneDataView(K, H);
        case float32Tag$1:
        case float64Tag$1:
        case int8Tag$1:
        case int16Tag$1:
        case int32Tag$1:
        case uint8Tag$1:
        case uint8ClampedTag$1:
        case uint16Tag$1:
        case uint32Tag$1:
            return cloneTypedArray(K, H);
        case mapTag$2:
            return new W;
        case numberTag$2:
        case stringTag$1:
            return new W(K);
        case regexpTag$1:
            return cloneRegExp(K);
        case setTag$2:
            return new W;
        case symbolTag$1:
            return cloneSymbol(K)
    }
}
var objectCreate = Object.create,
    baseCreate = function () {
        function K() {}
        return function (C) {
            if (!isObject$2(C)) return {};
            if (objectCreate) return objectCreate(C);
            K.prototype = C;
            var H = new K;
            return K.prototype = void 0, H
        }
    }();
const baseCreate$1 = baseCreate;

function initCloneObject(K) {
    return typeof K.constructor == "function" && !isPrototype(K) ? baseCreate$1(getPrototype$1(K)) : {}
}
var mapTag$1 = "[object Map]";

function baseIsMap(K) {
    return isObjectLike(K) && getTag$1(K) == mapTag$1
}
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap,
    isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
const isMap$1 = isMap;
var setTag$1 = "[object Set]";

function baseIsSet(K) {
    return isObjectLike(K) && getTag$1(K) == setTag$1
}
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet,
    isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
const isSet$1 = isSet;
var CLONE_DEEP_FLAG$2 = 1,
    CLONE_FLAT_FLAG$1 = 2,
    CLONE_SYMBOLS_FLAG$2 = 4,
    argsTag = "[object Arguments]",
    arrayTag = "[object Array]",
    boolTag = "[object Boolean]",
    dateTag = "[object Date]",
    errorTag = "[object Error]",
    funcTag = "[object Function]",
    genTag = "[object GeneratorFunction]",
    mapTag = "[object Map]",
    numberTag$1 = "[object Number]",
    objectTag = "[object Object]",
    regexpTag = "[object RegExp]",
    setTag = "[object Set]",
    stringTag = "[object String]",
    symbolTag = "[object Symbol]",
    weakMapTag = "[object WeakMap]",
    arrayBufferTag = "[object ArrayBuffer]",
    dataViewTag = "[object DataView]",
    float32Tag = "[object Float32Array]",
    float64Tag = "[object Float64Array]",
    int8Tag = "[object Int8Array]",
    int16Tag = "[object Int16Array]",
    int32Tag = "[object Int32Array]",
    uint8Tag = "[object Uint8Array]",
    uint8ClampedTag = "[object Uint8ClampedArray]",
    uint16Tag = "[object Uint16Array]",
    uint32Tag = "[object Uint32Array]",
    cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
    cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] =
    cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[
        numberTag$1] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[
        stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
    cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;

function baseClone(K, C, H, W, U, G) {
    var X, Z = C & CLONE_DEEP_FLAG$2,
        Q = C & CLONE_FLAT_FLAG$1,
        ee = C & CLONE_SYMBOLS_FLAG$2;
    if (H && (X = U ? H(K, W, U, G) : H(K)), X !== void 0) return X;
    if (!isObject$2(K)) return K;
    var ne = isArray$2(K);
    if (ne) {
        if (X = initCloneArray(K), !Z) return copyArray(K, X)
    } else {
        var te = getTag$1(K),
            re = te == funcTag || te == genTag;
        if (isBuffer$1(K)) return cloneBuffer(K, Z);
        if (te == objectTag || te == argsTag || re && !U) {
            if (X = Q || re ? {} : initCloneObject(K), !Z) return Q ? copySymbolsIn(K, baseAssignIn(X, K)) :
                copySymbols(K, baseAssign(X, K))
        } else {
            if (!cloneableTags[te]) return U ? K : {};
            X = initCloneByTag(K, te, Z)
        }
    }
    G || (G = new Stack);
    var ae = G.get(K);
    if (ae) return ae;
    G.set(K, X), isSet$1(K) ? K.forEach(function (ue) {
        X.add(baseClone(ue, C, H, ue, K, G))
    }) : isMap$1(K) && K.forEach(function (ue, le) {
        X.set(le, baseClone(ue, C, H, le, K, G))
    });
    var oe = ee ? Q ? getAllKeysIn : getAllKeys$1 : Q ? keysIn : keys$1,
        ie = ne ? void 0 : oe(K);
    return arrayEach(ie || K, function (ue, le) {
        ie && (le = ue, ue = K[le]), assignValue(X, le, baseClone(ue, C, H, le, K, G))
    }), X
}
var CLONE_DEEP_FLAG$1 = 1,
    CLONE_SYMBOLS_FLAG$1 = 4;

function cloneDeep(K) {
    return baseClone(K, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1)
}

function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function (K) {
        for (var C = 1; C < arguments.length; C++) {
            var H = arguments[C];
            for (var W in H) Object.prototype.hasOwnProperty.call(H, W) && (K[W] = H[W])
        }
        return K
    }, _extends.apply(this, arguments)
}

function _inheritsLoose(K, C) {
    K.prototype = Object.create(C.prototype), K.prototype.constructor = K, _setPrototypeOf(K, C)
}

function _getPrototypeOf(K) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (H) {
        return H.__proto__ || Object.getPrototypeOf(H)
    }, _getPrototypeOf(K)
}

function _setPrototypeOf(K, C) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (W, U) {
        return W.__proto__ = U, W
    }, _setPrototypeOf(K, C)
}

function _isNativeReflectConstruct() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0
    } catch {
        return !1
    }
}

function _construct(K, C, H) {
    return _isNativeReflectConstruct() ? _construct = Reflect.construct.bind() : _construct = function (U, G, X) {
        var Z = [null];
        Z.push.apply(Z, G);
        var Q = Function.bind.apply(U, Z),
            ee = new Q;
        return X && _setPrototypeOf(ee, X.prototype), ee
    }, _construct.apply(null, arguments)
}

function _isNativeFunction(K) {
    return Function.toString.call(K).indexOf("[native code]") !== -1
}

function _wrapNativeSuper(K) {
    var C = typeof Map == "function" ? new Map : void 0;
    return _wrapNativeSuper = function (W) {
        if (W === null || !_isNativeFunction(W)) return W;
        if (typeof W != "function") throw new TypeError("Super expression must either be null or a function");
        if (typeof C < "u") {
            if (C.has(W)) return C.get(W);
            C.set(W, U)
        }

        function U() {
            return _construct(W, arguments, _getPrototypeOf(this).constructor)
        }
        return U.prototype = Object.create(W.prototype, {
            constructor: {
                value: U,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), _setPrototypeOf(U, W)
    }, _wrapNativeSuper(K)
}
var formatRegExp = /%[sdj%]/g,
    warning = function () {};
typeof process < "u" && process.env;

function convertFieldsError(K) {
    if (!K || !K.length) return null;
    var C = {};
    return K.forEach(function (H) {
        var W = H.field;
        C[W] = C[W] || [], C[W].push(H)
    }), C
}

function format$2(K) {
    for (var C = arguments.length, H = new Array(C > 1 ? C - 1 : 0), W = 1; W < C; W++) H[W - 1] = arguments[W];
    var U = 0,
        G = H.length;
    if (typeof K == "function") return K.apply(null, H);
    if (typeof K == "string") {
        var X = K.replace(formatRegExp, function (Z) {
            if (Z === "%%") return "%";
            if (U >= G) return Z;
            switch (Z) {
                case "%s":
                    return String(H[U++]);
                case "%d":
                    return Number(H[U++]);
                case "%j":
                    try {
                        return JSON.stringify(H[U++])
                    } catch {
                        return "[Circular]"
                    }
                    break;
                default:
                    return Z
            }
        });
        return X
    }
    return K
}

function isNativeStringType(K) {
    return K === "string" || K === "url" || K === "hex" || K === "email" || K === "date" || K === "pattern"
}

function isEmptyValue(K, C) {
    return !!(K == null || C === "array" && Array.isArray(K) && !K.length || isNativeStringType(C) && typeof K ==
        "string" && !K)
}

function asyncParallelArray(K, C, H) {
    var W = [],
        U = 0,
        G = K.length;

    function X(Z) {
        W.push.apply(W, Z || []), U++, U === G && H(W)
    }
    K.forEach(function (Z) {
        C(Z, X)
    })
}

function asyncSerialArray(K, C, H) {
    var W = 0,
        U = K.length;

    function G(X) {
        if (X && X.length) {
            H(X);
            return
        }
        var Z = W;
        W = W + 1, Z < U ? C(K[Z], G) : H([])
    }
    G([])
}

function flattenObjArr(K) {
    var C = [];
    return Object.keys(K).forEach(function (H) {
        C.push.apply(C, K[H] || [])
    }), C
}
var AsyncValidationError = function (K) {
    _inheritsLoose(C, K);

    function C(H, W) {
        var U;
        return U = K.call(this, "Async Validation Error") || this, U.errors = H, U.fields = W, U
    }
    return C
}(_wrapNativeSuper(Error));

function asyncMap(K, C, H, W, U) {
    if (C.first) {
        var G = new Promise(function (re, ae) {
            var oe = function (le) {
                    return W(le), le.length ? ae(new AsyncValidationError(le, convertFieldsError(le))) : re(U)
                },
                ie = flattenObjArr(K);
            asyncSerialArray(ie, H, oe)
        });
        return G.catch(function (re) {
            return re
        }), G
    }
    var X = C.firstFields === !0 ? Object.keys(K) : C.firstFields || [],
        Z = Object.keys(K),
        Q = Z.length,
        ee = 0,
        ne = [],
        te = new Promise(function (re, ae) {
            var oe = function (ue) {
                if (ne.push.apply(ne, ue), ee++, ee === Q) return W(ne), ne.length ? ae(new AsyncValidationError(
                    ne, convertFieldsError(ne))) : re(U)
            };
            Z.length || (W(ne), re(U)), Z.forEach(function (ie) {
                var ue = K[ie];
                X.indexOf(ie) !== -1 ? asyncSerialArray(ue, H, oe) : asyncParallelArray(ue, H, oe)
            })
        });
    return te.catch(function (re) {
        return re
    }), te
}

function isErrorObj(K) {
    return !!(K && K.message !== void 0)
}

function getValue$1(K, C) {
    for (var H = K, W = 0; W < C.length; W++) {
        if (H == null) return H;
        H = H[C[W]]
    }
    return H
}

function complementError(K, C) {
    return function (H) {
        var W;
        return K.fullFields ? W = getValue$1(C, K.fullFields) : W = C[H.field || K.fullField], isErrorObj(H) ? (H.field =
            H.field || K.fullField, H.fieldValue = W, H) : {
            message: typeof H == "function" ? H() : H,
            fieldValue: W,
            field: H.field || K.fullField
        }
    }
}

function deepMerge(K, C) {
    if (C) {
        for (var H in C)
            if (C.hasOwnProperty(H)) {
                var W = C[H];
                typeof W == "object" && typeof K[H] == "object" ? K[H] = _extends({}, K[H], W) : K[H] = W
            }
    }
    return K
}
var required$1 = function (C, H, W, U, G, X) {
        C.required && (!W.hasOwnProperty(C.field) || isEmptyValue(H, X || C.type)) && U.push(format$2(G.messages.required,
            C.fullField))
    },
    whitespace = function (C, H, W, U, G) {
        (/^\s+$/.test(H) || H === "") && U.push(format$2(G.messages.whitespace, C.fullField))
    },
    urlReg, getUrlRegex = function () {
        if (urlReg) return urlReg;
        var K = "[a-fA-F\\d:]",
            C = function (de) {
                return de && de.includeBoundaries ? "(?:(?<=\\s|^)(?=" + K + ")|(?<=" + K + ")(?=\\s|$))" : ""
            },
            H = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}",
            W = "[a-fA-F\\d]{1,4}",
            U = (`
(?:
(?:` + W + ":){7}(?:" + W +
                `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + W + ":){6}(?:" + H +
                "|:" + W +
                `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` +
                W + ":){5}(?::" + H + "|(?::" + W +
                `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` +
                W + ":){4}(?:(?::" + W + "){0,1}:" + H + "|(?::" + W +
                `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + W +
                ":){3}(?:(?::" + W + "){0,2}:" + H + "|(?::" + W +
                `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + W +
                ":){2}(?:(?::" + W + "){0,3}:" + H + "|(?::" + W +
                `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + W +
                ":){1}(?:(?::" + W + "){0,4}:" + H + "|(?::" + W +
                `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + W +
                "){0,5}:" + H + "|(?::" + W +
                `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`
            ).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(),
            G = new RegExp("(?:^" + H + "$)|(?:^" + U + "$)"),
            X = new RegExp("^" + H + "$"),
            Z = new RegExp("^" + U + "$"),
            Q = function (de) {
                return de && de.exact ? G : new RegExp("(?:" + C(de) + H + C(de) + ")|(?:" + C(de) + U + C(de) + ")",
                    "g")
            };
        Q.v4 = function (ce) {
            return ce && ce.exact ? X : new RegExp("" + C(ce) + H + C(ce), "g")
        }, Q.v6 = function (ce) {
            return ce && ce.exact ? Z : new RegExp("" + C(ce) + U + C(ce), "g")
        };
        var ee = "(?:(?:[a-z]+:)?//)",
            ne = "(?:\\S+(?::\\S*)?@)?",
            te = Q.v4().source,
            re = Q.v6().source,
            ae = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)",
            oe = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*",
            ie = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))",
            ue = "(?::\\d{2,5})?",
            le = '(?:[/?#][^\\s"]*)?',
            se = "(?:" + ee + "|www\\.)" + ne + "(?:localhost|" + te + "|" + re + "|" + ae + oe + ie + ")" + ue + le;
        return urlReg = new RegExp("(?:^" + se + "$)", "i"), urlReg
    },
    pattern$2 = {
        email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
        hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
    },
    types$2 = {
        integer: function (C) {
            return types$2.number(C) && parseInt(C, 10) === C
        },
        float: function (C) {
            return types$2.number(C) && !types$2.integer(C)
        },
        array: function (C) {
            return Array.isArray(C)
        },
        regexp: function (C) {
            if (C instanceof RegExp) return !0;
            try {
                return !!new RegExp(C)
            } catch {
                return !1
            }
        },
        date: function (C) {
            return typeof C.getTime == "function" && typeof C.getMonth == "function" && typeof C.getYear ==
                "function" && !isNaN(C.getTime())
        },
        number: function (C) {
            return isNaN(C) ? !1 : typeof C == "number"
        },
        object: function (C) {
            return typeof C == "object" && !types$2.array(C)
        },
        method: function (C) {
            return typeof C == "function"
        },
        email: function (C) {
            return typeof C == "string" && C.length <= 320 && !!C.match(pattern$2.email)
        },
        url: function (C) {
            return typeof C == "string" && C.length <= 2048 && !!C.match(getUrlRegex())
        },
        hex: function (C) {
            return typeof C == "string" && !!C.match(pattern$2.hex)
        }
    },
    type$1 = function (C, H, W, U, G) {
        if (C.required && H === void 0) {
            required$1(C, H, W, U, G);
            return
        }
        var X = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"],
            Z = C.type;
        X.indexOf(Z) > -1 ? types$2[Z](H) || U.push(format$2(G.messages.types[Z], C.fullField, C.type)) : Z && typeof H !==
            C.type && U.push(format$2(G.messages.types[Z], C.fullField, C.type))
    },
    range = function (C, H, W, U, G) {
        var X = typeof C.len == "number",
            Z = typeof C.min == "number",
            Q = typeof C.max == "number",
            ee = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
            ne = H,
            te = null,
            re = typeof H == "number",
            ae = typeof H == "string",
            oe = Array.isArray(H);
        if (re ? te = "number" : ae ? te = "string" : oe && (te = "array"), !te) return !1;
        oe && (ne = H.length), ae && (ne = H.replace(ee, "_").length), X ? ne !== C.len && U.push(format$2(G.messages[
                te].len, C.fullField, C.len)) : Z && !Q && ne < C.min ? U.push(format$2(G.messages[te].min, C.fullField,
                C.min)) : Q && !Z && ne > C.max ? U.push(format$2(G.messages[te].max, C.fullField, C.max)) : Z && Q &&
            (ne < C.min || ne > C.max) && U.push(format$2(G.messages[te].range, C.fullField, C.min, C.max))
    },
    ENUM$1 = "enum",
    enumerable$1 = function (C, H, W, U, G) {
        C[ENUM$1] = Array.isArray(C[ENUM$1]) ? C[ENUM$1] : [], C[ENUM$1].indexOf(H) === -1 && U.push(format$2(G.messages[
            ENUM$1], C.fullField, C[ENUM$1].join(", ")))
    },
    pattern$1 = function (C, H, W, U, G) {
        if (C.pattern) {
            if (C.pattern instanceof RegExp) C.pattern.lastIndex = 0, C.pattern.test(H) || U.push(format$2(G.messages.pattern
                .mismatch, C.fullField, H, C.pattern));
            else if (typeof C.pattern == "string") {
                var X = new RegExp(C.pattern);
                X.test(H) || U.push(format$2(G.messages.pattern.mismatch, C.fullField, H, C.pattern))
            }
        }
    },
    rules = {
        required: required$1,
        whitespace,
        type: type$1,
        range,
        enum: enumerable$1,
        pattern: pattern$1
    },
    string = function (C, H, W, U, G) {
        var X = [],
            Z = C.required || !C.required && U.hasOwnProperty(C.field);
        if (Z) {
            if (isEmptyValue(H, "string") && !C.required) return W();
            rules.required(C, H, U, X, G, "string"), isEmptyValue(H, "string") || (rules.type(C, H, U, X, G), rules.range(
                C, H, U, X, G), rules.pattern(C, H, U, X, G), C.whitespace === !0 && rules.whitespace(C, H, U,
                X, G))
        }
        W(X)
    },
    method$1 = function (C, H, W, U, G) {
        var X = [],
            Z = C.required || !C.required && U.hasOwnProperty(C.field);
        if (Z) {
            if (isEmptyValue(H) && !C.required) return W();
            rules.required(C, H, U, X, G), H !== void 0 && rules.type(C, H, U, X, G)
        }
        W(X)
    },
    number = function (C, H, W, U, G) {
        var X = [],
            Z = C.required || !C.required && U.hasOwnProperty(C.field);
        if (Z) {
            if (H === "" && (H = void 0), isEmptyValue(H) && !C.required) return W();
            rules.required(C, H, U, X, G), H !== void 0 && (rules.type(C, H, U, X, G), rules.range(C, H, U, X, G))
        }
        W(X)
    },
    _boolean = function (C, H, W, U, G) {
        var X = [],
            Z = C.required || !C.required && U.hasOwnProperty(C.field);
        if (Z) {
            if (isEmptyValue(H) && !C.required) return W();
            rules.required(C, H, U, X, G), H !== void 0 && rules.type(C, H, U, X, G)
        }
        W(X)
    },
    regexp = function (C, H, W, U, G) {
        var X = [],
            Z = C.required || !C.required && U.hasOwnProperty(C.field);
        if (Z) {
            if (isEmptyValue(H) && !C.required) return W();
            rules.required(C, H, U, X, G), isEmptyValue(H) || rules.type(C, H, U, X, G)
        }
        W(X)
    },
    integer = function (C, H, W, U, G) {
        var X = [],
            Z = C.required || !C.required && U.hasOwnProperty(C.field);
        if (Z) {
            if (isEmptyValue(H) && !C.required) return W();
            rules.required(C, H, U, X, G), H !== void 0 && (rules.type(C, H, U, X, G), rules.range(C, H, U, X, G))
        }
        W(X)
    },
    floatFn = function (C, H, W, U, G) {
        var X = [],
            Z = C.required || !C.required && U.hasOwnProperty(C.field);
        if (Z) {
            if (isEmptyValue(H) && !C.required) return W();
            rules.required(C, H, U, X, G), H !== void 0 && (rules.type(C, H, U, X, G), rules.range(C, H, U, X, G))
        }
        W(X)
    },
    array = function (C, H, W, U, G) {
        var X = [],
            Z = C.required || !C.required && U.hasOwnProperty(C.field);
        if (Z) {
            if (H == null && !C.required) return W();
            rules.required(C, H, U, X, G, "array"), H != null && (rules.type(C, H, U, X, G), rules.range(C, H, U, X, G))
        }
        W(X)
    },
    object$1 = function (C, H, W, U, G) {
        var X = [],
            Z = C.required || !C.required && U.hasOwnProperty(C.field);
        if (Z) {
            if (isEmptyValue(H) && !C.required) return W();
            rules.required(C, H, U, X, G), H !== void 0 && rules.type(C, H, U, X, G)
        }
        W(X)
    },
    ENUM = "enum",
    enumerable = function (C, H, W, U, G) {
        var X = [],
            Z = C.required || !C.required && U.hasOwnProperty(C.field);
        if (Z) {
            if (isEmptyValue(H) && !C.required) return W();
            rules.required(C, H, U, X, G), H !== void 0 && rules[ENUM](C, H, U, X, G)
        }
        W(X)
    },
    pattern = function (C, H, W, U, G) {
        var X = [],
            Z = C.required || !C.required && U.hasOwnProperty(C.field);
        if (Z) {
            if (isEmptyValue(H, "string") && !C.required) return W();
            rules.required(C, H, U, X, G), isEmptyValue(H, "string") || rules.pattern(C, H, U, X, G)
        }
        W(X)
    },
    date = function (C, H, W, U, G) {
        var X = [],
            Z = C.required || !C.required && U.hasOwnProperty(C.field);
        if (Z) {
            if (isEmptyValue(H, "date") && !C.required) return W();
            if (rules.required(C, H, U, X, G), !isEmptyValue(H, "date")) {
                var Q;
                H instanceof Date ? Q = H : Q = new Date(H), rules.type(C, Q, U, X, G), Q && rules.range(C, Q.getTime(),
                    U, X, G)
            }
        }
        W(X)
    },
    required = function (C, H, W, U, G) {
        var X = [],
            Z = Array.isArray(H) ? "array" : typeof H;
        rules.required(C, H, U, X, G, Z), W(X)
    },
    type$2 = function (C, H, W, U, G) {
        var X = C.type,
            Z = [],
            Q = C.required || !C.required && U.hasOwnProperty(C.field);
        if (Q) {
            if (isEmptyValue(H, X) && !C.required) return W();
            rules.required(C, H, U, Z, G, X), isEmptyValue(H, X) || rules.type(C, H, U, Z, G)
        }
        W(Z)
    },
    any = function (C, H, W, U, G) {
        var X = [],
            Z = C.required || !C.required && U.hasOwnProperty(C.field);
        if (Z) {
            if (isEmptyValue(H) && !C.required) return W();
            rules.required(C, H, U, X, G)
        }
        W(X)
    },
    validators = {
        string,
        method: method$1,
        number,
        boolean: _boolean,
        regexp,
        integer,
        float: floatFn,
        array,
        object: object$1,
        enum: enumerable,
        pattern,
        date,
        url: type$2,
        hex: type$2,
        email: type$2,
        required,
        any
    };

function newMessages() {
    return {
        default: "Validation error on field %s",
        required: "%s is required",
        enum: "%s must be one of %s",
        whitespace: "%s cannot be empty",
        date: {
            format: "%s date %s is invalid for format %s",
            parse: "%s date could not be parsed, %s is invalid ",
            invalid: "%s date %s is invalid"
        },
        types: {
            string: "%s is not a %s",
            method: "%s is not a %s (function)",
            array: "%s is not an %s",
            object: "%s is not an %s",
            number: "%s is not a %s",
            date: "%s is not a %s",
            boolean: "%s is not a %s",
            integer: "%s is not an %s",
            float: "%s is not a %s",
            regexp: "%s is not a valid %s",
            email: "%s is not a valid %s",
            url: "%s is not a valid %s",
            hex: "%s is not a valid %s"
        },
        string: {
            len: "%s must be exactly %s characters",
            min: "%s must be at least %s characters",
            max: "%s cannot be longer than %s characters",
            range: "%s must be between %s and %s characters"
        },
        number: {
            len: "%s must equal %s",
            min: "%s cannot be less than %s",
            max: "%s cannot be greater than %s",
            range: "%s must be between %s and %s"
        },
        array: {
            len: "%s must be exactly %s in length",
            min: "%s cannot be less than %s in length",
            max: "%s cannot be greater than %s in length",
            range: "%s must be between %s and %s in length"
        },
        pattern: {
            mismatch: "%s value %s does not match pattern %s"
        },
        clone: function () {
            var C = JSON.parse(JSON.stringify(this));
            return C.clone = this.clone, C
        }
    }
}
var messages = newMessages(),
    Schema = function () {
        function K(H) {
            this.rules = null, this._messages = messages, this.define(H)
        }
        var C = K.prototype;
        return C.define = function (W) {
            var U = this;
            if (!W) throw new Error("Cannot configure a schema with no rules");
            if (typeof W != "object" || Array.isArray(W)) throw new Error("Rules must be an object");
            this.rules = {}, Object.keys(W).forEach(function (G) {
                var X = W[G];
                U.rules[G] = Array.isArray(X) ? X : [X]
            })
        }, C.messages = function (W) {
            return W && (this._messages = deepMerge(newMessages(), W)), this._messages
        }, C.validate = function (W, U, G) {
            var X = this;
            U === void 0 && (U = {}), G === void 0 && (G = function () {});
            var Z = W,
                Q = U,
                ee = G;
            if (typeof Q == "function" && (ee = Q, Q = {}), !this.rules || Object.keys(this.rules).length === 0)
                return ee && ee(null, Z), Promise.resolve(Z);

            function ne(ie) {
                var ue = [],
                    le = {};

                function se(de) {
                    if (Array.isArray(de)) {
                        var ve;
                        ue = (ve = ue).concat.apply(ve, de)
                    } else ue.push(de)
                }
                for (var ce = 0; ce < ie.length; ce++) se(ie[ce]);
                ue.length ? (le = convertFieldsError(ue), ee(ue, le)) : ee(null, Z)
            }
            if (Q.messages) {
                var te = this.messages();
                te === messages && (te = newMessages()), deepMerge(te, Q.messages), Q.messages = te
            } else Q.messages = this.messages();
            var re = {},
                ae = Q.keys || Object.keys(this.rules);
            ae.forEach(function (ie) {
                var ue = X.rules[ie],
                    le = Z[ie];
                ue.forEach(function (se) {
                    var ce = se;
                    typeof ce.transform == "function" && (Z === W && (Z = _extends({}, Z)), le = Z[
                            ie] = ce.transform(le)), typeof ce == "function" ? ce = {
                            validator: ce
                        } : ce = _extends({}, ce), ce.validator = X.getValidationMethod(ce), ce.validator &&
                        (ce.field = ie, ce.fullField = ce.fullField || ie, ce.type = X.getType(ce),
                            re[ie] = re[ie] || [], re[ie].push({
                                rule: ce,
                                value: le,
                                source: Z,
                                field: ie
                            }))
                })
            });
            var oe = {};
            return asyncMap(re, Q, function (ie, ue) {
                var le = ie.rule,
                    se = (le.type === "object" || le.type === "array") && (typeof le.fields == "object" ||
                        typeof le.defaultField == "object");
                se = se && (le.required || !le.required && ie.value), le.field = ie.field;

                function ce(fe, pe) {
                    return _extends({}, pe, {
                        fullField: le.fullField + "." + fe,
                        fullFields: le.fullFields ? [].concat(le.fullFields, [fe]) : [fe]
                    })
                }

                function de(fe) {
                    fe === void 0 && (fe = []);
                    var pe = Array.isArray(fe) ? fe : [fe];
                    !Q.suppressWarning && pe.length && K.warning("async-validator:", pe), pe.length && le.message !==
                        void 0 && (pe = [].concat(le.message));
                    var me = pe.map(complementError(le, Z));
                    if (Q.first && me.length) return oe[le.field] = 1, ue(me);
                    if (!se) ue(me);
                    else {
                        if (le.required && !ie.value) return le.message !== void 0 ? me = [].concat(le.message)
                            .map(complementError(le, Z)) : Q.error && (me = [Q.error(le, format$2(Q.messages
                                .required, le.field))]), ue(me);
                        var he = {};
                        le.defaultField && Object.keys(ie.value).map(function (be) {
                            he[be] = le.defaultField
                        }), he = _extends({}, he, ie.rule.fields);
                        var Se = {};
                        Object.keys(he).forEach(function (be) {
                            var ge = he[be],
                                xe = Array.isArray(ge) ? ge : [ge];
                            Se[be] = xe.map(ce.bind(null, be))
                        });
                        var _e = new K(Se);
                        _e.messages(Q.messages), ie.rule.options && (ie.rule.options.messages = Q.messages,
                            ie.rule.options.error = Q.error), _e.validate(ie.value, ie.rule.options ||
                            Q,
                            function (be) {
                                var ge = [];
                                me && me.length && ge.push.apply(ge, me), be && be.length && ge.push.apply(
                                    ge, be), ue(ge.length ? ge : null)
                            })
                    }
                }
                var ve;
                if (le.asyncValidator) ve = le.asyncValidator(le, ie.value, de, ie.source, Q);
                else if (le.validator) {
                    try {
                        ve = le.validator(le, ie.value, de, ie.source, Q)
                    } catch (fe) {
                        console.error == null || console.error(fe), Q.suppressValidatorError || setTimeout(
                            function () {
                                throw fe
                            }, 0), de(fe.message)
                    }
                    ve === !0 ? de() : ve === !1 ? de(typeof le.message == "function" ? le.message(le.fullField ||
                            le.field) : le.message || (le.fullField || le.field) + " fails") : ve instanceof Array ?
                        de(ve) : ve instanceof Error && de(ve.message)
                }
                ve && ve.then && ve.then(function () {
                    return de()
                }, function (fe) {
                    return de(fe)
                })
            }, function (ie) {
                ne(ie)
            }, Z)
        }, C.getType = function (W) {
            if (W.type === void 0 && W.pattern instanceof RegExp && (W.type = "pattern"), typeof W.validator !=
                "function" && W.type && !validators.hasOwnProperty(W.type)) throw new Error(format$2(
                "Unknown rule type %s", W.type));
            return W.type || "string"
        }, C.getValidationMethod = function (W) {
            if (typeof W.validator == "function") return W.validator;
            var U = Object.keys(W),
                G = U.indexOf("message");
            return G !== -1 && U.splice(G, 1), U.length === 1 && U[0] === "required" ? validators.required :
                validators[this.getType(W)] || void 0
        }, K
    }();
Schema.register = function (C, H) {
    if (typeof H != "function") throw new Error("Cannot register a validator by type, validator is not a function");
    validators[C] = H
};
Schema.warning = warning;
Schema.messages = messages;
Schema.validators = validators;

function toArray$6(K) {
    return K == null ? [] : Array.isArray(K) ? K : [K]
}

function get$4(K, C) {
    for (var H = K, W = 0; W < C.length; W += 1) {
        if (H == null) return;
        H = H[C[W]]
    }
    return H
}

function internalSet(K, C, H, W) {
    if (!C.length) return H;
    var U = _toArray(C),
        G = U[0],
        X = U.slice(1),
        Z;
    return !K && typeof G == "number" ? Z = [] : Array.isArray(K) ? Z = _toConsumableArray(K) : Z = _objectSpread2$1({},
        K), W && H === void 0 && X.length === 1 ? delete Z[G][X[0]] : Z[G] = internalSet(Z[G], X, H, W), Z
}

function set$2(K, C, H) {
    var W = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
    return C.length && W && H === void 0 && !get$4(K, C.slice(0, -1)) ? K : internalSet(K, C, H, W)
}

function getNamePath(K) {
    return toArray$6(K)
}

function getValue(K, C) {
    var H = get$4(K, C);
    return H
}

function setValue(K, C, H) {
    var W = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1,
        U = set$2(K, C, H, W);
    return U
}

function containsNamePath(K, C) {
    return K && K.some(function (H) {
        return matchNamePath(H, C)
    })
}

function isObject$1(K) {
    return _typeof$2(K) === "object" && K !== null && Object.getPrototypeOf(K) === Object.prototype
}

function internalSetValues(K, C) {
    var H = Array.isArray(K) ? _toConsumableArray(K) : _objectSpread2$1({}, K);
    return C && Object.keys(C).forEach(function (W) {
        var U = H[W],
            G = C[W],
            X = isObject$1(U) && isObject$1(G);
        H[W] = X ? internalSetValues(U, G || {}) : G
    }), H
}

function setValues(K) {
    for (var C = arguments.length, H = new Array(C > 1 ? C - 1 : 0), W = 1; W < C; W++) H[W - 1] = arguments[W];
    return H.reduce(function (U, G) {
        return internalSetValues(U, G)
    }, K)
}

function cloneByNamePathList(K, C) {
    var H = {};
    return C.forEach(function (W) {
        var U = getValue(K, W);
        H = setValue(H, W, U)
    }), H
}

function matchNamePath(K, C) {
    return !K || !C || K.length !== C.length ? !1 : K.every(function (H, W) {
        return C[W] === H
    })
}
var typeTemplate = "'${name}' is not a valid ${type}",
    defaultValidateMessages = {
        default: "Validation error on field '${name}'",
        required: "'${name}' is required",
        enum: "'${name}' must be one of [${enum}]",
        whitespace: "'${name}' cannot be empty",
        date: {
            format: "'${name}' is invalid for format date",
            parse: "'${name}' could not be parsed as date",
            invalid: "'${name}' is invalid date"
        },
        types: {
            string: typeTemplate,
            method: typeTemplate,
            array: typeTemplate,
            object: typeTemplate,
            number: typeTemplate,
            date: typeTemplate,
            boolean: typeTemplate,
            integer: typeTemplate,
            float: typeTemplate,
            regexp: typeTemplate,
            email: typeTemplate,
            url: typeTemplate,
            hex: typeTemplate
        },
        string: {
            len: "'${name}' must be exactly ${len} characters",
            min: "'${name}' must be at least ${min} characters",
            max: "'${name}' cannot be longer than ${max} characters",
            range: "'${name}' must be between ${min} and ${max} characters"
        },
        number: {
            len: "'${name}' must equal ${len}",
            min: "'${name}' cannot be less than ${min}",
            max: "'${name}' cannot be greater than ${max}",
            range: "'${name}' must be between ${min} and ${max}"
        },
        array: {
            len: "'${name}' must be exactly ${len} in length",
            min: "'${name}' cannot be less than ${min} in length",
            max: "'${name}' cannot be greater than ${max} in length",
            range: "'${name}' must be between ${min} and ${max} in length"
        },
        pattern: {
            mismatch: "'${name}' does not match pattern ${pattern}"
        }
    },
    AsyncValidator = Schema;

function replaceMessage(K, C) {
    return K.replace(/\$\{\w+\}/g, function (H) {
        var W = H.slice(2, -1);
        return C[W]
    })
}

function validateRule(K, C, H, W, U) {
    return _validateRule.apply(this, arguments)
}

function _validateRule() {
    return _validateRule = _asyncToGenerator(regenerator.mark(function K(C, H, W, U, G) {
        var X, Z, Q, ee, ne, te, re, ae;
        return regenerator.wrap(function (ie) {
            for (;;) switch (ie.prev = ie.next) {
                case 0:
                    return X = _objectSpread2$1({}, W), delete X.ruleIndex, delete X.trigger, Z =
                        null, X && X.type === "array" && X.defaultField && (Z = X.defaultField,
                            delete X.defaultField), Q = new AsyncValidator(_defineProperty$V({},
                            C, [X])), ee = setValues({}, defaultValidateMessages, U.validateMessages),
                        Q.messages(ee), ne = [], ie.prev = 9, ie.next = 12, Promise.resolve(Q.validate(
                            _defineProperty$V({}, C, H), _objectSpread2$1({}, U)));
                case 12:
                    ie.next = 17;
                    break;
                case 14:
                    ie.prev = 14, ie.t0 = ie.catch(9), ie.t0.errors ? ne = ie.t0.errors.map(
                        function (ue, le) {
                            var se = ue.message;
                            return isValidElement(se) ? cloneVNode(se, {
                                key: "error_".concat(le)
                            }) : se
                        }) : (console.error(ie.t0), ne = [ee.default()]);
                case 17:
                    if (!(!ne.length && Z)) {
                        ie.next = 22;
                        break
                    }
                    return ie.next = 20, Promise.all(H.map(function (ue, le) {
                        return validateRule("".concat(C, ".").concat(le), ue, Z, U,
                            G)
                    }));
                case 20:
                    return te = ie.sent, ie.abrupt("return", te.reduce(function (ue, le) {
                        return [].concat(_toConsumableArray(ue), _toConsumableArray(
                            le))
                    }, []));
                case 22:
                    return re = _objectSpread2$1(_objectSpread2$1({}, W), {}, {
                        name: C,
                        enum: (W.enum || []).join(", ")
                    }, G), ae = ne.map(function (ue) {
                        return typeof ue == "string" ? replaceMessage(ue, re) : ue
                    }), ie.abrupt("return", ae);
                case 25:
                case "end":
                    return ie.stop()
            }
        }, K, null, [[9, 14]])
    })), _validateRule.apply(this, arguments)
}

function validateRules(K, C, H, W, U, G) {
    var X = K.join("."),
        Z = H.map(function (ne, te) {
            var re = ne.validator,
                ae = _objectSpread2$1(_objectSpread2$1({}, ne), {}, {
                    ruleIndex: te
                });
            return re && (ae.validator = function (oe, ie, ue) {
                var le = !1,
                    se = function () {
                        for (var ve = arguments.length, fe = new Array(ve), pe = 0; pe < ve; pe++) fe[pe] =
                            arguments[pe];
                        Promise.resolve().then(function () {
                            le || ue.apply(void 0, fe)
                        })
                    },
                    ce = re(oe, ie, se);
                le = ce && typeof ce.then == "function" && typeof ce.catch == "function", le && ce.then(
                    function () {
                        ue()
                    }).catch(function (de) {
                    ue(de || " ")
                })
            }), ae
        }).sort(function (ne, te) {
            var re = ne.warningOnly,
                ae = ne.ruleIndex,
                oe = te.warningOnly,
                ie = te.ruleIndex;
            return !!re == !!oe ? ae - ie : re ? 1 : -1
        }),
        Q;
    if (U === !0) Q = new Promise(function () {
        var ne = _asyncToGenerator(regenerator.mark(function te(re, ae) {
            var oe, ie, ue;
            return regenerator.wrap(function (se) {
                for (;;) switch (se.prev = se.next) {
                    case 0:
                        oe = 0;
                    case 1:
                        if (!(oe < Z.length)) {
                            se.next = 12;
                            break
                        }
                        return ie = Z[oe], se.next = 5, validateRule(X, C, ie, W, G);
                    case 5:
                        if (ue = se.sent, !ue.length) {
                            se.next = 9;
                            break
                        }
                        return ae([{
                            errors: ue,
                            rule: ie
                        }]), se.abrupt("return");
                    case 9:
                        oe += 1, se.next = 1;
                        break;
                    case 12:
                        re([]);
                    case 13:
                    case "end":
                        return se.stop()
                }
            }, te)
        }));
        return function (te, re) {
            return ne.apply(this, arguments)
        }
    }());
    else {
        var ee = Z.map(function (ne) {
            return validateRule(X, C, ne, W, G).then(function (te) {
                return {
                    errors: te,
                    rule: ne
                }
            })
        });
        Q = (U ? finishOnFirstFailed(ee) : finishOnAllFailed(ee)).then(function (ne) {
            return Promise.reject(ne)
        })
    }
    return Q.catch(function (ne) {
        return ne
    }), Q
}

function finishOnAllFailed(K) {
    return _finishOnAllFailed.apply(this, arguments)
}

function _finishOnAllFailed() {
    return _finishOnAllFailed = _asyncToGenerator(regenerator.mark(function K(C) {
        return regenerator.wrap(function (W) {
            for (;;) switch (W.prev = W.next) {
                case 0:
                    return W.abrupt("return", Promise.all(C).then(function (U) {
                        var G, X = (G = []).concat.apply(G, _toConsumableArray(U));
                        return X
                    }));
                case 1:
                case "end":
                    return W.stop()
            }
        }, K)
    })), _finishOnAllFailed.apply(this, arguments)
}

function finishOnFirstFailed(K) {
    return _finishOnFirstFailed.apply(this, arguments)
}

function _finishOnFirstFailed() {
    return _finishOnFirstFailed = _asyncToGenerator(regenerator.mark(function K(C) {
        var H;
        return regenerator.wrap(function (U) {
            for (;;) switch (U.prev = U.next) {
                case 0:
                    return H = 0, U.abrupt("return", new Promise(function (G) {
                        C.forEach(function (X) {
                            X.then(function (Z) {
                                Z.errors.length && G([Z]), H += 1,
                                    H === C.length && G([])
                            })
                        })
                    }));
                case 2:
                case "end":
                    return U.stop()
            }
        }, K)
    })), _finishOnFirstFailed.apply(this, arguments)
}
var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;

function baseIsMatch(K, C, H, W) {
    var U = H.length,
        G = U,
        X = !W;
    if (K == null) return !G;
    for (K = Object(K); U--;) {
        var Z = H[U];
        if (X && Z[2] ? Z[1] !== K[Z[0]] : !(Z[0] in K)) return !1
    }
    for (; ++U < G;) {
        Z = H[U];
        var Q = Z[0],
            ee = K[Q],
            ne = Z[1];
        if (X && Z[2]) {
            if (ee === void 0 && !(Q in K)) return !1
        } else {
            var te = new Stack;
            if (W) var re = W(ee, ne, Q, K, C, te);
            if (!(re === void 0 ? baseIsEqual(ne, ee, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, W, te) : re))
                return !1
        }
    }
    return !0
}

function isStrictComparable(K) {
    return K === K && !isObject$2(K)
}

function getMatchData(K) {
    for (var C = keys$1(K), H = C.length; H--;) {
        var W = C[H],
            U = K[W];
        C[H] = [W, U, isStrictComparable(U)]
    }
    return C
}

function matchesStrictComparable(K, C) {
    return function (H) {
        return H == null ? !1 : H[K] === C && (C !== void 0 || K in Object(H))
    }
}

function baseMatches(K) {
    var C = getMatchData(K);
    return C.length == 1 && C[0][2] ? matchesStrictComparable(C[0][0], C[0][1]) : function (H) {
        return H === K || baseIsMatch(H, K, C)
    }
}

function get$3(K, C, H) {
    var W = K == null ? void 0 : baseGet(K, C);
    return W === void 0 ? H : W
}
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

function baseMatchesProperty(K, C) {
    return isKey(K) && isStrictComparable(C) ? matchesStrictComparable(toKey(K), C) : function (H) {
        var W = get$3(H, K);
        return W === void 0 && W === C ? hasIn(H, K) : baseIsEqual(C, W, COMPARE_PARTIAL_FLAG |
            COMPARE_UNORDERED_FLAG)
    }
}

function basePropertyDeep(K) {
    return function (C) {
        return baseGet(C, K)
    }
}

function property(K) {
    return isKey(K) ? baseProperty(toKey(K)) : basePropertyDeep(K)
}

function baseIteratee(K) {
    return typeof K == "function" ? K : K == null ? identity : typeof K == "object" ? isArray$2(K) ?
        baseMatchesProperty(K[0], K[1]) : baseMatches(K) : property(K)
}

function createFind(K) {
    return function (C, H, W) {
        var U = Object(C);
        if (!isArrayLike(C)) {
            var G = baseIteratee(H);
            C = keys$1(C), H = function (Z) {
                return G(U[Z], Z, U)
            }
        }
        var X = K(C, H, W);
        return X > -1 ? U[G ? C[X] : X] : void 0
    }
}
var nativeMax = Math.max;

function findIndex(K, C, H) {
    var W = K == null ? 0 : K.length;
    if (!W) return -1;
    var U = H == null ? 0 : toInteger(H);
    return U < 0 && (U = nativeMax(W + U, 0)), baseFindIndex(K, baseIteratee(C), U)
}
var find = createFind(findIndex);
const find$1 = find;
var FormContextKey = Symbol("formContextKey"),
    useProvideForm = function (C) {
        provide(FormContextKey, C)
    },
    useInjectForm = function () {
        return inject(FormContextKey, {
            name: computed(function () {}),
            labelAlign: computed(function () {
                return "right"
            }),
            vertical: computed(function () {
                return !1
            }),
            addField: function (H, W) {},
            removeField: function (H) {},
            model: computed(function () {}),
            rules: computed(function () {}),
            colon: computed(function () {}),
            labelWrap: computed(function () {}),
            labelCol: computed(function () {}),
            requiredMark: computed(function () {
                return !1
            }),
            validateTrigger: computed(function () {}),
            onValidate: function () {},
            validateMessages: computed(function () {
                return defaultValidateMessages
            })
        })
    },
    FormItemPrefixContextKey = Symbol("formItemPrefixContextKey"),
    useProvideFormItemPrefix = function (C) {
        provide(FormItemPrefixContextKey, C)
    },
    useInjectFormItemPrefix = function () {
        return inject(FormItemPrefixContextKey, {
            prefixCls: computed(function () {
                return ""
            })
        })
    },
    FormItemLabel = function (C, H) {
        var W, U, G, X, Z = H.slots,
            Q = H.emit,
            ee = H.attrs,
            ne = _objectSpread2$1(_objectSpread2$1({}, C), ee),
            te = ne.prefixCls,
            re = ne.htmlFor,
            ae = ne.labelCol,
            oe = ne.labelAlign,
            ie = ne.colon,
            ue = ne.required,
            le = ne.requiredMark,
            se = useLocaleReceiver("Form"),
            ce = _slicedToArray$2(se, 1),
            de = ce[0],
            ve = (W = C.label) !== null && W !== void 0 ? W : (U = Z.label) === null || U === void 0 ? void 0 : U.call(
                Z);
        if (!ve) return null;
        var fe = useInjectForm(),
            pe = fe.vertical,
            me = fe.labelAlign,
            he = fe.labelCol,
            Se = fe.labelWrap,
            _e = fe.colon,
            be = ae || (he == null ? void 0 : he.value) || {},
            ge = oe || (me == null ? void 0 : me.value),
            xe = "".concat(te, "-item-label"),
            Pe = classNames(xe, ge === "left" && "".concat(xe, "-left"), be.class, _defineProperty$V({}, "".concat(xe,
                "-wrap"), !!Se.value)),
            $e = ve,
            ye = ie === !0 || (_e == null ? void 0 : _e.value) !== !1 && ie !== !1,
            Ce = ye && !pe.value;
        if (Ce && typeof ve == "string" && ve.trim() !== "" && ($e = ve.replace(/[:|]\s*$/, "")), $e = createVNode(
                Fragment, null, [$e, (G = Z.tooltip) === null || G === void 0 ? void 0 : G.call(Z, {
                    class: "".concat(te, "-item-tooltip")
                })]), le === "optional" && !ue) {
            var we, Oe;
            $e = createVNode(Fragment, null, [$e, createVNode("span", {
                class: "".concat(te, "-item-optional")
            }, [((we = de.value) === null || we === void 0 ? void 0 : we.optional) || ((Oe =
                defaultLocale.Form) === null || Oe === void 0 ? void 0 : Oe.optional)])])
        }
        var Ne = classNames((X = {}, _defineProperty$V(X, "".concat(te, "-item-required"), ue), _defineProperty$V(X, ""
            .concat(te, "-item-required-mark-optional"), le === "optional"), _defineProperty$V(X, "".concat(
            te, "-item-no-colon"), !ye), X));
        return createVNode(Col$1, _objectSpread2$1(_objectSpread2$1({}, be), {}, {
            class: Pe
        }), {
            default: function () {
                return [createVNode("label", {
                    for: re,
                    class: Ne,
                    title: typeof ve == "string" ? ve : "",
                    onClick: function (ke) {
                        return Q("click", ke)
                    }
                }, [$e])]
            }
        })
    };
FormItemLabel.displayName = "FormItemLabel";
FormItemLabel.inheritAttrs = !1;
const FormItemLabel$1 = FormItemLabel,
    ErrorList = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ErrorList",
        props: ["errors", "help", "onDomErrorVisibleChange", "helpStatus", "warnings"],
        setup: function (C) {
            var H = useConfigInject("", C),
                W = H.prefixCls,
                U = useInjectFormItemPrefix(),
                G = U.prefixCls,
                X = U.status,
                Z = computed(function () {
                    return "".concat(G.value, "-item-explain")
                }),
                Q = computed(function () {
                    return !!(C.errors && C.errors.length)
                }),
                ee = ref(X.value);
            return watch([Q, X], function () {
                    Q.value && (ee.value = X.value)
                }),
                function () {
                    var ne, te, re = collapseMotion$1("".concat(W.value, "-show-help-item")),
                        ae = getTransitionGroupProps("".concat(W.value, "-show-help-item"), re);
                    return ae.class = Z.value, (ne = C.errors) !== null && ne !== void 0 && ne.length ?
                        createVNode(TransitionGroup, _objectSpread2$1(_objectSpread2$1({}, ae), {}, {
                            tag: "div"
                        }), {
                            default: function () {
                                return [(te = C.errors) === null || te === void 0 ? void 0 : te.map(
                                    function (ie, ue) {
                                        return createVNode("div", {
                                            key: ue,
                                            role: "alert",
                                            class: ee.value ? "".concat(Z.value, "-").concat(
                                                ee.value) : ""
                                        }, [ie])
                                    })]
                            }
                        }) : null
                }
        }
    });
var iconMap = {
        success: CheckCircleFilled$1,
        warning: ExclamationCircleFilled$1,
        error: CloseCircleFilled$1,
        validating: LoadingOutlined$1
    },
    FormItemInput = defineComponent({
        compatConfig: {
            MODE: 3
        },
        slots: ["help", "extra", "errors"],
        inheritAttrs: !1,
        props: ["prefixCls", "errors", "hasFeedback", "onDomErrorVisibleChange", "wrapperCol", "help", "extra",
            "status"],
        setup: function (C, H) {
            var W = H.slots,
                U = useInjectForm(),
                G = U.wrapperCol,
                X = _objectSpread2$1({}, U);
            return delete X.labelCol, delete X.wrapperCol, useProvideForm(X), useProvideFormItemPrefix({
                    prefixCls: computed(function () {
                        return C.prefixCls
                    }),
                    status: computed(function () {
                        return C.status
                    })
                }),
                function () {
                    var Z, Q, ee, ne = C.prefixCls,
                        te = C.wrapperCol,
                        re = C.help,
                        ae = re === void 0 ? (Z = W.help) === null || Z === void 0 ? void 0 : Z.call(W) : re,
                        oe = C.errors,
                        ie = oe === void 0 ? (Q = W.errors) === null || Q === void 0 ? void 0 : Q.call(W) : oe,
                        ue = C.hasFeedback,
                        le = C.status,
                        se = C.extra,
                        ce = se === void 0 ? (ee = W.extra) === null || ee === void 0 ? void 0 : ee.call(W) :
                        se,
                        de = "".concat(ne, "-item"),
                        ve = te || (G == null ? void 0 : G.value) || {},
                        fe = classNames("".concat(de, "-control"), ve.class),
                        pe = le && iconMap[le];
                    return createVNode(Col$1, _objectSpread2$1(_objectSpread2$1({}, ve), {}, {
                        class: fe
                    }), {
                        default: function () {
                            var he;
                            return createVNode(Fragment, null, [createVNode("div", {
                                class: "".concat(de, "-control-input")
                            }, [createVNode("div", {
                                class: "".concat(de,
                                    "-control-input-content")
                            }, [(he = W.default) === null || he === void 0 ?
                                void 0 : he.call(W)]), ue && pe ? createVNode(
                                "span", {
                                    class: "".concat(de, "-children-icon")
                                }, [createVNode(pe, null, null)]) : null]), createVNode(
                                ErrorList, {
                                    errors: ie,
                                    help: ae,
                                    class: "".concat(de, "-explain-connected")
                                }, null), ce ? createVNode("div", {
                                class: "".concat(de, "-extra")
                            }, [ce]) : null])
                        }
                    })
                }
        }
    });
const FormItemInput$1 = FormItemInput;

function useDebounce(K) {
    var C = shallowRef(K.value.slice()),
        H = null;
    return watchEffect(function () {
        clearTimeout(H), H = setTimeout(function () {
            C.value = K.value
        }, K.value.length ? 0 : 10)
    }), C
}
tuple$1("success", "warning", "error", "validating", "");

function getPropByPath$1(K, C, H) {
    var W = K,
        U = C,
        G = 0;
    try {
        for (var X = U.length; G < X - 1 && !(!W && !H); ++G) {
            var Z = U[G];
            if (Z in W) W = W[Z];
            else {
                if (H) throw Error("please transfer a valid name path to form item!");
                break
            }
        }
        if (H && !W) throw Error("please transfer a valid name path to form item!")
    } catch {
        console.error("please transfer a valid name path to form item!")
    }
    return {
        o: W,
        k: U[G],
        v: W ? W[U[G]] : void 0
    }
}
var formItemProps = function () {
        return {
            htmlFor: String,
            prefixCls: String,
            label: PropTypes$1.any,
            help: PropTypes$1.any,
            extra: PropTypes$1.any,
            labelCol: {
                type: Object
            },
            wrapperCol: {
                type: Object
            },
            hasFeedback: {
                type: Boolean,
                default: !1
            },
            colon: {
                type: Boolean,
                default: void 0
            },
            labelAlign: PropTypes$1.oneOf(tuple$1("left", "right")),
            prop: {
                type: [String, Number, Array]
            },
            name: {
                type: [String, Number, Array]
            },
            rules: [Array, Object],
            autoLink: {
                type: Boolean,
                default: !0
            },
            required: {
                type: Boolean,
                default: void 0
            },
            validateFirst: {
                type: Boolean,
                default: void 0
            },
            validateStatus: PropTypes$1.oneOf(tuple$1("", "success", "warning", "error", "validating")),
            validateTrigger: {
                type: [String, Array]
            },
            messageVariables: {
                type: Object
            },
            hidden: Boolean,
            noStyle: Boolean
        }
    },
    indexGuid$1 = 0,
    defaultItemNamePrefixCls = "form_item";
const FormItem = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AFormItem",
    inheritAttrs: !1,
    __ANT_NEW_FORM_ITEM: !0,
    props: formItemProps(),
    slots: ["help", "label", "extra"],
    setup: function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = H.expose;
        C.prop;
        var X = "form-item-".concat(++indexGuid$1),
            Z = useConfigInject("form", C),
            Q = Z.prefixCls,
            ee = useInjectForm(),
            ne = computed(function () {
                return C.name || C.prop
            }),
            te = ref([]),
            re = ref(!1),
            ae = ref(),
            oe = computed(function () {
                var we = ne.value;
                return getNamePath(we)
            }),
            ie = computed(function () {
                if (oe.value.length) {
                    var we = ee.name.value,
                        Oe = oe.value.join("_");
                    return we ? "".concat(we, "_").concat(Oe) : "".concat(defaultItemNamePrefixCls, "_")
                        .concat(Oe)
                } else return
            }),
            ue = function () {
                var Oe = ee.model.value;
                if (!(!Oe || !ne.value)) return getPropByPath$1(Oe, oe.value, !0).v
            },
            le = computed(function () {
                return ue()
            }),
            se = ref(cloneDeep(le.value)),
            ce = computed(function () {
                var we = C.validateTrigger !== void 0 ? C.validateTrigger : ee.validateTrigger.value;
                return we = we === void 0 ? "change" : we, toArray$6(we)
            }),
            de = computed(function () {
                var we = ee.rules.value,
                    Oe = C.rules,
                    Ne = C.required !== void 0 ? {
                        required: !!C.required,
                        trigger: ce.value
                    } : [],
                    Me = getPropByPath$1(we, oe.value);
                we = we ? Me.o[Me.k] || Me.v : [];
                var Ve = [].concat(Oe || we || []);
                return find$1(Ve, function (ke) {
                    return ke.required
                }) ? Ve : Ve.concat(Ne)
            }),
            ve = computed(function () {
                var we = de.value,
                    Oe = !1;
                return we && we.length && we.every(function (Ne) {
                    return Ne.required ? (Oe = !0, !1) : !0
                }), Oe || C.required
            }),
            fe = ref();
        watchEffect(function () {
            fe.value = C.validateStatus
        });
        var pe = computed(function () {
                var we = {};
                return typeof C.label == "string" ? we.label = C.label : C.name && (we.label = String(
                    name)), C.messageVariables && (we = _objectSpread2$1(_objectSpread2$1({}, we),
                    C.messageVariables)), we
            }),
            me = function (Oe) {
                if (oe.value.length !== 0) {
                    var Ne = C.validateFirst,
                        Me = Ne === void 0 ? !1 : Ne,
                        Ve = Oe || {},
                        ke = Ve.triggerName,
                        Ee = de.value;
                    if (ke && (Ee = Ee.filter(function (Re) {
                            var He = Re.trigger;
                            if (!He && !ce.value.length) return !0;
                            var je = toArray$6(He || ce.value);
                            return je.includes(ke)
                        })), !Ee.length) return Promise.resolve();
                    var Ae = validateRules(oe.value, le.value, Ee, _objectSpread2$1({
                        validateMessages: ee.validateMessages.value
                    }, Oe), Me, pe.value);
                    return fe.value = "validating", te.value = [], Ae.catch(function (Re) {
                        return Re
                    }).then(function () {
                        var Re = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                        if (fe.value === "validating") {
                            var He = Re.filter(function (je) {
                                return je && je.errors.length
                            });
                            fe.value = He.length ? "error" : "success", te.value = He.map(function (
                                je) {
                                return je.errors
                            }), ee.onValidate(ne.value, !te.value.length, te.value.length ?
                                toRaw(te.value[0]) : null)
                        }
                    }), Ae
                }
            },
            he = function () {
                me({
                    triggerName: "blur"
                })
            },
            Se = function () {
                if (re.value) {
                    re.value = !1;
                    return
                }
                me({
                    triggerName: "change"
                })
            },
            _e = function () {
                fe.value = C.validateStatus, re.value = !1, te.value = []
            },
            be = function () {
                fe.value = C.validateStatus, re.value = !0, te.value = [];
                var Oe = ee.model.value || {},
                    Ne = le.value,
                    Me = getPropByPath$1(Oe, oe.value, !0);
                Array.isArray(Ne) ? Me.o[Me.k] = [].concat(se.value) : Me.o[Me.k] = se.value, nextTick(
                    function () {
                        re.value = !1
                    })
            },
            ge = computed(function () {
                return C.htmlFor === void 0 ? ie.value : C.htmlFor
            }),
            xe = function () {
                var Oe = ge.value;
                if (!(!Oe || !ae.value)) {
                    var Ne = ae.value.$el.querySelector('[id="'.concat(Oe, '"]'));
                    Ne && Ne.focus && Ne.focus()
                }
            };
        G({
            onFieldBlur: he,
            onFieldChange: Se,
            clearValidate: _e,
            resetField: be
        }), useProvideFormItemContext({
            id: ie,
            onFieldBlur: function () {
                C.autoLink && he()
            },
            onFieldChange: function () {
                C.autoLink && Se()
            },
            clearValidate: _e
        }, computed(function () {
            return !!(C.autoLink && ee.model.value && ne.value)
        }));
        var Pe = !1;
        watch(ne, function (we) {
            we ? Pe || (Pe = !0, ee.addField(X, {
                fieldValue: le,
                fieldId: ie,
                fieldName: ne,
                resetField: be,
                clearValidate: _e,
                namePath: oe,
                validateRules: me,
                rules: de
            })) : (Pe = !1, ee.removeField(X))
        }, {
            immediate: !0
        }), onBeforeUnmount(function () {
            ee.removeField(X)
        });
        var $e = useDebounce(te),
            ye = computed(function () {
                return C.validateStatus !== void 0 ? C.validateStatus : $e.value.length ? "error" : fe.value
            }),
            Ce = computed(function () {
                var we;
                return we = {}, _defineProperty$V(we, "".concat(Q.value, "-item"), !0),
                    _defineProperty$V(we, "".concat(Q.value, "-item-has-feedback"), ye.value && C.hasFeedback),
                    _defineProperty$V(we, "".concat(Q.value, "-item-has-success"), ye.value ===
                        "success"), _defineProperty$V(we, "".concat(Q.value, "-item-has-warning"), ye.value ===
                        "warning"), _defineProperty$V(we, "".concat(Q.value, "-item-has-error"), ye.value ===
                        "error"), _defineProperty$V(we, "".concat(Q.value, "-item-is-validating"), ye.value ===
                        "validating"), _defineProperty$V(we, "".concat(Q.value, "-item-hidden"), C.hidden),
                    we
            });
        return function () {
            var we, Oe;
            if (C.noStyle) return (we = W.default) === null || we === void 0 ? void 0 : we.call(W);
            var Ne = (Oe = C.help) !== null && Oe !== void 0 ? Oe : W.help ? filterEmpty(W.help()) :
                null;
            return createVNode(Row$3, _objectSpread2$1(_objectSpread2$1({}, U), {}, {
                class: [Ce.value, Ne != null || $e.value.length ? "".concat(Q.value,
                    "-item-with-help") : "", U.class],
                key: "row"
            }), {
                default: function () {
                    var Ve, ke, Ee, Ae;
                    return createVNode(Fragment, null, [createVNode(FormItemLabel$1,
                        _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                            htmlFor: ge.value,
                            required: ve.value,
                            requiredMark: ee.requiredMark.value,
                            prefixCls: Q.value,
                            onClick: xe,
                            label: (Ve = C.label) !== null && Ve !== void 0 ?
                                Ve : (ke = W.label) === null || ke === void 0 ?
                                void 0 : ke.call(W)
                        }), null), createVNode(FormItemInput$1,
                        _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                            errors: Ne != null ? toArray$6(Ne) : $e.value,
                            prefixCls: Q.value,
                            status: ye.value,
                            ref: ae,
                            help: Ne,
                            extra: (Ee = C.extra) !== null && Ee !== void 0 ?
                                Ee : (Ae = W.extra) === null || Ae === void 0 ?
                                void 0 : Ae.call(W)
                        }), {
                            default: W.default
                        })])
                }
            })
        }
    }
});

function allPromiseFinish(K) {
    var C = !1,
        H = K.length,
        W = [];
    return K.length ? new Promise(function (U, G) {
        K.forEach(function (X, Z) {
            X.catch(function (Q) {
                return C = !0, Q
            }).then(function (Q) {
                H -= 1, W[Z] = Q, !(H > 0) && (C && G(W), U(W))
            })
        })
    }) : Promise.resolve([])
}

function t(K) {
    return typeof K == "object" && K != null && K.nodeType === 1
}

function e(K, C) {
    return (!C || K !== "hidden") && K !== "visible" && K !== "clip"
}

function n(K, C) {
    if (K.clientHeight < K.scrollHeight || K.clientWidth < K.scrollWidth) {
        var H = getComputedStyle(K, null);
        return e(H.overflowY, C) || e(H.overflowX, C) || function (W) {
            var U = function (G) {
                if (!G.ownerDocument || !G.ownerDocument.defaultView) return null;
                try {
                    return G.ownerDocument.defaultView.frameElement
                } catch {
                    return null
                }
            }(W);
            return !!U && (U.clientHeight < W.scrollHeight || U.clientWidth < W.scrollWidth)
        }(K)
    }
    return !1
}

function r(K, C, H, W, U, G, X, Z) {
    return G < K && X > C || G > K && X < C ? 0 : G <= K && Z <= H || X >= C && Z >= H ? G - K - W : X > C && Z < H ||
        G < K && Z > H ? X - C + U : 0
}
var i = function (K, C) {
    var H = window,
        W = C.scrollMode,
        U = C.block,
        G = C.inline,
        X = C.boundary,
        Z = C.skipOverflowHiddenElements,
        Q = typeof X == "function" ? X : function (De) {
            return De !== X
        };
    if (!t(K)) throw new TypeError("Invalid target");
    for (var ee, ne, te = document.scrollingElement || document.documentElement, re = [], ae = K; t(ae) && Q(ae);) {
        if ((ae = (ne = (ee = ae).parentElement) == null ? ee.getRootNode().host || null : ne) === te) {
            re.push(ae);
            break
        }
        ae != null && ae === document.body && n(ae) && !n(document.documentElement) || ae != null && n(ae, Z) && re
            .push(ae)
    }
    for (var oe = H.visualViewport ? H.visualViewport.width : innerWidth, ie = H.visualViewport ? H.visualViewport.height :
            innerHeight, ue = window.scrollX || pageXOffset, le = window.scrollY || pageYOffset, se = K.getBoundingClientRect(),
            ce = se.height, de = se.width, ve = se.top, fe = se.right, pe = se.bottom, me = se.left, he = U ===
            "start" || U === "nearest" ? ve : U === "end" ? pe : ve + ce / 2, Se = G === "center" ? me + de / 2 : G ===
            "end" ? fe : me, _e = [], be = 0; be < re.length; be++) {
        var ge = re[be],
            xe = ge.getBoundingClientRect(),
            Pe = xe.height,
            $e = xe.width,
            ye = xe.top,
            Ce = xe.right,
            we = xe.bottom,
            Oe = xe.left;
        if (W === "if-needed" && ve >= 0 && me >= 0 && pe <= ie && fe <= oe && ve >= ye && pe <= we && me >= Oe &&
            fe <= Ce) return _e;
        var Ne = getComputedStyle(ge),
            Me = parseInt(Ne.borderLeftWidth, 10),
            Ve = parseInt(Ne.borderTopWidth, 10),
            ke = parseInt(Ne.borderRightWidth, 10),
            Ee = parseInt(Ne.borderBottomWidth, 10),
            Ae = 0,
            Re = 0,
            He = "offsetWidth" in ge ? ge.offsetWidth - ge.clientWidth - Me - ke : 0,
            je = "offsetHeight" in ge ? ge.offsetHeight - ge.clientHeight - Ve - Ee : 0,
            Fe = "offsetWidth" in ge ? ge.offsetWidth === 0 ? 0 : $e / ge.offsetWidth : 0,
            Le = "offsetHeight" in ge ? ge.offsetHeight === 0 ? 0 : Pe / ge.offsetHeight : 0;
        if (te === ge) Ae = U === "start" ? he : U === "end" ? he - ie : U === "nearest" ? r(le, le + ie, ie, Ve,
                Ee, le + he, le + he + ce, ce) : he - ie / 2, Re = G === "start" ? Se : G === "center" ? Se - oe /
            2 : G === "end" ? Se - oe : r(ue, ue + oe, oe, Me, ke, ue + Se, ue + Se + de, de), Ae = Math.max(0, Ae +
                le), Re = Math.max(0, Re + ue);
        else {
            Ae = U === "start" ? he - ye - Ve : U === "end" ? he - we + Ee + je : U === "nearest" ? r(ye, we, Pe,
                    Ve, Ee + je, he, he + ce, ce) : he - (ye + Pe / 2) + je / 2, Re = G === "start" ? Se - Oe - Me :
                G === "center" ? Se - (Oe + $e / 2) + He / 2 : G === "end" ? Se - Ce + ke + He : r(Oe, Ce, $e, Me,
                    ke + He, Se, Se + de, de);
            var Ie = ge.scrollLeft,
                Te = ge.scrollTop;
            he += Te - (Ae = Math.max(0, Math.min(Te + Ae / Le, ge.scrollHeight - Pe / Le + je))), Se += Ie - (Re =
                Math.max(0, Math.min(Ie + Re / Fe, ge.scrollWidth - $e / Fe + He)))
        }
        _e.push({
            el: ge,
            top: Ae,
            left: Re
        })
    }
    return _e
};

function isOptionsObject(K) {
    return K === Object(K) && Object.keys(K).length !== 0
}

function defaultBehavior(K, C) {
    C === void 0 && (C = "auto");
    var H = "scrollBehavior" in document.body.style;
    K.forEach(function (W) {
        var U = W.el,
            G = W.top,
            X = W.left;
        U.scroll && H ? U.scroll({
            top: G,
            left: X,
            behavior: C
        }) : (U.scrollTop = G, U.scrollLeft = X)
    })
}

function getOptions(K) {
    return K === !1 ? {
        block: "end",
        inline: "nearest"
    } : isOptionsObject(K) ? K : {
        block: "start",
        inline: "nearest"
    }
}

function scrollIntoView(K, C) {
    var H = K.isConnected || K.ownerDocument.documentElement.contains(K);
    if (isOptionsObject(C) && typeof C.behavior == "function") return C.behavior(H ? i(K, C) : []);
    if (H) {
        var W = getOptions(C);
        return defaultBehavior(i(K, W), W.behavior)
    }
}
var nativeMin = Math.min;

function baseIntersection(K, C, H) {
    for (var W = H ? arrayIncludesWith : arrayIncludes, U = K[0].length, G = K.length, X = G, Z = Array(G), Q = 1 / 0,
            ee = []; X--;) {
        var ne = K[X];
        X && C && (ne = arrayMap(ne, baseUnary(C))), Q = nativeMin(ne.length, Q), Z[X] = !H && (C || U >= 120 && ne.length >=
            120) ? new SetCache(X && ne) : void 0
    }
    ne = K[0];
    var te = -1,
        re = Z[0];
    e: for (; ++te < U && ee.length < Q;) {
        var ae = ne[te],
            oe = C ? C(ae) : ae;
        if (ae = H || ae !== 0 ? ae : 0, !(re ? cacheHas(re, oe) : W(ee, oe, H))) {
            for (X = G; --X;) {
                var ie = Z[X];
                if (!(ie ? cacheHas(ie, oe) : W(K[X], oe, H))) continue e
            }
            re && re.push(oe), ee.push(ae)
        }
    }
    return ee
}

function baseRest(K, C) {
    return setToString$1(overRest(K, C, identity), K + "")
}

function isArrayLikeObject(K) {
    return isObjectLike(K) && isArrayLike(K)
}

function castArrayLikeObject(K) {
    return isArrayLikeObject(K) ? K : []
}
var intersection = baseRest(function (K) {
    var C = arrayMap(K, castArrayLikeObject);
    return C.length && C[0] === K[0] ? baseIntersection(C) : []
});
const intersection$1 = intersection;

function last(K) {
    var C = K == null ? 0 : K.length;
    return C ? K[C - 1] : void 0
}

function parent(K, C) {
    return C.length < 2 ? K : baseGet(K, baseSlice(C, 0, -1))
}

function baseUnset(K, C) {
    return C = castPath(C, K), K = parent(K, C), K == null || delete K[toKey(last(C))]
}

function customOmitClone(K) {
    return isPlainObject(K) ? void 0 : K
}
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4,
    omit = flatRest(function (K, C) {
        var H = {};
        if (K == null) return H;
        var W = !1;
        C = arrayMap(C, function (G) {
            return G = castPath(G, K), W || (W = G.length > 1), G
        }), copyObject(K, getAllKeysIn(K), H), W && (H = baseClone(H, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG |
            CLONE_SYMBOLS_FLAG, customOmitClone));
        for (var U = C.length; U--;) baseUnset(H, C[U]);
        return H
    });
const omit$1 = omit;

function isRequired(K) {
    var C = !1;
    return K && K.length && K.every(function (H) {
        return H.required ? (C = !0, !1) : !0
    }), C
}

function toArray$5(K) {
    return K == null ? [] : Array.isArray(K) ? K : [K]
}

function getPropByPath(K, C, H) {
    var W = K;
    C = C.replace(/\[(\w+)\]/g, ".$1"), C = C.replace(/^\./, "");
    for (var U = C.split("."), G = 0, X = U.length; G < X - 1 && !(!W && !H); ++G) {
        var Z = U[G];
        if (Z in W) W = W[Z];
        else {
            if (H) throw new Error("please transfer a valid name path to validate!");
            break
        }
    }
    return {
        o: W,
        k: U[G],
        v: W ? W[U[G]] : null,
        isValid: W && U[G] in W
    }
}

function useForm(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ref({}),
        H = arguments.length > 2 ? arguments[2] : void 0,
        W = cloneDeep(unref(K)),
        U = reactive({}),
        G = shallowRef([]),
        X = function (de) {
            _extends$1(unref(K), _objectSpread2$1(_objectSpread2$1({}, cloneDeep(W)), de)), nextTick(function () {
                Object.keys(U).forEach(function (ve) {
                    U[ve] = {
                        autoLink: !1,
                        required: isRequired(unref(C)[ve])
                    }
                })
            })
        },
        Z = function () {
            var de = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
                ve = arguments.length > 1 ? arguments[1] : void 0;
            return ve.length ? de.filter(function (fe) {
                var pe = toArray$5(fe.trigger || "change");
                return intersection$1(pe, ve).length
            }) : de
        },
        Q = null,
        ee = function (de) {
            for (var ve = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, fe = arguments.length >
                    2 ? arguments[2] : void 0, pe = [], me = {}, he = function () {
                        var Pe = de[Se],
                            $e = getPropByPath(unref(K), Pe, fe);
                        if (!$e.isValid) return "continue";
                        me[Pe] = $e.v;
                        var ye = Z(unref(C)[Pe], toArray$5(ve && ve.trigger));
                        ye.length && pe.push(ne(Pe, $e.v, ye, ve || {}).then(function () {
                            return {
                                name: Pe,
                                errors: [],
                                warnings: []
                            }
                        }).catch(function (Ce) {
                            var we = [],
                                Oe = [];
                            return Ce.forEach(function (Ne) {
                                var Me = Ne.rule.warningOnly,
                                    Ve = Ne.errors;
                                Me ? Oe.push.apply(Oe, _toConsumableArray(Ve)) : we.push.apply(we,
                                    _toConsumableArray(Ve))
                            }), we.length ? Promise.reject({
                                name: Pe,
                                errors: we,
                                warnings: Oe
                            }) : {
                                name: Pe,
                                errors: we,
                                warnings: Oe
                            }
                        }))
                    }, Se = 0; Se < de.length; Se++) var _e = he();
            var be = allPromiseFinish(pe);
            Q = be;
            var ge = be.then(function () {
                return Q === be ? Promise.resolve(me) : Promise.reject([])
            }).catch(function (xe) {
                var Pe = xe.filter(function ($e) {
                    return $e && $e.errors.length
                });
                return Promise.reject({
                    values: me,
                    errorFields: Pe,
                    outOfDate: Q !== be
                })
            });
            return ge.catch(function (xe) {
                return xe
            }), ge
        },
        ne = function (de, ve, fe) {
            var pe = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},
                me = validateRules([de], ve, fe, _objectSpread2$1({
                    validateMessages: defaultValidateMessages
                }, pe), !!pe.validateFirst);
            return U[de] ? (U[de].validateStatus = "validating", me.catch(function (he) {
                return he
            }).then(function () {
                var he = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                if (U[de].validateStatus === "validating") {
                    var Se, _e = he.filter(function (be) {
                        return be && be.errors.length
                    });
                    U[de].validateStatus = _e.length ? "error" : "success", U[de].help = _e.length ? _e.map(
                        function (be) {
                            return be.errors
                        }) : null, H == null || (Se = H.onValidate) === null || Se === void 0 || Se.call(
                        H, de, !_e.length, _e.length ? toRaw(U[de].help[0]) : null)
                }
            }), me) : me.catch(function (he) {
                return he
            })
        },
        te = function (de, ve) {
            var fe = [],
                pe = !0;
            de ? Array.isArray(de) ? fe = de : fe = [de] : (pe = !1, fe = G.value);
            var me = ee(fe, ve || {}, pe);
            return me.catch(function (he) {
                return he
            }), me
        },
        re = function (de) {
            var ve = [];
            de ? Array.isArray(de) ? ve = de : ve = [de] : ve = G.value, ve.forEach(function (fe) {
                U[fe] && _extends$1(U[fe], {
                    validateStatus: "",
                    help: null
                })
            })
        },
        ae = function (de) {
            for (var ve = {
                    autoLink: !1
                }, fe = [], pe = Array.isArray(de) ? de : [de], me = 0; me < pe.length; me++) {
                var he = pe[me];
                (he == null ? void 0 : he.validateStatus) === "error" && (ve.validateStatus = "error", he.help && fe.push(
                    he.help)), ve.required = ve.required || (he == null ? void 0 : he.required)
            }
            return ve.help = fe, ve
        },
        oe = W,
        ie = !0,
        ue = function (de) {
            var ve = [];
            G.value.forEach(function (fe) {
                var pe = getPropByPath(de, fe, !1),
                    me = getPropByPath(oe, fe, !1),
                    he = ie && (H == null ? void 0 : H.immediate) && pe.isValid;
                (he || !isEqual$1(pe.v, me.v)) && ve.push(fe)
            }), te(ve, {
                trigger: "change"
            }), ie = !1, oe = cloneDeep(toRaw(de))
        },
        le = H == null ? void 0 : H.debounce,
        se = !0;
    return watch(C, function () {
        G.value = C ? Object.keys(unref(C)) : [], !se && H && H.validateOnRuleChange && te(), se = !1
    }, {
        deep: !0,
        immediate: !0
    }), watch(G, function () {
        var ce = {};
        G.value.forEach(function (ve) {
            ce[ve] = _extends$1({}, U[ve], {
                autoLink: !1,
                required: isRequired(unref(C)[ve])
            }), delete U[ve]
        });
        for (var de in U) Object.prototype.hasOwnProperty.call(U, de) && delete U[de];
        _extends$1(U, ce)
    }, {
        immediate: !0
    }), watch(K, le && le.wait ? debounce(ue, le.wait, omit$1(le, ["wait"])) : ue, {
        immediate: H && !!H.immediate,
        deep: !0
    }), {
        modelRef: K,
        rulesRef: C,
        initialModel: W,
        validateInfos: U,
        resetFields: X,
        validate: te,
        validateField: ne,
        mergeValidateInfo: ae,
        clearValidate: re
    }
}
var formProps = function () {
    return {
        layout: PropTypes$1.oneOf(tuple$1("horizontal", "inline", "vertical")),
        labelCol: {
            type: Object
        },
        wrapperCol: {
            type: Object
        },
        colon: {
            type: Boolean,
            default: void 0
        },
        labelAlign: PropTypes$1.oneOf(tuple$1("left", "right")),
        labelWrap: {
            type: Boolean,
            default: void 0
        },
        prefixCls: String,
        requiredMark: {
            type: [String, Boolean],
            default: void 0
        },
        hideRequiredMark: {
            type: Boolean,
            default: void 0
        },
        model: PropTypes$1.object,
        rules: {
            type: Object
        },
        validateMessages: {
            type: Object,
            default: void 0
        },
        validateOnRuleChange: {
            type: Boolean,
            default: void 0
        },
        scrollToFirstError: {
            type: [Boolean, Object]
        },
        onSubmit: Function,
        name: String,
        validateTrigger: {
            type: [String, Array]
        },
        size: {
            type: String
        },
        onValuesChange: {
            type: Function
        },
        onFieldsChange: {
            type: Function
        },
        onFinish: {
            type: Function
        },
        onFinishFailed: {
            type: Function
        },
        onValidate: {
            type: Function
        }
    }
};

function isEqualName(K, C) {
    return isEqual$1(toArray$6(K), toArray$6(C))
}
var Form = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AForm",
    inheritAttrs: !1,
    props: initDefaultProps$1(formProps(), {
        layout: "horizontal",
        hideRequiredMark: !1,
        colon: !0
    }),
    Item: FormItem,
    useForm,
    setup: function (C, H) {
        var W = H.emit,
            U = H.slots,
            G = H.expose,
            X = H.attrs,
            Z = useInjectSize(C),
            Q = useConfigInject("form", C),
            ee = Q.prefixCls,
            ne = Q.direction,
            te = Q.form,
            re = computed(function () {
                return C.requiredMark === "" || C.requiredMark
            }),
            ae = computed(function () {
                var ye;
                return re.value !== void 0 ? re.value : te && ((ye = te.value) === null || ye === void 0 ?
                    void 0 : ye.requiredMark) !== void 0 ? te.value.requiredMark : !C.hideRequiredMark
            }),
            oe = computed(function () {
                var ye, Ce;
                return (ye = C.colon) !== null && ye !== void 0 ? ye : (Ce = te.value) === null || Ce ===
                    void 0 ? void 0 : Ce.colon
            }),
            ie = useInjectGlobalForm(),
            ue = ie.validateMessages,
            le = computed(function () {
                return _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, defaultValidateMessages),
                    ue.value), C.validateMessages)
            }),
            se = computed(function () {
                var ye;
                return classNames(ee.value, (ye = {}, _defineProperty$V(ye, "".concat(ee.value, "-").concat(
                    C.layout), !0), _defineProperty$V(ye, "".concat(ee.value,
                    "-hide-required-mark"), ae.value === !1), _defineProperty$V(ye, "".concat(
                    ee.value, "-rtl"), ne.value === "rtl"), _defineProperty$V(ye, "".concat(
                    ee.value, "-").concat(Z.value), Z.value), ye))
            }),
            ce = ref(),
            de = {},
            ve = function (Ce, we) {
                de[Ce] = we
            },
            fe = function (Ce) {
                delete de[Ce]
            },
            pe = function (Ce) {
                var we = !!Ce,
                    Oe = we ? toArray$6(Ce).map(getNamePath) : [];
                return we ? Object.values(de).filter(function (Ne) {
                    return Oe.findIndex(function (Me) {
                        return isEqualName(Me, Ne.fieldName.value)
                    }) > -1
                }) : Object.values(de)
            },
            me = function (Ce) {
                if (!C.model) {
                    warning$2(!1, "Form", "model is required for resetFields to work.");
                    return
                }
                pe(Ce).forEach(function (we) {
                    we.resetField()
                })
            },
            he = function (Ce) {
                pe(Ce).forEach(function (we) {
                    we.clearValidate()
                })
            },
            Se = function (Ce) {
                var we = C.scrollToFirstError;
                if (W("finishFailed", Ce), we && Ce.errorFields.length) {
                    var Oe = {};
                    _typeof$2(we) === "object" && (Oe = we), be(Ce.errorFields[0].name, Oe)
                }
            },
            _e = function () {
                return Pe.apply(void 0, arguments)
            },
            be = function (Ce) {
                var we = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                    Oe = pe(Ce ? [Ce] : void 0);
                if (Oe.length) {
                    var Ne = Oe[0].fieldId.value,
                        Me = Ne ? document.getElementById(Ne) : null;
                    Me && scrollIntoView(Me, _objectSpread2$1({
                        scrollMode: "if-needed",
                        block: "nearest"
                    }, we))
                }
            },
            ge = function () {
                var Ce = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
                if (Ce === !0) {
                    var we = [];
                    return Object.values(de).forEach(function (Oe) {
                        var Ne = Oe.namePath;
                        we.push(Ne.value)
                    }), cloneByNamePathList(C.model, we)
                } else return cloneByNamePathList(C.model, Ce)
            },
            xe = function (Ce, we) {
                if (warning$2(!(Ce instanceof Function), "Form",
                        "validateFields/validateField/validate not support callback, please use promise instead"
                    ), !C.model) return warning$2(!1, "Form",
                    "model is required for validateFields to work."), Promise.reject(
                    "Form `model` is required for validateFields to work.");
                var Oe = !!Ce,
                    Ne = Oe ? toArray$6(Ce).map(getNamePath) : [],
                    Me = [];
                Object.values(de).forEach(function (Ee) {
                    var Ae;
                    if (Oe || Ne.push(Ee.namePath.value), !!((Ae = Ee.rules) !== null && Ae !==
                            void 0 && Ae.value.length)) {
                        var Re = Ee.namePath.value;
                        if (!Oe || containsNamePath(Ne, Re)) {
                            var He = Ee.validateRules(_objectSpread2$1({
                                validateMessages: le.value
                            }, we));
                            Me.push(He.then(function () {
                                return {
                                    name: Re,
                                    errors: [],
                                    warnings: []
                                }
                            }).catch(function (je) {
                                var Fe = [],
                                    Le = [];
                                return je.forEach(function (Ie) {
                                    var Te = Ie.rule.warningOnly,
                                        De = Ie.errors;
                                    Te ? Le.push.apply(Le, _toConsumableArray(
                                        De)) : Fe.push.apply(Fe,
                                        _toConsumableArray(De))
                                }), Fe.length ? Promise.reject({
                                    name: Re,
                                    errors: Fe,
                                    warnings: Le
                                }) : {
                                    name: Re,
                                    errors: Fe,
                                    warnings: Le
                                }
                            }))
                        }
                    }
                });
                var Ve = allPromiseFinish(Me);
                ce.value = Ve;
                var ke = Ve.then(function () {
                    return ce.value === Ve ? Promise.resolve(ge(Ne)) : Promise.reject([])
                }).catch(function (Ee) {
                    var Ae = Ee.filter(function (Re) {
                        return Re && Re.errors.length
                    });
                    return Promise.reject({
                        values: ge(Ne),
                        errorFields: Ae,
                        outOfDate: ce.value !== Ve
                    })
                });
                return ke.catch(function (Ee) {
                    return Ee
                }), ke
            },
            Pe = function () {
                return xe.apply(void 0, arguments)
            },
            $e = function (Ce) {
                if (Ce.preventDefault(), Ce.stopPropagation(), W("submit", Ce), C.model) {
                    var we = xe();
                    we.then(function (Oe) {
                        W("finish", Oe)
                    }).catch(function (Oe) {
                        Se(Oe)
                    })
                }
            };
        return G({
                resetFields: me,
                clearValidate: he,
                validateFields: xe,
                getFieldsValue: ge,
                validate: _e,
                scrollToField: be
            }), useProvideForm({
                model: computed(function () {
                    return C.model
                }),
                name: computed(function () {
                    return C.name
                }),
                labelAlign: computed(function () {
                    return C.labelAlign
                }),
                labelCol: computed(function () {
                    return C.labelCol
                }),
                labelWrap: computed(function () {
                    return C.labelWrap
                }),
                wrapperCol: computed(function () {
                    return C.wrapperCol
                }),
                vertical: computed(function () {
                    return C.layout === "vertical"
                }),
                colon: oe,
                requiredMark: ae,
                validateTrigger: computed(function () {
                    return C.validateTrigger
                }),
                rules: computed(function () {
                    return C.rules
                }),
                addField: ve,
                removeField: fe,
                onValidate: function (Ce, we, Oe) {
                    W("validate", Ce, we, Oe)
                },
                validateMessages: le
            }), watch(function () {
                return C.rules
            }, function () {
                C.validateOnRuleChange && xe()
            }),
            function () {
                var ye;
                return createVNode("form", _objectSpread2$1(_objectSpread2$1({}, X), {}, {
                    onSubmit: $e,
                    class: [se.value, X.class]
                }), [(ye = U.default) === null || ye === void 0 ? void 0 : ye.call(U)])
            }
    }
});
const Form$1 = Form;
Form$1.useInjectFormItemContext = useInjectFormItemContext;
Form$1.ItemRest = FormItemRest;
Form$1.install = function (K) {
    return K.component(Form$1.name, Form$1), K.component(Form$1.Item.name, Form$1.Item), K.component(FormItemRest.name,
        FormItemRest), K
};
var _excluded$E = ["notFoundContent", "expandIcon", "multiple", "bordered", "allowClear", "choiceTransitionName",
    "transitionName", "id"];

function highlightKeyword(K, C, H) {
    var W = K.toLowerCase().split(C).reduce(function (X, Z, Q) {
            return Q === 0 ? [Z] : [].concat(_toConsumableArray(X), [C, Z])
        }, []),
        U = [],
        G = 0;
    return W.forEach(function (X, Z) {
        var Q = G + X.length,
            ee = K.slice(G, Q);
        G = Q, Z % 2 === 1 && (ee = createVNode("span", {
            class: "".concat(H, "-menu-item-keyword"),
            key: "seperator"
        }, [ee])), U.push(ee)
    }), U
}
var defaultSearchRender = function (C) {
    var H = C.inputValue,
        W = C.path,
        U = C.prefixCls,
        G = C.fieldNames,
        X = [],
        Z = H.toLowerCase();
    return W.forEach(function (Q, ee) {
        ee !== 0 && X.push(" / ");
        var ne = Q[G.label],
            te = _typeof$2(ne);
        (te === "string" || te === "number") && (ne = highlightKeyword(String(ne), Z, U)), X.push(ne)
    }), X
};

function cascaderProps() {
    return _objectSpread2$1(_objectSpread2$1({}, omit$2(internalCascaderProps(), ["customSlots", "checkable", "options"])), {}, {
        multiple: {
            type: Boolean,
            default: void 0
        },
        size: String,
        bordered: {
            type: Boolean,
            default: void 0
        },
        placement: {
            type: String
        },
        suffixIcon: PropTypes$1.any,
        options: Array,
        "onUpdate:value": Function
    })
}
var Cascader = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ACascader",
    inheritAttrs: !1,
    props: initDefaultProps$1(cascaderProps(), {
        bordered: !0,
        choiceTransitionName: "",
        allowClear: !0
    }),
    setup: function (C, H) {
        var W = H.attrs,
            U = H.expose,
            G = H.slots,
            X = H.emit,
            Z = useInjectFormItemContext(),
            Q = useConfigInject("cascader", C),
            ee = Q.prefixCls,
            ne = Q.rootPrefixCls,
            te = Q.getPrefixCls,
            re = Q.direction,
            ae = Q.getPopupContainer,
            oe = Q.renderEmpty,
            ie = Q.size,
            ue = computed(function () {
                return te("select", C.prefixCls)
            }),
            le = computed(function () {
                return re.value === "rtl"
            }),
            se = computed(function () {
                if (!C.showSearch) return C.showSearch;
                var he = {
                    render: defaultSearchRender
                };
                return _typeof$2(C.showSearch) === "object" && (he = _objectSpread2$1(_objectSpread2$1({},
                    he), C.showSearch)), he
            }),
            ce = computed(function () {
                return classNames(C.dropdownClassName || C.popupClassName, "".concat(ee.value,
                    "-dropdown"), _defineProperty$V({}, "".concat(ee.value, "-dropdown-rtl"),
                    le.value))
            }),
            de = ref();
        U({
            focus: function () {
                var Se;
                (Se = de.value) === null || Se === void 0 || Se.focus()
            },
            blur: function () {
                var Se;
                (Se = de.value) === null || Se === void 0 || Se.blur()
            }
        });
        var ve = function () {
                for (var Se = arguments.length, _e = new Array(Se), be = 0; be < Se; be++) _e[be] =
                    arguments[be];
                X("update:value", _e[0]), X.apply(void 0, ["change"].concat(_e)), Z.onFieldChange()
            },
            fe = function () {
                for (var Se = arguments.length, _e = new Array(Se), be = 0; be < Se; be++) _e[be] =
                    arguments[be];
                X.apply(void 0, ["blur"].concat(_e)), Z.onFieldBlur()
            },
            pe = computed(function () {
                return C.showArrow !== void 0 ? C.showArrow : C.loading || !C.multiple
            }),
            me = computed(function () {
                return C.placement !== void 0 ? C.placement : re.value === "rtl" ? "bottomRight" :
                    "bottomLeft"
            });
        return function () {
            var he, Se, _e, be = C.notFoundContent,
                ge = be === void 0 ? (he = G.notFoundContent) === null || he === void 0 ? void 0 : he.call(
                    G) : be,
                xe = C.expandIcon,
                Pe = xe === void 0 ? (Se = G.expandIcon) === null || Se === void 0 ? void 0 : Se.call(G) :
                xe,
                $e = C.multiple,
                ye = C.bordered,
                Ce = C.allowClear,
                we = C.choiceTransitionName,
                Oe = C.transitionName,
                Ne = C.id,
                Me = Ne === void 0 ? Z.id.value : Ne,
                Ve = _objectWithoutProperties$2(C, _excluded$E),
                ke = ge || oe.value("Cascader"),
                Ee = Pe;
            Pe || (Ee = le.value ? createVNode(LeftOutlined$1, null, null) : createVNode(
                RightOutlined$1, null, null));
            var Ae = createVNode("span", {
                    class: "".concat(ue.value, "-menu-item-loading-icon")
                }, [createVNode(LoadingOutlined$1, {
                    spin: !0
                }, null)]),
                Re = getIcons(_objectSpread2$1(_objectSpread2$1({}, C), {}, {
                    multiple: $e,
                    prefixCls: ue.value,
                    showArrow: pe.value
                }), G),
                He = Re.suffixIcon,
                je = Re.removeIcon,
                Fe = Re.clearIcon;
            return createVNode(Cascader$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, Ve),
                W), {}, {
                id: Me,
                prefixCls: ue.value,
                class: [ee.value, (_e = {}, _defineProperty$V(_e, "".concat(ue.value, "-lg"),
                    ie.value === "large"), _defineProperty$V(_e, "".concat(ue.value,
                    "-sm"), ie.value === "small"), _defineProperty$V(_e, "".concat(
                    ue.value, "-rtl"), le.value), _defineProperty$V(_e, "".concat(
                    ue.value, "-borderless"), !ye), _e), W.class],
                direction: re.value,
                placement: me.value,
                notFoundContent: ke,
                allowClear: Ce,
                showSearch: se.value,
                expandIcon: Ee,
                inputIcon: He,
                removeIcon: je,
                clearIcon: Fe,
                loadingIcon: Ae,
                checkable: !!$e,
                dropdownClassName: ce.value,
                dropdownPrefixCls: ee.value,
                choiceTransitionName: getTransitionName$2(ne.value, "", we),
                transitionName: getTransitionName$2(ne.value, getTransitionDirection(me.value),
                    Oe),
                getPopupContainer: ae.value,
                customSlots: _objectSpread2$1(_objectSpread2$1({}, G), {}, {
                    checkable: function () {
                        return createVNode("span", {
                            class: "".concat(ee.value,
                                "-checkbox-inner")
                        }, null)
                    }
                }),
                tagRender: C.tagRender || G.tagRender,
                displayRender: C.displayRender || G.displayRender,
                maxTagPlaceholder: C.maxTagPlaceholder || G.maxTagPlaceholder,
                showArrow: C.showArrow,
                onChange: ve,
                onBlur: fe,
                ref: de
            }), G)
        }
    }
});
const index$h = withInstall(Cascader);
var abstractCheckboxGroupProps = function () {
        return {
            name: String,
            prefixCls: String,
            options: {
                type: Array,
                default: function () {
                    return []
                }
            },
            disabled: Boolean,
            id: String
        }
    },
    checkboxGroupProps = function () {
        return _objectSpread2$1(_objectSpread2$1({}, abstractCheckboxGroupProps()), {}, {
            defaultValue: {
                type: Array
            },
            value: {
                type: Array
            },
            onChange: {
                type: Function
            },
            "onUpdate:value": {
                type: Function
            }
        })
    },
    abstractCheckboxProps = function () {
        return {
            prefixCls: String,
            defaultChecked: {
                type: Boolean,
                default: void 0
            },
            checked: {
                type: Boolean,
                default: void 0
            },
            disabled: {
                type: Boolean,
                default: void 0
            },
            isGroup: {
                type: Boolean,
                default: void 0
            },
            value: PropTypes$1.any,
            name: String,
            id: String,
            indeterminate: {
                type: Boolean,
                default: void 0
            },
            type: {
                type: String,
                default: "checkbox"
            },
            autofocus: {
                type: Boolean,
                default: void 0
            },
            onChange: Function,
            "onUpdate:checked": Function,
            onClick: Function,
            skipGroup: {
                type: Boolean,
                default: !1
            }
        }
    },
    checkboxProps = function () {
        return _objectSpread2$1(_objectSpread2$1({}, abstractCheckboxProps()), {}, {
            indeterminate: {
                type: Boolean,
                default: !1
            }
        })
    },
    CheckboxGroupContextKey = Symbol("CheckboxGroupContext"),
    _excluded$D = ["indeterminate", "skipGroup", "id"],
    _excluded2$5 = ["onMouseenter", "onMouseleave", "onInput", "class", "style"];
const Checkbox = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ACheckbox",
    inheritAttrs: !1,
    __ANT_CHECKBOX: !0,
    props: checkboxProps(),
    setup: function (C, H) {
        var W = H.emit,
            U = H.attrs,
            G = H.slots,
            X = H.expose,
            Z = useInjectFormItemContext(),
            Q = useConfigInject("checkbox", C),
            ee = Q.prefixCls,
            ne = Q.direction,
            te = inject(CheckboxGroupContextKey, void 0),
            re = Symbol("checkboxUniId");
        watchEffect(function () {
            !C.skipGroup && te && te.registerValue(re, C.value)
        }), onBeforeUnmount(function () {
            te && te.cancelValue(re)
        }), onMounted(function () {
            warning$2(C.checked !== void 0 || te || C.value === void 0, "Checkbox",
                "`value` is not validate prop, do you mean `checked`?")
        });
        var ae = function (se) {
                var ce = se.target.checked;
                W("update:checked", ce), W("change", se)
            },
            oe = ref(),
            ie = function () {
                var se;
                (se = oe.value) === null || se === void 0 || se.focus()
            },
            ue = function () {
                var se;
                (se = oe.value) === null || se === void 0 || se.blur()
            };
        return X({
                focus: ie,
                blur: ue
            }),
            function () {
                var le, se, ce = flattenChildren((le = G.default) === null || le === void 0 ? void 0 : le.call(
                        G)),
                    de = C.indeterminate,
                    ve = C.skipGroup,
                    fe = C.id,
                    pe = fe === void 0 ? Z.id.value : fe,
                    me = _objectWithoutProperties$2(C, _excluded$D),
                    he = U.onMouseenter,
                    Se = U.onMouseleave;
                U.onInput;
                var _e = U.class,
                    be = U.style,
                    ge = _objectWithoutProperties$2(U, _excluded2$5),
                    xe = _objectSpread2$1(_objectSpread2$1({}, me), {}, {
                        id: pe,
                        prefixCls: ee.value
                    }, ge);
                te && !ve ? (xe.onChange = function () {
                            for (var ye = arguments.length, Ce = new Array(ye), we = 0; we < ye; we++) Ce[
                                we] = arguments[we];
                            W.apply(void 0, ["change"].concat(Ce)), te.toggleOption({
                                label: ce,
                                value: C.value
                            })
                        }, xe.name = te.name.value, xe.checked = te.mergedValue.value.indexOf(C.value) !==
                        -1, xe.disabled = C.disabled || te.disabled.value, xe.indeterminate = de) : xe.onChange =
                    ae;
                var Pe = classNames((se = {}, _defineProperty$V(se, "".concat(ee.value, "-wrapper"), !0),
                        _defineProperty$V(se, "".concat(ee.value, "-rtl"), ne.value === "rtl"),
                        _defineProperty$V(se, "".concat(ee.value, "-wrapper-checked"), xe.checked),
                        _defineProperty$V(se, "".concat(ee.value, "-wrapper-disabled"), xe.disabled),
                        se), _e),
                    $e = classNames(_defineProperty$V({}, "".concat(ee.value, "-indeterminate"), de));
                return createVNode("label", {
                    class: Pe,
                    style: be,
                    onMouseenter: he,
                    onMouseleave: Se
                }, [createVNode(VcCheckbox, _objectSpread2$1(_objectSpread2$1({}, xe), {}, {
                    class: $e,
                    ref: oe
                }), null), ce.length ? createVNode("span", null, [ce]) : null])
            }
    }
});

function _createForOfIteratorHelper(K, C) {
    var H = typeof Symbol < "u" && K[Symbol.iterator] || K["@@iterator"];
    if (!H) {
        if (Array.isArray(K) || (H = _unsupportedIterableToArray$2(K)) || C && K && typeof K.length == "number") {
            H && (K = H);
            var W = 0,
                U = function () {};
            return {
                s: U,
                n: function () {
                    return W >= K.length ? {
                        done: !0
                    } : {
                        done: !1,
                        value: K[W++]
                    }
                },
                e: function (ee) {
                    throw ee
                },
                f: U
            }
        }
        throw new TypeError(
            `Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`
        )
    }
    var G = !0,
        X = !1,
        Z;
    return {
        s: function () {
            H = H.call(K)
        },
        n: function () {
            var ee = H.next();
            return G = ee.done, ee
        },
        e: function (ee) {
            X = !0, Z = ee
        },
        f: function () {
            try {
                !G && H.return != null && H.return()
            } finally {
                if (X) throw Z
            }
        }
    }
}
const CheckboxGroup = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ACheckboxGroup",
    props: checkboxGroupProps(),
    setup: function (C, H) {
        var W = H.slots,
            U = H.emit,
            G = H.expose,
            X = useInjectFormItemContext(),
            Z = useConfigInject("checkbox", C),
            Q = Z.prefixCls,
            ee = Z.direction,
            ne = ref((C.value === void 0 ? C.defaultValue : C.value) || []);
        watch(function () {
            return C.value
        }, function () {
            ne.value = C.value || []
        });
        var te = computed(function () {
                return C.options.map(function (se) {
                    return typeof se == "string" || typeof se == "number" ? {
                        label: se,
                        value: se
                    } : se
                })
            }),
            re = ref(Symbol()),
            ae = ref(new Map),
            oe = function (ce) {
                ae.value.delete(ce), re.value = Symbol()
            },
            ie = function (ce, de) {
                ae.value.set(ce, de), re.value = Symbol()
            },
            ue = ref(new Map);
        watch(re, function () {
            var se = new Map,
                ce = _createForOfIteratorHelper(ae.value.values()),
                de;
            try {
                for (ce.s(); !(de = ce.n()).done;) {
                    var ve = de.value;
                    se.set(ve, !0)
                }
            } catch (fe) {
                ce.e(fe)
            } finally {
                ce.f()
            }
            ue.value = se
        });
        var le = function (ce) {
            var de = ne.value.indexOf(ce.value),
                ve = _toConsumableArray(ne.value);
            de === -1 ? ve.push(ce.value) : ve.splice(de, 1), C.value === void 0 && (ne.value = ve);
            var fe = ve.filter(function (pe) {
                return ue.value.has(pe)
            }).sort(function (pe, me) {
                var he = te.value.findIndex(function (_e) {
                        return _e.value === pe
                    }),
                    Se = te.value.findIndex(function (_e) {
                        return _e.value === me
                    });
                return he - Se
            });
            U("update:value", fe), U("change", fe), X.onFieldChange()
        };
        return provide(CheckboxGroupContextKey, {
                cancelValue: oe,
                registerValue: ie,
                toggleOption: le,
                mergedValue: ne,
                name: computed(function () {
                    return C.name
                }),
                disabled: computed(function () {
                    return C.disabled
                })
            }), G({
                mergedValue: ne
            }),
            function () {
                var se, ce = C.id,
                    de = ce === void 0 ? X.id.value : ce,
                    ve = null,
                    fe = "".concat(Q.value, "-group");
                return te.value && te.value.length > 0 && (ve = te.value.map(function (pe) {
                    var me;
                    return createVNode(Checkbox, {
                        prefixCls: Q.value,
                        key: pe.value.toString(),
                        disabled: "disabled" in pe ? pe.disabled : C.disabled,
                        indeterminate: pe.indeterminate,
                        value: pe.value,
                        checked: ne.value.indexOf(pe.value) !== -1,
                        onChange: pe.onChange,
                        class: "".concat(fe, "-item")
                    }, {
                        default: function () {
                            return [pe.label === void 0 ? (me = W.label) === null ||
                                me === void 0 ? void 0 : me.call(W, pe) : pe.label
                                ]
                        }
                    })
                })), createVNode("div", {
                    class: [fe, _defineProperty$V({}, "".concat(fe, "-rtl"), ee.value === "rtl")],
                    id: de
                }, [ve || ((se = W.default) === null || se === void 0 ? void 0 : se.call(W))])
            }
    }
});
Checkbox.Group = CheckboxGroup;
Checkbox.install = function (K) {
    return K.component(Checkbox.name, Checkbox), K.component(CheckboxGroup.name, CheckboxGroup), K
};
var commentProps = function () {
        return {
            actions: Array,
            author: PropTypes$1.any,
            avatar: PropTypes$1.any,
            content: PropTypes$1.any,
            prefixCls: String,
            datetime: PropTypes$1.any
        }
    },
    Comment = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "AComment",
        props: commentProps(),
        slots: ["actions", "author", "avatar", "content", "datetime"],
        setup: function (C, H) {
            var W = H.slots,
                U = useConfigInject("comment", C),
                G = U.prefixCls,
                X = U.direction,
                Z = function (ne, te) {
                    return createVNode("div", {
                        class: "".concat(ne, "-nested")
                    }, [te])
                },
                Q = function (ne) {
                    if (!ne || !ne.length) return null;
                    var te = ne.map(function (re, ae) {
                        return createVNode("li", {
                            key: "action-".concat(ae)
                        }, [re])
                    });
                    return te
                };
            return function () {
                var ee, ne, te, re, ae, oe, ie, ue, le, se, ce, de = G.value,
                    ve = (ee = C.actions) !== null && ee !== void 0 ? ee : (ne = W.actions) === null || ne ===
                    void 0 ? void 0 : ne.call(W),
                    fe = (te = C.author) !== null && te !== void 0 ? te : (re = W.author) === null || re ===
                    void 0 ? void 0 : re.call(W),
                    pe = (ae = C.avatar) !== null && ae !== void 0 ? ae : (oe = W.avatar) === null || oe ===
                    void 0 ? void 0 : oe.call(W),
                    me = (ie = C.content) !== null && ie !== void 0 ? ie : (ue = W.content) === null || ue ===
                    void 0 ? void 0 : ue.call(W),
                    he = (le = C.datetime) !== null && le !== void 0 ? le : (se = W.datetime) === null ||
                    se === void 0 ? void 0 : se.call(W),
                    Se = createVNode("div", {
                        class: "".concat(de, "-avatar")
                    }, [typeof pe == "string" ? createVNode("img", {
                        src: pe,
                        alt: "comment-avatar"
                    }, null) : pe]),
                    _e = ve ? createVNode("ul", {
                        class: "".concat(de, "-actions")
                    }, [Q(Array.isArray(ve) ? ve : [ve])]) : null,
                    be = createVNode("div", {
                        class: "".concat(de, "-content-author")
                    }, [fe && createVNode("span", {
                        class: "".concat(de, "-content-author-name")
                    }, [fe]), he && createVNode("span", {
                        class: "".concat(de, "-content-author-time")
                    }, [he])]),
                    ge = createVNode("div", {
                        class: "".concat(de, "-content")
                    }, [be, createVNode("div", {
                        class: "".concat(de, "-content-detail")
                    }, [me]), _e]),
                    xe = createVNode("div", {
                        class: "".concat(de, "-inner")
                    }, [Se, ge]),
                    Pe = flattenChildren((ce = W.default) === null || ce === void 0 ? void 0 : ce.call(W));
                return createVNode("div", {
                    class: [de, _defineProperty$V({}, "".concat(de, "-rtl"), X.value === "rtl")]
                }, [xe, Pe && Pe.length ? Z(de, Pe) : null])
            }
        }
    });
const index$g = withInstall(Comment);
var PickerButton = function (C, H) {
    var W = H.attrs,
        U = H.slots;
    return createVNode(Button$1, _objectSpread2$1(_objectSpread2$1({
        size: "small",
        type: "primary"
    }, C), W), U)
};
const PickerButton$1 = PickerButton;
var checkableTagProps = function () {
        return {
            prefixCls: String,
            checked: {
                type: Boolean,
                default: void 0
            },
            onChange: {
                type: Function
            },
            onClick: {
                type: Function
            },
            "onUpdate:checked": Function
        }
    },
    CheckableTag = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ACheckableTag",
        props: checkableTagProps(),
        setup: function (C, H) {
            var W = H.slots,
                U = H.emit,
                G = useConfigInject("tag", C),
                X = G.prefixCls,
                Z = function (ne) {
                    var te = C.checked;
                    U("update:checked", !te), U("change", !te), U("click", ne)
                },
                Q = computed(function () {
                    var ee;
                    return classNames(X.value, (ee = {}, _defineProperty$V(ee, "".concat(X.value,
                        "-checkable"), !0), _defineProperty$V(ee, "".concat(X.value,
                        "-checkable-checked"), C.checked), ee))
                });
            return function () {
                var ee;
                return createVNode("span", {
                    class: Q.value,
                    onClick: Z
                }, [(ee = W.default) === null || ee === void 0 ? void 0 : ee.call(W)])
            }
        }
    });
const CheckableTag$1 = CheckableTag;
var PresetColorRegex = new RegExp("^(".concat(PresetColorTypes.join("|"), ")(-inverse)?$")),
    PresetStatusColorRegex = new RegExp("^(".concat(PresetStatusColorTypes.join("|"), ")$")),
    tagProps = function () {
        return {
            prefixCls: String,
            color: {
                type: String
            },
            closable: {
                type: Boolean,
                default: !1
            },
            closeIcon: PropTypes$1.any,
            visible: {
                type: Boolean,
                default: void 0
            },
            onClose: {
                type: Function
            },
            "onUpdate:visible": Function,
            icon: PropTypes$1.any
        }
    },
    Tag = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ATag",
        props: tagProps(),
        slots: ["closeIcon", "icon"],
        setup: function (C, H) {
            var W = H.slots,
                U = H.emit,
                G = H.attrs,
                X = useConfigInject("tag", C),
                Z = X.prefixCls,
                Q = X.direction,
                ee = ref(!0);
            watchEffect(function () {
                C.visible !== void 0 && (ee.value = C.visible)
            });
            var ne = function (oe) {
                    oe.stopPropagation(), U("update:visible", !1), U("close", oe), !oe.defaultPrevented && C.visible ===
                        void 0 && (ee.value = !1)
                },
                te = computed(function () {
                    var ae = C.color;
                    return ae ? PresetColorRegex.test(ae) || PresetStatusColorRegex.test(ae) : !1
                }),
                re = computed(function () {
                    var ae;
                    return classNames(Z.value, (ae = {}, _defineProperty$V(ae, "".concat(Z.value, "-").concat(
                        C.color), te.value), _defineProperty$V(ae, "".concat(Z.value,
                        "-has-color"), C.color && !te.value), _defineProperty$V(ae, "".concat(Z
                        .value, "-hidden"), !ee.value), _defineProperty$V(ae, "".concat(Z.value,
                        "-rtl"), Q.value === "rtl"), ae))
                });
            return function () {
                var ae, oe, ie, ue = C.icon,
                    le = ue === void 0 ? (ae = W.icon) === null || ae === void 0 ? void 0 : ae.call(W) : ue,
                    se = C.color,
                    ce = C.closeIcon,
                    de = ce === void 0 ? (oe = W.closeIcon) === null || oe === void 0 ? void 0 : oe.call(W) :
                    ce,
                    ve = C.closable,
                    fe = ve === void 0 ? !1 : ve,
                    pe = function () {
                        return fe ? de ? createVNode("span", {
                            class: "".concat(Z.value, "-close-icon"),
                            onClick: ne
                        }, [de]) : createVNode(CloseOutlined$1, {
                            class: "".concat(Z.value, "-close-icon"),
                            onClick: ne
                        }, null) : null
                    },
                    me = {
                        backgroundColor: se && !te.value ? se : void 0
                    },
                    he = le || null,
                    Se = (ie = W.default) === null || ie === void 0 ? void 0 : ie.call(W),
                    _e = he ? createVNode(Fragment, null, [he, createVNode("span", null, [Se])]) : Se,
                    be = "onClick" in G,
                    ge = createVNode("span", {
                        class: re.value,
                        style: me
                    }, [_e, pe()]);
                return be ? createVNode(Wave, null, {
                    default: function () {
                        return [ge]
                    }
                }) : ge
            }
        }
    });
Tag.CheckableTag = CheckableTag$1;
Tag.install = function (K) {
    return K.component(Tag.name, Tag), K.component(CheckableTag$1.name, CheckableTag$1), K
};
const Tag$1 = Tag;

function PickerTag(K, C) {
    var H = C.slots,
        W = C.attrs;
    return createVNode(Tag$1, _objectSpread2$1(_objectSpread2$1({
        color: "blue"
    }, K), W), H)
}
var CalendarOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M880 184H712v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H384v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H144c-17.7 0-32 14.3-32 32v664c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V216c0-17.7-14.3-32-32-32zm-40 656H184V460h656v380zM184 392V256h128v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h256v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h128v136H184z"
            }
        }]
    },
    name: "calendar",
    theme: "outlined"
};
const CalendarOutlinedSvg = CalendarOutlined$2;

function _objectSpread$y(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$y(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$y(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var CalendarOutlined = function (C, H) {
    var W = _objectSpread$y({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$y({}, W, {
        icon: CalendarOutlinedSvg
    }), null)
};
CalendarOutlined.displayName = "CalendarOutlined";
CalendarOutlined.inheritAttrs = !1;
const CalendarOutlined$1 = CalendarOutlined;
var ClockCircleOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
            }
        }, {
            tag: "path",
            attrs: {
                d: "M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z"
            }
        }]
    },
    name: "clock-circle",
    theme: "outlined"
};
const ClockCircleOutlinedSvg = ClockCircleOutlined$2;

function _objectSpread$x(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$x(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$x(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var ClockCircleOutlined = function (C, H) {
    var W = _objectSpread$x({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$x({}, W, {
        icon: ClockCircleOutlinedSvg
    }), null)
};
ClockCircleOutlined.displayName = "ClockCircleOutlined";
ClockCircleOutlined.inheritAttrs = !1;
const ClockCircleOutlined$1 = ClockCircleOutlined;

function getPlaceholder(K, C, H) {
    return H !== void 0 ? H : K === "year" && C.lang.yearPlaceholder ? C.lang.yearPlaceholder : K === "quarter" && C.lang
        .quarterPlaceholder ? C.lang.quarterPlaceholder : K === "month" && C.lang.monthPlaceholder ? C.lang.monthPlaceholder :
        K === "week" && C.lang.weekPlaceholder ? C.lang.weekPlaceholder : K === "time" && C.timePickerLocale.placeholder ?
        C.timePickerLocale.placeholder : C.lang.placeholder
}

function getRangePlaceholder(K, C, H) {
    return H !== void 0 ? H : K === "year" && C.lang.yearPlaceholder ? C.lang.rangeYearPlaceholder : K === "month" && C
        .lang.monthPlaceholder ? C.lang.rangeMonthPlaceholder : K === "week" && C.lang.weekPlaceholder ? C.lang.rangeWeekPlaceholder :
        K === "time" && C.timePickerLocale.placeholder ? C.timePickerLocale.rangePlaceholder : C.lang.rangePlaceholder
}

function commonProps() {
    return {
        id: String,
        dropdownClassName: String,
        dropdownAlign: {
            type: Object
        },
        popupStyle: {
            type: Object
        },
        transitionName: String,
        placeholder: String,
        allowClear: {
            type: Boolean,
            default: void 0
        },
        autofocus: {
            type: Boolean,
            default: void 0
        },
        disabled: {
            type: Boolean,
            default: void 0
        },
        tabindex: Number,
        open: {
            type: Boolean,
            default: void 0
        },
        defaultOpen: {
            type: Boolean,
            default: void 0
        },
        inputReadOnly: {
            type: Boolean,
            default: void 0
        },
        format: {
            type: [String, Function, Array]
        },
        getPopupContainer: {
            type: Function
        },
        panelRender: {
            type: Function
        },
        onChange: {
            type: Function
        },
        "onUpdate:value": {
            type: Function
        },
        onOk: {
            type: Function
        },
        onOpenChange: {
            type: Function
        },
        "onUpdate:open": {
            type: Function
        },
        onFocus: {
            type: Function
        },
        onBlur: {
            type: Function
        },
        onMousedown: {
            type: Function
        },
        onMouseup: {
            type: Function
        },
        onMouseenter: {
            type: Function
        },
        onMouseleave: {
            type: Function
        },
        onClick: {
            type: Function
        },
        onContextmenu: {
            type: Function
        },
        onKeydown: {
            type: Function
        },
        role: String,
        name: String,
        autocomplete: String,
        direction: {
            type: String
        },
        showToday: {
            type: Boolean,
            default: void 0
        },
        showTime: {
            type: [Boolean, Object],
            default: void 0
        },
        locale: {
            type: Object
        },
        size: {
            type: String
        },
        bordered: {
            type: Boolean,
            default: void 0
        },
        dateRender: {
            type: Function
        },
        disabledDate: {
            type: Function
        },
        mode: {
            type: String
        },
        picker: {
            type: String
        },
        valueFormat: String,
        disabledHours: Function,
        disabledMinutes: Function,
        disabledSeconds: Function
    }
}

function datePickerProps() {
    return {
        defaultPickerValue: {
            type: [String, Object]
        },
        defaultValue: {
            type: [String, Object]
        },
        value: {
            type: [String, Object]
        },
        disabledTime: {
            type: Function
        },
        renderExtraFooter: {
            type: Function
        },
        showNow: {
            type: Boolean,
            default: void 0
        },
        monthCellRender: {
            type: Function
        },
        monthCellContentRender: {
            type: Function
        }
    }
}

function rangePickerProps() {
    return {
        allowEmpty: {
            type: Array
        },
        dateRender: {
            type: Function
        },
        defaultPickerValue: {
            type: Array
        },
        defaultValue: {
            type: Array
        },
        value: {
            type: Array
        },
        disabledTime: {
            type: Function
        },
        disabled: {
            type: [Boolean, Array]
        },
        renderExtraFooter: {
            type: Function
        },
        separator: {
            type: String
        },
        ranges: {
            type: Object
        },
        placeholder: Array,
        mode: {
            type: Array
        },
        onChange: {
            type: Function
        },
        "onUpdate:value": {
            type: Function
        },
        onCalendarChange: {
            type: Function
        },
        onPanelChange: {
            type: Function
        },
        onOk: {
            type: Function
        }
    }
}
var _excluded$C = ["bordered", "placeholder", "suffixIcon", "showToday", "transitionName", "allowClear", "dateRender",
    "renderExtraFooter", "monthCellRender", "clearIcon", "id"];

function generateSinglePicker(K, C) {
    function H(ee, ne) {
        var te = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, commonProps()), datePickerProps()), C);
        return defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: ne,
            inheritAttrs: !1,
            props: te,
            slots: ["suffixIcon", "prevIcon", "nextIcon", "superPrevIcon", "superNextIcon", "dateRender",
                "renderExtraFooter", "monthCellRender"],
            setup: function (ae, oe) {
                var ie = oe.slots,
                    ue = oe.expose,
                    le = oe.attrs,
                    se = oe.emit,
                    ce = ae,
                    de = useInjectFormItemContext();
                devWarning(!(ce.monthCellContentRender || ie.monthCellContentRender), "DatePicker",
                        '`monthCellContentRender` is deprecated. Please use `monthCellRender"` instead.'),
                    devWarning(!le.getCalendarContainer, "DatePicker",
                        '`getCalendarContainer` is deprecated. Please use `getPopupContainer"` instead.');
                var ve = useConfigInject("picker", ce),
                    fe = ve.prefixCls,
                    pe = ve.direction,
                    me = ve.getPopupContainer,
                    he = ve.size,
                    Se = ve.rootPrefixCls,
                    _e = ref();
                ue({
                    focus: function () {
                        var Ae;
                        (Ae = _e.value) === null || Ae === void 0 || Ae.focus()
                    },
                    blur: function () {
                        var Ae;
                        (Ae = _e.value) === null || Ae === void 0 || Ae.blur()
                    }
                });
                var be = function (Ae) {
                        return ce.valueFormat ? K.toString(Ae, ce.valueFormat) : Ae
                    },
                    ge = function (Ae, Re) {
                        var He = be(Ae);
                        se("update:value", He), se("change", He, Re), de.onFieldChange()
                    },
                    xe = function (Ae) {
                        se("update:open", Ae), se("openChange", Ae)
                    },
                    Pe = function (Ae) {
                        se("focus", Ae)
                    },
                    $e = function (Ae) {
                        se("blur", Ae), de.onFieldBlur()
                    },
                    ye = function (Ae, Re) {
                        var He = be(Ae);
                        se("panelChange", He, Re)
                    },
                    Ce = function (Ae) {
                        var Re = be(Ae);
                        se("ok", Re)
                    },
                    we = useLocaleReceiver("DatePicker", enUS),
                    Oe = _slicedToArray$2(we, 1),
                    Ne = Oe[0],
                    Me = computed(function () {
                        return ce.value ? ce.valueFormat ? K.toDate(ce.value, ce.valueFormat) : ce.value :
                            ce.value === "" ? void 0 : ce.value
                    }),
                    Ve = computed(function () {
                        return ce.defaultValue ? ce.valueFormat ? K.toDate(ce.defaultValue, ce.valueFormat) :
                            ce.defaultValue : ce.defaultValue === "" ? void 0 : ce.defaultValue
                    }),
                    ke = computed(function () {
                        return ce.defaultPickerValue ? ce.valueFormat ? K.toDate(ce.defaultPickerValue,
                                ce.valueFormat) : ce.defaultPickerValue : ce.defaultPickerValue === "" ?
                            void 0 : ce.defaultPickerValue
                    });
                return function () {
                    var Ee, Ae, Re, He, je, Fe, Le, Ie = _objectSpread2$1(_objectSpread2$1({}, Ne.value),
                            ce.locale),
                        Te = _objectSpread2$1(_objectSpread2$1({}, ce), le),
                        De = Te.bordered,
                        Ke = De === void 0 ? !0 : De,
                        We = Te.placeholder,
                        Ue = Te.suffixIcon,
                        et = Ue === void 0 ? (Ee = ie.suffixIcon) === null || Ee === void 0 ? void 0 :
                        Ee.call(ie) : Ue,
                        Ye = Te.showToday,
                        ze = Ye === void 0 ? !0 : Ye,
                        Be = Te.transitionName,
                        Ge = Te.allowClear,
                        Xe = Ge === void 0 ? !0 : Ge,
                        nt = Te.dateRender,
                        it = nt === void 0 ? ie.dateRender : nt,
                        ft = Te.renderExtraFooter,
                        pt = ft === void 0 ? ie.renderExtraFooter : ft,
                        ot = Te.monthCellRender,
                        Ze = ot === void 0 ? ie.monthCellRender || ce.monthCellContentRender || ie.monthCellContentRender :
                        ot,
                        ut = Te.clearIcon,
                        st = ut === void 0 ? (Ae = ie.clearIcon) === null || Ae === void 0 ? void 0 :
                        Ae.call(ie) : ut,
                        rt = Te.id,
                        qe = rt === void 0 ? de.id.value : rt,
                        Je = _objectWithoutProperties$2(Te, _excluded$C),
                        Qe = Te.showTime === "" ? !0 : Te.showTime,
                        lt = Te.format,
                        ct = {};
                    ee && (ct.picker = ee);
                    var dt = ee || Te.picker || "date";
                    ct = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, ct), Qe ? getTimeProps(
                            _objectSpread2$1({
                                format: lt,
                                picker: dt
                            }, _typeof$2(Qe) === "object" ? Qe : {})) : {}), dt === "time" ?
                        getTimeProps(_objectSpread2$1(_objectSpread2$1({
                            format: lt
                        }, Je), {}, {
                            picker: dt
                        })) : {});
                    var tt = fe.value;
                    return createVNode(Picker$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                        monthCellRender: Ze,
                        dateRender: it,
                        renderExtraFooter: pt,
                        ref: _e,
                        placeholder: getPlaceholder(dt, Ie, We),
                        suffixIcon: et || createVNode(dt === "time" ?
                            ClockCircleOutlined$1 : CalendarOutlined$1, null,
                            null),
                        clearIcon: st || createVNode(CloseCircleFilled$1, null,
                            null),
                        allowClear: Xe,
                        transitionName: Be || "".concat(Se.value, "-slide-up")
                    }, Je), ct), {}, {
                        id: qe,
                        picker: dt,
                        value: Me.value,
                        defaultValue: Ve.value,
                        defaultPickerValue: ke.value,
                        showToday: ze,
                        locale: Ie.lang,
                        class: classNames((Re = {}, _defineProperty$V(Re, "".concat(tt, "-")
                            .concat(he.value), he.value), _defineProperty$V(Re,
                            "".concat(tt, "-borderless"), !Ke), Re), le.class),
                        prefixCls: tt,
                        getPopupContainer: le.getCalendarContainer || me.value,
                        generateConfig: K,
                        prevIcon: ((He = ie.prevIcon) === null || He === void 0 ? void 0 :
                            He.call(ie)) || createVNode("span", {
                            class: "".concat(tt, "-prev-icon")
                        }, null),
                        nextIcon: ((je = ie.nextIcon) === null || je === void 0 ? void 0 :
                            je.call(ie)) || createVNode("span", {
                            class: "".concat(tt, "-next-icon")
                        }, null),
                        superPrevIcon: ((Fe = ie.superPrevIcon) === null || Fe === void 0 ?
                            void 0 : Fe.call(ie)) || createVNode("span", {
                            class: "".concat(tt, "-super-prev-icon")
                        }, null),
                        superNextIcon: ((Le = ie.superNextIcon) === null || Le === void 0 ?
                            void 0 : Le.call(ie)) || createVNode("span", {
                            class: "".concat(tt, "-super-next-icon")
                        }, null),
                        components: Components,
                        direction: pe.value,
                        onChange: ge,
                        onOpenChange: xe,
                        onFocus: Pe,
                        onBlur: $e,
                        onPanelChange: ye,
                        onOk: Ce
                    }), null)
                }
            }
        })
    }
    var W = H(void 0, "ADatePicker"),
        U = H("week", "AWeekPicker"),
        G = H("month", "AMonthPicker"),
        X = H("year", "AYearPicker"),
        Z = H("time", "TimePicker"),
        Q = H("quarter", "AQuarterPicker");
    return {
        DatePicker: W,
        WeekPicker: U,
        MonthPicker: G,
        YearPicker: X,
        TimePicker: Z,
        QuarterPicker: Q
    }
}
var SwapRightOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "0 0 1024 1024",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M873.1 596.2l-164-208A32 32 0 00684 376h-64.8c-6.7 0-10.4 7.7-6.3 13l144.3 183H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h695.9c26.8 0 41.7-30.8 25.2-51.8z"
            }
        }]
    },
    name: "swap-right",
    theme: "outlined"
};
const SwapRightOutlinedSvg = SwapRightOutlined$2;

function _objectSpread$w(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$w(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$w(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var SwapRightOutlined = function (C, H) {
    var W = _objectSpread$w({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$w({}, W, {
        icon: SwapRightOutlinedSvg
    }), null)
};
SwapRightOutlined.displayName = "SwapRightOutlined";
SwapRightOutlined.inheritAttrs = !1;
const SwapRightOutlined$1 = SwapRightOutlined;
var _excluded$B = ["prefixCls", "bordered", "placeholder", "suffixIcon", "picker", "transitionName", "allowClear",
    "dateRender", "renderExtraFooter", "separator", "clearIcon", "id"];

function generateRangePicker(K, C) {
    var H = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ARangePicker",
        inheritAttrs: !1,
        props: _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, commonProps()), rangePickerProps()), C),
        slots: ["suffixIcon", "prevIcon", "nextIcon", "superPrevIcon", "superNextIcon", "dateRender",
            "renderExtraFooter"],
        setup: function (U, G) {
            var X = G.expose,
                Z = G.slots,
                Q = G.attrs,
                ee = G.emit,
                ne = U,
                te = useInjectFormItemContext();
            devWarning(!Q.getCalendarContainer, "DatePicker",
                '`getCalendarContainer` is deprecated. Please use `getPopupContainer"` instead.');
            var re = useConfigInject("picker", ne),
                ae = re.prefixCls,
                oe = re.direction,
                ie = re.getPopupContainer,
                ue = re.size,
                le = re.rootPrefixCls,
                se = ref();
            X({
                focus: function () {
                    var Ce;
                    (Ce = se.value) === null || Ce === void 0 || Ce.focus()
                },
                blur: function () {
                    var Ce;
                    (Ce = se.value) === null || Ce === void 0 || Ce.blur()
                }
            });
            var ce = function (Ce) {
                    return ne.valueFormat ? K.toString(Ce, ne.valueFormat) : Ce
                },
                de = function (Ce, we) {
                    var Oe = ce(Ce);
                    ee("update:value", Oe), ee("change", Oe, we), te.onFieldChange()
                },
                ve = function (Ce) {
                    ee("update:open", Ce), ee("openChange", Ce)
                },
                fe = function (Ce) {
                    ee("focus", Ce)
                },
                pe = function (Ce) {
                    ee("blur", Ce), te.onFieldBlur()
                },
                me = function (Ce, we) {
                    var Oe = ce(Ce);
                    ee("panelChange", Oe, we)
                },
                he = function (Ce) {
                    var we = ce(Ce);
                    ee("ok", we)
                },
                Se = function (Ce, we, Oe) {
                    var Ne = ce(Ce);
                    ee("calendarChange", Ne, we, Oe)
                },
                _e = useLocaleReceiver("DatePicker", enUS),
                be = _slicedToArray$2(_e, 1),
                ge = be[0],
                xe = computed(function () {
                    return ne.value && ne.valueFormat ? K.toDate(ne.value, ne.valueFormat) : ne.value
                }),
                Pe = computed(function () {
                    return ne.defaultValue && ne.valueFormat ? K.toDate(ne.defaultValue, ne.valueFormat) :
                        ne.defaultValue
                }),
                $e = computed(function () {
                    return ne.defaultPickerValue && ne.valueFormat ? K.toDate(ne.defaultPickerValue, ne
                        .valueFormat) : ne.defaultPickerValue
                });
            return function () {
                var ye, Ce, we, Oe, Ne, Me, Ve, ke, Ee = _objectSpread2$1(_objectSpread2$1({}, ge.value),
                        ne.locale),
                    Ae = _objectSpread2$1(_objectSpread2$1({}, ne), Q);
                Ae.prefixCls;
                var Re = Ae.bordered,
                    He = Re === void 0 ? !0 : Re,
                    je = Ae.placeholder,
                    Fe = Ae.suffixIcon,
                    Le = Fe === void 0 ? (ye = Z.suffixIcon) === null || ye === void 0 ? void 0 : ye.call(
                        Z) : Fe,
                    Ie = Ae.picker,
                    Te = Ie === void 0 ? "date" : Ie,
                    De = Ae.transitionName,
                    Ke = Ae.allowClear,
                    We = Ke === void 0 ? !0 : Ke,
                    Ue = Ae.dateRender,
                    et = Ue === void 0 ? Z.dateRender : Ue,
                    Ye = Ae.renderExtraFooter,
                    ze = Ye === void 0 ? Z.renderExtraFooter : Ye,
                    Be = Ae.separator,
                    Ge = Be === void 0 ? (Ce = Z.separator) === null || Ce === void 0 ? void 0 : Ce.call(
                        Z) : Be,
                    Xe = Ae.clearIcon,
                    nt = Xe === void 0 ? (we = Z.clearIcon) === null || we === void 0 ? void 0 : we.call(
                        Z) : Xe,
                    it = Ae.id,
                    ft = it === void 0 ? te.id.value : it,
                    pt = _objectWithoutProperties$2(Ae, _excluded$B);
                delete pt["onUpdate:value"], delete pt["onUpdate:open"];
                var ot = Ae.format,
                    Ze = Ae.showTime,
                    ut = {};
                ut = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, ut), Ze ? getTimeProps(
                    _objectSpread2$1({
                        format: ot,
                        picker: Te
                    }, Ze)) : {}), Te === "time" ? getTimeProps(_objectSpread2$1(
                    _objectSpread2$1({
                        format: ot
                    }, omit$2(pt, ["disabledTime"])), {}, {
                        picker: Te
                    })) : {});
                var st = ae.value;
                return createVNode(VCRangePicker, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                    dateRender: et,
                    renderExtraFooter: ze,
                    separator: Ge || createVNode("span", {
                        "aria-label": "to",
                        class: "".concat(st, "-separator")
                    }, [createVNode(SwapRightOutlined$1, null, null)]),
                    ref: se,
                    placeholder: getRangePlaceholder(Te, Ee, je),
                    suffixIcon: Le || createVNode(Te === "time" ?
                        ClockCircleOutlined$1 : CalendarOutlined$1, null, null),
                    clearIcon: nt || createVNode(CloseCircleFilled$1, null, null),
                    allowClear: We,
                    transitionName: De || "".concat(le.value, "-slide-up")
                }, pt), ut), {}, {
                    id: ft,
                    value: xe.value,
                    defaultValue: Pe.value,
                    defaultPickerValue: $e.value,
                    picker: Te,
                    class: classNames((Oe = {}, _defineProperty$V(Oe, "".concat(st, "-").concat(
                        ue.value), ue.value), _defineProperty$V(Oe, "".concat(
                        st, "-borderless"), !He), Oe), Q.class),
                    locale: Ee.lang,
                    prefixCls: st,
                    getPopupContainer: Q.getCalendarContainer || ie.value,
                    generateConfig: K,
                    prevIcon: ((Ne = Z.prevIcon) === null || Ne === void 0 ? void 0 : Ne.call(
                        Z)) || createVNode("span", {
                        class: "".concat(st, "-prev-icon")
                    }, null),
                    nextIcon: ((Me = Z.nextIcon) === null || Me === void 0 ? void 0 : Me.call(
                        Z)) || createVNode("span", {
                        class: "".concat(st, "-next-icon")
                    }, null),
                    superPrevIcon: ((Ve = Z.superPrevIcon) === null || Ve === void 0 ? void 0 :
                        Ve.call(Z)) || createVNode("span", {
                        class: "".concat(st, "-super-prev-icon")
                    }, null),
                    superNextIcon: ((ke = Z.superNextIcon) === null || ke === void 0 ? void 0 :
                        ke.call(Z)) || createVNode("span", {
                        class: "".concat(st, "-super-next-icon")
                    }, null),
                    components: Components,
                    direction: oe.value,
                    onChange: de,
                    onOpenChange: ve,
                    onFocus: fe,
                    onBlur: pe,
                    onPanelChange: me,
                    onOk: he,
                    onCalendarChange: Se
                }), null)
            }
        }
    });
    return H
}
var Components = {
    button: PickerButton$1,
    rangeItem: PickerTag
};

function toArray$4(K) {
    return K ? Array.isArray(K) ? K : [K] : []
}

function getTimeProps(K) {
    var C = K.format,
        H = K.picker,
        W = K.showHour,
        U = K.showMinute,
        G = K.showSecond,
        X = K.use12Hours,
        Z = toArray$4(C)[0],
        Q = _objectSpread2$1({}, K);
    return Z && typeof Z == "string" && (!Z.includes("s") && G === void 0 && (Q.showSecond = !1), !Z.includes("m") && U ===
        void 0 && (Q.showMinute = !1), !Z.includes("H") && !Z.includes("h") && W === void 0 && (Q.showHour = !1), (
            Z.includes("a") || Z.includes("A")) && X === void 0 && (Q.use12Hours = !0)), H === "time" ? Q : (typeof Z ==
        "function" && delete Q.format, {
            showTime: Q
        })
}

function generatePicker(K, C) {
    var H = generateSinglePicker(K, C),
        W = H.DatePicker,
        U = H.WeekPicker,
        G = H.MonthPicker,
        X = H.YearPicker,
        Z = H.TimePicker,
        Q = H.QuarterPicker,
        ee = generateRangePicker(K, C);
    return {
        DatePicker: W,
        WeekPicker: U,
        MonthPicker: G,
        YearPicker: X,
        TimePicker: Z,
        QuarterPicker: Q,
        RangePicker: ee
    }
}
var _generatePicker = generatePicker(dayjsGenerateConfig),
    DatePicker = _generatePicker.DatePicker,
    WeekPicker = _generatePicker.WeekPicker,
    MonthPicker = _generatePicker.MonthPicker,
    YearPicker = _generatePicker.YearPicker,
    TimePicker$2 = _generatePicker.TimePicker,
    QuarterPicker = _generatePicker.QuarterPicker,
    RangePicker = _generatePicker.RangePicker;
const DatePicker$1 = _extends$1(DatePicker, {
    WeekPicker,
    MonthPicker,
    YearPicker,
    RangePicker,
    TimePicker: TimePicker$2,
    QuarterPicker,
    install: function (C) {
        return C.component(DatePicker.name, DatePicker), C.component(RangePicker.name, RangePicker), C.component(
            MonthPicker.name, MonthPicker), C.component(WeekPicker.name, WeekPicker), C.component(
            QuarterPicker.name, QuarterPicker), C
    }
});

function notEmpty(K) {
    return K != null
}
var Cell$1 = function (C) {
    var H = C.itemPrefixCls,
        W = C.component,
        U = C.span,
        G = C.labelStyle,
        X = C.contentStyle,
        Z = C.bordered,
        Q = C.label,
        ee = C.content,
        ne = C.colon,
        te = W;
    if (Z) {
        var re;
        return createVNode(te, {
            class: [(re = {}, _defineProperty$V(re, "".concat(H, "-item-label"), notEmpty(Q)),
                _defineProperty$V(re, "".concat(H, "-item-content"), notEmpty(ee)), re)],
            colSpan: U
        }, {
            default: function () {
                return [notEmpty(Q) && createVNode("span", {
                    style: G
                }, [Q]), notEmpty(ee) && createVNode("span", {
                    style: X
                }, [ee])]
            }
        })
    }
    return createVNode(te, {
        class: ["".concat(H, "-item")],
        colSpan: U
    }, {
        default: function () {
            return [createVNode("div", {
                class: "".concat(H, "-item-container")
            }, [Q && createVNode("span", {
                class: ["".concat(H, "-item-label"), _defineProperty$V({}, "".concat(
                    H, "-item-no-colon"), !ne)],
                style: G
            }, [Q]), ee && createVNode("span", {
                class: "".concat(H, "-item-content"),
                style: X
            }, [ee])])]
        }
    })
};
const Cell$2 = Cell$1;
var Row = function (C) {
    var H = function (re, ae, oe) {
            var ie = ae.colon,
                ue = ae.prefixCls,
                le = ae.bordered,
                se = oe.component,
                ce = oe.type,
                de = oe.showLabel,
                ve = oe.showContent,
                fe = oe.labelStyle,
                pe = oe.contentStyle;
            return re.map(function (me, he) {
                var Se, _e, be = me.props || {},
                    ge = be.prefixCls,
                    xe = ge === void 0 ? ue : ge,
                    Pe = be.span,
                    $e = Pe === void 0 ? 1 : Pe,
                    ye = be.labelStyle,
                    Ce = ye === void 0 ? be["label-style"] : ye,
                    we = be.contentStyle,
                    Oe = we === void 0 ? be["content-style"] : we,
                    Ne = be.label,
                    Me = Ne === void 0 ? (Se = me.children) === null || Se === void 0 || (_e = Se.label) ===
                    null || _e === void 0 ? void 0 : _e.call(Se) : Ne,
                    Ve = getSlot(me),
                    ke = getClass(me),
                    Ee = getStyle(me),
                    Ae = me.key;
                return typeof se == "string" ? createVNode(Cell$2, {
                    key: "".concat(ce, "-").concat(String(Ae) || he),
                    class: ke,
                    style: Ee,
                    labelStyle: _objectSpread2$1(_objectSpread2$1({}, fe), Ce),
                    contentStyle: _objectSpread2$1(_objectSpread2$1({}, pe), Oe),
                    span: $e,
                    colon: ie,
                    component: se,
                    itemPrefixCls: xe,
                    bordered: le,
                    label: de ? Me : null,
                    content: ve ? Ve : null
                }, null) : [createVNode(Cell$2, {
                    key: "label-".concat(String(Ae) || he),
                    class: ke,
                    style: _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, fe), Ee), Ce),
                    span: 1,
                    colon: ie,
                    component: se[0],
                    itemPrefixCls: xe,
                    bordered: le,
                    label: Me
                }, null), createVNode(Cell$2, {
                    key: "content-".concat(String(Ae) || he),
                    class: ke,
                    style: _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, pe), Ee), Oe),
                    span: $e * 2 - 1,
                    component: se[1],
                    itemPrefixCls: xe,
                    bordered: le,
                    content: Ve
                }, null)]
            })
        },
        W = C.prefixCls,
        U = C.vertical,
        G = C.row,
        X = C.index,
        Z = C.bordered,
        Q = inject(descriptionsContext, {
            labelStyle: ref({}),
            contentStyle: ref({})
        }),
        ee = Q.labelStyle,
        ne = Q.contentStyle;
    return U ? createVNode(Fragment, null, [createVNode("tr", {
        key: "label-".concat(X),
        class: "".concat(W, "-row")
    }, [H(G, C, {
        component: "th",
        type: "label",
        showLabel: !0,
        labelStyle: ee.value,
        contentStyle: ne.value
    })]), createVNode("tr", {
        key: "content-".concat(X),
        class: "".concat(W, "-row")
    }, [H(G, C, {
        component: "td",
        type: "content",
        showContent: !0,
        labelStyle: ee.value,
        contentStyle: ne.value
    })])]) : createVNode("tr", {
        key: X,
        class: "".concat(W, "-row")
    }, [H(G, C, {
        component: Z ? ["th", "td"] : "td",
        type: "item",
        showLabel: !0,
        showContent: !0,
        labelStyle: ee.value,
        contentStyle: ne.value
    })])
};
const Row$1 = Row;
PropTypes$1.any;
var descriptionsItemProp = function () {
        return {
            prefixCls: String,
            label: PropTypes$1.any,
            labelStyle: {
                type: Object,
                default: void 0
            },
            contentStyle: {
                type: Object,
                default: void 0
            },
            span: {
                type: Number,
                default: 1
            }
        }
    },
    DescriptionsItem = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ADescriptionsItem",
        props: descriptionsItemProp(),
        slots: ["label"],
        setup: function (C, H) {
            var W = H.slots;
            return function () {
                var U;
                return (U = W.default) === null || U === void 0 ? void 0 : U.call(W)
            }
        }
    }),
    DEFAULT_COLUMN_MAP = {
        xxxl: 3,
        xxl: 3,
        xl: 3,
        lg: 3,
        md: 3,
        sm: 2,
        xs: 1
    };

function getColumn(K, C) {
    if (typeof K == "number") return K;
    if (_typeof$2(K) === "object")
        for (var H = 0; H < responsiveArray.length; H++) {
            var W = responsiveArray[H];
            if (C[W] && K[W] !== void 0) return K[W] || DEFAULT_COLUMN_MAP[W]
        }
    return 3
}

function getFilledItem(K, C, H) {
    var W = K;
    return (C === void 0 || C > H) && (W = cloneElement(K, {
        span: H
    }), warning$2(C === void 0, "Descriptions",
        "Sum of column `span` in a line not match `column` of Descriptions.")), W
}

function getRows(K, C) {
    var H = flattenChildren(K),
        W = [],
        U = [],
        G = C;
    return H.forEach(function (X, Z) {
        var Q, ee = (Q = X.props) === null || Q === void 0 ? void 0 : Q.span,
            ne = ee || 1;
        if (Z === H.length - 1) {
            U.push(getFilledItem(X, ee, G)), W.push(U);
            return
        }
        ne < G ? (G -= ne, U.push(X)) : (U.push(getFilledItem(X, ne, G)), W.push(U), G = C, U = [])
    }), W
}
var descriptionsProps = function () {
        return {
            prefixCls: String,
            bordered: {
                type: Boolean,
                default: void 0
            },
            size: {
                type: String,
                default: "default"
            },
            title: PropTypes$1.any,
            extra: PropTypes$1.any,
            column: {
                type: [Number, Object],
                default: function () {
                    return DEFAULT_COLUMN_MAP
                }
            },
            layout: String,
            colon: {
                type: Boolean,
                default: void 0
            },
            labelStyle: {
                type: Object,
                default: void 0
            },
            contentStyle: {
                type: Object,
                default: void 0
            }
        }
    },
    descriptionsContext = Symbol("descriptionsContext"),
    Descriptions = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ADescriptions",
        props: descriptionsProps(),
        slots: ["title", "extra"],
        Item: DescriptionsItem,
        setup: function (C, H) {
            var W = H.slots,
                U = useConfigInject("descriptions", C),
                G = U.prefixCls,
                X = U.direction,
                Z, Q = ref({});
            onBeforeMount(function () {
                Z = ResponsiveObserve.subscribe(function (ne) {
                    _typeof$2(C.column) === "object" && (Q.value = ne)
                })
            }), onBeforeUnmount(function () {
                ResponsiveObserve.unsubscribe(Z)
            }), provide(descriptionsContext, {
                labelStyle: toRef(C, "labelStyle"),
                contentStyle: toRef(C, "contentStyle")
            });
            var ee = computed(function () {
                return getColumn(C.column, Q.value)
            });
            return function () {
                var ne, te, re, ae, oe = C.size,
                    ie = C.bordered,
                    ue = ie === void 0 ? !1 : ie,
                    le = C.layout,
                    se = le === void 0 ? "horizontal" : le,
                    ce = C.colon,
                    de = ce === void 0 ? !0 : ce,
                    ve = C.title,
                    fe = ve === void 0 ? (ne = W.title) === null || ne === void 0 ? void 0 : ne.call(W) :
                    ve,
                    pe = C.extra,
                    me = pe === void 0 ? (te = W.extra) === null || te === void 0 ? void 0 : te.call(W) :
                    pe,
                    he = (re = W.default) === null || re === void 0 ? void 0 : re.call(W),
                    Se = getRows(he, ee.value);
                return createVNode("div", {
                    class: [G.value, (ae = {}, _defineProperty$V(ae, "".concat(G.value, "-").concat(
                        oe), oe !== "default"), _defineProperty$V(ae, "".concat(G.value,
                        "-bordered"), !!ue), _defineProperty$V(ae, "".concat(G.value,
                        "-rtl"), X.value === "rtl"), ae)]
                }, [(fe || me) && createVNode("div", {
                    class: "".concat(G.value, "-header")
                }, [fe && createVNode("div", {
                    class: "".concat(G.value, "-title")
                }, [fe]), me && createVNode("div", {
                    class: "".concat(G.value, "-extra")
                }, [me])]), createVNode("div", {
                    class: "".concat(G.value, "-view")
                }, [createVNode("table", null, [createVNode("tbody", null, [Se.map(function (
                    _e, be) {
                    return createVNode(Row$1, {
                        key: be,
                        index: be,
                        colon: de,
                        prefixCls: G.value,
                        vertical: se === "vertical",
                        bordered: ue,
                        row: _e
                    }, null)
                })])])])])
            }
        }
    });
Descriptions.install = function (K) {
    return K.component(Descriptions.name, Descriptions), K.component(Descriptions.Item.name, Descriptions.Item), K
};
const Descriptions$1 = Descriptions;
var dividerProps = function () {
        return {
            prefixCls: String,
            type: {
                type: String,
                default: "horizontal"
            },
            dashed: {
                type: Boolean,
                default: !1
            },
            orientation: {
                type: String,
                default: "center"
            },
            plain: {
                type: Boolean,
                default: !1
            },
            orientationMargin: [String, Number]
        }
    },
    Divider = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ADivider",
        props: dividerProps(),
        setup: function (C, H) {
            var W = H.slots,
                U = useConfigInject("divider", C),
                G = U.prefixCls,
                X = U.direction,
                Z = computed(function () {
                    return C.orientation === "left" && C.orientationMargin != null
                }),
                Q = computed(function () {
                    return C.orientation === "right" && C.orientationMargin != null
                }),
                ee = computed(function () {
                    var re, ae = C.type,
                        oe = C.dashed,
                        ie = C.plain,
                        ue = G.value;
                    return re = {}, _defineProperty$V(re, ue, !0), _defineProperty$V(re, "".concat(ue, "-")
                            .concat(ae), !0), _defineProperty$V(re, "".concat(ue, "-dashed"), !!oe),
                        _defineProperty$V(re, "".concat(ue, "-plain"), !!ie), _defineProperty$V(re, "".concat(
                            ue, "-rtl"), X.value === "rtl"), _defineProperty$V(re, "".concat(ue,
                            "-no-default-orientation-margin-left"), Z.value), _defineProperty$V(re, "".concat(
                            ue, "-no-default-orientation-margin-right"), Q.value), re
                }),
                ne = computed(function () {
                    var re = typeof C.orientationMargin == "number" ? "".concat(C.orientationMargin, "px") :
                        C.orientationMargin;
                    return _objectSpread2$1(_objectSpread2$1({}, Z.value && {
                        marginLeft: re
                    }), Q.value && {
                        marginRight: re
                    })
                }),
                te = computed(function () {
                    return C.orientation.length > 0 ? "-" + C.orientation : C.orientation
                });
            return function () {
                var re, ae = flattenChildren((re = W.default) === null || re === void 0 ? void 0 : re.call(
                    W));
                return createVNode("div", {
                    class: [ee.value, ae.length ? "".concat(G.value, "-with-text ").concat(G.value,
                        "-with-text").concat(te.value) : ""],
                    role: "separator"
                }, [ae.length ? createVNode("span", {
                    class: "".concat(G.value, "-inner-text"),
                    style: ne.value
                }, [ae]) : null])
            }
        }
    });
const index$f = withInstall(Divider);
Dropdown$1.Button = DropdownButton;
Dropdown$1.install = function (K) {
    return K.component(Dropdown$1.name, Dropdown$1), K.component(DropdownButton.name, DropdownButton), K
};
var cached;

function getScrollBarSize(K) {
    if (typeof document > "u") return 0;
    if (K || cached === void 0) {
        var C = document.createElement("div");
        C.style.width = "100%", C.style.height = "200px";
        var H = document.createElement("div"),
            W = H.style;
        W.position = "absolute", W.top = "0", W.left = "0", W.pointerEvents = "none", W.visibility = "hidden", W.width =
            "200px", W.height = "150px", W.overflow = "hidden", H.appendChild(C), document.body.appendChild(H);
        var U = C.offsetWidth;
        H.style.overflow = "scroll";
        var G = C.offsetWidth;
        U === G && (G = H.clientWidth), document.body.removeChild(H), cached = U - G
    }
    return cached
}

function ensureSize(K) {
    var C = K.match(/^(.*)px$/),
        H = Number(C == null ? void 0 : C[1]);
    return Number.isNaN(H) ? getScrollBarSize() : H
}

function getTargetScrollBarSize(K) {
    if (typeof document > "u" || !K || !(K instanceof Element)) return {
        width: 0,
        height: 0
    };
    var C = getComputedStyle(K, "::-webkit-scrollbar"),
        H = C.width,
        W = C.height;
    return {
        width: ensureSize(H),
        height: ensureSize(W)
    }
}
var props = function () {
        return {
            prefixCls: String,
            width: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number]),
            height: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number]),
            style: {
                type: Object,
                default: void 0
            },
            class: String,
            placement: {
                type: String
            },
            wrapperClassName: String,
            level: {
                type: [String, Array]
            },
            levelMove: {
                type: [Number, Function, Array]
            },
            duration: String,
            ease: String,
            showMask: {
                type: Boolean,
                default: void 0
            },
            maskClosable: {
                type: Boolean,
                default: void 0
            },
            maskStyle: {
                type: Object,
                default: void 0
            },
            afterVisibleChange: Function,
            keyboard: {
                type: Boolean,
                default: void 0
            },
            contentWrapperStyle: {
                type: Object,
                default: void 0
            },
            autofocus: {
                type: Boolean,
                default: void 0
            },
            open: {
                type: Boolean,
                default: void 0
            }
        }
    },
    drawerProps$1 = function () {
        return _objectSpread2$1(_objectSpread2$1({}, props()), {}, {
            forceRender: {
                type: Boolean,
                default: void 0
            },
            getContainer: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.func, PropTypes$1.object,
                PropTypes$1.looseBool])
        })
    },
    drawerChildProps = function () {
        return _objectSpread2$1(_objectSpread2$1({}, props()), {}, {
            getContainer: Function,
            getOpenCount: Function,
            scrollLocker: PropTypes$1.any,
            switchScrollingEffect: Function
        })
    };

function dataToArray(K) {
    return Array.isArray(K) ? K : [K]
}
var transitionEndObject = {
        transition: "transitionend",
        WebkitTransition: "webkitTransitionEnd",
        MozTransition: "transitionend",
        OTransition: "oTransitionEnd otransitionend"
    },
    transitionStr = Object.keys(transitionEndObject).filter(function (K) {
        if (typeof document > "u") return !1;
        var C = document.getElementsByTagName("html")[0];
        return K in (C ? C.style : {})
    })[0],
    transitionEndFun = transitionEndObject[transitionStr];

function addEventListener(K, C, H, W) {
    K.addEventListener ? K.addEventListener(C, H, W) : K.attachEvent && K.attachEvent("on".concat(C), H)
}

function removeEventListener(K, C, H, W) {
    K.removeEventListener ? K.removeEventListener(C, H, W) : K.attachEvent && K.detachEvent("on".concat(C), H)
}

function transformArguments(K, C) {
    var H = typeof K == "function" ? K(C) : K;
    return Array.isArray(H) ? H.length === 2 ? H : [H[0], H[1]] : [H]
}
var isNumeric = function (C) {
        return !isNaN(parseFloat(C)) && isFinite(C)
    },
    windowIsUndefined = !(typeof window < "u" && window.document && window.document.createElement),
    getTouchParentScroll = function K(C, H, W, U) {
        if (!H || H === document || H instanceof Document) return !1;
        if (H === C.parentNode) return !0;
        var G = Math.max(Math.abs(W), Math.abs(U)) === Math.abs(U),
            X = Math.max(Math.abs(W), Math.abs(U)) === Math.abs(W),
            Z = H.scrollHeight - H.clientHeight,
            Q = H.scrollWidth - H.clientWidth,
            ee = document.defaultView.getComputedStyle(H),
            ne = ee.overflowY === "auto" || ee.overflowY === "scroll",
            te = ee.overflowX === "auto" || ee.overflowX === "scroll",
            re = Z && ne,
            ae = Q && te;
        return G && (!re || re && (H.scrollTop >= Z && U < 0 || H.scrollTop <= 0 && U > 0)) || X && (!ae || ae && (H.scrollLeft >=
            Q && W < 0 || H.scrollLeft <= 0 && W > 0)) ? K(C, H.parentNode, W, U) : !1
    },
    _excluded$A = ["width", "height", "open", "prefixCls", "placement", "level", "levelMove", "ease", "duration",
        "getContainer", "onChange", "afterVisibleChange", "showMask", "maskClosable", "maskStyle", "keyboard",
        "getOpenCount", "scrollLocker", "contentWrapperStyle", "style", "class"],
    currentDrawer = {},
    DrawerChild = defineComponent({
        compatConfig: {
            MODE: 3
        },
        inheritAttrs: !1,
        props: drawerChildProps(),
        emits: ["close", "handleClick", "change"],
        setup: function (C, H) {
            var W = H.emit,
                U = H.slots,
                G = reactive({
                    startPos: {
                        x: null,
                        y: null
                    }
                }),
                X, Z = ref(),
                Q = ref(),
                ee = ref(),
                ne = ref(),
                te = ref(),
                re = [],
                ae = "drawer_id_".concat(Number((Date.now() + Math.random()).toString().replace(".", Math.round(
                    Math.random() * 9).toString())).toString(16)),
                oe = !windowIsUndefined && supportsPassive$1 ? {
                    passive: !1
                } : !1;
            onMounted(function () {
                nextTick(function () {
                    var ye = C.open,
                        Ce = C.getContainer,
                        we = C.showMask,
                        Oe = C.autofocus,
                        Ne = Ce == null ? void 0 : Ce();
                    if (xe(C), ye && (Ne && Ne.parentNode === document.body && (currentDrawer[
                            ae] = ye), pe(), nextTick(function () {
                            Oe && ie()
                        }), we)) {
                        var Me;
                        (Me = C.scrollLocker) === null || Me === void 0 || Me.lock()
                    }
                })
            }), watch(function () {
                return C.level
            }, function () {
                xe(C)
            }, {
                flush: "post"
            }), watch(function () {
                return C.open
            }, function () {
                var ye = C.open,
                    Ce = C.getContainer,
                    we = C.scrollLocker,
                    Oe = C.showMask,
                    Ne = C.autofocus,
                    Me = Ce == null ? void 0 : Ce();
                Me && Me.parentNode === document.body && (currentDrawer[ae] = !!ye), pe(), ye ? (Ne &&
                    ie(), Oe && (we == null || we.lock())) : we == null || we.unLock()
            }, {
                flush: "post"
            }), onUnmounted(function () {
                var ye, Ce = C.open;
                delete currentDrawer[ae], Ce && (me(!1), document.body.style.touchAction = ""), (ye = C
                    .scrollLocker) === null || ye === void 0 || ye.unLock()
            }), watch(function () {
                return C.placement
            }, function (ye) {
                ye && (te.value = null)
            });
            var ie = function () {
                    var Ce, we;
                    (Ce = Q.value) === null || Ce === void 0 || (we = Ce.focus) === null || we === void 0 || we
                        .call(Ce)
                },
                ue = function (Ce) {
                    Ce.touches.length > 1 || (G.startPos = {
                        x: Ce.touches[0].clientX,
                        y: Ce.touches[0].clientY
                    })
                },
                le = function (Ce) {
                    if (!(Ce.changedTouches.length > 1)) {
                        var we = Ce.currentTarget,
                            Oe = Ce.changedTouches[0].clientX - G.startPos.x,
                            Ne = Ce.changedTouches[0].clientY - G.startPos.y;
                        (we === ee.value || we === ne.value || we === te.value && getTouchParentScroll(we, Ce.target,
                            Oe, Ne)) && Ce.cancelable && Ce.preventDefault()
                    }
                },
                se = function ye(Ce) {
                    var we = Ce.target;
                    removeEventListener(we, transitionEndFun, ye), we.style.transition = ""
                },
                ce = function (Ce) {
                    W("close", Ce)
                },
                de = function (Ce) {
                    Ce.keyCode === KeyCode$1.ESC && (Ce.stopPropagation(), ce(Ce))
                },
                ve = function (Ce) {
                    var we = C.open,
                        Oe = C.afterVisibleChange;
                    Ce.target === Z.value && Ce.propertyName.match(/transform$/) && (Q.value.style.transition =
                        "", !we && ge() && (document.body.style.overflowX = "", ee.value && (ee.value.style
                            .left = "", ee.value.style.width = "")), Oe && Oe(!!we))
                },
                fe = computed(function () {
                    var ye = C.placement,
                        Ce = ye === "left" || ye === "right",
                        we = "translate".concat(Ce ? "X" : "Y");
                    return {
                        isHorizontal: Ce,
                        placementName: we
                    }
                }),
                pe = function () {
                    var Ce = C.open,
                        we = C.width,
                        Oe = C.height,
                        Ne = fe.value,
                        Me = Ne.isHorizontal,
                        Ve = Ne.placementName,
                        ke = te.value ? te.value.getBoundingClientRect()[Me ? "width" : "height"] : 0,
                        Ee = (Me ? we : Oe) || ke;
                    he(Ce, Ve, Ee)
                },
                me = function (Ce, we, Oe, Ne) {
                    var Me = C.placement,
                        Ve = C.levelMove,
                        ke = C.duration,
                        Ee = C.ease,
                        Ae = C.showMask;
                    re.forEach(function (Re) {
                        Re.style.transition = "transform ".concat(ke, " ").concat(Ee), addEventListener(
                            Re, transitionEndFun, se);
                        var He = Ce ? Oe : 0;
                        if (Ve) {
                            var je = transformArguments(Ve, {
                                target: Re,
                                open: Ce
                            });
                            He = Ce ? je[0] : je[1] || 0
                        }
                        var Fe = typeof He == "number" ? "".concat(He, "px") : He,
                            Le = Me === "left" || Me === "top" ? Fe : "-".concat(Fe);
                        Le = Ae && Me === "right" && Ne ? "calc(".concat(Le, " + ").concat(Ne, "px)") :
                            Le, Re.style.transform = He ? "".concat(we, "(").concat(Le, ")") : ""
                    })
                },
                he = function (Ce, we, Oe) {
                    if (!windowIsUndefined) {
                        var Ne = document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) &&
                            window.innerWidth > document.body.offsetWidth ? getScrollBarSize(!0) : 0;
                        me(Ce, we, Oe, Ne), Se(Ne)
                    }
                    W("change", Ce)
                },
                Se = function (Ce) {
                    var we = C.getContainer,
                        Oe = C.showMask,
                        Ne = C.open,
                        Me = we == null ? void 0 : we();
                    if (Me && Me.parentNode === document.body && Oe) {
                        var Ve = ["touchstart"],
                            ke = [document.body, ee.value, ne.value, te.value];
                        Ne && document.body.style.overflow !== "hidden" ? (Ce && _e(Ce), document.body.style.touchAction =
                            "none", ke.forEach(function (Ee, Ae) {
                                Ee && addEventListener(Ee, Ve[Ae] || "touchmove", Ae ? le : ue, oe)
                            })) : ge() && (document.body.style.touchAction = "", Ce && be(Ce), ke.forEach(
                            function (Ee, Ae) {
                                Ee && removeEventListener(Ee, Ve[Ae] || "touchmove", Ae ? le : ue, oe)
                            }))
                    }
                },
                _e = function (Ce) {
                    var we = C.placement,
                        Oe = C.duration,
                        Ne = C.ease,
                        Me = "width ".concat(Oe, " ").concat(Ne),
                        Ve = "transform ".concat(Oe, " ").concat(Ne);
                    switch (Q.value.style.transition = "none", we) {
                        case "right":
                            Q.value.style.transform = "translateX(-".concat(Ce, "px)");
                            break;
                        case "top":
                        case "bottom":
                            Q.value.style.width = "calc(100% - ".concat(Ce, "px)"), Q.value.style.transform =
                                "translateZ(0)";
                            break
                    }
                    clearTimeout(X), X = setTimeout(function () {
                        Q.value && (Q.value.style.transition = "".concat(Ve, ",").concat(Me), Q.value.style
                            .width = "", Q.value.style.transform = "")
                    })
                },
                be = function (Ce) {
                    var we = C.placement,
                        Oe = C.duration,
                        Ne = C.ease;
                    Q.value.style.transition = "none";
                    var Me, Ve = "width ".concat(Oe, " ").concat(Ne),
                        ke = "transform ".concat(Oe, " ").concat(Ne);
                    switch (we) {
                        case "left":
                            {
                                Q.value.style.width = "100%",
                                Ve = "width 0s ".concat(Ne, " ").concat(Oe);
                                break
                            }
                        case "right":
                            {
                                Q.value.style.transform = "translateX(".concat(Ce, "px)"),
                                Q.value.style.width = "100%",
                                Ve = "width 0s ".concat(Ne, " ").concat(Oe),
                                ee.value && (ee.value.style.left = "-".concat(Ce, "px"), ee.value.style.width =
                                    "calc(100% + ".concat(Ce, "px)"));
                                break
                            }
                        case "top":
                        case "bottom":
                            {
                                Q.value.style.width = "calc(100% + ".concat(Ce, "px)"),
                                Q.value.style.height = "100%",
                                Q.value.style.transform = "translateZ(0)",
                                Me = "height 0s ".concat(Ne, " ").concat(Oe);
                                break
                            }
                    }
                    clearTimeout(X), X = setTimeout(function () {
                        Q.value && (Q.value.style.transition = "".concat(ke, ",").concat(Me ? "".concat(
                                Me, ",") : "").concat(Ve), Q.value.style.transform = "", Q.value.style
                            .width = "", Q.value.style.height = "")
                    })
                },
                ge = function () {
                    return !Object.keys(currentDrawer).some(function (Ce) {
                        return currentDrawer[Ce]
                    })
                },
                xe = function (Ce) {
                    var we = Ce.level,
                        Oe = Ce.getContainer;
                    if (!windowIsUndefined) {
                        var Ne = Oe == null ? void 0 : Oe(),
                            Me = Ne ? Ne.parentNode : null;
                        if (re = [], we === "all") {
                            var Ve = Me ? Array.prototype.slice.call(Me.children) : [];
                            Ve.forEach(function (ke) {
                                ke.nodeName !== "SCRIPT" && ke.nodeName !== "STYLE" && ke.nodeName !==
                                    "LINK" && ke !== Ne && re.push(ke)
                            })
                        } else we && dataToArray(we).forEach(function (ke) {
                            document.querySelectorAll(ke).forEach(function (Ee) {
                                re.push(Ee)
                            })
                        })
                    }
                },
                Pe = function (Ce) {
                    W("handleClick", Ce)
                },
                $e = ref(!1);
            return watch(Q, function () {
                    nextTick(function () {
                        $e.value = !0
                    })
                }),
                function () {
                    var ye, Ce, we, Oe = C.width,
                        Ne = C.height,
                        Me = C.open,
                        Ve = C.prefixCls,
                        ke = C.placement;
                    C.level, C.levelMove, C.ease, C.duration, C.getContainer, C.onChange, C.afterVisibleChange;
                    var Ee = C.showMask,
                        Ae = C.maskClosable,
                        Re = C.maskStyle,
                        He = C.keyboard;
                    C.getOpenCount, C.scrollLocker;
                    var je = C.contentWrapperStyle,
                        Fe = C.style,
                        Le = C.class,
                        Ie = _objectWithoutProperties$2(C, _excluded$A),
                        Te = Me && $e.value,
                        De = classNames(Ve, (ye = {}, _defineProperty$V(ye, "".concat(Ve, "-").concat(ke), !0),
                            _defineProperty$V(ye, "".concat(Ve, "-open"), Te), _defineProperty$V(ye, Le, !!
                                Le), _defineProperty$V(ye, "no-mask", !Ee), ye)),
                        Ke = fe.value.placementName,
                        We = ke === "left" || ke === "top" ? "-100%" : "100%",
                        Ue = Te ? "" : "".concat(Ke, "(").concat(We, ")");
                    return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, omit$2(Ie, [
                        "switchScrollingEffect", "autofocus"])), {}, {
                        tabindex: -1,
                        class: De,
                        style: Fe,
                        ref: Q,
                        onKeydown: Te && He ? de : void 0,
                        onTransitionend: ve
                    }), [Ee && createVNode("div", {
                        class: "".concat(Ve, "-mask"),
                        onClick: Ae ? ce : void 0,
                        style: Re,
                        ref: ee
                    }, null), createVNode("div", {
                        class: "".concat(Ve, "-content-wrapper"),
                        style: _objectSpread2$1({
                            transform: Ue,
                            msTransform: Ue,
                            width: isNumeric(Oe) ? "".concat(Oe, "px") : Oe,
                            height: isNumeric(Ne) ? "".concat(Ne, "px") : Ne
                        }, je),
                        ref: Z
                    }, [createVNode("div", {
                            class: "".concat(Ve, "-content"),
                            ref: te
                        }, [(Ce = U.default) === null || Ce === void 0 ? void 0 : Ce.call(U)]),
                        U.handler ? createVNode("div", {
                            onClick: Pe,
                            ref: ne
                        }, [(we = U.handler) === null || we === void 0 ? void 0 : we.call(U)]) :
                        null])])
                }
        }
    });
const Child = DrawerChild;

function setStyle(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        H = C.element,
        W = H === void 0 ? document.body : H,
        U = {},
        G = Object.keys(K);
    return G.forEach(function (X) {
        U[X] = W.style[X]
    }), G.forEach(function (X) {
        W.style[X] = K[X]
    }), U
}

function isBodyOverflowing() {
    return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth >
        document.body.offsetWidth
}
var cacheStyle$1 = {};
const switchScrollingEffect = function (K) {
    if (!(!isBodyOverflowing() && !K)) {
        var C = "ant-scrolling-effect",
            H = new RegExp("".concat(C), "g"),
            W = document.body.className;
        if (K) {
            if (!H.test(W)) return;
            setStyle(cacheStyle$1), cacheStyle$1 = {}, document.body.className = W.replace(H, "").trim();
            return
        }
        var U = getScrollBarSize();
        if (U && (cacheStyle$1 = setStyle({
                position: "relative",
                width: "calc(100% - ".concat(U, "px)")
            }), !H.test(W))) {
            var G = "".concat(W, " ").concat(C);
            document.body.className = G.trim()
        }
    }
};
var locks = [],
    scrollingEffectClassName = "ant-scrolling-effect",
    scrollingEffectClassNameReg = new RegExp("".concat(scrollingEffectClassName), "g"),
    uuid$2 = 0,
    cacheStyle = new Map,
    ScrollLocker = _createClass(function K(C) {
        var H = this;
        _classCallCheck(this, K), _defineProperty$V(this, "getContainer", function () {
            var W;
            return (W = H.options) === null || W === void 0 ? void 0 : W.container
        }), _defineProperty$V(this, "reLock", function (W) {
            var U = locks.find(function (G) {
                var X = G.target;
                return X === H.lockTarget
            });
            U && H.unLock(), H.options = W, U && (U.options = W, H.lock())
        }), _defineProperty$V(this, "lock", function () {
            var W;
            if (!locks.some(function (Q) {
                    var ee = Q.target;
                    return ee === H.lockTarget
                })) {
                if (locks.some(function (Q) {
                        var ee, ne = Q.options;
                        return (ne == null ? void 0 : ne.container) === ((ee = H.options) === null ||
                            ee === void 0 ? void 0 : ee.container)
                    })) {
                    locks = [].concat(_toConsumableArray(locks), [{
                        target: H.lockTarget,
                        options: H.options
                    }]);
                    return
                }
                var U = 0,
                    G = ((W = H.options) === null || W === void 0 ? void 0 : W.container) || document.body;
                (G === document.body && window.innerWidth - document.documentElement.clientWidth > 0 || G.scrollHeight >
                    G.clientHeight) && (U = getScrollBarSize());
                var X = G.className;
                if (locks.filter(function (Q) {
                        var ee, ne = Q.options;
                        return (ne == null ? void 0 : ne.container) === ((ee = H.options) === null ||
                            ee === void 0 ? void 0 : ee.container)
                    }).length === 0 && cacheStyle.set(G, setStyle({
                        width: U !== 0 ? "calc(100% - ".concat(U, "px)") : void 0,
                        overflow: "hidden",
                        overflowX: "hidden",
                        overflowY: "hidden"
                    }, {
                        element: G
                    })), !scrollingEffectClassNameReg.test(X)) {
                    var Z = "".concat(X, " ").concat(scrollingEffectClassName);
                    G.className = Z.trim()
                }
                locks = [].concat(_toConsumableArray(locks), [{
                    target: H.lockTarget,
                    options: H.options
                }])
            }
        }), _defineProperty$V(this, "unLock", function () {
            var W, U = locks.find(function (Z) {
                var Q = Z.target;
                return Q === H.lockTarget
            });
            if (locks = locks.filter(function (Z) {
                    var Q = Z.target;
                    return Q !== H.lockTarget
                }), !(!U || locks.some(function (Z) {
                    var Q, ee = Z.options;
                    return (ee == null ? void 0 : ee.container) === ((Q = U.options) === null || Q ===
                        void 0 ? void 0 : Q.container)
                }))) {
                var G = ((W = H.options) === null || W === void 0 ? void 0 : W.container) || document.body,
                    X = G.className;
                scrollingEffectClassNameReg.test(X) && (setStyle(cacheStyle.get(G), {
                    element: G
                }), cacheStyle.delete(G), G.className = G.className.replace(
                    scrollingEffectClassNameReg, "").trim())
            }
        }), this.lockTarget = uuid$2++, this.options = C
    }),
    openCount = 0,
    supportDom = canUseDom(),
    cacheOverflow = {},
    getParent = function (C) {
        if (!supportDom) return null;
        if (C) {
            if (typeof C == "string") return document.querySelectorAll(C)[0];
            if (typeof C == "function") return C();
            if (_typeof$2(C) === "object" && C instanceof window.HTMLElement) return C
        }
        return document.body
    };
const Portal = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "PortalWrapper",
    inheritAttrs: !1,
    props: {
        wrapperClassName: String,
        forceRender: {
            type: Boolean,
            default: void 0
        },
        getContainer: PropTypes$1.any,
        visible: {
            type: Boolean,
            default: void 0
        }
    },
    setup: function (C, H) {
        var W = H.slots,
            U = ref(),
            G = ref(),
            X = ref(),
            Z = new ScrollLocker({
                container: getParent(C.getContainer)
            }),
            Q = function () {
                var ie, ue;
                (ie = U.value) === null || ie === void 0 || (ue = ie.parentNode) === null || ue === void 0 ||
                    ue.removeChild(U.value)
            },
            ee = function () {
                var ie = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
                if (ie || U.value && !U.value.parentNode) {
                    var ue = getParent(C.getContainer);
                    return ue ? (ue.appendChild(U.value), !0) : !1
                }
                return !0
            },
            ne = function () {
                return supportDom ? (U.value || (U.value = document.createElement("div"), ee(!0)), te(), U.value) :
                    null
            },
            te = function () {
                var ie = C.wrapperClassName;
                U.value && ie && ie !== U.value.className && (U.value.className = ie)
            };
        onUpdated(function () {
            te(), ee()
        });
        var re = function () {
                openCount === 1 && !Object.keys(cacheOverflow).length ? (switchScrollingEffect(),
                    cacheOverflow = setStyle({
                        overflow: "hidden",
                        overflowX: "hidden",
                        overflowY: "hidden"
                    })) : openCount || (setStyle(cacheOverflow), cacheOverflow = {},
                    switchScrollingEffect(!0))
            },
            ae = getCurrentInstance();
        return onMounted(function () {
                var oe = !1;
                watch([function () {
                    return C.visible
                }, function () {
                    return C.getContainer
                }], function (ie, ue) {
                    var le = _slicedToArray$2(ie, 2),
                        se = le[0],
                        ce = le[1],
                        de = _slicedToArray$2(ue, 2),
                        ve = de[0],
                        fe = de[1];
                    if (supportDom && getParent(C.getContainer) === document.body && (se && !ve ?
                            openCount += 1 : oe && (openCount -= 1)), oe) {
                        var pe = typeof ce == "function" && typeof fe == "function";
                        (pe ? ce.toString() !== fe.toString() : ce !== fe) && Q(), se && se !==
                            ve && supportDom && getParent(ce) !== Z.getContainer() && Z.reLock({
                                container: getParent(ce)
                            })
                    }
                    oe = !0
                }, {
                    immediate: !0,
                    flush: "post"
                }), nextTick(function () {
                    ee() || (X.value = wrapperRaf(function () {
                        ae.update()
                    }))
                })
            }), onBeforeUnmount(function () {
                var oe = C.visible,
                    ie = C.getContainer;
                supportDom && getParent(ie) === document.body && (openCount = oe && openCount ?
                    openCount - 1 : openCount), Q(), wrapperRaf.cancel(X.value)
            }),
            function () {
                var oe = C.forceRender,
                    ie = C.visible,
                    ue = null,
                    le = {
                        getOpenCount: function () {
                            return openCount
                        },
                        getContainer: ne,
                        switchScrollingEffect: re,
                        scrollLocker: Z
                    };
                return (oe || ie || G.value) && (ue = createVNode(Portal$1, {
                    getContainer: ne,
                    ref: G
                }, {
                    default: function () {
                        var ce;
                        return (ce = W.default) === null || ce === void 0 ? void 0 : ce.call(
                            W, le)
                    }
                })), ue
            }
    }
});
var _excluded$z = ["afterVisibleChange", "getContainer", "wrapperClassName", "forceRender"],
    _excluded2$4 = ["visible", "afterClose"],
    DrawerWrapper = defineComponent({
        compatConfig: {
            MODE: 3
        },
        inheritAttrs: !1,
        props: initDefaultProps$1(drawerProps$1(), {
            prefixCls: "drawer",
            placement: "left",
            getContainer: "body",
            level: "all",
            duration: ".3s",
            ease: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
            afterVisibleChange: function () {},
            showMask: !0,
            maskClosable: !0,
            maskStyle: {},
            wrapperClassName: "",
            keyboard: !0,
            forceRender: !1,
            autofocus: !0
        }),
        emits: ["handleClick", "close"],
        slots: ["handler"],
        setup: function (C, H) {
            var W = H.emit,
                U = H.slots,
                G = ref(null),
                X = function (ee) {
                    W("handleClick", ee)
                },
                Z = function (ee) {
                    W("close", ee)
                };
            return function () {
                C.afterVisibleChange;
                var Q = C.getContainer,
                    ee = C.wrapperClassName,
                    ne = C.forceRender,
                    te = _objectWithoutProperties$2(C, _excluded$z),
                    re = null;
                if (!Q) return createVNode("div", {
                    class: ee,
                    ref: G
                }, [createVNode(Child, _objectSpread2$1(_objectSpread2$1({}, te), {}, {
                    open: C.open,
                    getContainer: function () {
                        return G.value
                    },
                    onClose: Z,
                    onHandleClick: X
                }), U)]);
                var ae = !!U.handler || ne;
                return (ae || C.open || G.value) && (re = createVNode(Portal, {
                    visible: C.open,
                    forceRender: ae,
                    getContainer: Q,
                    wrapperClassName: ee
                }, {
                    default: function (ie) {
                        var ue = ie.visible,
                            le = ie.afterClose,
                            se = _objectWithoutProperties$2(ie, _excluded2$4);
                        return createVNode(Child, _objectSpread2$1(_objectSpread2$1(
                            _objectSpread2$1({
                                ref: G
                            }, te), se), {}, {
                            open: ue !== void 0 ? ue : C.open,
                            afterVisibleChange: le !== void 0 ? le : C.afterVisibleChange,
                            onClose: Z,
                            onHandleClick: X
                        }), U)
                    }
                })), re
            }
        }
    });
const Drawer$1 = DrawerWrapper;
var _excluded$y = ["width", "height", "visible", "placement", "mask", "wrapClassName", "class"],
    PlacementTypes = tuple$1("top", "right", "bottom", "left");
tuple$1("default", "large");
var defaultPushState = {
        distance: 180
    },
    drawerProps = function () {
        return {
            autofocus: {
                type: Boolean,
                default: void 0
            },
            closable: {
                type: Boolean,
                default: void 0
            },
            closeIcon: PropTypes$1.any,
            destroyOnClose: {
                type: Boolean,
                default: void 0
            },
            forceRender: {
                type: Boolean,
                default: void 0
            },
            getContainer: PropTypes$1.any,
            maskClosable: {
                type: Boolean,
                default: void 0
            },
            mask: {
                type: Boolean,
                default: void 0
            },
            maskStyle: {
                type: Object,
                default: void 0
            },
            wrapStyle: {
                type: Object,
                default: void 0
            },
            style: {
                type: Object,
                default: void 0
            },
            class: PropTypes$1.any,
            wrapClassName: String,
            size: {
                type: String
            },
            drawerStyle: {
                type: Object,
                default: void 0
            },
            headerStyle: {
                type: Object,
                default: void 0
            },
            bodyStyle: {
                type: Object,
                default: void 0
            },
            contentWrapperStyle: {
                type: Object,
                default: void 0
            },
            title: PropTypes$1.any,
            visible: {
                type: Boolean,
                default: void 0
            },
            width: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number]),
            height: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number]),
            zIndex: Number,
            prefixCls: String,
            push: PropTypes$1.oneOfType([PropTypes$1.looseBool, {
                type: Object
            }]),
            placement: PropTypes$1.oneOf(PlacementTypes),
            keyboard: {
                type: Boolean,
                default: void 0
            },
            extra: PropTypes$1.any,
            footer: PropTypes$1.any,
            footerStyle: {
                type: Object,
                default: void 0
            },
            level: PropTypes$1.any,
            levelMove: {
                type: [Number, Array, Function]
            },
            handle: PropTypes$1.any,
            afterVisibleChange: Function,
            onAfterVisibleChange: Function,
            "onUpdate:visible": Function,
            onClose: Function
        }
    },
    Drawer = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ADrawer",
        inheritAttrs: !1,
        props: initDefaultProps$1(drawerProps(), {
            closable: !0,
            placement: "right",
            maskClosable: !0,
            mask: !0,
            level: null,
            keyboard: !0,
            push: defaultPushState
        }),
        slots: ["closeIcon", "title", "extra", "footer", "handle"],
        setup: function (C, H) {
            var W = H.emit,
                U = H.slots,
                G = H.attrs,
                X = ref(!1),
                Z = ref(!1),
                Q = ref(null),
                ee = inject("parentDrawerOpts", null),
                ne = useConfigInject("drawer", C),
                te = ne.prefixCls;
            devWarning(!C.afterVisibleChange, "Drawer",
                    "`afterVisibleChange` prop is deprecated, please use `@afterVisibleChange` event instead"),
                devWarning(C.wrapStyle === void 0, "Drawer",
                    "`wrapStyle` prop is deprecated, please use `style` instead"), devWarning(C.wrapClassName ===
                    void 0, "Drawer", "`wrapClassName` prop is deprecated, please use `class` instead");
            var re = function () {
                    X.value = !0
                },
                ae = function () {
                    X.value = !1, nextTick(function () {
                        oe()
                    })
                };
            provide("parentDrawerOpts", {
                setPush: re,
                setPull: ae
            }), onMounted(function () {
                var Se = C.visible;
                Se && ee && ee.setPush()
            }), onUnmounted(function () {
                ee && ee.setPull()
            }), watch(function () {
                return C.visible
            }, function (Se) {
                ee && (Se ? ee.setPush() : ee.setPull())
            }, {
                flush: "post"
            });
            var oe = function () {
                    var _e, be;
                    (_e = Q.value) === null || _e === void 0 || (be = _e.domFocus) === null || be === void 0 ||
                        be.call(_e)
                },
                ie = function (_e) {
                    W("update:visible", !1), W("close", _e)
                },
                ue = function (_e) {
                    var be;
                    (be = C.afterVisibleChange) === null || be === void 0 || be.call(C, _e), W(
                        "afterVisibleChange", _e)
                },
                le = computed(function () {
                    return C.destroyOnClose && !C.visible
                }),
                se = function () {
                    var _e = le.value;
                    _e && (C.visible || (Z.value = !0))
                },
                ce = computed(function () {
                    var Se = C.push,
                        _e = C.placement,
                        be;
                    return typeof Se == "boolean" ? be = Se ? defaultPushState.distance : 0 : be = Se.distance,
                        be = parseFloat(String(be || 0)), _e === "left" || _e === "right" ? "translateX(".concat(
                            _e === "left" ? be : -be, "px)") : _e === "top" || _e === "bottom" ?
                        "translateY(".concat(_e === "top" ? be : -be, "px)") : null
                }),
                de = computed(function () {
                    var Se = C.visible,
                        _e = C.mask,
                        be = C.placement,
                        ge = C.size,
                        xe = ge === void 0 ? "default" : ge,
                        Pe = C.width,
                        $e = C.height;
                    if (!Se && !_e) return {};
                    var ye = {};
                    if (be === "left" || be === "right") {
                        var Ce = xe === "large" ? 736 : 378;
                        ye.width = typeof Pe > "u" ? Ce : Pe, ye.width = typeof ye.width == "string" ? ye.width :
                            "".concat(ye.width, "px")
                    } else {
                        var we = xe === "large" ? 736 : 378;
                        ye.height = typeof $e > "u" ? we : $e, ye.height = typeof ye.height == "string" ?
                            ye.height : "".concat(ye.height, "px")
                    }
                    return ye
                }),
                ve = computed(function () {
                    var Se = C.zIndex,
                        _e = C.wrapStyle,
                        be = C.mask,
                        ge = C.style,
                        xe = be ? {} : de.value;
                    return _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                        zIndex: Se,
                        transform: X.value ? ce.value : void 0
                    }, xe), _e), ge)
                }),
                fe = function (_e) {
                    var be = C.closable,
                        ge = C.headerStyle,
                        xe = getPropsSlot(U, C, "extra"),
                        Pe = getPropsSlot(U, C, "title");
                    return !Pe && !be ? null : createVNode("div", {
                        class: classNames("".concat(_e, "-header"), _defineProperty$V({}, "".concat(_e,
                            "-header-close-only"), be && !Pe && !xe)),
                        style: ge
                    }, [createVNode("div", {
                        class: "".concat(_e, "-header-title")
                    }, [pe(_e), Pe && createVNode("div", {
                        class: "".concat(_e, "-title")
                    }, [Pe])]), xe && createVNode("div", {
                        class: "".concat(_e, "-extra")
                    }, [xe])])
                },
                pe = function (_e) {
                    var be, ge = C.closable,
                        xe = U.closeIcon ? (be = U.closeIcon) === null || be === void 0 ? void 0 : be.call(U) :
                        C.closeIcon;
                    return ge && createVNode("button", {
                        key: "closer",
                        onClick: ie,
                        "aria-label": "Close",
                        class: "".concat(_e, "-close")
                    }, [xe === void 0 ? createVNode(CloseOutlined$1, null, null) : xe])
                },
                me = function (_e) {
                    var be;
                    if (Z.value && !C.visible) return null;
                    Z.value = !1;
                    var ge = C.bodyStyle,
                        xe = C.drawerStyle,
                        Pe = {},
                        $e = le.value;
                    return $e && (Pe.opacity = 0, Pe.transition = "opacity .3s"), createVNode("div", {
                        class: "".concat(_e, "-wrapper-body"),
                        style: _objectSpread2$1(_objectSpread2$1({}, Pe), xe),
                        onTransitionend: se
                    }, [fe(_e), createVNode("div", {
                        key: "body",
                        class: "".concat(_e, "-body"),
                        style: ge
                    }, [(be = U.default) === null || be === void 0 ? void 0 : be.call(U)]), he(_e)])
                },
                he = function (_e) {
                    var be = getPropsSlot(U, C, "footer");
                    if (!be) return null;
                    var ge = "".concat(_e, "-footer");
                    return createVNode("div", {
                        class: ge,
                        style: C.footerStyle
                    }, [be])
                };
            return function () {
                var Se;
                C.width, C.height;
                var _e = C.visible,
                    be = C.placement,
                    ge = C.mask,
                    xe = C.wrapClassName,
                    Pe = C.class,
                    $e = _objectWithoutProperties$2(C, _excluded$y),
                    ye = ge ? de.value : {},
                    Ce = ge ? "" : "no-mask",
                    we = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, G), omit$2(
                        $e, ["size", "closeIcon", "closable", "destroyOnClose", "drawerStyle",
                            "headerStyle", "bodyStyle", "title", "push", "wrapStyle",
                            "onAfterVisibleChange", "onClose", "onUpdate:visible"])), ye), {}, {
                        onClose: ie,
                        afterVisibleChange: ue,
                        handler: !1,
                        prefixCls: te.value,
                        open: _e,
                        showMask: ge,
                        placement: be,
                        class: classNames((Se = {}, _defineProperty$V(Se, Pe, Pe), _defineProperty$V(Se,
                            xe, !!xe), _defineProperty$V(Se, Ce, !!Ce), Se)),
                        style: ve.value,
                        ref: Q
                    });
                return createVNode(Drawer$1, we, {
                    handler: C.handle ? function () {
                        return C.handle
                    } : U.handle,
                    default: function () {
                        return me(te.value)
                    }
                })
            }
        }
    });
const index$e = withInstall(Drawer);
var inputProps = function () {
    return {
        id: String,
        prefixCls: String,
        inputPrefixCls: String,
        defaultValue: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number]),
        value: {
            type: [String, Number, Symbol],
            default: void 0
        },
        placeholder: {
            type: [String, Number]
        },
        autocomplete: String,
        type: {
            type: String,
            default: "text"
        },
        name: String,
        size: {
            type: String
        },
        disabled: {
            type: Boolean,
            default: void 0
        },
        readonly: {
            type: Boolean,
            default: void 0
        },
        addonBefore: PropTypes$1.any,
        addonAfter: PropTypes$1.any,
        prefix: PropTypes$1.any,
        suffix: PropTypes$1.any,
        autofocus: {
            type: Boolean,
            default: void 0
        },
        allowClear: {
            type: Boolean,
            default: void 0
        },
        lazy: {
            type: Boolean,
            default: !0
        },
        maxlength: Number,
        loading: {
            type: Boolean,
            default: void 0
        },
        bordered: {
            type: Boolean,
            default: void 0
        },
        showCount: {
            type: [Boolean, Object]
        },
        htmlSize: Number,
        onPressEnter: Function,
        onKeydown: Function,
        onKeyup: Function,
        onFocus: Function,
        onBlur: Function,
        onChange: Function,
        onInput: Function,
        "onUpdate:value": Function,
        valueModifiers: Object,
        hidden: Boolean
    }
};
const inputProps$1 = inputProps;
var textAreaProps = function () {
    return _objectSpread2$1(_objectSpread2$1({}, omit$2(inputProps(), ["prefix", "addonBefore", "addonAfter",
        "suffix"])), {}, {
        rows: Number,
        autosize: {
            type: [Boolean, Object],
            default: void 0
        },
        autoSize: {
            type: [Boolean, Object],
            default: void 0
        },
        onResize: {
            type: Function
        },
        onCompositionstart: Function,
        onCompositionend: Function,
        valueModifiers: Object
    })
};

function getInputClassName(K, C, H, W, U) {
    var G;
    return classNames(K, (G = {}, _defineProperty$V(G, "".concat(K, "-sm"), H === "small"), _defineProperty$V(G, "".concat(
        K, "-lg"), H === "large"), _defineProperty$V(G, "".concat(K, "-disabled"), W), _defineProperty$V(G,
        "".concat(K, "-rtl"), U === "rtl"), _defineProperty$V(G, "".concat(K, "-borderless"), !C), G))
}
var isValid$3 = function (C) {
    return C != null && (Array.isArray(C) ? filterEmpty(C).length : !0)
};

function hasPrefixSuffix(K) {
    return isValid$3(K.prefix) || isValid$3(K.suffix) || isValid$3(K.allowClear)
}

function hasAddon(K) {
    return isValid$3(K.addonBefore) || isValid$3(K.addonAfter)
}
var ClearableInputType = ["text", "input"];
const ClearableLabeledInput = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ClearableLabeledInput",
    inheritAttrs: !1,
    props: {
        prefixCls: String,
        inputType: PropTypes$1.oneOf(tuple$1("text", "input")),
        value: PropTypes$1.any,
        defaultValue: PropTypes$1.any,
        allowClear: {
            type: Boolean,
            default: void 0
        },
        element: PropTypes$1.any,
        handleReset: Function,
        disabled: {
            type: Boolean,
            default: void 0
        },
        direction: {
            type: String
        },
        size: {
            type: String
        },
        suffix: PropTypes$1.any,
        prefix: PropTypes$1.any,
        addonBefore: PropTypes$1.any,
        addonAfter: PropTypes$1.any,
        readonly: {
            type: Boolean,
            default: void 0
        },
        focused: {
            type: Boolean,
            default: void 0
        },
        bordered: {
            type: Boolean,
            default: !0
        },
        triggerFocus: {
            type: Function
        },
        hidden: Boolean
    },
    setup: function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = ref(),
            X = function (ae) {
                var oe;
                if ((oe = G.value) !== null && oe !== void 0 && oe.contains(ae.target)) {
                    var ie = C.triggerFocus;
                    ie == null || ie()
                }
            },
            Z = function (ae) {
                var oe, ie = C.allowClear,
                    ue = C.value,
                    le = C.disabled,
                    se = C.readonly,
                    ce = C.handleReset,
                    de = C.suffix,
                    ve = de === void 0 ? W.suffix : de;
                if (!ie) return null;
                var fe = !le && !se && ue,
                    pe = "".concat(ae, "-clear-icon");
                return createVNode(CloseCircleFilled$1, {
                    onClick: ce,
                    onMousedown: function (he) {
                        return he.preventDefault()
                    },
                    class: classNames((oe = {}, _defineProperty$V(oe, "".concat(pe, "-hidden"), !fe),
                        _defineProperty$V(oe, "".concat(pe, "-has-suffix"), !!ve), oe), pe),
                    role: "button"
                }, null)
            },
            Q = function (ae) {
                var oe, ie = C.suffix,
                    ue = ie === void 0 ? (oe = W.suffix) === null || oe === void 0 ? void 0 : oe.call(W) :
                    ie,
                    le = C.allowClear;
                return ue || le ? createVNode("span", {
                    class: "".concat(ae, "-suffix")
                }, [Z(ae), ue]) : null
            },
            ee = function (ae, oe) {
                var ie, ue, le, se = C.focused,
                    ce = C.value,
                    de = C.prefix,
                    ve = de === void 0 ? (ie = W.prefix) === null || ie === void 0 ? void 0 : ie.call(W) :
                    de,
                    fe = C.size,
                    pe = C.suffix,
                    me = pe === void 0 ? (ue = W.suffix) === null || ue === void 0 ? void 0 : ue.call(W) :
                    pe,
                    he = C.disabled,
                    Se = C.allowClear,
                    _e = C.direction,
                    be = C.readonly,
                    ge = C.bordered,
                    xe = C.hidden,
                    Pe = C.addonAfter,
                    $e = Pe === void 0 ? W.addonAfter : Pe,
                    ye = C.addonBefore,
                    Ce = ye === void 0 ? W.addonBefore : ye,
                    we = Q(ae);
                if (!hasPrefixSuffix({
                        prefix: ve,
                        suffix: me,
                        allowClear: Se
                    })) return cloneElement(oe, {
                    value: ce
                });
                var Oe = ve ? createVNode("span", {
                        class: "".concat(ae, "-prefix")
                    }, [ve]) : null,
                    Ne = classNames("".concat(ae, "-affix-wrapper"), (le = {}, _defineProperty$V(le, "".concat(
                        ae, "-affix-wrapper-focused"), se), _defineProperty$V(le, "".concat(ae,
                        "-affix-wrapper-disabled"), he), _defineProperty$V(le, "".concat(ae,
                        "-affix-wrapper-sm"), fe === "small"), _defineProperty$V(le, "".concat(ae,
                        "-affix-wrapper-lg"), fe === "large"), _defineProperty$V(le, "".concat(ae,
                        "-affix-wrapper-input-with-clear-btn"), me && Se && ce), _defineProperty$V(
                        le, "".concat(ae, "-affix-wrapper-rtl"), _e === "rtl"), _defineProperty$V(
                        le, "".concat(ae, "-affix-wrapper-readonly"), be), _defineProperty$V(le, ""
                        .concat(ae, "-affix-wrapper-borderless"), !ge), _defineProperty$V(le, "".concat(
                        U.class), !hasAddon({
                        addonAfter: $e,
                        addonBefore: Ce
                    }) && U.class), le));
                return createVNode("span", {
                    ref: G,
                    class: Ne,
                    style: U.style,
                    onMouseup: X,
                    hidden: xe
                }, [Oe, cloneElement(oe, {
                    style: null,
                    value: ce,
                    class: getInputClassName(ae, ge, fe, he)
                }), we])
            },
            ne = function (ae, oe) {
                var ie, ue, le, se = C.addonBefore,
                    ce = se === void 0 ? (ie = W.addonBefore) === null || ie === void 0 ? void 0 : ie.call(
                        W) : se,
                    de = C.addonAfter,
                    ve = de === void 0 ? (ue = W.addonAfter) === null || ue === void 0 ? void 0 : ue.call(W) :
                    de,
                    fe = C.size,
                    pe = C.direction,
                    me = C.hidden;
                if (!hasAddon({
                        addonBefore: ce,
                        addonAfter: ve
                    })) return oe;
                var he = "".concat(ae, "-group"),
                    Se = "".concat(he, "-addon"),
                    _e = ce ? createVNode("span", {
                        class: Se
                    }, [ce]) : null,
                    be = ve ? createVNode("span", {
                        class: Se
                    }, [ve]) : null,
                    ge = classNames("".concat(ae, "-wrapper"), he, _defineProperty$V({}, "".concat(he,
                        "-rtl"), pe === "rtl")),
                    xe = classNames("".concat(ae, "-group-wrapper"), (le = {}, _defineProperty$V(le, "".concat(
                        ae, "-group-wrapper-sm"), fe === "small"), _defineProperty$V(le, "".concat(
                        ae, "-group-wrapper-lg"), fe === "large"), _defineProperty$V(le, "".concat(
                        ae, "-group-wrapper-rtl"), pe === "rtl"), le), U.class);
                return createVNode("span", {
                    class: xe,
                    style: U.style,
                    hidden: me
                }, [createVNode("span", {
                    class: ge
                }, [_e, cloneElement(oe, {
                    style: null
                }), be])])
            },
            te = function (ae, oe) {
                var ie, ue = C.value,
                    le = C.allowClear,
                    se = C.direction,
                    ce = C.bordered,
                    de = C.hidden,
                    ve = C.addonAfter,
                    fe = ve === void 0 ? W.addonAfter : ve,
                    pe = C.addonBefore,
                    me = pe === void 0 ? W.addonBefore : pe;
                if (!le) return cloneElement(oe, {
                    value: ue
                });
                var he = classNames("".concat(ae, "-affix-wrapper"), "".concat(ae,
                    "-affix-wrapper-textarea-with-clear-btn"), (ie = {}, _defineProperty$V(ie, "".concat(
                    ae, "-affix-wrapper-rtl"), se === "rtl"), _defineProperty$V(ie, "".concat(
                    ae, "-affix-wrapper-borderless"), !ce), _defineProperty$V(ie, "".concat(U.class),
                    !hasAddon({
                        addonAfter: fe,
                        addonBefore: me
                    }) && U.class), ie));
                return createVNode("span", {
                    class: he,
                    style: U.style,
                    hidden: de
                }, [cloneElement(oe, {
                    style: null,
                    value: ue
                }), Z(ae)])
            };
        return function () {
            var re, ae = C.prefixCls,
                oe = C.inputType,
                ie = C.element,
                ue = ie === void 0 ? (re = W.element) === null || re === void 0 ? void 0 : re.call(W) :
                ie;
            return oe === ClearableInputType[0] ? te(ae, ue) : ne(ae, ee(ae, ue))
        }
    }
});

function fixControlledValue(K) {
    return typeof K > "u" || K === null ? "" : String(K)
}

function resolveOnChange(K, C, H, W) {
    if (H) {
        var U = C;
        if (C.type === "click") {
            Object.defineProperty(U, "target", {
                writable: !0
            }), Object.defineProperty(U, "currentTarget", {
                writable: !0
            });
            var G = K.cloneNode(!0);
            U.target = G, U.currentTarget = G, G.value = "", H(U);
            return
        }
        if (W !== void 0) {
            Object.defineProperty(U, "target", {
                writable: !0
            }), Object.defineProperty(U, "currentTarget", {
                writable: !0
            }), U.target = K, U.currentTarget = K, K.value = W, H(U);
            return
        }
        H(U)
    }
}

function triggerFocus(K, C) {
    if (K) {
        K.focus(C);
        var H = C || {},
            W = H.cursor;
        if (W) {
            var U = K.value.length;
            switch (W) {
                case "start":
                    K.setSelectionRange(0, 0);
                    break;
                case "end":
                    K.setSelectionRange(U, U);
                    break;
                default:
                    K.setSelectionRange(0, U)
            }
        }
    }
}
const Input = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "AInput",
        inheritAttrs: !1,
        props: inputProps$1(),
        setup: function (C, H) {
            var W = H.slots,
                U = H.attrs,
                G = H.expose,
                X = H.emit,
                Z = ref(),
                Q = ref(),
                ee, ne = useInjectFormItemContext(),
                te = useConfigInject("input", C),
                re = te.direction,
                ae = te.prefixCls,
                oe = te.size,
                ie = te.autocomplete,
                ue = ref(C.value === void 0 ? C.defaultValue : C.value),
                le = ref(!1);
            watch(function () {
                return C.value
            }, function () {
                ue.value = C.value
            }), watch(function () {
                return C.disabled
            }, function () {
                C.value !== void 0 && (ue.value = C.value), C.disabled && (le.value = !1)
            });
            var se = function () {
                    ee = setTimeout(function () {
                        var Ce;
                        ((Ce = Z.value) === null || Ce === void 0 ? void 0 : Ce.getAttribute("type")) ===
                        "password" && Z.value.hasAttribute("value") && Z.value.removeAttribute("value")
                    })
                },
                ce = function (Ce) {
                    triggerFocus(Z.value, Ce)
                },
                de = function () {
                    var Ce;
                    (Ce = Z.value) === null || Ce === void 0 || Ce.blur()
                },
                ve = function (Ce, we, Oe) {
                    var Ne;
                    (Ne = Z.value) === null || Ne === void 0 || Ne.setSelectionRange(Ce, we, Oe)
                },
                fe = function () {
                    var Ce;
                    (Ce = Z.value) === null || Ce === void 0 || Ce.select()
                };
            G({
                focus: ce,
                blur: de,
                input: Z,
                stateValue: ue,
                setSelectionRange: ve,
                select: fe
            });
            var pe = function (Ce) {
                    var we = C.onFocus;
                    le.value = !0, we == null || we(Ce), nextTick(function () {
                        se()
                    })
                },
                me = function (Ce) {
                    var we = C.onBlur;
                    le.value = !1, we == null || we(Ce), ne.onFieldBlur(), nextTick(function () {
                        se()
                    })
                },
                he = function (Ce) {
                    X("update:value", Ce.target.value), X("change", Ce), X("input", Ce), ne.onFieldChange()
                },
                Se = getCurrentInstance(),
                _e = function (Ce, we) {
                    ue.value !== Ce && (C.value === void 0 ? ue.value = Ce : nextTick(function () {
                        Z.value.value !== ue.value && Se.update()
                    }), nextTick(function () {
                        we && we()
                    }))
                },
                be = function (Ce) {
                    resolveOnChange(Z.value, Ce, he), _e("", function () {
                        ce()
                    })
                },
                ge = function (Ce) {
                    var we = Ce.target,
                        Oe = we.value,
                        Ne = we.composing;
                    if (!((Ce.isComposing || Ne) && C.lazy || ue.value === Oe)) {
                        var Me = Ce.target.value;
                        resolveOnChange(Z.value, Ce, he), _e(Me, function () {
                            se()
                        })
                    }
                },
                xe = function (Ce) {
                    Ce.keyCode === 13 && X("pressEnter", Ce), X("keydown", Ce)
                };
            onMounted(function () {
                se()
            }), onBeforeUnmount(function () {
                clearTimeout(ee)
            });
            var Pe = function () {
                    var Ce, we = C.addonBefore,
                        Oe = we === void 0 ? W.addonBefore : we,
                        Ne = C.addonAfter,
                        Me = Ne === void 0 ? W.addonAfter : Ne,
                        Ve = C.disabled,
                        ke = C.bordered,
                        Ee = ke === void 0 ? !0 : ke,
                        Ae = C.valueModifiers,
                        Re = Ae === void 0 ? {} : Ae,
                        He = C.htmlSize,
                        je = omit$2(C, ["prefixCls", "onPressEnter", "addonBefore", "addonAfter", "prefix",
                            "suffix", "allowClear", "defaultValue", "size", "bordered", "htmlSize", "lazy",
                            "showCount", "valueModifiers"]),
                        Fe = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, je), U), {}, {
                            autocomplete: ie.value,
                            onChange: ge,
                            onInput: ge,
                            onFocus: pe,
                            onBlur: me,
                            onKeydown: xe,
                            class: classNames(getInputClassName(ae.value, Ee, oe.value, Ve, re.value),
                                _defineProperty$V({}, U.class, U.class && !Oe && !Me)),
                            ref: Z,
                            key: "ant-input",
                            size: He,
                            id: (Ce = je.id) !== null && Ce !== void 0 ? Ce : ne.id.value
                        });
                    Re.lazy && delete Fe.onInput, Fe.autofocus || delete Fe.autofocus;
                    var Le = createVNode("input", omit$2(Fe, ["size"]), null);
                    return withDirectives(Le, [[antInputDirective]])
                },
                $e = function () {
                    var Ce, we = ue.value,
                        Oe = C.maxlength,
                        Ne = C.suffix,
                        Me = Ne === void 0 ? (Ce = W.suffix) === null || Ce === void 0 ? void 0 : Ce.call(W) :
                        Ne,
                        Ve = C.showCount,
                        ke = Number(Oe) > 0;
                    if (Me || Ve) {
                        var Ee = _toConsumableArray(fixControlledValue(we)).length,
                            Ae = null;
                        return _typeof$2(Ve) === "object" ? Ae = Ve.formatter({
                            count: Ee,
                            maxlength: Oe
                        }) : Ae = "".concat(Ee).concat(ke ? " / ".concat(Oe) : ""), createVNode(Fragment,
                            null, [!!Ve && createVNode("span", {
                                class: classNames("".concat(ae.value, "-show-count-suffix"),
                                    _defineProperty$V({}, "".concat(ae.value,
                                        "-show-count-has-suffix"), !!Me))
                            }, [Ae]), Me])
                    }
                    return null
                };
            return function () {
                var ye = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, U), C), {}, {
                    prefixCls: ae.value,
                    inputType: "input",
                    value: fixControlledValue(ue.value),
                    handleReset: be,
                    focused: le.value && !C.disabled
                });
                return createVNode(ClearableLabeledInput, _objectSpread2$1(_objectSpread2$1({}, omit$2(ye,
                    ["element", "valueModifiers", "suffix", "showCount"])), {}, {
                    ref: Q
                }), _objectSpread2$1(_objectSpread2$1({}, W), {}, {
                    element: Pe,
                    suffix: $e
                }))
            }
        }
    }),
    Group$1 = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "AInputGroup",
        props: {
            prefixCls: String,
            size: {
                type: String
            },
            compact: {
                type: Boolean,
                default: void 0
            },
            onMouseenter: {
                type: Function
            },
            onMouseleave: {
                type: Function
            },
            onFocus: {
                type: Function
            },
            onBlur: {
                type: Function
            }
        },
        setup: function (C, H) {
            var W = H.slots,
                U = useConfigInject("input-group", C),
                G = U.prefixCls,
                X = U.direction,
                Z = computed(function () {
                    var Q, ee = G.value;
                    return Q = {}, _defineProperty$V(Q, "".concat(ee), !0), _defineProperty$V(Q, "".concat(
                            ee, "-lg"), C.size === "large"), _defineProperty$V(Q, "".concat(ee, "-sm"), C.size ===
                            "small"), _defineProperty$V(Q, "".concat(ee, "-compact"), C.compact),
                        _defineProperty$V(Q, "".concat(ee, "-rtl"), X.value === "rtl"), Q
                });
            return function () {
                var Q;
                return createVNode("span", {
                    class: Z.value,
                    onMouseenter: C.onMouseenter,
                    onMouseleave: C.onMouseleave,
                    onFocus: C.onFocus,
                    onBlur: C.onBlur
                }, [(Q = W.default) === null || Q === void 0 ? void 0 : Q.call(W)])
            }
        }
    });
var applePhone = /iPhone/i,
    appleIpod = /iPod/i,
    appleTablet = /iPad/i,
    androidPhone = /\bAndroid(?:.+)Mobile\b/i,
    androidTablet = /Android/i,
    amazonPhone = /\bAndroid(?:.+)SD4930UR\b/i,
    amazonTablet = /\bAndroid(?:.+)(?:KF[A-Z]{2,4})\b/i,
    windowsPhone = /Windows Phone/i,
    windowsTablet = /\bWindows(?:.+)ARM\b/i,
    otherBlackberry = /BlackBerry/i,
    otherBlackberry10 = /BB10/i,
    otherOpera = /Opera Mini/i,
    otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i,
    otherFirefox = /Mobile(?:.+)Firefox\b/i;

function match(K, C) {
    return K.test(C)
}

function isMobile(K) {
    var C = K || (typeof navigator < "u" ? navigator.userAgent : ""),
        H = C.split("[FBAN");
    if (typeof H[1] < "u") {
        var W = H,
            U = _slicedToArray$2(W, 1);
        C = U[0]
    }
    if (H = C.split("Twitter"), typeof H[1] < "u") {
        var G = H,
            X = _slicedToArray$2(G, 1);
        C = X[0]
    }
    var Z = {
        apple: {
            phone: match(applePhone, C) && !match(windowsPhone, C),
            ipod: match(appleIpod, C),
            tablet: !match(applePhone, C) && match(appleTablet, C) && !match(windowsPhone, C),
            device: (match(applePhone, C) || match(appleIpod, C) || match(appleTablet, C)) && !match(windowsPhone,
                C)
        },
        amazon: {
            phone: match(amazonPhone, C),
            tablet: !match(amazonPhone, C) && match(amazonTablet, C),
            device: match(amazonPhone, C) || match(amazonTablet, C)
        },
        android: {
            phone: !match(windowsPhone, C) && match(amazonPhone, C) || !match(windowsPhone, C) && match(
                androidPhone, C),
            tablet: !match(windowsPhone, C) && !match(amazonPhone, C) && !match(androidPhone, C) && (match(
                amazonTablet, C) || match(androidTablet, C)),
            device: !match(windowsPhone, C) && (match(amazonPhone, C) || match(amazonTablet, C) || match(
                androidPhone, C) || match(androidTablet, C)) || match(/\bokhttp\b/i, C)
        },
        windows: {
            phone: match(windowsPhone, C),
            tablet: match(windowsTablet, C),
            device: match(windowsPhone, C) || match(windowsTablet, C)
        },
        other: {
            blackberry: match(otherBlackberry, C),
            blackberry10: match(otherBlackberry10, C),
            opera: match(otherOpera, C),
            firefox: match(otherFirefox, C),
            chrome: match(otherChrome, C),
            device: match(otherBlackberry, C) || match(otherBlackberry10, C) || match(otherOpera, C) || match(
                otherFirefox, C) || match(otherChrome, C)
        },
        any: null,
        phone: null,
        tablet: null
    };
    return Z.any = Z.apple.device || Z.android.device || Z.windows.device || Z.other.device, Z.phone = Z.apple.phone ||
        Z.android.phone || Z.windows.phone, Z.tablet = Z.apple.tablet || Z.android.tablet || Z.windows.tablet, Z
}
var defaultResult = _objectSpread2$1(_objectSpread2$1({}, isMobile()), {}, {
    isMobile
});
const isMobile$1 = defaultResult;
var _excluded$x = ["disabled", "loading", "addonAfter", "suffix"];
const Search$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AInputSearch",
    inheritAttrs: !1,
    props: _objectSpread2$1(_objectSpread2$1({}, inputProps$1()), {}, {
        inputPrefixCls: String,
        enterButton: PropTypes$1.any,
        onSearch: {
            type: Function
        }
    }),
    setup: function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = H.expose,
            X = H.emit,
            Z = ref(),
            Q = function () {
                var de;
                (de = Z.value) === null || de === void 0 || de.focus()
            },
            ee = function () {
                var de;
                (de = Z.value) === null || de === void 0 || de.blur()
            };
        G({
            focus: Q,
            blur: ee
        });
        var ne = function (de) {
                X("update:value", de.target.value), de && de.target && de.type === "click" && X("search",
                    de.target.value, de), X("change", de)
            },
            te = function (de) {
                var ve;
                document.activeElement === ((ve = Z.value) === null || ve === void 0 ? void 0 : ve.input) &&
                    de.preventDefault()
            },
            re = function (de) {
                var ve;
                X("search", (ve = Z.value) === null || ve === void 0 ? void 0 : ve.stateValue, de),
                    isMobile$1.tablet || Z.value.focus()
            },
            ae = useConfigInject("input-search", C),
            oe = ae.prefixCls,
            ie = ae.getPrefixCls,
            ue = ae.direction,
            le = ae.size,
            se = computed(function () {
                return ie("input", C.inputPrefixCls)
            });
        return function () {
            var ce, de, ve, fe, pe, me = C.disabled,
                he = C.loading,
                Se = C.addonAfter,
                _e = Se === void 0 ? (ce = W.addonAfter) === null || ce === void 0 ? void 0 : ce.call(W) :
                Se,
                be = C.suffix,
                ge = be === void 0 ? (de = W.suffix) === null || de === void 0 ? void 0 : de.call(W) :
                be,
                xe = _objectWithoutProperties$2(C, _excluded$x),
                Pe = C.enterButton,
                $e = Pe === void 0 ? (ve = (fe = W.enterButton) === null || fe === void 0 ? void 0 : fe
                    .call(W)) !== null && ve !== void 0 ? ve : !1 : Pe;
            $e = $e || $e === "";
            var ye = typeof $e == "boolean" ? createVNode(SearchOutlined$1, null, null) : null,
                Ce = "".concat(oe.value, "-button"),
                we = Array.isArray($e) ? $e[0] : $e,
                Oe, Ne = we.type && isPlainObject(we.type) && we.type.__ANT_BUTTON;
            if (Ne || we.tagName === "button") Oe = cloneElement(we, _objectSpread2$1({
                onMousedown: te,
                onClick: re,
                key: "enterButton"
            }, Ne ? {
                class: Ce,
                size: le.value
            } : {}), !1);
            else {
                var Me = ye && !$e;
                Oe = createVNode(Button$1, {
                    class: Ce,
                    type: $e ? "primary" : void 0,
                    size: le.value,
                    disabled: me,
                    key: "enterButton",
                    onMousedown: te,
                    onClick: re,
                    loading: he,
                    icon: Me ? ye : null
                }, {
                    default: function () {
                        return [Me ? null : ye || $e]
                    }
                })
            }
            _e && (Oe = [Oe, _e]);
            var Ve = classNames(oe.value, (pe = {}, _defineProperty$V(pe, "".concat(oe.value, "-rtl"),
                ue.value === "rtl"), _defineProperty$V(pe, "".concat(oe.value, "-").concat(
                le.value), !!le.value), _defineProperty$V(pe, "".concat(oe.value,
                "-with-button"), !!$e), pe), U.class);
            return createVNode(Input, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                ref: Z
            }, omit$2(xe, ["onUpdate:value", "onSearch", "enterButton"])), U), {}, {
                onPressEnter: re,
                size: le.value,
                prefixCls: se.value,
                addonAfter: Oe,
                suffix: ge,
                onChange: ne,
                class: Ve,
                disabled: me
            }), W)
        }
    }
});
var HIDDEN_TEXTAREA_STYLE =
    `
 min-height:0 !important;
 max-height:none !important;
 height:0 !important;
 visibility:hidden !important;
 overflow:hidden !important;
 position:absolute !important;
 z-index:-1000 !important;
 top:0 !important;
 right:0 !important
`,
    SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight",
        "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left",
        "padding-right", "border-width", "box-sizing", "word-break"],
    computedStyleCache = {},
    hiddenTextarea;

function calculateNodeStyling(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
        H = K.getAttribute("id") || K.getAttribute("data-reactid") || K.getAttribute("name");
    if (C && computedStyleCache[H]) return computedStyleCache[H];
    var W = window.getComputedStyle(K),
        U = W.getPropertyValue("box-sizing") || W.getPropertyValue("-moz-box-sizing") || W.getPropertyValue(
            "-webkit-box-sizing"),
        G = parseFloat(W.getPropertyValue("padding-bottom")) + parseFloat(W.getPropertyValue("padding-top")),
        X = parseFloat(W.getPropertyValue("border-bottom-width")) + parseFloat(W.getPropertyValue("border-top-width")),
        Z = SIZING_STYLE.map(function (ee) {
            return "".concat(ee, ":").concat(W.getPropertyValue(ee))
        }).join(";"),
        Q = {
            sizingStyle: Z,
            paddingSize: G,
            borderSize: X,
            boxSizing: U
        };
    return C && H && (computedStyleCache[H] = Q), Q
}

function calculateNodeHeight(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
        H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null,
        W = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
    hiddenTextarea || (hiddenTextarea = document.createElement("textarea"), hiddenTextarea.setAttribute("tab-index",
        "-1"), hiddenTextarea.setAttribute("aria-hidden", "true"), document.body.appendChild(hiddenTextarea)), K.getAttribute(
        "wrap") ? hiddenTextarea.setAttribute("wrap", K.getAttribute("wrap")) : hiddenTextarea.removeAttribute(
        "wrap");
    var U = calculateNodeStyling(K, C),
        G = U.paddingSize,
        X = U.borderSize,
        Z = U.boxSizing,
        Q = U.sizingStyle;
    hiddenTextarea.setAttribute("style", "".concat(Q, ";").concat(HIDDEN_TEXTAREA_STYLE)), hiddenTextarea.value = K.value ||
        K.placeholder || "";
    var ee = Number.MIN_SAFE_INTEGER,
        ne = Number.MAX_SAFE_INTEGER,
        te = hiddenTextarea.scrollHeight,
        re;
    if (Z === "border-box" ? te += X : Z === "content-box" && (te -= G), H !== null || W !== null) {
        hiddenTextarea.value = " ";
        var ae = hiddenTextarea.scrollHeight - G;
        H !== null && (ee = ae * H, Z === "border-box" && (ee = ee + G + X), te = Math.max(ee, te)), W !== null && (ne =
            ae * W, Z === "border-box" && (ne = ne + G + X), re = te > ne ? "" : "hidden", te = Math.min(ne, te))
    }
    return {
        height: "".concat(te, "px"),
        minHeight: "".concat(ee, "px"),
        maxHeight: "".concat(ne, "px"),
        overflowY: re,
        resize: "none"
    }
}
var RESIZE_STATUS_NONE = 0,
    RESIZE_STATUS_RESIZING = 1,
    RESIZE_STATUS_RESIZED = 2,
    ResizableTextArea = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ResizableTextArea",
        inheritAttrs: !1,
        props: textAreaProps(),
        setup: function (C, H) {
            var W = H.attrs,
                U = H.emit,
                G = H.expose,
                X, Z, Q = ref(),
                ee = ref({}),
                ne = ref(RESIZE_STATUS_NONE);
            onBeforeUnmount(function () {
                wrapperRaf.cancel(X), wrapperRaf.cancel(Z)
            });
            var te = function () {
                    try {
                        if (document.activeElement === Q.value) {
                            var se = Q.value.selectionStart,
                                ce = Q.value.selectionEnd;
                            Q.value.setSelectionRange(se, ce)
                        }
                    } catch {}
                },
                re = function () {
                    var se = C.autoSize || C.autosize;
                    if (!(!se || !Q.value)) {
                        var ce = se.minRows,
                            de = se.maxRows;
                        ee.value = calculateNodeHeight(Q.value, !1, ce, de), ne.value = RESIZE_STATUS_RESIZING,
                            wrapperRaf.cancel(Z), Z = wrapperRaf(function () {
                                ne.value = RESIZE_STATUS_RESIZED, Z = wrapperRaf(function () {
                                    ne.value = RESIZE_STATUS_NONE, te()
                                })
                            })
                    }
                },
                ae = function () {
                    wrapperRaf.cancel(X), X = wrapperRaf(re)
                },
                oe = function (se) {
                    if (ne.value === RESIZE_STATUS_NONE) {
                        U("resize", se);
                        var ce = C.autoSize || C.autosize;
                        ce && ae()
                    }
                };
            warning$2(C.autosize === void 0, "Input.TextArea",
                "autosize is deprecated, please use autoSize instead.");
            var ie = function () {
                var se = C.prefixCls,
                    ce = C.autoSize,
                    de = C.autosize,
                    ve = C.disabled,
                    fe = omit$2(C, ["prefixCls", "onPressEnter", "autoSize", "autosize", "defaultValue",
                        "allowClear", "type", "lazy", "maxlength", "valueModifiers"]),
                    pe = classNames(se, W.class, _defineProperty$V({}, "".concat(se, "-disabled"), ve)),
                    me = [W.style, ee.value, ne.value === RESIZE_STATUS_RESIZING ? {
                        overflowX: "hidden",
                        overflowY: "hidden"
                    } : null],
                    he = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, fe), W), {}, {
                        style: me,
                        class: pe
                    });
                return he.autofocus || delete he.autofocus, he.rows === 0 && delete he.rows, createVNode(
                    ResizeObserver$1, {
                        onResize: oe,
                        disabled: !(ce || de)
                    }, {
                        default: function () {
                            return [withDirectives(createVNode("textarea", _objectSpread2$1(
                                _objectSpread2$1({}, he), {}, {
                                    ref: Q
                                }), null), [[antInputDirective]])]
                        }
                    })
            };
            watch(function () {
                return C.value
            }, function () {
                nextTick(function () {
                    re()
                })
            }), onMounted(function () {
                nextTick(function () {
                    re()
                })
            });
            var ue = getCurrentInstance();
            return G({
                    resizeTextarea: re,
                    textArea: Q,
                    instance: ue
                }),
                function () {
                    return ie()
                }
        }
    });
const ResizableTextArea$1 = ResizableTextArea;

function fixEmojiLength(K, C) {
    return _toConsumableArray(K || "").slice(0, C).join("")
}

function setTriggerValue(K, C, H, W) {
    var U = H;
    return K ? U = fixEmojiLength(H, W) : _toConsumableArray(C || "").length < H.length && _toConsumableArray(H || "").length >
        W && (U = C), U
}
const TextArea = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ATextarea",
    inheritAttrs: !1,
    props: textAreaProps(),
    setup: function (C, H) {
        var W = H.attrs,
            U = H.expose,
            G = H.emit,
            X = useInjectFormItemContext(),
            Z = ref(C.value === void 0 ? C.defaultValue : C.value),
            Q = ref(),
            ee = ref(""),
            ne = useConfigInject("input", C),
            te = ne.prefixCls,
            re = ne.size,
            ae = ne.direction,
            oe = computed(function () {
                return C.showCount === "" || C.showCount || !1
            }),
            ie = computed(function () {
                return Number(C.maxlength) > 0
            }),
            ue = ref(!1),
            le = ref(),
            se = ref(0),
            ce = function ($e) {
                ue.value = !0, le.value = ee.value, se.value = $e.currentTarget.selectionStart, G(
                    "compositionstart", $e)
            },
            de = function ($e) {
                ue.value = !1;
                var ye = $e.currentTarget.value;
                if (ie.value) {
                    var Ce, we = se.value >= C.maxlength + 1 || se.value === ((Ce = le.value) === null ||
                        Ce === void 0 ? void 0 : Ce.length);
                    ye = setTriggerValue(we, le.value, ye, C.maxlength)
                }
                ye !== ee.value && (me(ye), resolveOnChange($e.currentTarget, $e, _e, ye)), G(
                    "compositionend", $e)
            },
            ve = getCurrentInstance();
        watch(function () {
            return C.value
        }, function () {
            "value" in ve.vnode.props;
            var Pe;
            Z.value = (Pe = C.value) !== null && Pe !== void 0 ? Pe : ""
        });
        var fe = function ($e) {
                var ye;
                triggerFocus((ye = Q.value) === null || ye === void 0 ? void 0 : ye.textArea, $e)
            },
            pe = function () {
                var $e, ye;
                ($e = Q.value) === null || $e === void 0 || (ye = $e.textArea) === null || ye === void 0 ||
                    ye.blur()
            },
            me = function ($e, ye) {
                Z.value !== $e && (C.value === void 0 ? Z.value = $e : nextTick(function () {
                    if (Q.value.textArea.value !== ee.value) {
                        var Ce, we, Oe;
                        (Ce = Q.value) === null || Ce === void 0 || (we = (Oe = Ce.instance).update) ===
                            null || we === void 0 || we.call(Oe)
                    }
                }), nextTick(function () {
                    ye && ye()
                }))
            },
            he = function ($e) {
                $e.keyCode === 13 && G("pressEnter", $e), G("keydown", $e)
            },
            Se = function ($e) {
                var ye = C.onBlur;
                ye == null || ye($e), X.onFieldBlur()
            },
            _e = function ($e) {
                G("update:value", $e.target.value), G("change", $e), G("input", $e), X.onFieldChange()
            },
            be = function ($e) {
                resolveOnChange(Q.value.textArea, $e, _e), me("", function () {
                    fe()
                })
            },
            ge = function ($e) {
                var ye = $e.target.composing,
                    Ce = $e.target.value;
                if (ue.value = !!($e.isComposing || ye), !(ue.value && C.lazy || Z.value === Ce)) {
                    if (ie.value) {
                        var we = $e.target,
                            Oe = we.selectionStart >= C.maxlength + 1 || we.selectionStart === Ce.length ||
                            !we.selectionStart;
                        Ce = setTriggerValue(Oe, ee.value, Ce, C.maxlength)
                    }
                    resolveOnChange($e.currentTarget, $e, _e, Ce), me(Ce)
                }
            },
            xe = function () {
                var $e, ye, Ce, we = W.style,
                    Oe = W.class,
                    Ne = C.bordered,
                    Me = Ne === void 0 ? !0 : Ne,
                    Ve = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, omit$2(C, ["allowClear"])),
                        W), {}, {
                        style: oe.value ? {} : we,
                        class: ($e = {}, _defineProperty$V($e, "".concat(te.value, "-borderless"), !Me),
                            _defineProperty$V($e, "".concat(Oe), Oe && !oe.value),
                            _defineProperty$V($e, "".concat(te.value, "-sm"), re.value === "small"),
                            _defineProperty$V($e, "".concat(te.value, "-lg"), re.value === "large"),
                            $e),
                        showCount: null,
                        prefixCls: te.value,
                        onInput: ge,
                        onChange: ge,
                        onBlur: Se,
                        onKeydown: he,
                        onCompositionstart: ce,
                        onCompositionend: de
                    });
                return (ye = C.valueModifiers) !== null && ye !== void 0 && ye.lazy && delete Ve.onInput,
                    createVNode(ResizableTextArea$1, _objectSpread2$1(_objectSpread2$1({}, Ve), {}, {
                        id: (Ce = Ve.id) !== null && Ce !== void 0 ? Ce : X.id.value,
                        ref: Q,
                        maxlength: C.maxlength
                    }), null)
            };
        return U({
                focus: fe,
                blur: pe,
                resizableTextArea: Q
            }), watchEffect(function () {
                var Pe = fixControlledValue(Z.value);
                !ue.value && ie.value && (C.value === null || C.value === void 0) && (Pe =
                    fixEmojiLength(Pe, C.maxlength)), ee.value = Pe
            }),
            function () {
                var Pe = C.maxlength,
                    $e = C.bordered,
                    ye = $e === void 0 ? !0 : $e,
                    Ce = C.hidden,
                    we = W.style,
                    Oe = W.class,
                    Ne = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, C), W), {}, {
                        prefixCls: te.value,
                        inputType: "text",
                        handleReset: be,
                        direction: ae.value,
                        bordered: ye,
                        style: oe.value ? void 0 : we
                    }),
                    Me = createVNode(ClearableLabeledInput, _objectSpread2$1(_objectSpread2$1({}, Ne), {}, {
                        value: ee.value
                    }), {
                        element: xe
                    });
                if (oe.value) {
                    var Ve = _toConsumableArray(ee.value).length,
                        ke = "";
                    _typeof$2(oe.value) === "object" ? ke = oe.value.formatter({
                        count: Ve,
                        maxlength: Pe
                    }) : ke = "".concat(Ve).concat(ie.value ? " / ".concat(Pe) : ""), Me = createVNode(
                        "div", {
                            hidden: Ce,
                            class: classNames("".concat(te.value, "-textarea"), _defineProperty$V({},
                                "".concat(te.value, "-textarea-rtl"), ae.value === "rtl"), "".concat(
                                te.value, "-textarea-show-count"), Oe),
                            style: we,
                            "data-count": _typeof$2(ke) !== "object" ? ke : void 0
                        }, [Me])
                }
                return Me
            }
    }
});
var EyeOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z"
            }
        }]
    },
    name: "eye",
    theme: "outlined"
};
const EyeOutlinedSvg = EyeOutlined$2;

function _objectSpread$v(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$v(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$v(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var EyeOutlined = function (C, H) {
    var W = _objectSpread$v({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$v({}, W, {
        icon: EyeOutlinedSvg
    }), null)
};
EyeOutlined.displayName = "EyeOutlined";
EyeOutlined.inheritAttrs = !1;
const EyeOutlined$1 = EyeOutlined;
var EyeInvisibleOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z"
            }
        }, {
            tag: "path",
            attrs: {
                d: "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z"
            }
        }]
    },
    name: "eye-invisible",
    theme: "outlined"
};
const EyeInvisibleOutlinedSvg = EyeInvisibleOutlined$2;

function _objectSpread$u(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$u(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$u(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var EyeInvisibleOutlined = function (C, H) {
    var W = _objectSpread$u({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$u({}, W, {
        icon: EyeInvisibleOutlinedSvg
    }), null)
};
EyeInvisibleOutlined.displayName = "EyeInvisibleOutlined";
EyeInvisibleOutlined.inheritAttrs = !1;
const EyeInvisibleOutlined$1 = EyeInvisibleOutlined;
var _excluded$w = ["size", "visibilityToggle"],
    ActionMap = {
        click: "onClick",
        hover: "onMouseover"
    },
    defaultIconRender = function (C) {
        return createVNode(C ? EyeOutlined$1 : EyeInvisibleOutlined$1, null, null)
    };
const Password = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AInputPassword",
    inheritAttrs: !1,
    props: _objectSpread2$1(_objectSpread2$1({}, inputProps$1()), {}, {
        prefixCls: String,
        inputPrefixCls: String,
        action: {
            type: String,
            default: "click"
        },
        visibilityToggle: {
            type: Boolean,
            default: !0
        },
        iconRender: Function
    }),
    setup: function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = H.expose,
            X = ref(!1),
            Z = function () {
                var se = C.disabled;
                se || (X.value = !X.value)
            },
            Q = ref(),
            ee = function () {
                var se;
                (se = Q.value) === null || se === void 0 || se.focus()
            },
            ne = function () {
                var se;
                (se = Q.value) === null || se === void 0 || se.blur()
            };
        G({
            focus: ee,
            blur: ne
        });
        var te = function (se) {
                var ce, de = C.action,
                    ve = C.iconRender,
                    fe = ve === void 0 ? W.iconRender || defaultIconRender : ve,
                    pe = ActionMap[de] || "",
                    me = fe(X.value),
                    he = (ce = {}, _defineProperty$V(ce, pe, Z), _defineProperty$V(ce, "class", "".concat(
                        se, "-icon")), _defineProperty$V(ce, "key", "passwordIcon"), _defineProperty$V(
                        ce, "onMousedown",
                        function (_e) {
                            _e.preventDefault()
                        }), _defineProperty$V(ce, "onMouseup", function (_e) {
                        _e.preventDefault()
                    }), ce);
                return cloneElement(isValidElement(me) ? me : createVNode("span", null, [me]), he)
            },
            re = useConfigInject("input-password", C),
            ae = re.prefixCls,
            oe = re.getPrefixCls,
            ie = computed(function () {
                return oe("input", C.inputPrefixCls)
            }),
            ue = function () {
                var se = C.size,
                    ce = C.visibilityToggle,
                    de = _objectWithoutProperties$2(C, _excluded$w),
                    ve = ce && te(ae.value),
                    fe = classNames(ae.value, U.class, _defineProperty$V({}, "".concat(ae.value, "-").concat(
                        se), !!se)),
                    pe = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, omit$2(de, ["suffix",
                        "iconRender", "action"])), U), {}, {
                        type: X.value ? "text" : "password",
                        class: fe,
                        prefixCls: ie.value,
                        suffix: ve
                    });
                return se && (pe.size = se), createVNode(Input, _objectSpread2$1({
                    ref: Q
                }, pe), W)
            };
        return function () {
            return ue()
        }
    }
});
Input.Group = Group$1;
Input.Search = Search$1;
Input.TextArea = TextArea;
Input.Password = Password;
Input.install = function (K) {
    return K.component(Input.name, Input), K.component(Input.Group.name, Input.Group), K.component(Input.Search.name,
        Input.Search), K.component(Input.TextArea.name, Input.TextArea), K.component(Input.Password.name, Input
        .Password), K
};
var numberTag = "[object Number]";

function isNumber$1(K) {
    return typeof K == "number" || isObjectLike(K) && baseGetTag(K) == numberTag
}

function getClientSize() {
    var K = document.documentElement.clientWidth,
        C = window.innerHeight || document.documentElement.clientHeight;
    return {
        width: K,
        height: C
    }
}

function getOffset(K) {
    var C = K.getBoundingClientRect(),
        H = document.documentElement;
    return {
        left: C.left + (window.pageXOffset || H.scrollLeft) - (H.clientLeft || document.body.clientLeft || 0),
        top: C.top + (window.pageYOffset || H.scrollTop) - (H.clientTop || document.body.clientTop || 0)
    }
}

function dialogPropTypes() {
    return {
        keyboard: {
            type: Boolean,
            default: void 0
        },
        mask: {
            type: Boolean,
            default: void 0
        },
        afterClose: Function,
        closable: {
            type: Boolean,
            default: void 0
        },
        maskClosable: {
            type: Boolean,
            default: void 0
        },
        visible: {
            type: Boolean,
            default: void 0
        },
        destroyOnClose: {
            type: Boolean,
            default: void 0
        },
        mousePosition: PropTypes$1.shape({
            x: Number,
            y: Number
        }).loose,
        title: PropTypes$1.any,
        footer: PropTypes$1.any,
        transitionName: String,
        maskTransitionName: String,
        animation: PropTypes$1.any,
        maskAnimation: PropTypes$1.any,
        wrapStyle: {
            type: Object,
            default: void 0
        },
        bodyStyle: {
            type: Object,
            default: void 0
        },
        maskStyle: {
            type: Object,
            default: void 0
        },
        prefixCls: String,
        wrapClassName: String,
        rootClassName: String,
        width: [String, Number],
        height: [String, Number],
        zIndex: Number,
        bodyProps: PropTypes$1.any,
        maskProps: PropTypes$1.any,
        wrapProps: PropTypes$1.any,
        getContainer: PropTypes$1.any,
        dialogStyle: {
            type: Object,
            default: void 0
        },
        dialogClass: String,
        closeIcon: PropTypes$1.any,
        forceRender: {
            type: Boolean,
            default: void 0
        },
        getOpenCount: Function,
        focusTriggerAfterClose: {
            type: Boolean,
            default: void 0
        },
        onClose: Function,
        modalRender: Function
    }
}

function getMotionName(K, C, H) {
    var W = C;
    return !W && H && (W = "".concat(K, "-").concat(H)), W
}
var uuid$1 = -1;

function getUUID() {
    return uuid$1 += 1, uuid$1
}

function getScroll$1(K, C) {
    var H = K["page".concat(C ? "Y" : "X", "Offset")],
        W = "scroll".concat(C ? "Top" : "Left");
    if (typeof H != "number") {
        var U = K.document;
        H = U.documentElement[W], typeof H != "number" && (H = U.body[W])
    }
    return H
}

function offset$2(K) {
    var C = K.getBoundingClientRect(),
        H = {
            left: C.left,
            top: C.top
        },
        W = K.ownerDocument,
        U = W.defaultView || W.parentWindow;
    return H.left += getScroll$1(U), H.top += getScroll$1(U, !0), H
}
var sentinelStyle = {
    width: 0,
    height: 0,
    overflow: "hidden",
    outline: "none"
};
const Content$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Content",
    inheritAttrs: !1,
    props: _objectSpread2$1(_objectSpread2$1({}, dialogPropTypes()), {}, {
        motionName: String,
        ariaId: String,
        onVisibleChanged: Function,
        onMousedown: Function,
        onMouseup: Function
    }),
    setup: function (C, H) {
        var W = H.expose,
            U = H.slots,
            G = H.attrs,
            X = ref(),
            Z = ref(),
            Q = ref();
        W({
            focus: function () {
                var oe;
                (oe = X.value) === null || oe === void 0 || oe.focus()
            },
            changeActive: function (oe) {
                var ie = document,
                    ue = ie.activeElement;
                oe && ue === Z.value ? X.value.focus() : !oe && ue === X.value && Z.value.focus()
            }
        });
        var ee = ref(),
            ne = computed(function () {
                var ae = C.width,
                    oe = C.height,
                    ie = {};
                return ae !== void 0 && (ie.width = typeof ae == "number" ? "".concat(ae, "px") : ae),
                    oe !== void 0 && (ie.height = typeof oe == "number" ? "".concat(oe, "px") : oe), ee
                    .value && (ie.transformOrigin = ee.value), ie
            }),
            te = function () {
                nextTick(function () {
                    if (Q.value) {
                        var oe = offset$2(Q.value);
                        ee.value = C.mousePosition ? "".concat(C.mousePosition.x - oe.left, "px ").concat(
                            C.mousePosition.y - oe.top, "px") : ""
                    }
                })
            },
            re = function (oe) {
                C.onVisibleChanged(oe)
            };
        return function () {
            var ae, oe, ie, ue, le = C.prefixCls,
                se = C.footer,
                ce = se === void 0 ? (ae = U.footer) === null || ae === void 0 ? void 0 : ae.call(U) :
                se,
                de = C.title,
                ve = de === void 0 ? (oe = U.title) === null || oe === void 0 ? void 0 : oe.call(U) :
                de,
                fe = C.ariaId,
                pe = C.closable,
                me = C.closeIcon,
                he = me === void 0 ? (ie = U.closeIcon) === null || ie === void 0 ? void 0 : ie.call(U) :
                me,
                Se = C.onClose,
                _e = C.bodyStyle,
                be = C.bodyProps,
                ge = C.onMousedown,
                xe = C.onMouseup,
                Pe = C.visible,
                $e = C.modalRender,
                ye = $e === void 0 ? U.modalRender : $e,
                Ce = C.destroyOnClose,
                we = C.motionName,
                Oe;
            ce && (Oe = createVNode("div", {
                class: "".concat(le, "-footer")
            }, [ce]));
            var Ne;
            ve && (Ne = createVNode("div", {
                class: "".concat(le, "-header")
            }, [createVNode("div", {
                class: "".concat(le, "-title"),
                id: fe
            }, [ve])]));
            var Me;
            pe && (Me = createVNode("button", {
                type: "button",
                onClick: Se,
                "aria-label": "Close",
                class: "".concat(le, "-close")
            }, [he || createVNode("span", {
                class: "".concat(le, "-close-x")
            }, null)]));
            var Ve = createVNode("div", {
                    class: "".concat(le, "-content")
                }, [Me, Ne, createVNode("div", _objectSpread2$1({
                    class: "".concat(le, "-body"),
                    style: _e
                }, be), [(ue = U.default) === null || ue === void 0 ? void 0 : ue.call(U)]), Oe]),
                ke = getTransitionProps(we);
            return createVNode(Transition, _objectSpread2$1(_objectSpread2$1({}, ke), {}, {
                onBeforeEnter: te,
                onAfterEnter: function () {
                    return re(!0)
                },
                onAfterLeave: function () {
                    return re(!1)
                }
            }), {
                default: function () {
                    return [Pe || !Ce ? withDirectives(createVNode("div", _objectSpread2$1(
                        _objectSpread2$1({}, G), {}, {
                            ref: Q,
                            key: "dialog-element",
                            role: "document",
                            style: [ne.value, G.style],
                            class: [le, G.class],
                            onMousedown: ge,
                            onMouseup: xe
                        }), [createVNode("div", {
                        tabindex: 0,
                        ref: X,
                        style: sentinelStyle,
                        "aria-hidden": "true"
                    }, null), ye ? ye({
                        originVNode: Ve
                    }) : Ve, createVNode("div", {
                        tabindex: 0,
                        ref: Z,
                        style: sentinelStyle,
                        "aria-hidden": "true"
                    }, null)]), [[vShow, Pe]]) : null]
                }
            })
        }
    }
});

function _objectDestructuringEmpty(K) {
    if (K == null) throw new TypeError("Cannot destructure " + K)
}
const Mask = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "Mask",
        props: {
            prefixCls: String,
            visible: Boolean,
            motionName: String,
            maskProps: Object
        },
        setup: function (C, H) {
            return _objectDestructuringEmpty(H),
                function () {
                    var W = C.prefixCls,
                        U = C.visible,
                        G = C.maskProps,
                        X = C.motionName,
                        Z = getTransitionProps(X);
                    return createVNode(Transition, Z, {
                        default: function () {
                            return [withDirectives(createVNode("div", _objectSpread2$1({
                                class: "".concat(W, "-mask")
                            }, G), null), [[vShow, U]])]
                        }
                    })
                }
        }
    }),
    Dialog = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "Dialog",
        inheritAttrs: !1,
        props: initDefaultProps$1(_objectSpread2$1(_objectSpread2$1({}, dialogPropTypes()), {}, {
            getOpenCount: Function,
            scrollLocker: Object
        }), {
            mask: !0,
            visible: !1,
            keyboard: !0,
            closable: !0,
            maskClosable: !0,
            destroyOnClose: !1,
            prefixCls: "rc-dialog",
            getOpenCount: function () {
                return null
            },
            focusTriggerAfterClose: !0
        }),
        setup: function (C, H) {
            var W = H.attrs,
                U = H.slots,
                G = ref(),
                X = ref(),
                Z = ref(),
                Q = ref(C.visible),
                ee = ref("vcDialogTitle".concat(getUUID())),
                ne = function (ce) {
                    if (ce) {
                        if (!contains(X.value, document.activeElement)) {
                            var de;
                            G.value = document.activeElement, (de = Z.value) === null || de === void 0 || de.focus()
                        }
                    } else {
                        var ve = Q.value;
                        if (Q.value = !1, C.mask && G.value && C.focusTriggerAfterClose) {
                            try {
                                G.value.focus({
                                    preventScroll: !0
                                })
                            } catch {}
                            G.value = null
                        }
                        if (ve) {
                            var fe;
                            (fe = C.afterClose) === null || fe === void 0 || fe.call(C)
                        }
                    }
                },
                te = function (ce) {
                    var de;
                    (de = C.onClose) === null || de === void 0 || de.call(C, ce)
                },
                re = ref(!1),
                ae = ref(),
                oe = function () {
                    clearTimeout(ae.value), re.value = !0
                },
                ie = function () {
                    ae.value = setTimeout(function () {
                        re.value = !1
                    })
                },
                ue = function (ce) {
                    if (!C.maskClosable) return null;
                    re.value ? re.value = !1 : X.value === ce.target && te(ce)
                },
                le = function (ce) {
                    if (C.keyboard && ce.keyCode === KeyCode$1.ESC) {
                        ce.stopPropagation(), te(ce);
                        return
                    }
                    C.visible && ce.keyCode === KeyCode$1.TAB && Z.value.changeActive(!ce.shiftKey)
                };
            return watch(function () {
                    return C.visible
                }, function () {
                    C.visible && (Q.value = !0)
                }, {
                    flush: "post"
                }), onBeforeUnmount(function () {
                    var se;
                    clearTimeout(ae.value), (se = C.scrollLocker) === null || se === void 0 || se.unLock()
                }), watchEffect(function () {
                    var se;
                    if ((se = C.scrollLocker) === null || se === void 0 || se.unLock(), Q.value) {
                        var ce;
                        (ce = C.scrollLocker) === null || ce === void 0 || ce.lock()
                    }
                }),
                function () {
                    var se = C.prefixCls,
                        ce = C.mask,
                        de = C.visible,
                        ve = C.maskTransitionName,
                        fe = C.maskAnimation,
                        pe = C.zIndex,
                        me = C.wrapClassName,
                        he = C.rootClassName,
                        Se = C.wrapStyle,
                        _e = C.closable,
                        be = C.maskProps,
                        ge = C.maskStyle,
                        xe = C.transitionName,
                        Pe = C.animation,
                        $e = C.wrapProps,
                        ye = C.title,
                        Ce = ye === void 0 ? U.title : ye,
                        we = W.style,
                        Oe = W.class;
                    return createVNode("div", _objectSpread2$1({
                        class: ["".concat(se, "-root"), he]
                    }, pickAttrs(C, {
                        data: !0
                    })), [createVNode(Mask, {
                        prefixCls: se,
                        visible: ce && de,
                        motionName: getMotionName(se, ve, fe),
                        style: _objectSpread2$1({
                            zIndex: pe
                        }, ge),
                        maskProps: be
                    }, null), createVNode("div", _objectSpread2$1({
                        tabIndex: -1,
                        onKeydown: le,
                        class: classNames("".concat(se, "-wrap"), me),
                        ref: X,
                        onClick: ue,
                        role: "dialog",
                        "aria-labelledby": Ce ? ee.value : null,
                        style: _objectSpread2$1(_objectSpread2$1({
                            zIndex: pe
                        }, Se), {}, {
                            display: Q.value ? null : "none"
                        })
                    }, $e), [createVNode(Content$1, _objectSpread2$1(_objectSpread2$1({},
                        omit$2(C, ["scrollLocker"])), {}, {
                        style: we,
                        class: Oe,
                        onMousedown: oe,
                        onMouseup: ie,
                        ref: Z,
                        closable: _e,
                        ariaId: ee.value,
                        prefixCls: se,
                        visible: de,
                        onClose: te,
                        onVisibleChanged: ne,
                        motionName: getMotionName(se, xe, Pe)
                    }), U)])])
                }
        }
    });
var IDialogPropTypes = dialogPropTypes(),
    DialogWrap = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "DialogWrap",
        inheritAttrs: !1,
        props: initDefaultProps$1(IDialogPropTypes, {
            visible: !1
        }),
        setup: function (C, H) {
            var W = H.attrs,
                U = H.slots,
                G = ref(C.visible);
            return useProvidePortal({}, {
                    inTriggerContext: !1
                }), watch(function () {
                    return C.visible
                }, function () {
                    C.visible && (G.value = !0)
                }, {
                    flush: "post"
                }),
                function () {
                    var X = C.visible,
                        Z = C.getContainer,
                        Q = C.forceRender,
                        ee = C.destroyOnClose,
                        ne = ee === void 0 ? !1 : ee,
                        te = C.afterClose,
                        re = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, C), W), {}, {
                            ref: "_component",
                            key: "dialog"
                        });
                    return Z === !1 ? createVNode(Dialog, _objectSpread2$1(_objectSpread2$1({}, re), {}, {
                        getOpenCount: function () {
                            return 2
                        }
                    }), U) : !Q && ne && !G.value ? null : createVNode(Portal, {
                        visible: X,
                        forceRender: Q,
                        getContainer: Z
                    }, {
                        default: function (oe) {
                            return re = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, re),
                                oe), {}, {
                                afterClose: function () {
                                    te == null || te(), G.value = !1
                                }
                            }), createVNode(Dialog, re, U)
                        }
                    })
                }
        }
    });
const DialogWrap$1 = DialogWrap;

function useFrameSetState(K) {
    var C = ref(null),
        H = reactive(_objectSpread2$1({}, K)),
        W = ref([]),
        U = function (X) {
            C.value === null && (W.value = [], C.value = wrapperRaf(function () {
                var Z;
                W.value.forEach(function (Q) {
                    Z = _objectSpread2$1(_objectSpread2$1({}, Z), Q)
                }), _extends$1(H, Z), C.value = null
            })), W.value.push(X)
        };
    return onMounted(function () {
        C.value && wrapperRaf.cancel(C.value)
    }), [H, U]
}

function fixPoint(K, C, H, W) {
    var U = C + H,
        G = (H - W) / 2;
    if (H > W) {
        if (C > 0) return _defineProperty$V({}, K, G);
        if (C < 0 && U < W) return _defineProperty$V({}, K, -G)
    } else if (C < 0 || U > W) return _defineProperty$V({}, K, C < 0 ? G : -G);
    return {}
}

function getFixScaleEleTransPosition(K, C, H, W) {
    var U = getClientSize(),
        G = U.width,
        X = U.height,
        Z = null;
    return K <= G && C <= X ? Z = {
        x: 0,
        y: 0
    } : (K > G || C > X) && (Z = _objectSpread2$1(_objectSpread2$1({}, fixPoint("x", H, K, G)), fixPoint("y", W, C,
        X))), Z
}
var previewGroupContext = Symbol("previewGroupContext"),
    context = {
        provide: function (C) {
            provide(previewGroupContext, C)
        },
        inject: function () {
            return inject(previewGroupContext, {
                isPreviewGroup: ref(!1),
                previewUrls: computed(function () {
                    return new Map
                }),
                setPreviewUrls: function () {},
                current: ref(null),
                setCurrent: function () {},
                setShowPreview: function () {},
                setMousePosition: function () {},
                registerImage: null,
                rootClassName: ""
            })
        }
    },
    Group = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "PreviewGroup",
        inheritAttrs: !1,
        props: {
            previewPrefixCls: String,
            preview: {
                type: [Boolean, Object],
                default: !0
            },
            icons: {
                type: Object,
                default: function () {
                    return {}
                }
            }
        },
        setup: function (C, H) {
            var W = H.slots,
                U = computed(function () {
                    var me = {
                        visible: void 0,
                        onVisibleChange: function () {},
                        getContainer: void 0,
                        current: 0
                    };
                    return _typeof$2(C.preview) === "object" ? mergeDefaultValue(C.preview, me) : me
                }),
                G = reactive(new Map),
                X = ref(),
                Z = computed(function () {
                    return U.value.visible
                }),
                Q = computed(function () {
                    return U.value.getContainer
                }),
                ee = function (he, Se) {
                    var _e, be;
                    (_e = (be = U.value).onVisibleChange) === null || _e === void 0 || _e.call(be, he, Se)
                },
                ne = useMergedState(!!Z.value, {
                    value: Z,
                    onChange: ee
                }),
                te = _slicedToArray$2(ne, 2),
                re = te[0],
                ae = te[1],
                oe = ref(null),
                ie = computed(function () {
                    return Z.value !== void 0
                }),
                ue = computed(function () {
                    return Array.from(G.keys())
                }),
                le = computed(function () {
                    return ue.value[U.value.current]
                }),
                se = computed(function () {
                    return new Map(Array.from(G).filter(function (me) {
                        var he = _slicedToArray$2(me, 2),
                            Se = he[1].canPreview;
                        return !!Se
                    }).map(function (me) {
                        var he = _slicedToArray$2(me, 2),
                            Se = he[0],
                            _e = he[1].url;
                        return [Se, _e]
                    }))
                }),
                ce = function (he, Se) {
                    var _e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
                    G.set(he, {
                        url: Se,
                        canPreview: _e
                    })
                },
                de = function (he) {
                    X.value = he
                },
                ve = function (he) {
                    oe.value = he
                },
                fe = function (he, Se) {
                    var _e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0,
                        be = function () {
                            G.delete(he)
                        };
                    return G.set(he, {
                        url: Se,
                        canPreview: _e
                    }), be
                },
                pe = function (he) {
                    he == null || he.stopPropagation(), ae(!1), ve(null)
                };
            return watch(le, function (me) {
                    de(me)
                }, {
                    immediate: !0,
                    flush: "post"
                }), watchEffect(function () {
                    re.value && ie.value && de(le.value)
                }, {
                    flush: "post"
                }), context.provide({
                    isPreviewGroup: ref(!0),
                    previewUrls: se,
                    setPreviewUrls: ce,
                    current: X,
                    setCurrent: de,
                    setShowPreview: ae,
                    setMousePosition: ve,
                    registerImage: fe
                }),
                function () {
                    var me = _extends$1({}, (_objectDestructuringEmpty(U.value), U.value));
                    return createVNode(Fragment, null, [W.default && W.default(), createVNode(Preview$1,
                        _objectSpread2$1(_objectSpread2$1({}, me), {}, {
                            "ria-hidden": !re.value,
                            visible: re.value,
                            prefixCls: C.previewPrefixCls,
                            onClose: pe,
                            mousePosition: oe.value,
                            src: se.value.get(X.value),
                            icons: C.icons,
                            getContainer: Q.value
                        }), null)])
                }
        }
    });
const PreviewGroup$1 = Group;
var initialPosition = {
        x: 0,
        y: 0
    },
    previewProps = _objectSpread2$1(_objectSpread2$1({}, dialogPropTypes()), {}, {
        src: String,
        alt: String,
        rootClassName: String,
        icons: {
            type: Object,
            default: function () {
                return {}
            }
        }
    }),
    Preview = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "Preview",
        inheritAttrs: !1,
        props: previewProps,
        emits: ["close", "afterClose"],
        setup: function (C, H) {
            var W = H.emit,
                U = H.attrs,
                G = reactive(C.icons),
                X = G.rotateLeft,
                Z = G.rotateRight,
                Q = G.zoomIn,
                ee = G.zoomOut,
                ne = G.close,
                te = G.left,
                re = G.right,
                ae = ref(1),
                oe = ref(0),
                ie = useFrameSetState(initialPosition),
                ue = _slicedToArray$2(ie, 2),
                le = ue[0],
                se = ue[1],
                ce = function () {
                    return W("close")
                },
                de = ref(),
                ve = reactive({
                    originX: 0,
                    originY: 0,
                    deltaX: 0,
                    deltaY: 0
                }),
                fe = ref(!1),
                pe = context.inject(),
                me = pe.previewUrls,
                he = pe.current,
                Se = pe.isPreviewGroup,
                _e = pe.setCurrent,
                be = computed(function () {
                    return me.value.size
                }),
                ge = computed(function () {
                    return Array.from(me.value.keys())
                }),
                xe = computed(function () {
                    return ge.value.indexOf(he.value)
                }),
                Pe = computed(function () {
                    return Se.value ? me.value.get(he.value) : C.src
                }),
                $e = computed(function () {
                    return Se.value && be.value > 1
                }),
                ye = ref({
                    wheelDirection: 0
                }),
                Ce = function () {
                    ae.value = 1, oe.value = 0, se(initialPosition), W("afterClose")
                },
                we = function () {
                    ae.value++, se(initialPosition)
                },
                Oe = function () {
                    ae.value > 1 && ae.value--, se(initialPosition)
                },
                Ne = function () {
                    oe.value += 90
                },
                Me = function () {
                    oe.value -= 90
                },
                Ve = function (Ue) {
                    Ue.preventDefault(), Ue.stopPropagation(), xe.value > 0 && _e(ge.value[xe.value - 1])
                },
                ke = function (Ue) {
                    Ue.preventDefault(), Ue.stopPropagation(), xe.value < be.value - 1 && _e(ge.value[xe.value +
                        1])
                },
                Ee = classNames(_defineProperty$V({}, "".concat(C.prefixCls, "-moving"), fe.value)),
                Ae = "".concat(C.prefixCls, "-operations-operation"),
                Re = "".concat(C.prefixCls, "-operations-icon"),
                He = [{
                    icon: ne,
                    onClick: ce,
                    type: "close"
                }, {
                    icon: Q,
                    onClick: we,
                    type: "zoomIn"
                }, {
                    icon: ee,
                    onClick: Oe,
                    type: "zoomOut",
                    disabled: computed(function () {
                        return ae.value === 1
                    })
                }, {
                    icon: Z,
                    onClick: Ne,
                    type: "rotateRight"
                }, {
                    icon: X,
                    onClick: Me,
                    type: "rotateLeft"
                }],
                je = function () {
                    if (C.visible && fe.value) {
                        var Ue = de.value.offsetWidth * ae.value,
                            et = de.value.offsetHeight * ae.value,
                            Ye = getOffset(de.value),
                            ze = Ye.left,
                            Be = Ye.top,
                            Ge = oe.value % 180 !== 0;
                        fe.value = !1;
                        var Xe = getFixScaleEleTransPosition(Ge ? et : Ue, Ge ? Ue : et, ze, Be);
                        Xe && se(_objectSpread2$1({}, Xe))
                    }
                },
                Fe = function (Ue) {
                    Ue.button === 0 && (Ue.preventDefault(), Ue.stopPropagation(), ve.deltaX = Ue.pageX - le.x,
                        ve.deltaY = Ue.pageY - le.y, ve.originX = le.x, ve.originY = le.y, fe.value = !0)
                },
                Le = function (Ue) {
                    C.visible && fe.value && se({
                        x: Ue.pageX - ve.deltaX,
                        y: Ue.pageY - ve.deltaY
                    })
                },
                Ie = function (Ue) {
                    if (C.visible) {
                        Ue.preventDefault();
                        var et = Ue.deltaY;
                        ye.value = {
                            wheelDirection: et
                        }
                    }
                },
                Te = function (Ue) {
                    !C.visible || !$e.value || (Ue.preventDefault(), Ue.keyCode === KeyCode$1.LEFT ? xe.value >
                        0 && _e(ge.value[xe.value - 1]) : Ue.keyCode === KeyCode$1.RIGHT && xe.value < be.value -
                        1 && _e(ge.value[xe.value + 1]))
                },
                De = function () {
                    C.visible && (ae.value !== 1 && (ae.value = 1), (le.x !== initialPosition.x || le.y !==
                        initialPosition.y) && se(initialPosition))
                },
                Ke = function () {};
            return onMounted(function () {
                    watch([function () {
                        return C.visible
                    }, fe], function () {
                        Ke();
                        var We, Ue, et = addEventListenerWrap(window, "mouseup", je, !1),
                            Ye = addEventListenerWrap(window, "mousemove", Le, !1),
                            ze = addEventListenerWrap(window, "wheel", Ie, {
                                passive: !1
                            }),
                            Be = addEventListenerWrap(window, "keydown", Te, !1);
                        try {
                            window.top !== window.self && (We = addEventListenerWrap(window.top,
                                "mouseup", je, !1), Ue = addEventListenerWrap(window.top,
                                "mousemove", Le, !1))
                        } catch {}
                        Ke = function () {
                            et.remove(), Ye.remove(), ze.remove(), Be.remove(), We && We.remove(),
                                Ue && Ue.remove()
                        }
                    }, {
                        flush: "post",
                        immediate: !0
                    }), watch([ye], function () {
                        var We = ye.value.wheelDirection;
                        We > 0 ? Oe() : We < 0 && we()
                    })
                }), onUnmounted(function () {
                    Ke()
                }),
                function () {
                    var We = C.visible,
                        Ue = C.prefixCls,
                        et = C.rootClassName;
                    return createVNode(DialogWrap$1, _objectSpread2$1(_objectSpread2$1({}, U), {}, {
                        transitionName: "zoom",
                        maskTransitionName: "fade",
                        closable: !1,
                        keyboard: !0,
                        prefixCls: Ue,
                        onClose: ce,
                        afterClose: Ce,
                        visible: We,
                        wrapClassName: Ee,
                        rootClassName: et,
                        getContainer: C.getContainer
                    }), {
                        default: function () {
                            return [createVNode("ul", {
                                class: "".concat(C.prefixCls, "-operations")
                            }, [He.map(function (ze) {
                                var Be = ze.icon,
                                    Ge = ze.onClick,
                                    Xe = ze.type,
                                    nt = ze.disabled;
                                return createVNode("li", {
                                    class: classNames(Ae,
                                        _defineProperty$V({}, "".concat(
                                            C.prefixCls,
                                            "-operations-operation-disabled"
                                        ), nt && (nt == null ?
                                            void 0 : nt.value))),
                                    onClick: Ge,
                                    key: Xe
                                }, [cloneVNode(Be, {
                                    class: Re
                                })])
                            })]), createVNode("div", {
                                class: "".concat(C.prefixCls, "-img-wrapper"),
                                style: {
                                    transform: "translate3d(".concat(le.x, "px, ").concat(
                                        le.y, "px, 0)")
                                }
                            }, [createVNode("img", {
                                onMousedown: Fe,
                                onDblclick: De,
                                ref: de,
                                class: "".concat(C.prefixCls, "-img"),
                                src: Pe.value,
                                alt: C.alt,
                                style: {
                                    transform: "scale3d(".concat(ae.value, ", ")
                                        .concat(ae.value, ", 1) rotate(").concat(
                                            oe.value, "deg)")
                                }
                            }, null)]), $e.value && createVNode("div", {
                                class: classNames("".concat(C.prefixCls, "-switch-left"),
                                    _defineProperty$V({}, "".concat(C.prefixCls,
                                        "-switch-left-disabled"), xe.value <= 0)),
                                onClick: Ve
                            }, [te]), $e.value && createVNode("div", {
                                class: classNames("".concat(C.prefixCls,
                                    "-switch-right"), _defineProperty$V({}, "".concat(
                                        C.prefixCls, "-switch-right-disabled"),
                                    xe.value >= be.value - 1)),
                                onClick: ke
                            }, [re])]
                        }
                    })
                }
        }
    });
const Preview$1 = Preview;
var _excluded$v = ["icons", "maskClassName"],
    imageProps = function () {
        return {
            src: String,
            wrapperClassName: String,
            wrapperStyle: {
                type: Object,
                default: void 0
            },
            rootClassName: String,
            prefixCls: String,
            previewPrefixCls: String,
            previewMask: {
                type: [Boolean, Function],
                default: void 0
            },
            placeholder: PropTypes$1.any,
            fallback: String,
            preview: {
                type: [Boolean, Object],
                default: !0
            },
            onClick: {
                type: Function
            },
            onError: {
                type: Function
            }
        }
    },
    mergeDefaultValue = function (C, H) {
        var W = _objectSpread2$1({}, C);
        return Object.keys(H).forEach(function (U) {
            C[U] === void 0 && (W[U] = H[U])
        }), W
    },
    uuid = 0,
    ImageInternal = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "Image",
        inheritAttrs: !1,
        props: imageProps(),
        emits: ["click", "error"],
        setup: function (C, H) {
            var W = H.attrs,
                U = H.slots,
                G = H.emit,
                X = computed(function () {
                    return C.prefixCls
                }),
                Z = computed(function () {
                    return "".concat(X.value, "-preview")
                }),
                Q = computed(function () {
                    var Ne = {
                        visible: void 0,
                        onVisibleChange: function () {},
                        getContainer: void 0
                    };
                    return _typeof$2(C.preview) === "object" ? mergeDefaultValue(C.preview, Ne) : Ne
                }),
                ee = computed(function () {
                    var Ne;
                    return (Ne = Q.value.src) !== null && Ne !== void 0 ? Ne : C.src
                }),
                ne = computed(function () {
                    return C.placeholder && C.placeholder !== !0 || U.placeholder
                }),
                te = computed(function () {
                    return Q.value.visible
                }),
                re = computed(function () {
                    return Q.value.getContainer
                }),
                ae = computed(function () {
                    return te.value !== void 0
                }),
                oe = function (Me, Ve) {
                    var ke, Ee;
                    (ke = (Ee = Q.value).onVisibleChange) === null || ke === void 0 || ke.call(Ee, Me, Ve)
                },
                ie = useMergedState(!!te.value, {
                    value: te,
                    onChange: oe
                }),
                ue = _slicedToArray$2(ie, 2),
                le = ue[0],
                se = ue[1];
            watch(le, function (Ne, Me) {
                oe(Ne, Me)
            });
            var ce = ref(ne.value ? "loading" : "normal");
            watch(function () {
                return C.src
            }, function () {
                ce.value = ne.value ? "loading" : "normal"
            });
            var de = ref(null),
                ve = computed(function () {
                    return ce.value === "error"
                }),
                fe = context.inject(),
                pe = fe.isPreviewGroup,
                me = fe.setCurrent,
                he = fe.setShowPreview,
                Se = fe.setMousePosition,
                _e = fe.registerImage,
                be = ref(uuid++),
                ge = computed(function () {
                    return C.preview && !ve.value
                }),
                xe = function () {
                    ce.value = "normal"
                },
                Pe = function (Me) {
                    ce.value = "error", G("error", Me)
                },
                $e = function (Me) {
                    if (!ae.value) {
                        var Ve = getOffset(Me.target),
                            ke = Ve.left,
                            Ee = Ve.top;
                        pe.value ? (me(be.value), Se({
                            x: ke,
                            y: Ee
                        })) : de.value = {
                            x: ke,
                            y: Ee
                        }
                    }
                    pe.value ? he(!0) : se(!0), G("click", Me)
                },
                ye = function () {
                    se(!1), ae.value || (de.value = null)
                },
                Ce = ref(null);
            watch(function () {
                return Ce
            }, function () {
                ce.value === "loading" && Ce.value.complete && (Ce.value.naturalWidth || Ce.value.naturalHeight) &&
                    xe()
            });
            var we = function () {};
            onMounted(function () {
                watch([ee, ge], function () {
                    if (we(), !pe.value) return function () {};
                    we = _e(be.value, ee.value, ge.value), ge.value || we()
                }, {
                    flush: "post",
                    immediate: !0
                })
            }), onUnmounted(function () {
                we()
            });
            var Oe = function (Me) {
                return isNumber$1(Me) ? Me + "px" : Me
            };
            return function () {
                var Ne = C.prefixCls,
                    Me = C.wrapperClassName,
                    Ve = C.fallback,
                    ke = C.src,
                    Ee = C.placeholder,
                    Ae = C.wrapperStyle,
                    Re = C.rootClassName,
                    He = W.width,
                    je = W.height,
                    Fe = W.crossorigin,
                    Le = W.decoding,
                    Ie = W.alt,
                    Te = W.sizes,
                    De = W.srcset,
                    Ke = W.usemap,
                    We = W.class,
                    Ue = W.style,
                    et = Q.value,
                    Ye = et.icons,
                    ze = et.maskClassName,
                    Be = _objectWithoutProperties$2(et, _excluded$v),
                    Ge = classNames(Ne, Me, Re, _defineProperty$V({}, "".concat(Ne, "-error"), ve.value)),
                    Xe = ve.value && Ve ? Ve : ee.value,
                    nt = {
                        crossorigin: Fe,
                        decoding: Le,
                        alt: Ie,
                        sizes: Te,
                        srcset: De,
                        usemap: Ke,
                        class: classNames("".concat(Ne, "-img"), _defineProperty$V({}, "".concat(Ne,
                            "-img-placeholder"), Ee === !0), We),
                        style: _objectSpread2$1({
                            height: je
                        }, Ue)
                    };
                return createVNode(Fragment, null, [createVNode("div", {
                    class: Ge,
                    onClick: ge.value ? $e : function (it) {
                        G("click", it)
                    },
                    style: _objectSpread2$1({
                        width: Oe(He),
                        height: Oe(je)
                    }, Ae)
                }, [createVNode("img", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({},
                        nt), ve.value && Ve ? {
                        src: Ve
                    } : {
                        onLoad: xe,
                        onError: Pe,
                        src: ke
                    }), {}, {
                        ref: Ce
                    }), null), ce.value === "loading" && createVNode("div", {
                        "aria-hidden": "true",
                        class: "".concat(Ne, "-placeholder")
                    }, [Ee || U.placeholder && U.placeholder()]), U.previewMask && ge.value &&
                    createVNode("div", {
                        class: ["".concat(Ne, "-mask"), ze]
                    }, [U.previewMask()])]), !pe.value && ge.value && createVNode(Preview$1,
                    _objectSpread2$1(_objectSpread2$1({}, Be), {}, {
                        "aria-hidden": !le.value,
                        visible: le.value,
                        prefixCls: Z.value,
                        onClose: ye,
                        mousePosition: de.value,
                        src: Xe,
                        alt: Ie,
                        getContainer: re.value,
                        icons: Ye,
                        rootClassName: Re
                    }), null)])
            }
        }
    });
ImageInternal.PreviewGroup = PreviewGroup$1;
const Image$3 = ImageInternal;
var RotateLeftOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "defs",
            attrs: {},
            children: [{
                tag: "style",
                attrs: {}
            }]
        }, {
            tag: "path",
            attrs: {
                d: "M672 418H144c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H188V494h440v326z"
            }
        }, {
            tag: "path",
            attrs: {
                d: "M819.3 328.5c-78.8-100.7-196-153.6-314.6-154.2l-.2-64c0-6.5-7.6-10.1-12.6-6.1l-128 101c-4 3.1-3.9 9.1 0 12.3L492 318.6c5.1 4 12.7.4 12.6-6.1v-63.9c12.9.1 25.9.9 38.8 2.5 42.1 5.2 82.1 18.2 119 38.7 38.1 21.2 71.2 49.7 98.4 84.3 27.1 34.7 46.7 73.7 58.1 115.8a325.95 325.95 0 016.5 140.9h74.9c14.8-103.6-11.3-213-81-302.3z"
            }
        }]
    },
    name: "rotate-left",
    theme: "outlined"
};
const RotateLeftOutlinedSvg = RotateLeftOutlined$2;

function _objectSpread$t(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$t(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$t(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var RotateLeftOutlined = function (C, H) {
    var W = _objectSpread$t({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$t({}, W, {
        icon: RotateLeftOutlinedSvg
    }), null)
};
RotateLeftOutlined.displayName = "RotateLeftOutlined";
RotateLeftOutlined.inheritAttrs = !1;
const RotateLeftOutlined$1 = RotateLeftOutlined;
var RotateRightOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "defs",
            attrs: {},
            children: [{
                tag: "style",
                attrs: {}
            }]
        }, {
            tag: "path",
            attrs: {
                d: "M480.5 251.2c13-1.6 25.9-2.4 38.8-2.5v63.9c0 6.5 7.5 10.1 12.6 6.1L660 217.6c4-3.2 4-9.2 0-12.3l-128-101c-5.1-4-12.6-.4-12.6 6.1l-.2 64c-118.6.5-235.8 53.4-314.6 154.2A399.75 399.75 0 00123.5 631h74.9c-.9-5.3-1.7-10.7-2.4-16.1-5.1-42.1-2.1-84.1 8.9-124.8 11.4-42.2 31-81.1 58.1-115.8 27.2-34.7 60.3-63.2 98.4-84.3 37-20.6 76.9-33.6 119.1-38.8z"
            }
        }, {
            tag: "path",
            attrs: {
                d: "M880 418H352c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H396V494h440v326z"
            }
        }]
    },
    name: "rotate-right",
    theme: "outlined"
};
const RotateRightOutlinedSvg = RotateRightOutlined$2;

function _objectSpread$s(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$s(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$s(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var RotateRightOutlined = function (C, H) {
    var W = _objectSpread$s({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$s({}, W, {
        icon: RotateRightOutlinedSvg
    }), null)
};
RotateRightOutlined.displayName = "RotateRightOutlined";
RotateRightOutlined.inheritAttrs = !1;
const RotateRightOutlined$1 = RotateRightOutlined;
var ZoomInOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M637 443H519V309c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v134H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h118v134c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V519h118c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z"
            }
        }]
    },
    name: "zoom-in",
    theme: "outlined"
};
const ZoomInOutlinedSvg = ZoomInOutlined$2;

function _objectSpread$r(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$r(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$r(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var ZoomInOutlined = function (C, H) {
    var W = _objectSpread$r({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$r({}, W, {
        icon: ZoomInOutlinedSvg
    }), null)
};
ZoomInOutlined.displayName = "ZoomInOutlined";
ZoomInOutlined.inheritAttrs = !1;
const ZoomInOutlined$1 = ZoomInOutlined;
var ZoomOutOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M637 443H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h312c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z"
            }
        }]
    },
    name: "zoom-out",
    theme: "outlined"
};
const ZoomOutOutlinedSvg = ZoomOutOutlined$2;

function _objectSpread$q(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$q(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$q(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var ZoomOutOutlined = function (C, H) {
    var W = _objectSpread$q({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$q({}, W, {
        icon: ZoomOutOutlinedSvg
    }), null)
};
ZoomOutOutlined.displayName = "ZoomOutOutlined";
ZoomOutOutlined.inheritAttrs = !1;
const ZoomOutOutlined$1 = ZoomOutOutlined;
var icons = {
        rotateLeft: createVNode(RotateLeftOutlined$1, null, null),
        rotateRight: createVNode(RotateRightOutlined$1, null, null),
        zoomIn: createVNode(ZoomInOutlined$1, null, null),
        zoomOut: createVNode(ZoomOutOutlined$1, null, null),
        close: createVNode(CloseOutlined$1, null, null),
        left: createVNode(LeftOutlined$1, null, null),
        right: createVNode(RightOutlined$1, null, null)
    },
    InternalPreviewGroup = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "AImagePreviewGroup",
        inheritAttrs: !1,
        props: {
            previewPrefixCls: String
        },
        setup: function (C, H) {
            var W = H.attrs,
                U = H.slots,
                G = useConfigInject("image", C),
                X = G.getPrefixCls,
                Z = computed(function () {
                    return X("image-preview", C.previewPrefixCls)
                });
            return function () {
                return createVNode(PreviewGroup$1, _objectSpread2$1(_objectSpread2$1({}, _objectSpread2$1(
                    _objectSpread2$1({}, W), C)), {}, {
                    icons,
                    previewPrefixCls: Z.value
                }), U)
            }
        }
    });
const PreviewGroup = InternalPreviewGroup;
var Image$1 = defineComponent({
    name: "AImage",
    inheritAttrs: !1,
    props: imageProps(),
    setup: function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = useConfigInject("image", C),
            X = G.prefixCls,
            Z = G.rootPrefixCls,
            Q = G.configProvider,
            ee = computed(function () {
                var ne = C.preview;
                if (ne === !1) return ne;
                var te = _typeof$2(ne) === "object" ? ne : {};
                return _objectSpread2$1(_objectSpread2$1({
                    icons
                }, te), {}, {
                    transitionName: getTransitionName$2(Z.value, "zoom", te.transitionName),
                    maskTransitionName: getTransitionName$2(Z.value, "fade", te.maskTransitionName)
                })
            });
        return function () {
            var ne, te = ((ne = Q.locale) === null || ne === void 0 ? void 0 : ne.Image) ||
                defaultLocale.Image,
                re = function () {
                    return createVNode("div", {
                        class: "".concat(X.value, "-mask-info")
                    }, [createVNode(EyeOutlined$1, null, null), te == null ? void 0 : te.preview])
                },
                ae = C.previewMask,
                oe = ae === void 0 ? W.previewMask || re : ae;
            return createVNode(Image$3, _objectSpread2$1(_objectSpread2$1({}, _objectSpread2$1(
                _objectSpread2$1(_objectSpread2$1({}, U), C), {}, {
                    prefixCls: X.value
                })), {}, {
                preview: ee.value
            }), _objectSpread2$1(_objectSpread2$1({}, W), {}, {
                previewMask: typeof oe == "function" ? oe : null
            }))
        }
    }
});
Image$1.PreviewGroup = PreviewGroup;
Image$1.install = function (K) {
    return K.component(Image$1.name, Image$1), K.component(Image$1.PreviewGroup.name, Image$1.PreviewGroup), K
};
const Image$2 = Image$1;
var UpOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M890.5 755.3L537.9 269.2c-12.8-17.6-39-17.6-51.7 0L133.5 755.3A8 8 0 00140 768h75c5.1 0 9.9-2.5 12.9-6.6L512 369.8l284.1 391.6c3 4.1 7.8 6.6 12.9 6.6h75c6.5 0 10.3-7.4 6.5-12.7z"
            }
        }]
    },
    name: "up",
    theme: "outlined"
};
const UpOutlinedSvg = UpOutlined$2;

function _objectSpread$p(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$p(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$p(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var UpOutlined = function (C, H) {
    var W = _objectSpread$p({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$p({}, W, {
        icon: UpOutlinedSvg
    }), null)
};
UpOutlined.displayName = "UpOutlined";
UpOutlined.inheritAttrs = !1;
const UpOutlined$1 = UpOutlined;

function supportBigInt() {
    return typeof BigInt == "function"
}

function trimNumber(K) {
    var C = K.trim(),
        H = C.startsWith("-");
    H && (C = C.slice(1)), C = C.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, ""), C.startsWith(
        ".") && (C = "0".concat(C));
    var W = C || "0",
        U = W.split("."),
        G = U[0] || "0",
        X = U[1] || "0";
    G === "0" && X === "0" && (H = !1);
    var Z = H ? "-" : "";
    return {
        negative: H,
        negativeStr: Z,
        trimStr: W,
        integerStr: G,
        decimalStr: X,
        fullStr: "".concat(Z).concat(W)
    }
}

function isE(K) {
    var C = String(K);
    return !Number.isNaN(Number(C)) && C.includes("e")
}

function getNumberPrecision(K) {
    var C = String(K);
    if (isE(K)) {
        var H = Number(C.slice(C.indexOf("e-") + 2)),
            W = C.match(/\.(\d+)/);
        return W != null && W[1] && (H += W[1].length), H
    }
    return C.includes(".") && validateNumber(C) ? C.length - C.indexOf(".") - 1 : 0
}

function num2str(K) {
    var C = String(K);
    if (isE(K)) {
        if (K > Number.MAX_SAFE_INTEGER) return String(supportBigInt() ? BigInt(K).toString() : Number.MAX_SAFE_INTEGER);
        if (K < Number.MIN_SAFE_INTEGER) return String(supportBigInt() ? BigInt(K).toString() : Number.MIN_SAFE_INTEGER);
        C = K.toFixed(getNumberPrecision(C))
    }
    return trimNumber(C).fullStr
}

function validateNumber(K) {
    return typeof K == "number" ? !Number.isNaN(K) : K ? /^\s*-?\d+(\.\d+)?\s*$/.test(K) || /^\s*-?\d+\.\s*$/.test(K) ||
        /^\s*-?\.\d+\s*$/.test(K) : !1
}

function isEmpty(K) {
    return !K && K !== 0 && !Number.isNaN(K) || !String(K).trim()
}
var NumberDecimal = function () {
        function K(C) {
            if (_classCallCheck(this, K), _defineProperty$V(this, "origin", ""), isEmpty(C)) {
                this.empty = !0;
                return
            }
            this.origin = String(C), this.number = Number(C)
        }
        return _createClass(K, [{
            key: "negate",
            value: function () {
                return new K(-this.toNumber())
            }
        }, {
            key: "add",
            value: function (H) {
                if (this.isInvalidate()) return new K(H);
                var W = Number(H);
                if (Number.isNaN(W)) return this;
                var U = this.number + W;
                if (U > Number.MAX_SAFE_INTEGER) return new K(Number.MAX_SAFE_INTEGER);
                if (U < Number.MIN_SAFE_INTEGER) return new K(Number.MIN_SAFE_INTEGER);
                var G = Math.max(getNumberPrecision(this.number), getNumberPrecision(W));
                return new K(U.toFixed(G))
            }
        }, {
            key: "isEmpty",
            value: function () {
                return this.empty
            }
        }, {
            key: "isNaN",
            value: function () {
                return Number.isNaN(this.number)
            }
        }, {
            key: "isInvalidate",
            value: function () {
                return this.isEmpty() || this.isNaN()
            }
        }, {
            key: "equals",
            value: function (H) {
                return this.toNumber() === (H == null ? void 0 : H.toNumber())
            }
        }, {
            key: "lessEquals",
            value: function (H) {
                return this.add(H.negate().toString()).toNumber() <= 0
            }
        }, {
            key: "toNumber",
            value: function () {
                return this.number
            }
        }, {
            key: "toString",
            value: function () {
                var H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
                return H ? this.isInvalidate() ? "" : num2str(this.number) : this.origin
            }
        }]), K
    }(),
    BigIntDecimal = function () {
        function K(C) {
            if (_classCallCheck(this, K), _defineProperty$V(this, "origin", ""), isEmpty(C)) {
                this.empty = !0;
                return
            }
            if (this.origin = String(C), C === "-" || Number.isNaN(C)) {
                this.nan = !0;
                return
            }
            var H = C;
            if (isE(H) && (H = Number(H)), H = typeof H == "string" ? H : num2str(H), validateNumber(H)) {
                var W = trimNumber(H);
                this.negative = W.negative;
                var U = W.trimStr.split(".");
                this.integer = BigInt(U[0]);
                var G = U[1] || "0";
                this.decimal = BigInt(G), this.decimalLen = G.length
            } else this.nan = !0
        }
        return _createClass(K, [{
            key: "getMark",
            value: function () {
                return this.negative ? "-" : ""
            }
        }, {
            key: "getIntegerStr",
            value: function () {
                return this.integer.toString()
            }
        }, {
            key: "getDecimalStr",
            value: function () {
                return this.decimal.toString().padStart(this.decimalLen, "0")
            }
        }, {
            key: "alignDecimal",
            value: function (H) {
                var W = "".concat(this.getMark()).concat(this.getIntegerStr()).concat(this.getDecimalStr()
                    .padEnd(H, "0"));
                return BigInt(W)
            }
        }, {
            key: "negate",
            value: function () {
                var H = new K(this.toString());
                return H.negative = !H.negative, H
            }
        }, {
            key: "add",
            value: function (H) {
                if (this.isInvalidate()) return new K(H);
                var W = new K(H);
                if (W.isInvalidate()) return this;
                var U = Math.max(this.getDecimalStr().length, W.getDecimalStr().length),
                    G = this.alignDecimal(U),
                    X = W.alignDecimal(U),
                    Z = (G + X).toString(),
                    Q = trimNumber(Z),
                    ee = Q.negativeStr,
                    ne = Q.trimStr,
                    te = "".concat(ee).concat(ne.padStart(U + 1, "0"));
                return new K("".concat(te.slice(0, -U), ".").concat(te.slice(-U)))
            }
        }, {
            key: "isEmpty",
            value: function () {
                return this.empty
            }
        }, {
            key: "isNaN",
            value: function () {
                return this.nan
            }
        }, {
            key: "isInvalidate",
            value: function () {
                return this.isEmpty() || this.isNaN()
            }
        }, {
            key: "equals",
            value: function (H) {
                return this.toString() === (H == null ? void 0 : H.toString())
            }
        }, {
            key: "lessEquals",
            value: function (H) {
                return this.add(H.negate().toString()).toNumber() <= 0
            }
        }, {
            key: "toNumber",
            value: function () {
                return this.isNaN() ? NaN : Number(this.toString())
            }
        }, {
            key: "toString",
            value: function () {
                var H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
                return H ? this.isInvalidate() ? "" : trimNumber("".concat(this.getMark()).concat(this.getIntegerStr(),
                    ".").concat(this.getDecimalStr())).fullStr : this.origin
            }
        }]), K
    }();

function getMiniDecimal(K) {
    return supportBigInt() ? new BigIntDecimal(K) : new NumberDecimal(K)
}

function toFixed(K, C, H) {
    var W = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
    if (K === "") return "";
    var U = trimNumber(K),
        G = U.negativeStr,
        X = U.integerStr,
        Z = U.decimalStr,
        Q = "".concat(C).concat(Z),
        ee = "".concat(G).concat(X);
    if (H >= 0) {
        var ne = Number(Z[H]);
        if (ne >= 5 && !W) {
            var te = getMiniDecimal(K).add("".concat(G, "0.").concat("0".repeat(H)).concat(10 - ne));
            return toFixed(te.toString(), C, H, W)
        }
        return H === 0 ? ee : "".concat(ee).concat(C).concat(Z.padEnd(H, "0").slice(0, H))
    }
    return Q === ".0" ? ee : "".concat(ee).concat(Q)
}
var STEP_INTERVAL = 200,
    STEP_DELAY = 600;
const StepHandler = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "StepHandler",
    inheritAttrs: !1,
    props: {
        prefixCls: String,
        upDisabled: Boolean,
        downDisabled: Boolean,
        onStep: {
            type: Function
        }
    },
    slots: ["upNode", "downNode"],
    setup: function (C, H) {
        var W = H.slots,
            U = H.emit,
            G = ref(),
            X = function (ee, ne) {
                ee.preventDefault(), U("step", ne);

                function te() {
                    U("step", ne), G.value = setTimeout(te, STEP_INTERVAL)
                }
                G.value = setTimeout(te, STEP_DELAY)
            },
            Z = function () {
                clearTimeout(G.value)
            };
        return onBeforeUnmount(function () {
                Z()
            }),
            function () {
                if (isMobile$2()) return null;
                var Q = C.prefixCls,
                    ee = C.upDisabled,
                    ne = C.downDisabled,
                    te = "".concat(Q, "-handler"),
                    re = classNames(te, "".concat(te, "-up"), _defineProperty$V({}, "".concat(te,
                        "-up-disabled"), ee)),
                    ae = classNames(te, "".concat(te, "-down"), _defineProperty$V({}, "".concat(te,
                        "-down-disabled"), ne)),
                    oe = {
                        unselectable: "on",
                        role: "button",
                        onMouseup: Z,
                        onMouseleave: Z
                    },
                    ie = W.upNode,
                    ue = W.downNode;
                return createVNode("div", {
                    class: "".concat(te, "-wrap")
                }, [createVNode("span", _objectSpread2$1(_objectSpread2$1({}, oe), {}, {
                    onMousedown: function (se) {
                        X(se, !0)
                    },
                    "aria-label": "Increase Value",
                    "aria-disabled": ee,
                    class: re
                }), [(ie == null ? void 0 : ie()) || createVNode("span", {
                    unselectable: "on",
                    class: "".concat(Q, "-handler-up-inner")
                }, null)]), createVNode("span", _objectSpread2$1(_objectSpread2$1({}, oe), {}, {
                    onMousedown: function (se) {
                        X(se, !1)
                    },
                    "aria-label": "Decrease Value",
                    "aria-disabled": ne,
                    class: ae
                }), [(ue == null ? void 0 : ue()) || createVNode("span", {
                    unselectable: "on",
                    class: "".concat(Q, "-handler-down-inner")
                }, null)])])
            }
    }
});

function useCursor(K, C) {
    var H = ref(null);

    function W() {
        try {
            var G = K.value,
                X = G.selectionStart,
                Z = G.selectionEnd,
                Q = G.value,
                ee = Q.substring(0, X),
                ne = Q.substring(Z);
            H.value = {
                start: X,
                end: Z,
                value: Q,
                beforeTxt: ee,
                afterTxt: ne
            }
        } catch {}
    }

    function U() {
        if (K.value && H.value && C.value) try {
            var G = K.value.value,
                X = H.value,
                Z = X.beforeTxt,
                Q = X.afterTxt,
                ee = X.start,
                ne = G.length;
            if (G.endsWith(Q)) ne = G.length - H.value.afterTxt.length;
            else if (G.startsWith(Z)) ne = Z.length;
            else {
                var te = Z[ee - 1],
                    re = G.indexOf(te, ee - 1);
                re !== -1 && (ne = re + 1)
            }
            K.value.setSelectionRange(ne, ne)
        } catch (ae) {
            "Something warning of cursor restore. Please fire issue about this: ".concat(ae.message)
        }
    }
    return [W, U]
}
const useFrame = function () {
    var K = ref(0),
        C = function () {
            wrapperRaf.cancel(K.value)
        };
    return onBeforeUnmount(function () {
            C()
        }),
        function (H) {
            C(), K.value = wrapperRaf(function () {
                H()
            })
        }
};
var _excluded$u = ["prefixCls", "min", "max", "step", "defaultValue", "value", "disabled", "readonly", "keyboard",
        "controls", "autofocus", "stringMode", "parser", "formatter", "precision", "decimalSeparator", "onChange",
        "onInput", "onPressEnter", "onStep", "lazy", "class", "style"],
    getDecimalValue = function (C, H) {
        return C || H.isEmpty() ? H.toString() : H.toNumber()
    },
    getDecimalIfValidate = function (C) {
        var H = getMiniDecimal(C);
        return H.isInvalidate() ? null : H
    },
    inputNumberProps$1 = function () {
        return {
            stringMode: {
                type: Boolean
            },
            defaultValue: {
                type: [String, Number]
            },
            value: {
                type: [String, Number]
            },
            prefixCls: {
                type: String
            },
            min: {
                type: [String, Number]
            },
            max: {
                type: [String, Number]
            },
            step: {
                type: [String, Number],
                default: 1
            },
            tabindex: {
                type: Number
            },
            controls: {
                type: Boolean,
                default: !0
            },
            readonly: {
                type: Boolean
            },
            disabled: {
                type: Boolean
            },
            autofocus: {
                type: Boolean
            },
            keyboard: {
                type: Boolean,
                default: !0
            },
            parser: {
                type: Function
            },
            formatter: {
                type: Function
            },
            precision: {
                type: Number
            },
            decimalSeparator: {
                type: String
            },
            onInput: {
                type: Function
            },
            onChange: {
                type: Function
            },
            onPressEnter: {
                type: Function
            },
            onStep: {
                type: Function
            },
            onBlur: {
                type: Function
            },
            onFocus: {
                type: Function
            }
        }
    };
const VcInputNumber = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "InnerInputNumber",
    inheritAttrs: !1,
    props: _objectSpread2$1(_objectSpread2$1({}, inputNumberProps$1()), {}, {
        lazy: Boolean
    }),
    slots: ["upHandler", "downHandler"],
    setup: function (C, H) {
        var W = H.attrs,
            U = H.slots,
            G = H.emit,
            X = H.expose,
            Z = ref(),
            Q = ref(!1),
            ee = ref(!1),
            ne = ref(!1),
            te = ref(getMiniDecimal(C.value));

        function re(ke) {
            C.value === void 0 && (te.value = ke)
        }
        var ae = function (Ee, Ae) {
                if (!Ae) return C.precision >= 0 ? C.precision : Math.max(getNumberPrecision(Ee),
                    getNumberPrecision(C.step))
            },
            oe = function (Ee) {
                var Ae = String(Ee);
                if (C.parser) return C.parser(Ae);
                var Re = Ae;
                return C.decimalSeparator && (Re = Re.replace(C.decimalSeparator, ".")), Re.replace(
                    /[^\w.-]+/g, "")
            },
            ie = ref(""),
            ue = function (Ee, Ae) {
                if (C.formatter) return C.formatter(Ee, {
                    userTyping: Ae,
                    input: String(ie.value)
                });
                var Re = typeof Ee == "number" ? num2str(Ee) : Ee;
                if (!Ae) {
                    var He = ae(Re, Ae);
                    if (validateNumber(Re) && (C.decimalSeparator || He >= 0)) {
                        var je = C.decimalSeparator || ".";
                        Re = toFixed(Re, je, He)
                    }
                }
                return Re
            },
            le = function () {
                var ke = C.value;
                return te.value.isInvalidate() && ["string", "number"].includes(_typeof$2(ke)) ? Number.isNaN(
                    ke) ? "" : ke : ue(te.value.toString(), !1)
            }();
        ie.value = le;

        function se(ke, Ee) {
            ie.value = ue(ke.isInvalidate() ? ke.toString(!1) : ke.toString(!Ee), Ee)
        }
        var ce = computed(function () {
                return getDecimalIfValidate(C.max)
            }),
            de = computed(function () {
                return getDecimalIfValidate(C.min)
            }),
            ve = computed(function () {
                return !ce.value || !te.value || te.value.isInvalidate() ? !1 : ce.value.lessEquals(te.value)
            }),
            fe = computed(function () {
                return !de.value || !te.value || te.value.isInvalidate() ? !1 : te.value.lessEquals(de.value)
            }),
            pe = useCursor(Z, Q),
            me = _slicedToArray$2(pe, 2),
            he = me[0],
            Se = me[1],
            _e = function (Ee) {
                return ce.value && !Ee.lessEquals(ce.value) ? ce.value : de.value && !de.value.lessEquals(
                    Ee) ? de.value : null
            },
            be = function (Ee) {
                return !_e(Ee)
            },
            ge = function (Ee, Ae) {
                var Re = Ee,
                    He = be(Re) || Re.isEmpty();
                if (!Re.isEmpty() && !Ae && (Re = _e(Re) || Re, He = !0), !C.readonly && !C.disabled && He) {
                    var je = Re.toString(),
                        Fe = ae(je, Ae);
                    if (Fe >= 0 && (Re = getMiniDecimal(toFixed(je, ".", Fe))), !Re.equals(te.value)) {
                        var Le;
                        re(Re), (Le = C.onChange) === null || Le === void 0 || Le.call(C, Re.isEmpty() ?
                            null : getDecimalValue(C.stringMode, Re)), C.value === void 0 && se(Re, Ae)
                    }
                    return Re
                }
                return te.value
            },
            xe = useFrame(),
            Pe = function ke(Ee) {
                var Ae;
                if (he(), ie.value = Ee, !ne.value) {
                    var Re = oe(Ee),
                        He = getMiniDecimal(Re);
                    He.isNaN() || ge(He, !0)
                }(Ae = C.onInput) === null || Ae === void 0 || Ae.call(C, Ee), xe(function () {
                    var je = Ee;
                    C.parser || (je = Ee.replace(//g, ".")), je !== Ee && ke(je)
                })
            },
            $e = function () {
                ne.value = !0
            },
            ye = function () {
                ne.value = !1, Pe(Z.value.value)
            },
            Ce = function (Ee) {
                Pe(Ee.target.value)
            },
            we = function (Ee) {
                var Ae, Re;
                if (!(Ee && ve.value || !Ee && fe.value)) {
                    ee.value = !1;
                    var He = getMiniDecimal(C.step);
                    Ee || (He = He.negate());
                    var je = (te.value || getMiniDecimal(0)).add(He.toString()),
                        Fe = ge(je, !1);
                    (Ae = C.onStep) === null || Ae === void 0 || Ae.call(C, getDecimalValue(C.stringMode,
                        Fe), {
                        offset: C.step,
                        type: Ee ? "up" : "down"
                    }), (Re = Z.value) === null || Re === void 0 || Re.focus()
                }
            },
            Oe = function (Ee) {
                var Ae = getMiniDecimal(oe(ie.value)),
                    Re = Ae;
                Ae.isNaN() ? Re = te.value : Re = ge(Ae, Ee), C.value !== void 0 ? se(te.value, !1) : Re.isNaN() ||
                    se(Re, !1)
            },
            Ne = function (Ee) {
                var Ae = Ee.which;
                if (ee.value = !0, Ae === KeyCode$1.ENTER) {
                    var Re;
                    ne.value || (ee.value = !1), Oe(!1), (Re = C.onPressEnter) === null || Re === void 0 ||
                        Re.call(C, Ee)
                }
                C.keyboard !== !1 && !ne.value && [KeyCode$1.UP, KeyCode$1.DOWN].includes(Ae) && (we(
                    KeyCode$1.UP === Ae), Ee.preventDefault())
            },
            Me = function () {
                ee.value = !1
            },
            Ve = function (Ee) {
                Oe(!1), Q.value = !1, ee.value = !1, G("blur", Ee)
            };
        return watch(function () {
                return C.precision
            }, function () {
                te.value.isInvalidate() || se(te.value, !1)
            }, {
                flush: "post"
            }), watch(function () {
                return C.value
            }, function () {
                var ke = getMiniDecimal(C.value);
                te.value = ke;
                var Ee = getMiniDecimal(oe(ie.value));
                (!ke.equals(Ee) || !ee.value || C.formatter) && se(ke, ee.value)
            }, {
                flush: "post"
            }), watch(ie, function () {
                C.formatter && Se()
            }, {
                flush: "post"
            }), watch(function () {
                return C.disabled
            }, function (ke) {
                ke && (Q.value = !1)
            }), X({
                focus: function () {
                    var Ee;
                    (Ee = Z.value) === null || Ee === void 0 || Ee.focus()
                },
                blur: function () {
                    var Ee;
                    (Ee = Z.value) === null || Ee === void 0 || Ee.blur()
                }
            }),
            function () {
                var ke, Ee = _objectSpread2$1(_objectSpread2$1({}, W), C),
                    Ae = Ee.prefixCls,
                    Re = Ae === void 0 ? "rc-input-number" : Ae,
                    He = Ee.min,
                    je = Ee.max,
                    Fe = Ee.step,
                    Le = Fe === void 0 ? 1 : Fe;
                Ee.defaultValue, Ee.value;
                var Ie = Ee.disabled,
                    Te = Ee.readonly;
                Ee.keyboard;
                var De = Ee.controls,
                    Ke = De === void 0 ? !0 : De,
                    We = Ee.autofocus;
                Ee.stringMode, Ee.parser, Ee.formatter, Ee.precision, Ee.decimalSeparator, Ee.onChange, Ee.onInput,
                    Ee.onPressEnter, Ee.onStep;
                var Ue = Ee.lazy,
                    et = Ee.class,
                    Ye = Ee.style,
                    ze = _objectWithoutProperties$2(Ee, _excluded$u),
                    Be = U.upHandler,
                    Ge = U.downHandler,
                    Xe = "".concat(Re, "-input"),
                    nt = {};
                return Ue ? nt.onChange = Ce : nt.onInput = Ce, createVNode("div", {
                    class: classNames(Re, et, (ke = {}, _defineProperty$V(ke, "".concat(Re,
                            "-focused"), Q.value), _defineProperty$V(ke, "".concat(Re,
                            "-disabled"), Ie), _defineProperty$V(ke, "".concat(Re,
                            "-readonly"), Te), _defineProperty$V(ke, "".concat(Re,
                            "-not-a-number"), te.value.isNaN()), _defineProperty$V(ke, "".concat(
                            Re, "-out-of-range"), !te.value.isInvalidate() && !be(te.value)),
                        ke)),
                    style: Ye,
                    onKeydown: Ne,
                    onKeyup: Me
                }, [Ke && createVNode(StepHandler, {
                    prefixCls: Re,
                    upDisabled: ve.value,
                    downDisabled: fe.value,
                    onStep: we
                }, {
                    upNode: Be,
                    downNode: Ge
                }), createVNode("div", {
                    class: "".concat(Xe, "-wrap")
                }, [createVNode("input", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                    autofocus: We,
                    autocomplete: "off",
                    role: "spinbutton",
                    "aria-valuemin": He,
                    "aria-valuemax": je,
                    "aria-valuenow": te.value.isInvalidate() ? null : te
                        .value.toString(),
                    step: Le
                }, ze), {}, {
                    ref: Z,
                    class: Xe,
                    value: ie.value,
                    disabled: Ie,
                    readonly: Te,
                    onFocus: function (ft) {
                        Q.value = !0, G("focus", ft)
                    }
                }, nt), {}, {
                    onBlur: Ve,
                    onCompositionstart: $e,
                    onCompositionend: ye
                }), null)])])
            }
    }
});

function isValidValue(K) {
    return K != null
}
var _excluded$t = ["class", "bordered", "readonly", "style", "addonBefore", "addonAfter", "prefix", "valueModifiers"],
    baseProps$1 = inputNumberProps$1(),
    inputNumberProps = function () {
        return _objectSpread2$1(_objectSpread2$1({}, baseProps$1), {}, {
            size: {
                type: String
            },
            bordered: {
                type: Boolean,
                default: !0
            },
            placeholder: String,
            name: String,
            id: String,
            type: String,
            addonBefore: PropTypes$1.any,
            addonAfter: PropTypes$1.any,
            prefix: PropTypes$1.any,
            "onUpdate:value": baseProps$1.onChange,
            valueModifiers: Object
        })
    },
    InputNumber = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "AInputNumber",
        inheritAttrs: !1,
        props: inputNumberProps(),
        slots: ["addonBefore", "addonAfter", "prefix"],
        setup: function (C, H) {
            var W = H.emit,
                U = H.expose,
                G = H.attrs,
                X = H.slots,
                Z = useInjectFormItemContext(),
                Q = useConfigInject("input-number", C),
                ee = Q.prefixCls,
                ne = Q.size,
                te = Q.direction,
                re = ref(C.value === void 0 ? C.defaultValue : C.value),
                ae = ref(!1);
            watch(function () {
                return C.value
            }, function () {
                re.value = C.value
            });
            var oe = ref(null),
                ie = function () {
                    var ve;
                    (ve = oe.value) === null || ve === void 0 || ve.focus()
                },
                ue = function () {
                    var ve;
                    (ve = oe.value) === null || ve === void 0 || ve.blur()
                };
            U({
                focus: ie,
                blur: ue
            });
            var le = function (ve) {
                    C.value === void 0 && (re.value = ve), W("update:value", ve), W("change", ve), Z.onFieldChange()
                },
                se = function (ve) {
                    ae.value = !1, W("blur", ve), Z.onFieldBlur()
                },
                ce = function (ve) {
                    ae.value = !0, W("focus", ve)
                };
            return function () {
                var de, ve, fe, pe, me = _objectSpread2$1(_objectSpread2$1({}, G), C),
                    he = me.class,
                    Se = me.bordered,
                    _e = me.readonly,
                    be = me.style,
                    ge = me.addonBefore,
                    xe = ge === void 0 ? (de = X.addonBefore) === null || de === void 0 ? void 0 : de.call(
                        X) : ge,
                    Pe = me.addonAfter,
                    $e = Pe === void 0 ? (ve = X.addonAfter) === null || ve === void 0 ? void 0 : ve.call(X) :
                    Pe,
                    ye = me.prefix,
                    Ce = ye === void 0 ? (fe = X.prefix) === null || fe === void 0 ? void 0 : fe.call(X) :
                    ye,
                    we = me.valueModifiers,
                    Oe = we === void 0 ? {} : we,
                    Ne = _objectWithoutProperties$2(me, _excluded$t),
                    Me = ee.value,
                    Ve = ne.value,
                    ke = classNames((pe = {}, _defineProperty$V(pe, "".concat(Me, "-lg"), Ve === "large"),
                        _defineProperty$V(pe, "".concat(Me, "-sm"), Ve === "small"), _defineProperty$V(
                            pe, "".concat(Me, "-rtl"), te.value === "rtl"), _defineProperty$V(pe, "".concat(
                            Me, "-readonly"), _e), _defineProperty$V(pe, "".concat(Me, "-borderless"),
                            !Se), pe), he),
                    Ee = createVNode(VcInputNumber, _objectSpread2$1(_objectSpread2$1({}, omit$2(Ne, [
                        "size", "defaultValue"])), {}, {
                        ref: oe,
                        lazy: !!Oe.lazy,
                        value: re.value,
                        class: ke,
                        prefixCls: Me,
                        readonly: _e,
                        onChange: le,
                        onBlur: se,
                        onFocus: ce
                    }), {
                        upHandler: function () {
                            return createVNode(UpOutlined$1, {
                                class: "".concat(Me, "-handler-up-inner")
                            }, null)
                        },
                        downHandler: function () {
                            return createVNode(DownOutlined$1, {
                                class: "".concat(Me, "-handler-down-inner")
                            }, null)
                        }
                    }),
                    Ae = isValidValue(xe) || isValidValue($e);
                if (isValidValue(Ce)) {
                    var Re, He = classNames("".concat(Me, "-affix-wrapper"), (Re = {}, _defineProperty$V(Re,
                            "".concat(Me, "-affix-wrapper-focused"), ae.value), _defineProperty$V(
                            Re, "".concat(Me, "-affix-wrapper-disabled"), C.disabled),
                        _defineProperty$V(Re, "".concat(Me, "-affix-wrapper-rtl"), te.value ===
                            "rtl"), _defineProperty$V(Re, "".concat(Me, "-affix-wrapper-readonly"),
                            _e), _defineProperty$V(Re, "".concat(Me, "-affix-wrapper-borderless"),
                            !Se), _defineProperty$V(Re, "".concat(he), !Ae && he), Re));
                    Ee = createVNode("div", {
                        class: He,
                        style: be,
                        onMouseup: function () {
                            return oe.value.focus()
                        }
                    }, [createVNode("span", {
                        class: "".concat(Me, "-prefix")
                    }, [Ce]), Ee])
                }
                if (Ae) {
                    var je, Fe = "".concat(Me, "-group"),
                        Le = "".concat(Fe, "-addon"),
                        Ie = xe ? createVNode("div", {
                            class: Le
                        }, [xe]) : null,
                        Te = $e ? createVNode("div", {
                            class: Le
                        }, [$e]) : null,
                        De = classNames("".concat(Me, "-wrapper"), Fe, _defineProperty$V({}, "".concat(Fe,
                            "-rtl"), te.value === "rtl")),
                        Ke = classNames("".concat(Me, "-group-wrapper"), (je = {}, _defineProperty$V(je, ""
                            .concat(Me, "-group-wrapper-sm"), Ve === "small"), _defineProperty$V(je,
                            "".concat(Me, "-group-wrapper-lg"), Ve === "large"), _defineProperty$V(
                            je, "".concat(Me, "-group-wrapper-rtl"), te.value === "rtl"), je), he);
                    Ee = createVNode("div", {
                        class: Ke,
                        style: be
                    }, [createVNode("div", {
                        class: De
                    }, [Ie, Ee, Te])])
                }
                return cloneElement(Ee, {
                    style: be
                })
            }
        }
    });
const index$d = _extends$1(InputNumber, {
    install: function (C) {
        return C.component(InputNumber.name, InputNumber), C
    }
});
var basicProps = function () {
    return {
        prefixCls: String,
        hasSider: {
            type: Boolean,
            default: void 0
        },
        tagName: String
    }
};

function generator(K) {
    var C = K.suffixCls,
        H = K.tagName,
        W = K.name;
    return function (U) {
        var G = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: W,
            props: basicProps(),
            setup: function (Z, Q) {
                var ee = Q.slots,
                    ne = useConfigInject(C, Z),
                    te = ne.prefixCls;
                return function () {
                    var re = _objectSpread2$1(_objectSpread2$1({}, Z), {}, {
                        prefixCls: te.value,
                        tagName: H
                    });
                    return createVNode(U, re, ee)
                }
            }
        });
        return G
    }
}
var Basic = defineComponent({
        compatConfig: {
            MODE: 3
        },
        props: basicProps(),
        setup: function (C, H) {
            var W = H.slots;
            return function () {
                return createVNode(C.tagName, {
                    class: C.prefixCls
                }, W)
            }
        }
    }),
    BasicLayout = defineComponent({
        compatConfig: {
            MODE: 3
        },
        props: basicProps(),
        setup: function (C, H) {
            var W = H.slots,
                U = useConfigInject("", C),
                G = U.direction,
                X = ref([]),
                Z = {
                    addSider: function (ne) {
                        X.value = [].concat(_toConsumableArray(X.value), [ne])
                    },
                    removeSider: function (ne) {
                        X.value = X.value.filter(function (te) {
                            return te !== ne
                        })
                    }
                };
            provide(SiderHookProviderKey, Z);
            var Q = computed(function () {
                var ee, ne = C.prefixCls,
                    te = C.hasSider;
                return ee = {}, _defineProperty$V(ee, "".concat(ne), !0), _defineProperty$V(ee, "".concat(
                        ne, "-has-sider"), typeof te == "boolean" ? te : X.value.length > 0),
                    _defineProperty$V(ee, "".concat(ne, "-rtl"), G.value === "rtl"), ee
            });
            return function () {
                var ee = C.tagName;
                return createVNode(ee, {
                    class: Q.value
                }, W)
            }
        }
    }),
    Layout = generator({
        suffixCls: "layout",
        tagName: "section",
        name: "ALayout"
    })(BasicLayout),
    Header$1 = generator({
        suffixCls: "layout-header",
        tagName: "header",
        name: "ALayoutHeader"
    })(Basic),
    Footer$1 = generator({
        suffixCls: "layout-footer",
        tagName: "footer",
        name: "ALayoutFooter"
    })(Basic),
    Content = generator({
        suffixCls: "layout-content",
        tagName: "main",
        name: "ALayoutContent"
    })(Basic);
const Layout$1 = Layout;
var BarsOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "0 0 1024 1024",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0z"
            }
        }]
    },
    name: "bars",
    theme: "outlined"
};
const BarsOutlinedSvg = BarsOutlined$2;

function _objectSpread$o(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$o(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$o(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var BarsOutlined = function (C, H) {
    var W = _objectSpread$o({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$o({}, W, {
        icon: BarsOutlinedSvg
    }), null)
};
BarsOutlined.displayName = "BarsOutlined";
BarsOutlined.inheritAttrs = !1;
const BarsOutlined$1 = BarsOutlined;
var dimensionMaxMap = {
        xs: "479.98px",
        sm: "575.98px",
        md: "767.98px",
        lg: "991.98px",
        xl: "1199.98px",
        xxl: "1599.98px",
        xxxl: "1999.98px"
    },
    siderProps = function () {
        return {
            prefixCls: String,
            collapsible: {
                type: Boolean,
                default: void 0
            },
            collapsed: {
                type: Boolean,
                default: void 0
            },
            defaultCollapsed: {
                type: Boolean,
                default: void 0
            },
            reverseArrow: {
                type: Boolean,
                default: void 0
            },
            zeroWidthTriggerStyle: {
                type: Object,
                default: void 0
            },
            trigger: PropTypes$1.any,
            width: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
            collapsedWidth: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
            breakpoint: PropTypes$1.oneOf(tuple$1("xs", "sm", "md", "lg", "xl", "xxl", "xxxl")),
            theme: PropTypes$1.oneOf(tuple$1("light", "dark")).def("dark"),
            onBreakpoint: Function,
            onCollapse: Function
        }
    },
    generateId = function () {
        var K = 0;
        return function () {
            var C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
            return K += 1, "".concat(C).concat(K)
        }
    }();
const Sider = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ALayoutSider",
    inheritAttrs: !1,
    props: initDefaultProps$1(siderProps(), {
        collapsible: !1,
        defaultCollapsed: !1,
        reverseArrow: !1,
        width: 200,
        collapsedWidth: 80
    }),
    emits: ["breakpoint", "update:collapsed", "collapse"],
    setup: function (C, H) {
        var W = H.emit,
            U = H.attrs,
            G = H.slots,
            X = useConfigInject("layout-sider", C),
            Z = X.prefixCls,
            Q = inject(SiderHookProviderKey, void 0),
            ee = ref(!!(C.collapsed !== void 0 ? C.collapsed : C.defaultCollapsed)),
            ne = ref(!1);
        watch(function () {
            return C.collapsed
        }, function () {
            ee.value = !!C.collapsed
        }), provide(SiderCollapsedKey, ee);
        var te = function (se, ce) {
                C.collapsed === void 0 && (ee.value = se), W("update:collapsed", se), W("collapse", se, ce)
            },
            re = ref(function (le) {
                ne.value = le.matches, W("breakpoint", le.matches), ee.value !== le.matches && te(le.matches,
                    "responsive")
            }),
            ae;

        function oe(le) {
            return re.value(le)
        }
        var ie = generateId("ant-sider-");
        Q && Q.addSider(ie), onMounted(function () {
            watch(function () {
                return C.breakpoint
            }, function () {
                try {
                    var le;
                    (le = ae) === null || le === void 0 || le.removeEventListener("change",
                        oe)
                } catch {
                    var se;
                    (se = ae) === null || se === void 0 || se.removeListener(oe)
                }
                if (typeof window < "u") {
                    var ce = window,
                        de = ce.matchMedia;
                    if (de && C.breakpoint && C.breakpoint in dimensionMaxMap) {
                        ae = de("(max-width: ".concat(dimensionMaxMap[C.breakpoint], ")"));
                        try {
                            ae.addEventListener("change", oe)
                        } catch {
                            ae.addListener(oe)
                        }
                        oe(ae)
                    }
                }
            }, {
                immediate: !0
            })
        }), onBeforeUnmount(function () {
            try {
                var le;
                (le = ae) === null || le === void 0 || le.removeEventListener("change", oe)
            } catch {
                var se;
                (se = ae) === null || se === void 0 || se.removeListener(oe)
            }
            Q && Q.removeSider(ie)
        });
        var ue = function () {
            te(!ee.value, "clickTrigger")
        };
        return function () {
            var le, se, ce, de = Z.value,
                ve = C.collapsedWidth,
                fe = C.width,
                pe = C.reverseArrow,
                me = C.zeroWidthTriggerStyle,
                he = C.trigger,
                Se = he === void 0 ? (le = G.trigger) === null || le === void 0 ? void 0 : le.call(G) :
                he,
                _e = C.collapsible,
                be = C.theme,
                ge = ee.value ? ve : fe,
                xe = isNumeric$2(ge) ? "".concat(ge, "px") : String(ge),
                Pe = parseFloat(String(ve || 0)) === 0 ? createVNode("span", {
                    onClick: ue,
                    class: classNames("".concat(de, "-zero-width-trigger"), "".concat(de,
                        "-zero-width-trigger-").concat(pe ? "right" : "left")),
                    style: me
                }, [Se || createVNode(BarsOutlined$1, null, null)]) : null,
                $e = {
                    expanded: createVNode(pe ? RightOutlined$1 : LeftOutlined$1, null, null),
                    collapsed: createVNode(pe ? LeftOutlined$1 : RightOutlined$1, null, null)
                },
                ye = ee.value ? "collapsed" : "expanded",
                Ce = $e[ye],
                we = Se !== null ? Pe || createVNode("div", {
                    class: "".concat(de, "-trigger"),
                    onClick: ue,
                    style: {
                        width: xe
                    }
                }, [Se || Ce]) : null,
                Oe = [U.style, {
                    flex: "0 0 ".concat(xe),
                    maxWidth: xe,
                    minWidth: xe,
                    width: xe
                }],
                Ne = classNames(de, "".concat(de, "-").concat(be), (se = {}, _defineProperty$V(se, "".concat(
                    de, "-collapsed"), !!ee.value), _defineProperty$V(se, "".concat(de,
                    "-has-trigger"), _e && Se !== null && !Pe), _defineProperty$V(se, "".concat(
                    de, "-below"), !!ne.value), _defineProperty$V(se, "".concat(de,
                    "-zero-width"), parseFloat(xe) === 0), se), U.class);
            return createVNode("aside", _objectSpread2$1(_objectSpread2$1({}, U), {}, {
                class: Ne,
                style: Oe
            }), [createVNode("div", {
                    class: "".concat(de, "-children")
                }, [(ce = G.default) === null || ce === void 0 ? void 0 : ce.call(G)]), _e ||
                ne.value && Pe ? we : null])
        }
    }
});
var LayoutHeader = Header$1,
    LayoutFooter = Footer$1,
    LayoutSider = Sider,
    LayoutContent = Content;
const index$c = _extends$1(Layout$1, {
    Header: Header$1,
    Footer: Footer$1,
    Content,
    Sider,
    install: function (C) {
        return C.component(Layout$1.name, Layout$1), C.component(Header$1.name, Header$1), C.component(
                Footer$1.name, Footer$1), C.component(Sider.name, Sider), C.component(Content.name, Content),
            C
    }
});
var _excluded$s = ["class", "style"],
    spinProps = function () {
        return {
            prefixCls: String,
            spinning: {
                type: Boolean,
                default: void 0
            },
            size: String,
            wrapperClassName: String,
            tip: PropTypes$1.any,
            delay: Number,
            indicator: PropTypes$1.any
        }
    },
    defaultIndicator = null;

function shouldDelay(K, C) {
    return !!K && !!C && !isNaN(Number(C))
}

function setDefaultIndicator(K) {
    var C = K.indicator;
    defaultIndicator = typeof C == "function" ? C : function () {
        return createVNode(C, null, null)
    }
}
const Spin = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ASpin",
    inheritAttrs: !1,
    props: initDefaultProps$1(spinProps(), {
        size: "default",
        spinning: !0,
        wrapperClassName: ""
    }),
    setup: function () {
        return {
            originalUpdateSpinning: null,
            configProvider: inject("configProvider", defaultConfigProvider)
        }
    },
    data: function () {
        var C = this.spinning,
            H = this.delay,
            W = shouldDelay(C, H);
        return {
            sSpinning: C && !W
        }
    },
    created: function () {
        this.originalUpdateSpinning = this.updateSpinning, this.debouncifyUpdateSpinning(this.$props)
    },
    mounted: function () {
        this.updateSpinning()
    },
    updated: function () {
        var C = this;
        nextTick(function () {
            C.debouncifyUpdateSpinning(), C.updateSpinning()
        })
    },
    beforeUnmount: function () {
        this.cancelExistingSpin()
    },
    methods: {
        debouncifyUpdateSpinning: function (C) {
            var H = C || this.$props,
                W = H.delay;
            W && (this.cancelExistingSpin(), this.updateSpinning = debounce(this.originalUpdateSpinning, W))
        },
        updateSpinning: function () {
            var C = this.spinning,
                H = this.sSpinning;
            H !== C && (this.sSpinning = C)
        },
        cancelExistingSpin: function () {
            var C = this.updateSpinning;
            C && C.cancel && C.cancel()
        },
        renderIndicator: function (C) {
            var H = "".concat(C, "-dot"),
                W = getComponent(this, "indicator");
            return W === null ? null : (Array.isArray(W) && (W = W.length === 1 ? W[0] : W), isVNode(W) ?
                cloneVNode(W, {
                    class: H
                }) : defaultIndicator && isVNode(defaultIndicator()) ? cloneVNode(defaultIndicator(), {
                    class: H
                }) : createVNode("span", {
                    class: "".concat(H, " ").concat(C, "-dot-spin")
                }, [createVNode("i", {
                    class: "".concat(C, "-dot-item")
                }, null), createVNode("i", {
                    class: "".concat(C, "-dot-item")
                }, null), createVNode("i", {
                    class: "".concat(C, "-dot-item")
                }, null), createVNode("i", {
                    class: "".concat(C, "-dot-item")
                }, null)]))
        }
    },
    render: function () {
        var C, H, W, U = this.$props,
            G = U.size,
            X = U.prefixCls,
            Z = U.tip,
            Q = Z === void 0 ? (C = (H = this.$slots).tip) === null || C === void 0 ? void 0 : C.call(H) :
            Z,
            ee = U.wrapperClassName,
            ne = this.$attrs,
            te = ne.class,
            re = ne.style,
            ae = _objectWithoutProperties$2(ne, _excluded$s),
            oe = this.configProvider,
            ie = oe.getPrefixCls,
            ue = oe.direction,
            le = ie("spin", X),
            se = this.sSpinning,
            ce = (W = {}, _defineProperty$V(W, le, !0), _defineProperty$V(W, "".concat(le, "-sm"), G ===
                "small"), _defineProperty$V(W, "".concat(le, "-lg"), G === "large"), _defineProperty$V(
                W, "".concat(le, "-spinning"), se), _defineProperty$V(W, "".concat(le, "-show-text"), !
                !Q), _defineProperty$V(W, "".concat(le, "-rtl"), ue === "rtl"), _defineProperty$V(W, te,
                !!te), W),
            de = createVNode("div", _objectSpread2$1(_objectSpread2$1({}, ae), {}, {
                style: re,
                class: ce
            }), [this.renderIndicator(le), Q ? createVNode("div", {
                class: "".concat(le, "-text")
            }, [Q]) : null]),
            ve = getSlot(this);
        if (ve && ve.length) {
            var fe, pe = (fe = {}, _defineProperty$V(fe, "".concat(le, "-container"), !0),
                _defineProperty$V(fe, "".concat(le, "-blur"), se), fe);
            return createVNode("div", {
                class: ["".concat(le, "-nested-loading"), ee]
            }, [se && createVNode("div", {
                key: "loading"
            }, [de]), createVNode("div", {
                class: pe,
                key: "container"
            }, [ve])])
        }
        return de
    }
});
Spin.setDefaultIndicator = setDefaultIndicator;
Spin.install = function (K) {
    return K.component(Spin.name, Spin), K
};
var DoubleLeftOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z"
            }
        }]
    },
    name: "double-left",
    theme: "outlined"
};
const DoubleLeftOutlinedSvg = DoubleLeftOutlined$2;

function _objectSpread$n(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$n(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$n(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var DoubleLeftOutlined = function (C, H) {
    var W = _objectSpread$n({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$n({}, W, {
        icon: DoubleLeftOutlinedSvg
    }), null)
};
DoubleLeftOutlined.displayName = "DoubleLeftOutlined";
DoubleLeftOutlined.inheritAttrs = !1;
const DoubleLeftOutlined$1 = DoubleLeftOutlined;
var DoubleRightOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z"
            }
        }]
    },
    name: "double-right",
    theme: "outlined"
};
const DoubleRightOutlinedSvg = DoubleRightOutlined$2;

function _objectSpread$m(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$m(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$m(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var DoubleRightOutlined = function (C, H) {
    var W = _objectSpread$m({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$m({}, W, {
        icon: DoubleRightOutlinedSvg
    }), null)
};
DoubleRightOutlined.displayName = "DoubleRightOutlined";
DoubleRightOutlined.inheritAttrs = !1;
const DoubleRightOutlined$1 = DoubleRightOutlined,
    MiniSelect = defineComponent({
        compatConfig: {
            MODE: 3
        },
        inheritAttrs: !1,
        props: selectProps(),
        Option: VcSelect.Option,
        setup: function (C, H) {
            var W = H.attrs,
                U = H.slots;
            return function () {
                var G = _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                    size: "small"
                }, W);
                return createVNode(VcSelect, G, U)
            }
        }
    }),
    Pager = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "Pager",
        inheritAttrs: !1,
        props: {
            rootPrefixCls: String,
            page: Number,
            active: {
                type: Boolean,
                default: void 0
            },
            last: {
                type: Boolean,
                default: void 0
            },
            locale: PropTypes$1.object,
            showTitle: {
                type: Boolean,
                default: void 0
            },
            itemRender: {
                type: Function,
                default: function () {}
            },
            onClick: {
                type: Function
            },
            onKeypress: {
                type: Function
            }
        },
        eimt: ["click", "keypress"],
        setup: function (C, H) {
            var W = H.emit,
                U = H.attrs,
                G = function () {
                    W("click", C.page)
                },
                X = function (Q) {
                    W("keypress", Q, G, C.page)
                };
            return function () {
                var Z, Q = C.showTitle,
                    ee = C.page,
                    ne = C.itemRender,
                    te = U.class,
                    re = U.style,
                    ae = "".concat(C.rootPrefixCls, "-item"),
                    oe = classNames(ae, "".concat(ae, "-").concat(C.page), (Z = {}, _defineProperty$V(Z, ""
                        .concat(ae, "-active"), C.active), _defineProperty$V(Z, "".concat(ae,
                        "-disabled"), !C.page), Z), te);
                return createVNode("li", {
                    onClick: G,
                    onKeypress: X,
                    title: Q ? String(ee) : null,
                    tabindex: "0",
                    class: oe,
                    style: re
                }, [ne({
                    page: ee,
                    type: "page",
                    originalElement: createVNode("a", {
                        rel: "nofollow"
                    }, [ee])
                })])
            }
        }
    }),
    KEYCODE = {
        ZERO: 48,
        NINE: 57,
        NUMPAD_ZERO: 96,
        NUMPAD_NINE: 105,
        BACKSPACE: 8,
        DELETE: 46,
        ENTER: 13,
        ARROW_UP: 38,
        ARROW_DOWN: 40
    },
    Options = defineComponent({
        compatConfig: {
            MODE: 3
        },
        props: {
            disabled: {
                type: Boolean,
                default: void 0
            },
            changeSize: Function,
            quickGo: Function,
            selectComponentClass: PropTypes$1.any,
            current: Number,
            pageSizeOptions: PropTypes$1.array.def(["10", "20", "50", "100"]),
            pageSize: Number,
            buildOptionText: Function,
            locale: PropTypes$1.object,
            rootPrefixCls: String,
            selectPrefixCls: String,
            goButton: PropTypes$1.any
        },
        setup: function (C) {
            var H = ref(""),
                W = computed(function () {
                    return !H.value || isNaN(H.value) ? void 0 : Number(H.value)
                }),
                U = function (ne) {
                    return "".concat(ne.value, " ").concat(C.locale.items_per_page)
                },
                G = function (ne) {
                    var te = ne.target,
                        re = te.value,
                        ae = te.composing;
                    ne.isComposing || ae || H.value === re || (H.value = re)
                },
                X = function (ne) {
                    var te = C.goButton,
                        re = C.quickGo,
                        ae = C.rootPrefixCls;
                    if (!(te || H.value === ""))
                        if (ne.relatedTarget && (ne.relatedTarget.className.indexOf("".concat(ae, "-item-link")) >=
                                0 || ne.relatedTarget.className.indexOf("".concat(ae, "-item")) >= 0)) {
                            H.value = "";
                            return
                        } else re(W.value), H.value = ""
                },
                Z = function (ne) {
                    H.value !== "" && (ne.keyCode === KEYCODE.ENTER || ne.type === "click") && (C.quickGo(W.value),
                        H.value = "")
                },
                Q = computed(function () {
                    var ee = C.pageSize,
                        ne = C.pageSizeOptions;
                    return ne.some(function (te) {
                        return te.toString() === ee.toString()
                    }) ? ne : ne.concat([ee.toString()]).sort(function (te, re) {
                        var ae = isNaN(Number(te)) ? 0 : Number(te),
                            oe = isNaN(Number(re)) ? 0 : Number(re);
                        return ae - oe
                    })
                });
            return function () {
                var ee = C.rootPrefixCls,
                    ne = C.locale,
                    te = C.changeSize,
                    re = C.quickGo,
                    ae = C.goButton,
                    oe = C.selectComponentClass,
                    ie = C.selectPrefixCls,
                    ue = C.pageSize,
                    le = C.disabled,
                    se = "".concat(ee, "-options"),
                    ce = null,
                    de = null,
                    ve = null;
                if (!te && !re) return null;
                if (te && oe) {
                    var fe = C.buildOptionText || U,
                        pe = Q.value.map(function (me, he) {
                            return createVNode(oe.Option, {
                                key: he,
                                value: me
                            }, {
                                default: function () {
                                    return [fe({
                                        value: me
                                    })]
                                }
                            })
                        });
                    ce = createVNode(oe, {
                        disabled: le,
                        prefixCls: ie,
                        showSearch: !1,
                        class: "".concat(se, "-size-changer"),
                        optionLabelProp: "children",
                        value: (ue || Q.value[0]).toString(),
                        onChange: function (he) {
                            return te(Number(he))
                        },
                        getPopupContainer: function (he) {
                            return he.parentNode
                        }
                    }, {
                        default: function () {
                            return [pe]
                        }
                    })
                }
                return re && (ae && (ve = typeof ae == "boolean" ? createVNode("button", {
                    type: "button",
                    onClick: Z,
                    onKeyup: Z,
                    disabled: le,
                    class: "".concat(se, "-quick-jumper-button")
                }, [ne.jump_to_confirm]) : createVNode("span", {
                    onClick: Z,
                    onKeyup: Z
                }, [ae])), de = createVNode("div", {
                    class: "".concat(se, "-quick-jumper")
                }, [ne.jump_to, withDirectives(createVNode("input", {
                    disabled: le,
                    type: "text",
                    value: H.value,
                    onInput: G,
                    onChange: G,
                    onKeyup: Z,
                    onBlur: X
                }, null), [[antInputDirective]]), ne.page, ve])), createVNode("li", {
                    class: "".concat(se)
                }, [ce, de])
            }
        }
    }),
    LOCALE = {
        items_per_page: "/",
        jump_to: "",
        jump_to_confirm: "",
        page: "",
        prev_page: "",
        next_page: "",
        prev_5: " 5 ",
        next_5: " 5 ",
        prev_3: " 3 ",
        next_3: " 3 "
    };
var _excluded$r = ["class"];

function isInteger(K) {
    return typeof K == "number" && isFinite(K) && Math.floor(K) === K
}

function defaultItemRender(K) {
    var C = K.originalElement;
    return C
}

function calculatePage(K, C, H) {
    var W = typeof K > "u" ? C.statePageSize : K;
    return Math.floor((H.total - 1) / W) + 1
}
const VcPagination = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Pagination",
    mixins: [BaseMixin],
    inheritAttrs: !1,
    props: {
        disabled: {
            type: Boolean,
            default: void 0
        },
        prefixCls: PropTypes$1.string.def("rc-pagination"),
        selectPrefixCls: PropTypes$1.string.def("rc-select"),
        current: Number,
        defaultCurrent: PropTypes$1.number.def(1),
        total: PropTypes$1.number.def(0),
        pageSize: Number,
        defaultPageSize: PropTypes$1.number.def(10),
        hideOnSinglePage: {
            type: Boolean,
            default: !1
        },
        showSizeChanger: {
            type: Boolean,
            default: void 0
        },
        showLessItems: {
            type: Boolean,
            default: !1
        },
        selectComponentClass: PropTypes$1.any,
        showPrevNextJumpers: {
            type: Boolean,
            default: !0
        },
        showQuickJumper: PropTypes$1.oneOfType([PropTypes$1.looseBool, PropTypes$1.object]).def(!1),
        showTitle: {
            type: Boolean,
            default: !0
        },
        pageSizeOptions: PropTypes$1.arrayOf(PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string])),
        buildOptionText: Function,
        showTotal: Function,
        simple: {
            type: Boolean,
            default: void 0
        },
        locale: PropTypes$1.object.def(LOCALE),
        itemRender: PropTypes$1.func.def(defaultItemRender),
        prevIcon: PropTypes$1.any,
        nextIcon: PropTypes$1.any,
        jumpPrevIcon: PropTypes$1.any,
        jumpNextIcon: PropTypes$1.any,
        totalBoundaryShowSizeChanger: PropTypes$1.number.def(50)
    },
    data: function () {
        var C = this.$props,
            H = firstNotUndefined([this.current, this.defaultCurrent]),
            W = firstNotUndefined([this.pageSize, this.defaultPageSize]);
        return H = Math.min(H, calculatePage(W, void 0, C)), {
            stateCurrent: H,
            stateCurrentInputValue: H,
            statePageSize: W
        }
    },
    watch: {
        current: function (C) {
            this.setState({
                stateCurrent: C,
                stateCurrentInputValue: C
            })
        },
        pageSize: function (C) {
            var H = {},
                W = this.stateCurrent,
                U = calculatePage(C, this.$data, this.$props);
            W = W > U ? U : W, hasProp(this, "current") || (H.stateCurrent = W, H.stateCurrentInputValue =
                W), H.statePageSize = C, this.setState(H)
        },
        stateCurrent: function (C, H) {
            var W = this;
            this.$nextTick(function () {
                if (W.$refs.paginationNode) {
                    var U = W.$refs.paginationNode.querySelector(".".concat(W.prefixCls, "-item-").concat(
                        H));
                    U && document.activeElement === U && U.blur()
                }
            })
        },
        total: function () {
            var C = {},
                H = calculatePage(this.pageSize, this.$data, this.$props);
            if (hasProp(this, "current")) {
                var W = Math.min(this.current, H);
                C.stateCurrent = W, C.stateCurrentInputValue = W
            } else {
                var U = this.stateCurrent;
                U === 0 && H > 0 ? U = 1 : U = Math.min(this.stateCurrent, H), C.stateCurrent = U
            }
            this.setState(C)
        }
    },
    methods: {
        getJumpPrevPage: function () {
            return Math.max(1, this.stateCurrent - (this.showLessItems ? 3 : 5))
        },
        getJumpNextPage: function () {
            return Math.min(calculatePage(void 0, this.$data, this.$props), this.stateCurrent + (this.showLessItems ?
                3 : 5))
        },
        getItemIcon: function (C, H) {
            var W = this.$props.prefixCls,
                U = getComponent(this, C, this.$props) || createVNode("button", {
                    type: "button",
                    "aria-label": H,
                    class: "".concat(W, "-item-link")
                }, null);
            return U
        },
        getValidValue: function (C) {
            var H = C.target.value,
                W = calculatePage(void 0, this.$data, this.$props),
                U = this.$data.stateCurrentInputValue,
                G;
            return H === "" ? G = H : isNaN(Number(H)) ? G = U : H >= W ? G = W : G = Number(H), G
        },
        isValid: function (C) {
            return isInteger(C) && C !== this.stateCurrent
        },
        shouldDisplayQuickJumper: function () {
            var C = this.$props,
                H = C.showQuickJumper,
                W = C.pageSize,
                U = C.total;
            return U <= W ? !1 : H
        },
        handleKeyDown: function (C) {
            (C.keyCode === KEYCODE.ARROW_UP || C.keyCode === KEYCODE.ARROW_DOWN) && C.preventDefault()
        },
        handleKeyUp: function (C) {
            if (!(C.isComposing || C.target.composing)) {
                var H = this.getValidValue(C),
                    W = this.stateCurrentInputValue;
                H !== W && this.setState({
                        stateCurrentInputValue: H
                    }), C.keyCode === KEYCODE.ENTER ? this.handleChange(H) : C.keyCode === KEYCODE.ARROW_UP ?
                    this.handleChange(H - 1) : C.keyCode === KEYCODE.ARROW_DOWN && this.handleChange(H + 1)
            }
        },
        changePageSize: function (C) {
            var H = this.stateCurrent,
                W = H,
                U = calculatePage(C, this.$data, this.$props);
            H = H > U ? U : H, U === 0 && (H = this.stateCurrent), typeof C == "number" && (hasProp(this,
                "pageSize") || this.setState({
                statePageSize: C
            }), hasProp(this, "current") || this.setState({
                stateCurrent: H,
                stateCurrentInputValue: H
            })), this.__emit("update:pageSize", C), H !== W && this.__emit("update:current", H), this.__emit(
                "showSizeChange", H, C), this.__emit("change", H, C)
        },
        handleChange: function (C) {
            var H = this.$props.disabled,
                W = C;
            if (this.isValid(W) && !H) {
                var U = calculatePage(void 0, this.$data, this.$props);
                return W > U ? W = U : W < 1 && (W = 1), hasProp(this, "current") || this.setState({
                    stateCurrent: W,
                    stateCurrentInputValue: W
                }), this.__emit("update:current", W), this.__emit("change", W, this.statePageSize), W
            }
            return this.stateCurrent
        },
        prev: function () {
            this.hasPrev() && this.handleChange(this.stateCurrent - 1)
        },
        next: function () {
            this.hasNext() && this.handleChange(this.stateCurrent + 1)
        },
        jumpPrev: function () {
            this.handleChange(this.getJumpPrevPage())
        },
        jumpNext: function () {
            this.handleChange(this.getJumpNextPage())
        },
        hasPrev: function () {
            return this.stateCurrent > 1
        },
        hasNext: function () {
            return this.stateCurrent < calculatePage(void 0, this.$data, this.$props)
        },
        getShowSizeChanger: function () {
            var C = this.$props,
                H = C.showSizeChanger,
                W = C.total,
                U = C.totalBoundaryShowSizeChanger;
            return typeof H < "u" ? H : W > U
        },
        runIfEnter: function (C, H) {
            if (C.key === "Enter" || C.charCode === 13) {
                for (var W = arguments.length, U = new Array(W > 2 ? W - 2 : 0), G = 2; G < W; G++) U[G - 2] =
                    arguments[G];
                H.apply(void 0, U)
            }
        },
        runIfEnterPrev: function (C) {
            this.runIfEnter(C, this.prev)
        },
        runIfEnterNext: function (C) {
            this.runIfEnter(C, this.next)
        },
        runIfEnterJumpPrev: function (C) {
            this.runIfEnter(C, this.jumpPrev)
        },
        runIfEnterJumpNext: function (C) {
            this.runIfEnter(C, this.jumpNext)
        },
        handleGoTO: function (C) {
            (C.keyCode === KEYCODE.ENTER || C.type === "click") && this.handleChange(this.stateCurrentInputValue)
        },
        renderPrev: function (C) {
            var H = this.$props.itemRender,
                W = H({
                    page: C,
                    type: "prev",
                    originalElement: this.getItemIcon("prevIcon", "prev page")
                }),
                U = !this.hasPrev();
            return isValidElement(W) ? cloneElement(W, U ? {
                disabled: U
            } : {}) : W
        },
        renderNext: function (C) {
            var H = this.$props.itemRender,
                W = H({
                    page: C,
                    type: "next",
                    originalElement: this.getItemIcon("nextIcon", "next page")
                }),
                U = !this.hasNext();
            return isValidElement(W) ? cloneElement(W, U ? {
                disabled: U
            } : {}) : W
        }
    },
    render: function () {
        var C, H = this.$props,
            W = H.prefixCls,
            U = H.disabled,
            G = H.hideOnSinglePage,
            X = H.total,
            Z = H.locale,
            Q = H.showQuickJumper,
            ee = H.showLessItems,
            ne = H.showTitle,
            te = H.showTotal,
            re = H.simple,
            ae = H.itemRender,
            oe = H.showPrevNextJumpers,
            ie = H.jumpPrevIcon,
            ue = H.jumpNextIcon,
            le = H.selectComponentClass,
            se = H.selectPrefixCls,
            ce = H.pageSizeOptions,
            de = this.stateCurrent,
            ve = this.statePageSize,
            fe = splitAttrs(this.$attrs).extraAttrs,
            pe = fe.class,
            me = _objectWithoutProperties$2(fe, _excluded$r);
        if (G === !0 && this.total <= ve) return null;
        var he = calculatePage(void 0, this.$data, this.$props),
            Se = [],
            _e = null,
            be = null,
            ge = null,
            xe = null,
            Pe = null,
            $e = Q && Q.goButton,
            ye = ee ? 1 : 2,
            Ce = de - 1 > 0 ? de - 1 : 0,
            we = de + 1 < he ? de + 1 : he,
            Oe = this.hasPrev(),
            Ne = this.hasNext();
        if (re) return $e && (typeof $e == "boolean" ? Pe = createVNode("button", {
            type: "button",
            onClick: this.handleGoTO,
            onKeyup: this.handleGoTO
        }, [Z.jump_to_confirm]) : Pe = createVNode("span", {
            onClick: this.handleGoTO,
            onKeyup: this.handleGoTO
        }, [$e]), Pe = createVNode("li", {
            title: ne ? "".concat(Z.jump_to).concat(de, "/").concat(he) : null,
            class: "".concat(W, "-simple-pager")
        }, [Pe])), createVNode("ul", _objectSpread2$1({
            class: classNames("".concat(W, " ").concat(W, "-simple"), _defineProperty$V({},
                "".concat(W, "-disabled"), U), pe)
        }, me), [createVNode("li", {
            title: ne ? Z.prev_page : null,
            onClick: this.prev,
            tabindex: Oe ? 0 : null,
            onKeypress: this.runIfEnterPrev,
            class: classNames("".concat(W, "-prev"), _defineProperty$V({}, "".concat(W,
                "-disabled"), !Oe)),
            "aria-disabled": !Oe
        }, [this.renderPrev(Ce)]), createVNode("li", {
            title: ne ? "".concat(de, "/").concat(he) : null,
            class: "".concat(W, "-simple-pager")
        }, [withDirectives(createVNode("input", {
            type: "text",
            value: this.stateCurrentInputValue,
            disabled: U,
            onKeydown: this.handleKeyDown,
            onKeyup: this.handleKeyUp,
            onInput: this.handleKeyUp,
            onChange: this.handleKeyUp,
            size: "3"
        }, null), [[antInputDirective]]), createVNode("span", {
            class: "".concat(W, "-slash")
        }, [createTextVNode("")]), he]), createVNode("li", {
            title: ne ? Z.next_page : null,
            onClick: this.next,
            tabindex: Ne ? 0 : null,
            onKeypress: this.runIfEnterNext,
            class: classNames("".concat(W, "-next"), _defineProperty$V({}, "".concat(W,
                "-disabled"), !Ne)),
            "aria-disabled": !Ne
        }, [this.renderNext(we)]), Pe]);
        if (he <= 3 + ye * 2) {
            var Me = {
                locale: Z,
                rootPrefixCls: W,
                showTitle: ne,
                itemRender: ae,
                onClick: this.handleChange,
                onKeypress: this.runIfEnter
            };
            he || Se.push(createVNode(Pager, _objectSpread2$1(_objectSpread2$1({}, Me), {}, {
                key: "noPager",
                page: 1,
                class: "".concat(W, "-item-disabled")
            }), null));
            for (var Ve = 1; Ve <= he; Ve += 1) {
                var ke = de === Ve;
                Se.push(createVNode(Pager, _objectSpread2$1(_objectSpread2$1({}, Me), {}, {
                    key: Ve,
                    page: Ve,
                    active: ke
                }), null))
            }
        } else {
            var Ee = ee ? Z.prev_3 : Z.prev_5,
                Ae = ee ? Z.next_3 : Z.next_5;
            oe && (_e = createVNode("li", {
                title: this.showTitle ? Ee : null,
                key: "prev",
                onClick: this.jumpPrev,
                tabindex: "0",
                onKeypress: this.runIfEnterJumpPrev,
                class: classNames("".concat(W, "-jump-prev"), _defineProperty$V({}, "".concat(W,
                    "-jump-prev-custom-icon"), !!ie))
            }, [ae({
                page: this.getJumpPrevPage(),
                type: "jump-prev",
                originalElement: this.getItemIcon("jumpPrevIcon", "prev page")
            })]), be = createVNode("li", {
                title: this.showTitle ? Ae : null,
                key: "next",
                tabindex: "0",
                onClick: this.jumpNext,
                onKeypress: this.runIfEnterJumpNext,
                class: classNames("".concat(W, "-jump-next"), _defineProperty$V({}, "".concat(W,
                    "-jump-next-custom-icon"), !!ue))
            }, [ae({
                page: this.getJumpNextPage(),
                type: "jump-next",
                originalElement: this.getItemIcon("jumpNextIcon", "next page")
            })])), xe = createVNode(Pager, {
                locale: Z,
                last: !0,
                rootPrefixCls: W,
                onClick: this.handleChange,
                onKeypress: this.runIfEnter,
                key: he,
                page: he,
                active: !1,
                showTitle: ne,
                itemRender: ae
            }, null), ge = createVNode(Pager, {
                locale: Z,
                rootPrefixCls: W,
                onClick: this.handleChange,
                onKeypress: this.runIfEnter,
                key: 1,
                page: 1,
                active: !1,
                showTitle: ne,
                itemRender: ae
            }, null);
            var Re = Math.max(1, de - ye),
                He = Math.min(de + ye, he);
            de - 1 <= ye && (He = 1 + ye * 2), he - de <= ye && (Re = he - ye * 2);
            for (var je = Re; je <= He; je += 1) {
                var Fe = de === je;
                Se.push(createVNode(Pager, {
                    locale: Z,
                    rootPrefixCls: W,
                    onClick: this.handleChange,
                    onKeypress: this.runIfEnter,
                    key: je,
                    page: je,
                    active: Fe,
                    showTitle: ne,
                    itemRender: ae
                }, null))
            }
            de - 1 >= ye * 2 && de !== 1 + 2 && (Se[0] = createVNode(Pager, {
                locale: Z,
                rootPrefixCls: W,
                onClick: this.handleChange,
                onKeypress: this.runIfEnter,
                key: Re,
                page: Re,
                class: "".concat(W, "-item-after-jump-prev"),
                active: !1,
                showTitle: this.showTitle,
                itemRender: ae
            }, null), Se.unshift(_e)), he - de >= ye * 2 && de !== he - 2 && (Se[Se.length - 1] =
                createVNode(Pager, {
                    locale: Z,
                    rootPrefixCls: W,
                    onClick: this.handleChange,
                    onKeypress: this.runIfEnter,
                    key: He,
                    page: He,
                    class: "".concat(W, "-item-before-jump-next"),
                    active: !1,
                    showTitle: this.showTitle,
                    itemRender: ae
                }, null), Se.push(be)), Re !== 1 && Se.unshift(ge), He !== he && Se.push(xe)
        }
        var Le = null;
        te && (Le = createVNode("li", {
            class: "".concat(W, "-total-text")
        }, [te(X, [X === 0 ? 0 : (de - 1) * ve + 1, de * ve > X ? X : de * ve])]));
        var Ie = !Oe || !he,
            Te = !Ne || !he,
            De = this.buildOptionText || this.$slots.buildOptionText;
        return createVNode("ul", _objectSpread2$1(_objectSpread2$1({
            unselectable: "on",
            ref: "paginationNode"
        }, me), {}, {
            class: classNames((C = {}, _defineProperty$V(C, "".concat(W), !0),
                _defineProperty$V(C, "".concat(W, "-disabled"), U), C), pe)
        }), [Le, createVNode("li", {
            title: ne ? Z.prev_page : null,
            onClick: this.prev,
            tabindex: Ie ? null : 0,
            onKeypress: this.runIfEnterPrev,
            class: classNames("".concat(W, "-prev"), _defineProperty$V({}, "".concat(W,
                "-disabled"), Ie)),
            "aria-disabled": Ie
        }, [this.renderPrev(Ce)]), Se, createVNode("li", {
            title: ne ? Z.next_page : null,
            onClick: this.next,
            tabindex: Te ? null : 0,
            onKeypress: this.runIfEnterNext,
            class: classNames("".concat(W, "-next"), _defineProperty$V({}, "".concat(W,
                "-disabled"), Te)),
            "aria-disabled": Te
        }, [this.renderNext(we)]), createVNode(Options, {
            disabled: U,
            locale: Z,
            rootPrefixCls: W,
            selectComponentClass: le,
            selectPrefixCls: se,
            changeSize: this.getShowSizeChanger() ? this.changePageSize : null,
            current: de,
            pageSize: ve,
            pageSizeOptions: ce,
            buildOptionText: De || null,
            quickGo: this.shouldDisplayQuickJumper() ? this.handleChange : null,
            goButton: $e
        }, null)])
    }
});
var _excluded$q = ["size", "itemRender", "buildOptionText", "selectComponentClass", "responsive"],
    paginationProps = function () {
        return {
            total: Number,
            defaultCurrent: Number,
            disabled: {
                type: Boolean,
                default: void 0
            },
            current: Number,
            defaultPageSize: Number,
            pageSize: Number,
            hideOnSinglePage: {
                type: Boolean,
                default: void 0
            },
            showSizeChanger: {
                type: Boolean,
                default: void 0
            },
            pageSizeOptions: Array,
            buildOptionText: Function,
            showQuickJumper: {
                type: [Boolean, Object],
                default: void 0
            },
            showTotal: Function,
            size: String,
            simple: {
                type: Boolean,
                default: void 0
            },
            locale: Object,
            prefixCls: String,
            selectPrefixCls: String,
            totalBoundaryShowSizeChanger: Number,
            selectComponentClass: String,
            itemRender: Function,
            role: String,
            responsive: Boolean,
            showLessItems: {
                type: Boolean,
                default: void 0
            },
            onChange: Function,
            onShowSizeChange: Function,
            "onUpdate:current": Function,
            "onUpdate:pageSize": Function
        }
    };
const Pagination$1 = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "APagination",
        inheritAttrs: !1,
        props: paginationProps(),
        setup: function (C, H) {
            var W = H.slots,
                U = H.attrs,
                G = useConfigInject("pagination", C),
                X = G.prefixCls,
                Z = G.configProvider,
                Q = G.direction,
                ee = computed(function () {
                    return Z.getPrefixCls("select", C.selectPrefixCls)
                }),
                ne = useBreakpoint(),
                te = useLocaleReceiver("Pagination", enUS$1, toRef(C, "locale")),
                re = _slicedToArray$2(te, 1),
                ae = re[0],
                oe = function (ue) {
                    var le = createVNode("span", {
                            class: "".concat(ue, "-item-ellipsis")
                        }, [createTextVNode("")]),
                        se = createVNode("button", {
                            class: "".concat(ue, "-item-link"),
                            type: "button",
                            tabindex: -1
                        }, [createVNode(LeftOutlined$1, null, null)]),
                        ce = createVNode("button", {
                            class: "".concat(ue, "-item-link"),
                            type: "button",
                            tabindex: -1
                        }, [createVNode(RightOutlined$1, null, null)]),
                        de = createVNode("a", {
                            rel: "nofollow",
                            class: "".concat(ue, "-item-link")
                        }, [createVNode("div", {
                            class: "".concat(ue, "-item-container")
                        }, [createVNode(DoubleLeftOutlined$1, {
                            class: "".concat(ue, "-item-link-icon")
                        }, null), le])]),
                        ve = createVNode("a", {
                            rel: "nofollow",
                            class: "".concat(ue, "-item-link")
                        }, [createVNode("div", {
                            class: "".concat(ue, "-item-container")
                        }, [createVNode(DoubleRightOutlined$1, {
                            class: "".concat(ue, "-item-link-icon")
                        }, null), le])]);
                    if (Q.value === "rtl") {
                        var fe = [ce, se];
                        se = fe[0], ce = fe[1];
                        var pe = [ve, de];
                        de = pe[0], ve = pe[1]
                    }
                    return {
                        prevIcon: se,
                        nextIcon: ce,
                        jumpPrevIcon: de,
                        jumpNextIcon: ve
                    }
                };
            return function () {
                var ie, ue = C.size,
                    le = C.itemRender,
                    se = le === void 0 ? W.itemRender : le,
                    ce = C.buildOptionText,
                    de = ce === void 0 ? W.buildOptionText : ce,
                    ve = C.selectComponentClass,
                    fe = C.responsive,
                    pe = _objectWithoutProperties$2(C, _excluded$q),
                    me = ue === "small" || !!((ie = ne.value) !== null && ie !== void 0 && ie.xs && !ue &&
                        fe),
                    he = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, pe), oe(X.value)), {}, {
                        prefixCls: X.value,
                        selectPrefixCls: ee.value,
                        selectComponentClass: ve || (me ? MiniSelect : VcSelect),
                        locale: ae.value,
                        buildOptionText: de
                    }, U), {}, {
                        class: classNames(_defineProperty$V({
                            mini: me
                        }, "".concat(X.value, "-rtl"), Q.value === "rtl"), U.class),
                        itemRender: se
                    });
                return createVNode(VcPagination, he, null)
            }
        }
    }),
    Pagination = withInstall(Pagination$1);
var listItemMetaProps = function () {
    return {
        avatar: PropTypes$1.any,
        description: PropTypes$1.any,
        prefixCls: String,
        title: PropTypes$1.any
    }
};
const ItemMeta = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AListItemMeta",
    props: listItemMetaProps(),
    displayName: "AListItemMeta",
    __ANT_LIST_ITEM_META: !0,
    slots: ["avatar", "description", "title"],
    setup: function (C, H) {
        var W = H.slots,
            U = useConfigInject("list", C),
            G = U.prefixCls;
        return function () {
            var X, Z, Q, ee, ne, te, re = "".concat(G.value, "-item-meta"),
                ae = (X = C.title) !== null && X !== void 0 ? X : (Z = W.title) === null || Z === void 0 ?
                void 0 : Z.call(W),
                oe = (Q = C.description) !== null && Q !== void 0 ? Q : (ee = W.description) === null ||
                ee === void 0 ? void 0 : ee.call(W),
                ie = (ne = C.avatar) !== null && ne !== void 0 ? ne : (te = W.avatar) === null || te ===
                void 0 ? void 0 : te.call(W),
                ue = createVNode("div", {
                    class: "".concat(G.value, "-item-meta-content")
                }, [ae && createVNode("h4", {
                    class: "".concat(G.value, "-item-meta-title")
                }, [ae]), oe && createVNode("div", {
                    class: "".concat(G.value, "-item-meta-description")
                }, [oe])]);
            return createVNode("div", {
                class: re
            }, [ie && createVNode("div", {
                class: "".concat(G.value, "-item-meta-avatar")
            }, [ie]), (ae || oe) && ue])
        }
    }
});
var ListContextKey = Symbol("ListContextKey"),
    _excluded$p = ["class"],
    listItemProps$1 = function () {
        return {
            prefixCls: String,
            extra: PropTypes$1.any,
            actions: PropTypes$1.array,
            grid: Object,
            colStyle: {
                type: Object,
                default: void 0
            }
        }
    };
const Item = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AListItem",
    inheritAttrs: !1,
    Meta: ItemMeta,
    props: listItemProps$1(),
    slots: ["actions", "extra"],
    setup: function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = inject(ListContextKey, {
                grid: ref(),
                itemLayout: ref()
            }),
            X = G.itemLayout,
            Z = G.grid,
            Q = useConfigInject("list", C),
            ee = Q.prefixCls,
            ne = function () {
                var ae, oe = ((ae = W.default) === null || ae === void 0 ? void 0 : ae.call(W)) || [],
                    ie;
                return oe.forEach(function (ue) {
                    isStringElement(ue) && !isEmptyElement(ue) && (ie = !0)
                }), ie && oe.length > 1
            },
            te = function () {
                var ae, oe, ie = (ae = C.extra) !== null && ae !== void 0 ? ae : (oe = W.extra) === null ||
                    oe === void 0 ? void 0 : oe.call(W);
                return X.value === "vertical" ? !!ie : !ne()
            };
        return function () {
            var re, ae, oe, ie, ue, le = U.class,
                se = _objectWithoutProperties$2(U, _excluded$p),
                ce = ee.value,
                de = (re = C.extra) !== null && re !== void 0 ? re : (ae = W.extra) === null || ae ===
                void 0 ? void 0 : ae.call(W),
                ve = (oe = W.default) === null || oe === void 0 ? void 0 : oe.call(W),
                fe = (ie = C.actions) !== null && ie !== void 0 ? ie : flattenChildren((ue = W.actions) ===
                    null || ue === void 0 ? void 0 : ue.call(W));
            fe = fe && !Array.isArray(fe) ? [fe] : fe;
            var pe = fe && fe.length > 0 && createVNode("ul", {
                    class: "".concat(ce, "-item-action"),
                    key: "actions"
                }, [fe.map(function (Se, _e) {
                    return createVNode("li", {
                        key: "".concat(ce, "-item-action-").concat(_e)
                    }, [Se, _e !== fe.length - 1 && createVNode("em", {
                        class: "".concat(ce, "-item-action-split")
                    }, null)])
                })]),
                me = Z.value ? "div" : "li",
                he = createVNode(me, _objectSpread2$1(_objectSpread2$1({}, se), {}, {
                    class: classNames("".concat(ce, "-item"), _defineProperty$V({}, "".concat(
                        ce, "-item-no-flex"), !te()), le)
                }), {
                    default: function () {
                        return [X.value === "vertical" && de ? [createVNode("div", {
                            class: "".concat(ce, "-item-main"),
                            key: "content"
                        }, [ve, pe]), createVNode("div", {
                            class: "".concat(ce, "-item-extra"),
                            key: "extra"
                        }, [de])] : [ve, pe, cloneElement(de, {
                            key: "extra"
                        })]]
                    }
                });
            return Z.value ? createVNode(Col$1, {
                flex: 1,
                style: C.colStyle
            }, {
                default: function () {
                    return [he]
                }
            }) : he
        }
    }
});
var listProps = function () {
        return {
            bordered: {
                type: Boolean,
                default: void 0
            },
            dataSource: PropTypes$1.array,
            extra: PropTypes$1.any,
            grid: {
                type: Object,
                default: void 0
            },
            itemLayout: String,
            loading: {
                type: [Boolean, Object],
                default: void 0
            },
            loadMore: PropTypes$1.any,
            pagination: {
                type: [Boolean, Object],
                default: void 0
            },
            prefixCls: String,
            rowKey: [String, Number, Function],
            renderItem: Function,
            size: String,
            split: {
                type: Boolean,
                default: void 0
            },
            header: PropTypes$1.any,
            footer: PropTypes$1.any,
            locale: {
                type: Object
            }
        }
    },
    List$1 = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "AList",
        Item,
        props: initDefaultProps$1(listProps(), {
            dataSource: [],
            bordered: !1,
            split: !0,
            loading: !1,
            pagination: !1
        }),
        slots: ["extra", "loadMore", "renderItem", "header", "footer"],
        setup: function (C, H) {
            var W, U, G = H.slots;
            provide(ListContextKey, {
                grid: toRef(C, "grid"),
                itemLayout: toRef(C, "itemLayout")
            });
            var X = {
                    current: 1,
                    total: 0
                },
                Z = useConfigInject("list", C),
                Q = Z.prefixCls,
                ee = Z.direction,
                ne = Z.renderEmpty,
                te = computed(function () {
                    return C.pagination && _typeof$2(C.pagination) === "object" ? C.pagination : {}
                }),
                re = ref((W = te.value.defaultCurrent) !== null && W !== void 0 ? W : 1),
                ae = ref((U = te.value.defaultPageSize) !== null && U !== void 0 ? U : 10);
            watch(te, function () {
                "current" in te.value && (re.value = te.value.current), "pageSize" in te.value && (ae.value =
                    te.value.pageSize)
            });
            var oe = [],
                ie = function (xe) {
                    return function (Pe, $e) {
                        re.value = Pe, ae.value = $e, te.value[xe] && te.value[xe](Pe, $e)
                    }
                },
                ue = ie("onChange"),
                le = ie("onShowSizeChange"),
                se = function (xe) {
                    var Pe;
                    return createVNode("div", {
                        class: "".concat(Q.value, "-empty-text")
                    }, [((Pe = C.locale) === null || Pe === void 0 ? void 0 : Pe.emptyText) || xe(
                        "List")])
                },
                ce = computed(function () {
                    return typeof C.loading == "boolean" ? {
                        spinning: C.loading
                    } : C.loading
                }),
                de = computed(function () {
                    return ce.value && ce.value.spinning
                }),
                ve = computed(function () {
                    var ge = "";
                    switch (C.size) {
                        case "large":
                            ge = "lg";
                            break;
                        case "small":
                            ge = "sm";
                            break
                    }
                    return ge
                }),
                fe = computed(function () {
                    var ge;
                    return ge = {}, _defineProperty$V(ge, "".concat(Q.value), !0), _defineProperty$V(ge, ""
                            .concat(Q.value, "-vertical"), C.itemLayout === "vertical"), _defineProperty$V(
                            ge, "".concat(Q.value, "-").concat(ve.value), ve.value), _defineProperty$V(ge,
                            "".concat(Q.value, "-split"), C.split), _defineProperty$V(ge, "".concat(Q.value,
                            "-bordered"), C.bordered), _defineProperty$V(ge, "".concat(Q.value, "-loading"),
                            de.value), _defineProperty$V(ge, "".concat(Q.value, "-grid"), !!C.grid),
                        _defineProperty$V(ge, "".concat(Q.value, "-rtl"), ee.value === "rtl"), ge
                }),
                pe = computed(function () {
                    var ge = _objectSpread2$1(_objectSpread2$1({}, X), {}, {
                            total: C.dataSource.length,
                            current: re.value,
                            pageSize: ae.value
                        }, C.pagination || {}),
                        xe = Math.ceil(ge.total / ge.pageSize);
                    return ge.current > xe && (ge.current = xe), ge
                }),
                me = computed(function () {
                    var ge = _toConsumableArray(C.dataSource);
                    return C.pagination && C.dataSource.length > (pe.value.current - 1) * pe.value.pageSize &&
                        (ge = _toConsumableArray(C.dataSource).splice((pe.value.current - 1) * pe.value.pageSize,
                            pe.value.pageSize)), ge
                }),
                he = useBreakpoint(),
                Se = eagerComputed(function () {
                    for (var ge = 0; ge < responsiveArray.length; ge += 1) {
                        var xe = responsiveArray[ge];
                        if (he.value[xe]) return xe
                    }
                }),
                _e = computed(function () {
                    if (C.grid) {
                        var ge = Se.value && C.grid[Se.value] ? C.grid[Se.value] : C.grid.column;
                        if (ge) return {
                            width: "".concat(100 / ge, "%"),
                            maxWidth: "".concat(100 / ge, "%")
                        }
                    }
                }),
                be = function (xe, Pe) {
                    var $e, ye = ($e = C.renderItem) !== null && $e !== void 0 ? $e : G.renderItem;
                    if (!ye) return null;
                    var Ce, we = _typeof$2(C.rowKey);
                    return we === "function" ? Ce = C.rowKey(xe) : we === "string" || we === "number" ? Ce = xe[
                        C.rowKey] : Ce = xe.key, Ce || (Ce = "list-item-".concat(Pe)), oe[Pe] = Ce, ye({
                        item: xe,
                        index: Pe
                    })
                };
            return function () {
                var ge, xe, Pe, $e, ye, Ce, we, Oe = (ge = C.loadMore) !== null && ge !== void 0 ? ge : (xe =
                        G.loadMore) === null || xe === void 0 ? void 0 : xe.call(G),
                    Ne = (Pe = C.footer) !== null && Pe !== void 0 ? Pe : ($e = G.footer) === null || $e ===
                    void 0 ? void 0 : $e.call(G),
                    Me = (ye = C.header) !== null && ye !== void 0 ? ye : (Ce = G.header) === null || Ce ===
                    void 0 ? void 0 : Ce.call(G),
                    Ve = flattenChildren((we = G.default) === null || we === void 0 ? void 0 : we.call(G)),
                    ke = !!(Oe || C.pagination || Ne),
                    Ee = _objectSpread2$1(_objectSpread2$1({}, fe.value), {}, _defineProperty$V({}, "".concat(
                        Q.value, "-something-after-last-item"), ke)),
                    Ae = C.pagination ? createVNode("div", {
                        class: "".concat(Q.value, "-pagination")
                    }, [createVNode(Pagination, _objectSpread2$1(_objectSpread2$1({}, pe.value), {}, {
                        onChange: ue,
                        onShowSizeChange: le
                    }), null)]) : null,
                    Re = de.value && createVNode("div", {
                        style: {
                            minHeight: "53px"
                        }
                    }, null);
                if (me.value.length > 0) {
                    oe.length = 0;
                    var He = me.value.map(function (Le, Ie) {
                            return be(Le, Ie)
                        }),
                        je = He.map(function (Le, Ie) {
                            return createVNode("div", {
                                key: oe[Ie],
                                style: _e.value
                            }, [Le])
                        });
                    Re = C.grid ? createVNode(Row$3, {
                        gutter: C.grid.gutter
                    }, {
                        default: function () {
                            return [je]
                        }
                    }) : createVNode("ul", {
                        class: "".concat(Q.value, "-items")
                    }, [He])
                } else !Ve.length && !de.value && (Re = se(ne.value));
                var Fe = pe.value.position || "bottom";
                return createVNode("div", {
                    class: Ee
                }, [(Fe === "top" || Fe === "both") && Ae, Me && createVNode("div", {
                    class: "".concat(Q.value, "-header")
                }, [Me]), createVNode(Spin, ce.value, {
                    default: function () {
                        return [Re, Ve]
                    }
                }), Ne && createVNode("div", {
                    class: "".concat(Q.value, "-footer")
                }, [Ne]), Oe || (Fe === "bottom" || Fe === "both") && Ae])
            }
        }
    });
List$1.install = function (K) {
    return K.component(List$1.name, List$1), K.component(List$1.Item.name, List$1.Item), K.component(List$1.Item.Meta
        .name, List$1.Item.Meta), K
};
const List$2 = List$1;

function getBeforeSelectionText(K) {
    var C = K.selectionStart;
    return K.value.slice(0, C)
}

function getLastMeasureIndex(K) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "",
        H = Array.isArray(C) ? C : [C];
    return H.reduce(function (W, U) {
        var G = K.lastIndexOf(U);
        return G > W.location ? {
            location: G,
            prefix: U
        } : W
    }, {
        location: -1,
        prefix: ""
    })
}

function lower(K) {
    return (K || "").toLowerCase()
}

function reduceText(K, C, H) {
    var W = K[0];
    if (!W || W === H) return K;
    for (var U = K, G = C.length, X = 0; X < G; X += 1)
        if (lower(U[X]) !== lower(C[X])) {
            U = U.slice(X);
            break
        } else X === G - 1 && (U = U.slice(G));
    return U
}

function replaceWithMeasure(K, C) {
    var H = C.measureLocation,
        W = C.prefix,
        U = C.targetText,
        G = C.selectionStart,
        X = C.split,
        Z = K.slice(0, H);
    Z[Z.length - X.length] === X && (Z = Z.slice(0, Z.length - X.length)), Z && (Z = "".concat(Z).concat(X));
    var Q = reduceText(K.slice(G), U.slice(G - H - W.length), X);
    Q.slice(0, X.length) === X && (Q = Q.slice(X.length));
    var ee = "".concat(Z).concat(W).concat(U).concat(X);
    return {
        text: "".concat(ee).concat(Q),
        selectionLocation: ee.length
    }
}

function setInputSelection(K, C) {
    K.setSelectionRange(C, C), K.blur(), K.focus()
}

function validateSearch(K, C) {
    var H = C.split;
    return !H || K.indexOf(H) === -1
}

function filterOption(K, C) {
    var H = C.value,
        W = H === void 0 ? "" : H,
        U = K.toLowerCase();
    return W.toLowerCase().indexOf(U) !== -1
}
var MentionsContextKey = Symbol("MentionsContextKey");
const MentionsContextKey$1 = MentionsContextKey;

function noop$7() {}
const DropdownMenu = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "DropdownMenu",
    props: {
        prefixCls: String,
        options: {
            type: Array,
            default: function () {
                return []
            }
        }
    },
    slots: ["notFoundContent", "option"],
    setup: function (C, H) {
        var W = H.slots,
            U = inject(MentionsContextKey$1, {
                activeIndex: ref(),
                loading: ref(!1)
            }),
            G = U.activeIndex,
            X = U.setActiveIndex,
            Z = U.selectOption,
            Q = U.onFocus,
            ee = Q === void 0 ? noop$7 : Q,
            ne = U.loading,
            te, re = function (oe) {
                clearTimeout(te), te = setTimeout(function () {
                    ee(oe)
                })
            };
        return onBeforeUnmount(function () {
                clearTimeout(te)
            }),
            function () {
                var ae, oe = C.prefixCls,
                    ie = C.options,
                    ue = ie[G.value] || {};
                return createVNode(Menu, {
                    prefixCls: "".concat(oe, "-menu"),
                    activeKey: ue.value,
                    onSelect: function (se) {
                        var ce = se.key,
                            de = ie.find(function (ve) {
                                var fe = ve.value;
                                return fe === ce
                            });
                        Z(de)
                    },
                    onMousedown: re
                }, {
                    default: function () {
                        return [!ne.value && ie.map(function (se, ce) {
                            var de, ve, fe = se.value,
                                pe = se.disabled,
                                me = se.label,
                                he = me === void 0 ? se.value : me;
                            return createVNode(MenuItem$1, {
                                key: fe,
                                disabled: pe,
                                onMouseenter: function () {
                                    X(ce)
                                }
                            }, {
                                default: function () {
                                    return [(de = (ve = W.option) ===
                                            null || ve === void 0 ?
                                            void 0 : ve.call(W, se)
                                        ) !== null && de !== void 0 ?
                                        de : typeof he ==
                                        "function" ? he({
                                            value: fe,
                                            disabled: pe
                                        }) : he]
                                }
                            })
                        }), !ne.value && ie.length === 0 ? createVNode(MenuItem$1, {
                            key: "notFoundContent",
                            disabled: !0
                        }, {
                            default: function () {
                                return [(ae = W.notFoundContent) === null || ae ===
                                    void 0 ? void 0 : ae.call(W)]
                            }
                        }) : null, ne.value && createVNode(MenuItem$1, {
                            key: "loading",
                            disabled: !0
                        }, {
                            default: function () {
                                return [createVNode(Spin, {
                                    size: "small"
                                }, null)]
                            }
                        })]
                    }
                })
            }
    }
});
var BUILT_IN_PLACEMENTS = {
    bottomRight: {
        points: ["tl", "br"],
        offset: [0, 4],
        overflow: {
            adjustX: 0,
            adjustY: 1
        }
    },
    bottomLeft: {
        points: ["tr", "bl"],
        offset: [0, 4],
        overflow: {
            adjustX: 0,
            adjustY: 1
        }
    },
    topRight: {
        points: ["bl", "tr"],
        offset: [0, -4],
        overflow: {
            adjustX: 0,
            adjustY: 1
        }
    },
    topLeft: {
        points: ["br", "tl"],
        offset: [0, -4],
        overflow: {
            adjustX: 0,
            adjustY: 1
        }
    }
};
const KeywordTrigger = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "KeywordTrigger",
    props: {
        loading: {
            type: Boolean,
            default: void 0
        },
        options: {
            type: Array,
            default: function () {
                return []
            }
        },
        prefixCls: String,
        placement: String,
        visible: {
            type: Boolean,
            default: void 0
        },
        transitionName: String,
        getPopupContainer: Function,
        direction: String
    },
    slots: ["notFoundContent", "option"],
    setup: function (C, H) {
        var W = H.slots,
            U = function () {
                return "".concat(C.prefixCls, "-dropdown")
            },
            G = function () {
                var Q = C.options;
                return createVNode(DropdownMenu, {
                    prefixCls: U(),
                    options: Q
                }, {
                    notFoundContent: W.notFoundContent,
                    option: W.option
                })
            },
            X = computed(function () {
                var Z = C.placement,
                    Q = C.direction,
                    ee = "topRight";
                return Q === "rtl" ? ee = Z === "top" ? "topLeft" : "bottomLeft" : ee = Z === "top" ?
                    "topRight" : "bottomRight", ee
            });
        return function () {
            var Z = C.visible,
                Q = C.transitionName,
                ee = C.getPopupContainer;
            return createVNode(Trigger, {
                prefixCls: U(),
                popupVisible: Z,
                popup: G(),
                popupPlacement: X.value,
                popupTransitionName: Q,
                builtinPlacements: BUILT_IN_PLACEMENTS,
                getPopupContainer: ee
            }, {
                default: W.default
            })
        }
    }
});
var PlaceMent = tuple$1("top", "bottom"),
    mentionsProps$1 = {
        autofocus: {
            type: Boolean,
            default: void 0
        },
        prefix: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.arrayOf(PropTypes$1.string)]),
        prefixCls: String,
        value: String,
        disabled: {
            type: Boolean,
            default: void 0
        },
        split: String,
        transitionName: String,
        placement: PropTypes$1.oneOf(PlaceMent),
        character: PropTypes$1.any,
        characterRender: Function,
        filterOption: {
            type: [Boolean, Function]
        },
        validateSearch: Function,
        getPopupContainer: {
            type: Function
        },
        options: {
            type: Array,
            default: function () {}
        },
        loading: {
            type: Boolean,
            default: void 0
        },
        rows: [Number, String],
        direction: {
            type: String
        }
    },
    vcMentionsProps = _objectSpread2$1({}, mentionsProps$1),
    defaultProps$1 = {
        prefix: "@",
        split: " ",
        rows: 1,
        validateSearch,
        filterOption: function () {
            return filterOption
        }
    };
initDefaultProps$1(vcMentionsProps, defaultProps$1);
var _excluded$o = ["prefixCls", "placement", "transitionName", "getPopupContainer", "direction"],
    _excluded2$3 = ["class", "style"];

function noop$6() {}
const Mentions$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Mentions",
    inheritAttrs: !1,
    props: initDefaultProps$1(vcMentionsProps, defaultProps$1),
    slots: ["notFoundContent", "option"],
    emits: ["change", "select", "search", "focus", "blur", "pressenter"],
    setup: function (C, H) {
        var W = H.emit,
            U = H.attrs,
            G = H.expose,
            X = H.slots,
            Z = ref(null),
            Q = ref(null),
            ee = ref(),
            ne = reactive({
                value: C.value || "",
                measuring: !1,
                measureLocation: 0,
                measureText: null,
                measurePrefix: "",
                activeIndex: 0,
                isFocus: !1
            });
        watchEffect(function () {
            ne.value = C.value
        });
        var te = function (ge) {
                W("change", ge)
            },
            re = function (ge) {
                var xe = ge.target,
                    Pe = xe.value,
                    $e = xe.composing,
                    ye = ge.isComposing;
                ye || $e || te(Pe)
            },
            ae = function (ge, xe, Pe) {
                _extends$1(ne, {
                    measuring: !0,
                    measureText: ge,
                    measurePrefix: xe,
                    measureLocation: Pe,
                    activeIndex: 0
                })
            },
            oe = function (ge) {
                _extends$1(ne, {
                    measuring: !1,
                    measureLocation: 0,
                    measureText: null
                }), ge == null || ge()
            },
            ie = function (ge) {
                var xe = ge.which;
                if (ne.measuring) {
                    if (xe === KeyCode$1.UP || xe === KeyCode$1.DOWN) {
                        var Pe = he.value.length,
                            $e = xe === KeyCode$1.UP ? -1 : 1,
                            ye = (ne.activeIndex + $e + Pe) % Pe;
                        ne.activeIndex = ye, ge.preventDefault()
                    } else if (xe === KeyCode$1.ESC) oe();
                    else if (xe === KeyCode$1.ENTER) {
                        if (ge.preventDefault(), !he.value.length) {
                            oe();
                            return
                        }
                        var Ce = he.value[ne.activeIndex];
                        fe(Ce)
                    }
                }
            },
            ue = function (ge) {
                var xe = ge.key,
                    Pe = ge.which,
                    $e = ne.measureText,
                    ye = ne.measuring,
                    Ce = C.prefix,
                    we = C.validateSearch,
                    Oe = ge.target;
                if (!Oe.composing) {
                    var Ne = getBeforeSelectionText(Oe),
                        Me = getLastMeasureIndex(Ne, Ce),
                        Ve = Me.location,
                        ke = Me.prefix;
                    if ([KeyCode$1.ESC, KeyCode$1.UP, KeyCode$1.DOWN, KeyCode$1.ENTER].indexOf(Pe) === -1)
                        if (Ve !== -1) {
                            var Ee = Ne.slice(Ve + ke.length),
                                Ae = we(Ee, C),
                                Re = !!me(Ee).length;
                            Ae ? (xe === ke || xe === "Shift" || ye || Ee !== $e && Re) && ae(Ee, ke, Ve) :
                                ye && oe(), Ae && W("search", Ee, ke)
                        } else ye && oe()
                }
            },
            le = function (ge) {
                ne.measuring || W("pressenter", ge)
            },
            se = function (ge) {
                de(ge)
            },
            ce = function (ge) {
                ve(ge)
            },
            de = function (ge) {
                clearTimeout(ee.value);
                var xe = ne.isFocus;
                !xe && ge && W("focus", ge), ne.isFocus = !0
            },
            ve = function (ge) {
                ee.value = setTimeout(function () {
                    ne.isFocus = !1, oe(), W("blur", ge)
                }, 100)
            },
            fe = function (ge) {
                var xe = C.split,
                    Pe = ge.value,
                    $e = Pe === void 0 ? "" : Pe,
                    ye = replaceWithMeasure(ne.value, {
                        measureLocation: ne.measureLocation,
                        targetText: $e,
                        prefix: ne.measurePrefix,
                        selectionStart: Q.value.selectionStart,
                        split: xe
                    }),
                    Ce = ye.text,
                    we = ye.selectionLocation;
                te(Ce), oe(function () {
                    setInputSelection(Q.value, we)
                }), W("select", ge, ne.measurePrefix)
            },
            pe = function (ge) {
                ne.activeIndex = ge
            },
            me = function (ge) {
                var xe = ge || ne.measureText || "",
                    Pe = C.filterOption,
                    $e = C.options.filter(function (ye) {
                        return Pe ? Pe(xe, ye) : !0
                    });
                return $e
            },
            he = computed(function () {
                return me()
            }),
            Se = function () {
                Q.value.focus()
            },
            _e = function () {
                Q.value.blur()
            };
        return G({
                blur: _e,
                focus: Se
            }), provide(MentionsContextKey$1, {
                activeIndex: toRef(ne, "activeIndex"),
                setActiveIndex: pe,
                selectOption: fe,
                onFocus: de,
                onBlur: ve,
                loading: toRef(C, "loading")
            }), onUpdated(function () {
                nextTick(function () {
                    ne.measuring && (Z.value.scrollTop = Q.value.scrollTop)
                })
            }),
            function () {
                var be = ne.measureLocation,
                    ge = ne.measurePrefix,
                    xe = ne.measuring,
                    Pe = C.prefixCls,
                    $e = C.placement,
                    ye = C.transitionName,
                    Ce = C.getPopupContainer,
                    we = C.direction,
                    Oe = _objectWithoutProperties$2(C, _excluded$o),
                    Ne = U.class,
                    Me = U.style,
                    Ve = _objectWithoutProperties$2(U, _excluded2$3),
                    ke = omit$2(Oe, ["value", "prefix", "split", "validateSearch", "filterOption",
                        "options", "loading"]),
                    Ee = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, ke), Ve), {}, {
                        onChange: noop$6,
                        onSelect: noop$6,
                        value: ne.value,
                        onInput: re,
                        onBlur: ce,
                        onKeydown: ie,
                        onKeyup: ue,
                        onFocus: se,
                        onPressenter: le
                    });
                return createVNode("div", {
                    class: classNames(Pe, Ne),
                    style: Me
                }, [withDirectives(createVNode("textarea", _objectSpread2$1({
                    ref: Q
                }, Ee), null), [[antInputDirective]]), xe && createVNode("div", {
                    ref: Z,
                    class: "".concat(Pe, "-measure")
                }, [ne.value.slice(0, be), createVNode(KeywordTrigger, {
                    prefixCls: Pe,
                    transitionName: ye,
                    placement: $e,
                    options: xe ? he.value : [],
                    visible: !0,
                    direction: we,
                    getPopupContainer: Ce
                }, {
                    default: function () {
                        return [createVNode("span", null, [ge])]
                    },
                    notFoundContent: X.notFoundContent,
                    option: X.option
                }), ne.value.slice(be + ge.length)])])
            }
    }
});
var optionProps = {
    value: String,
    disabled: Boolean,
    label: [String, Number, Function]
};
const Option = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Option",
    props: optionProps,
    render: function (C, H) {
        var W, U = H.slots;
        return (W = U.default) === null || W === void 0 ? void 0 : W.call(U)
    }
});
var _excluded$n = ["disabled", "getPopupContainer", "rows", "id"],
    _excluded2$2 = ["class"],
    getMentions = function () {
        var C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "",
            H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            W = H.prefix,
            U = W === void 0 ? "@" : W,
            G = H.split,
            X = G === void 0 ? " " : G,
            Z = Array.isArray(U) ? U : [U];
        return C.split(X).map(function () {
            var Q = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "",
                ee = null;
            return Z.some(function (ne) {
                var te = Q.slice(0, ne.length);
                return te === ne ? (ee = ne, !0) : !1
            }), ee !== null ? {
                prefix: ee,
                value: Q.slice(ee.length)
            } : null
        }).filter(function (Q) {
            return !!Q && !!Q.value
        })
    },
    mentionsProps = function () {
        return _objectSpread2$1(_objectSpread2$1({}, mentionsProps$1), {}, {
            loading: {
                type: Boolean,
                default: void 0
            },
            onFocus: {
                type: Function
            },
            onBlur: {
                type: Function
            },
            onSelect: {
                type: Function
            },
            onChange: {
                type: Function
            },
            onPressenter: {
                type: Function
            },
            "onUpdate:value": {
                type: Function
            },
            notFoundContent: PropTypes$1.any,
            defaultValue: String,
            id: String
        })
    },
    Mentions = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "AMentions",
        inheritAttrs: !1,
        props: mentionsProps(),
        slots: ["notFoundContent", "option"],
        setup: function (C, H) {
            var W, U, G = H.slots,
                X = H.emit,
                Z = H.attrs,
                Q = H.expose,
                ee = useConfigInject("mentions", C),
                ne = ee.prefixCls,
                te = ee.renderEmpty,
                re = ee.direction,
                ae = ref(!1),
                oe = ref(null),
                ie = ref((W = (U = C.value) !== null && U !== void 0 ? U : C.defaultValue) !== null && W !==
                    void 0 ? W : ""),
                ue = useInjectFormItemContext();
            watch(function () {
                return C.value
            }, function (he) {
                ie.value = he
            });
            var le = function (Se) {
                    ae.value = !0, X("focus", Se)
                },
                se = function (Se) {
                    ae.value = !1, X("blur", Se), ue.onFieldBlur()
                },
                ce = function () {
                    for (var Se = arguments.length, _e = new Array(Se), be = 0; be < Se; be++) _e[be] =
                        arguments[be];
                    X.apply(void 0, ["select"].concat(_e)), ae.value = !0
                },
                de = function (Se) {
                    C.value === void 0 && (ie.value = Se), X("update:value", Se), X("change", Se), ue.onFieldChange()
                },
                ve = function () {
                    var Se = C.notFoundContent;
                    return Se !== void 0 ? Se : G.notFoundContent ? G.notFoundContent() : te.value("Select")
                },
                fe = function () {
                    var Se;
                    return flattenChildren(((Se = G.default) === null || Se === void 0 ? void 0 : Se.call(G)) ||
                        []).map(function (_e) {
                        var be, ge;
                        return _objectSpread2$1(_objectSpread2$1({}, getOptionProps(_e)), {}, {
                            label: (be = _e.children) === null || be === void 0 || (ge = be.default) ===
                                null || ge === void 0 ? void 0 : ge.call(be)
                        })
                    })
                },
                pe = function () {
                    oe.value.focus()
                },
                me = function () {
                    oe.value.blur()
                };
            return Q({
                    focus: pe,
                    blur: me
                }),
                function () {
                    var he, Se = C.disabled,
                        _e = C.getPopupContainer,
                        be = C.rows,
                        ge = be === void 0 ? 1 : be,
                        xe = C.id,
                        Pe = xe === void 0 ? ue.id.value : xe,
                        $e = _objectWithoutProperties$2(C, _excluded$n),
                        ye = Z.class,
                        Ce = _objectWithoutProperties$2(Z, _excluded2$2),
                        we = omit$2($e, ["defaultValue", "onUpdate:value", "prefixCls"]),
                        Oe = classNames(ye, (he = {}, _defineProperty$V(he, "".concat(ne.value, "-disabled"),
                                Se), _defineProperty$V(he, "".concat(ne.value, "-focused"), ae.value),
                            _defineProperty$V(he, "".concat(ne.value, "-rtl"), re.value === "rtl"), he)),
                        Ne = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                            prefixCls: ne.value
                        }, we), {}, {
                            disabled: Se,
                            direction: re.value,
                            filterOption: C.filterOption,
                            getPopupContainer: _e,
                            options: C.options || fe(),
                            class: Oe
                        }, Ce), {}, {
                            rows: ge,
                            onChange: de,
                            onSelect: ce,
                            onFocus: le,
                            onBlur: se,
                            ref: oe,
                            value: ie.value,
                            id: Pe
                        });
                    return createVNode(Mentions$1, Ne, {
                        notFoundContent: ve,
                        option: G.option
                    })
                }
        }
    }),
    MentionsOption = defineComponent(_objectSpread2$1(_objectSpread2$1({
        compatConfig: {
            MODE: 3
        }
    }, Option), {}, {
        name: "AMentionsOption",
        props: optionProps
    }));
const index$b = _extends$1(Mentions, {
    Option: MentionsOption,
    getMentions,
    install: function (C) {
        return C.component(Mentions.name, Mentions), C.component(MentionsOption.name, MentionsOption), C
    }
});
var _excluded$m = ["prefixCls", "visible", "wrapClassName", "centered", "getContainer", "closeIcon",
        "focusTriggerAfterClose"],
    mousePosition = null,
    getClickPosition = function (C) {
        mousePosition = {
            x: C.pageX,
            y: C.pageY
        }, setTimeout(function () {
            return mousePosition = null
        }, 100)
    };
canUseDocElement() && addEventListenerWrap(document.documentElement, "click", getClickPosition, !0);
var modalProps = function () {
        return {
            prefixCls: String,
            visible: {
                type: Boolean,
                default: void 0
            },
            confirmLoading: {
                type: Boolean,
                default: void 0
            },
            title: PropTypes$1.any,
            closable: {
                type: Boolean,
                default: void 0
            },
            closeIcon: PropTypes$1.any,
            onOk: Function,
            onCancel: Function,
            "onUpdate:visible": Function,
            onChange: Function,
            afterClose: Function,
            centered: {
                type: Boolean,
                default: void 0
            },
            width: [String, Number],
            footer: PropTypes$1.any,
            okText: PropTypes$1.any,
            okType: String,
            cancelText: PropTypes$1.any,
            icon: PropTypes$1.any,
            maskClosable: {
                type: Boolean,
                default: void 0
            },
            forceRender: {
                type: Boolean,
                default: void 0
            },
            okButtonProps: Object,
            cancelButtonProps: Object,
            destroyOnClose: {
                type: Boolean,
                default: void 0
            },
            wrapClassName: String,
            maskTransitionName: String,
            transitionName: String,
            getContainer: {
                type: [String, Function, Boolean, Object],
                default: void 0
            },
            zIndex: Number,
            bodyStyle: {
                type: Object,
                default: void 0
            },
            maskStyle: {
                type: Object,
                default: void 0
            },
            mask: {
                type: Boolean,
                default: void 0
            },
            keyboard: {
                type: Boolean,
                default: void 0
            },
            wrapProps: Object,
            focusTriggerAfterClose: {
                type: Boolean,
                default: void 0
            },
            modalRender: Function
        }
    },
    destroyFns = [];
const Modal = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AModal",
    inheritAttrs: !1,
    props: initDefaultProps$1(modalProps(), {
        width: 520,
        transitionName: "zoom",
        maskTransitionName: "fade",
        confirmLoading: !1,
        visible: !1,
        okType: "primary"
    }),
    setup: function (C, H) {
        var W = H.emit,
            U = H.slots,
            G = H.attrs,
            X = useLocaleReceiver("Modal"),
            Z = _slicedToArray$2(X, 1),
            Q = Z[0],
            ee = useConfigInject("modal", C),
            ne = ee.prefixCls,
            te = ee.rootPrefixCls,
            re = ee.direction,
            ae = ee.getPopupContainer,
            oe = function (se) {
                W("update:visible", !1), W("cancel", se), W("change", !1)
            },
            ie = function (se) {
                W("ok", se)
            },
            ue = function () {
                var se, ce, de = C.okText,
                    ve = de === void 0 ? (se = U.okText) === null || se === void 0 ? void 0 : se.call(U) :
                    de,
                    fe = C.okType,
                    pe = C.cancelText,
                    me = pe === void 0 ? (ce = U.cancelText) === null || ce === void 0 ? void 0 : ce.call(U) :
                    pe,
                    he = C.confirmLoading;
                return createVNode(Fragment, null, [createVNode(Button$1, _objectSpread2$1({
                    onClick: oe
                }, C.cancelButtonProps), {
                    default: function () {
                        return [me || Q.value.cancelText]
                    }
                }), createVNode(Button$1, _objectSpread2$1(_objectSpread2$1({},
                    convertLegacyProps(fe)), {}, {
                    loading: he,
                    onClick: ie
                }, C.okButtonProps), {
                    default: function () {
                        return [ve || Q.value.okText]
                    }
                })])
            };
        return function () {
            var le, se;
            C.prefixCls;
            var ce = C.visible,
                de = C.wrapClassName,
                ve = C.centered,
                fe = C.getContainer,
                pe = C.closeIcon,
                me = pe === void 0 ? (le = U.closeIcon) === null || le === void 0 ? void 0 : le.call(U) :
                pe,
                he = C.focusTriggerAfterClose,
                Se = he === void 0 ? !0 : he,
                _e = _objectWithoutProperties$2(C, _excluded$m),
                be = classNames(de, (se = {}, _defineProperty$V(se, "".concat(ne.value, "-centered"), !
                    !ve), _defineProperty$V(se, "".concat(ne.value, "-wrap-rtl"), re.value ===
                    "rtl"), se));
            return createVNode(DialogWrap$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, _e),
                G), {}, {
                getContainer: fe || ae.value,
                prefixCls: ne.value,
                wrapClassName: be,
                visible: ce,
                mousePosition,
                onClose: oe,
                focusTriggerAfterClose: Se,
                transitionName: getTransitionName$2(te.value, "zoom", C.transitionName),
                maskTransitionName: getTransitionName$2(te.value, "fade", C.maskTransitionName)
            }), _objectSpread2$1(_objectSpread2$1({}, U), {}, {
                footer: U.footer || ue,
                closeIcon: function () {
                    return createVNode("span", {
                        class: "".concat(ne.value, "-close-x")
                    }, [me || createVNode(CloseOutlined$1, {
                        class: "".concat(ne.value, "-close-icon")
                    }, null)])
                }
            }))
        }
    }
});
var useDestroyed = function () {
    var C = ref(!1);
    return onBeforeUnmount(function () {
        C.value = !0
    }), C
};
const useDestroyed$1 = useDestroyed;
var actionButtonProps = {
    type: {
        type: String
    },
    actionFn: Function,
    close: Function,
    autofocus: Boolean,
    prefixCls: String,
    buttonProps: Object,
    emitEvent: Boolean,
    quitOnNullishReturnValue: Boolean
};

function isThenable(K) {
    return !!(K && K.then)
}
const ActionButton = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ActionButton",
    props: actionButtonProps,
    setup: function (C, H) {
        var W = H.slots,
            U = ref(!1),
            G = ref(),
            X = ref(!1),
            Z, Q = useDestroyed$1();
        onMounted(function () {
            C.autofocus && (Z = setTimeout(function () {
                var te;
                return (te = G.value.$el) === null || te === void 0 ? void 0 : te.focus()
            }))
        }), onBeforeUnmount(function () {
            clearTimeout(Z)
        });
        var ee = function (re) {
                var ae = C.close;
                isThenable(re) && (X.value = !0, re.then(function () {
                    Q.value || (X.value = !1), ae.apply(void 0, arguments), U.value = !1
                }, function (oe) {
                    console.error(oe), Q.value || (X.value = !1), U.value = !1
                }))
            },
            ne = function (re) {
                var ae = C.actionFn,
                    oe = C.close,
                    ie = oe === void 0 ? function () {} : oe;
                if (!U.value) {
                    if (U.value = !0, !ae) {
                        ie();
                        return
                    }
                    var ue;
                    if (C.emitEvent) {
                        if (ue = ae(re), C.quitOnNullishReturnValue && !isThenable(ue)) {
                            U.value = !1, ie(re);
                            return
                        }
                    } else if (ae.length) ue = ae(ie), U.value = !1;
                    else if (ue = ae(), !ue) {
                        ie();
                        return
                    }
                    ee(ue)
                }
            };
        return function () {
            var te = C.type,
                re = C.prefixCls,
                ae = C.buttonProps;
            return createVNode(Button$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({},
                convertLegacyProps(te)), {}, {
                onClick: ne,
                loading: X.value,
                prefixCls: re
            }, ae), {}, {
                ref: G
            }), W)
        }
    }
});

function renderSomeContent(K) {
    return typeof K == "function" ? K() : K
}
const ConfirmDialog = defineComponent({
    name: "ConfirmDialog",
    inheritAttrs: !1,
    props: ["icon", "onCancel", "onOk", "close", "closable", "zIndex", "afterClose", "visible", "keyboard",
        "centered", "getContainer", "maskStyle", "okButtonProps", "cancelButtonProps", "okType",
        "prefixCls", "okCancel", "width", "mask", "maskClosable", "okText", "cancelText", "autoFocusButton",
        "transitionName", "maskTransitionName", "type", "title", "content", "direction", "rootPrefixCls",
        "bodyStyle", "closeIcon", "modalRender", "focusTriggerAfterClose", "wrapClassName"],
    setup: function (C, H) {
        var W = H.attrs,
            U = useLocaleReceiver("Modal"),
            G = _slicedToArray$2(U, 1),
            X = G[0];
        return function () {
            var Z = C.icon,
                Q = C.onCancel,
                ee = C.onOk,
                ne = C.close,
                te = C.closable,
                re = te === void 0 ? !1 : te,
                ae = C.zIndex,
                oe = C.afterClose,
                ie = C.visible,
                ue = C.keyboard,
                le = C.centered,
                se = C.getContainer,
                ce = C.maskStyle,
                de = C.okButtonProps,
                ve = C.cancelButtonProps,
                fe = C.okCancel,
                pe = fe === void 0 ? !0 : fe,
                me = C.width,
                he = me === void 0 ? 416 : me,
                Se = C.mask,
                _e = Se === void 0 ? !0 : Se,
                be = C.maskClosable,
                ge = be === void 0 ? !1 : be,
                xe = C.type,
                Pe = C.title,
                $e = C.content,
                ye = C.direction,
                Ce = C.closeIcon,
                we = C.modalRender,
                Oe = C.focusTriggerAfterClose,
                Ne = C.rootPrefixCls,
                Me = C.bodyStyle,
                Ve = C.wrapClassName,
                ke = C.okType || "primary",
                Ee = C.prefixCls || "ant-modal",
                Ae = "".concat(Ee, "-confirm"),
                Re = W.style || {},
                He = renderSomeContent(C.okText) || (pe ? X.value.okText : X.value.justOkText),
                je = renderSomeContent(C.cancelText) || X.value.cancelText,
                Fe = C.autoFocusButton === null ? !1 : C.autoFocusButton || "ok",
                Le = classNames(Ae, "".concat(Ae, "-").concat(xe), "".concat(Ee, "-").concat(xe),
                    _defineProperty$V({}, "".concat(Ae, "-rtl"), ye === "rtl"), W.class),
                Ie = pe && createVNode(ActionButton, {
                    actionFn: Q,
                    close: ne,
                    autofocus: Fe === "cancel",
                    buttonProps: ve,
                    prefixCls: "".concat(Ne, "-btn")
                }, {
                    default: function () {
                        return [je]
                    }
                });
            return createVNode(Modal, {
                prefixCls: Ee,
                class: Le,
                wrapClassName: classNames(_defineProperty$V({}, "".concat(Ae, "-centered"), !!
                    le), Ve),
                onCancel: function (De) {
                    return ne({
                        triggerCancel: !0
                    }, De)
                },
                visible: ie,
                title: "",
                footer: "",
                transitionName: getTransitionName$2(Ne, "zoom", C.transitionName),
                maskTransitionName: getTransitionName$2(Ne, "fade", C.maskTransitionName),
                mask: _e,
                maskClosable: ge,
                maskStyle: ce,
                style: Re,
                bodyStyle: Me,
                width: he,
                zIndex: ae,
                afterClose: oe,
                keyboard: ue,
                centered: le,
                getContainer: se,
                closable: re,
                closeIcon: Ce,
                modalRender: we,
                focusTriggerAfterClose: Oe
            }, {
                default: function () {
                    return [createVNode("div", {
                        class: "".concat(Ae, "-body-wrapper")
                    }, [createVNode("div", {
                        class: "".concat(Ae, "-body")
                    }, [renderSomeContent(Z), Pe === void 0 ? null :
                        createVNode("span", {
                            class: "".concat(Ae, "-title")
                        }, [renderSomeContent(Pe)]), createVNode("div", {
                            class: "".concat(Ae, "-content")
                        }, [renderSomeContent($e)])]), createVNode("div", {
                        class: "".concat(Ae, "-btns")
                    }, [Ie, createVNode(ActionButton, {
                        type: ke,
                        actionFn: ee,
                        close: ne,
                        autofocus: Fe === "ok",
                        buttonProps: de,
                        prefixCls: "".concat(Ne, "-btn")
                    }, {
                        default: function () {
                            return [He]
                        }
                    })])])]
                }
            })
        }
    }
});
var confirm = function (C) {
    var H = document.createDocumentFragment(),
        W = _objectSpread2$1(_objectSpread2$1({}, omit$2(C, ["parentContext", "appContext"])), {}, {
            close: X,
            visible: !0
        }),
        U = null;

    function G() {
        U && (render(null, H), U.component.update(), U = null);
        for (var ne = arguments.length, te = new Array(ne), re = 0; re < ne; re++) te[re] = arguments[re];
        var ae = te.some(function (ue) {
            return ue && ue.triggerCancel
        });
        C.onCancel && ae && C.onCancel.apply(C, te);
        for (var oe = 0; oe < destroyFns.length; oe++) {
            var ie = destroyFns[oe];
            if (ie === X) {
                destroyFns.splice(oe, 1);
                break
            }
        }
    }

    function X() {
        for (var ne = this, te = arguments.length, re = new Array(te), ae = 0; ae < te; ae++) re[ae] = arguments[ae];
        W = _objectSpread2$1(_objectSpread2$1({}, W), {}, {
            visible: !1,
            afterClose: function () {
                typeof C.afterClose == "function" && C.afterClose(), G.apply(ne, re)
            }
        }), Z(W)
    }

    function Z(ne) {
        typeof ne == "function" ? W = ne(W) : W = _objectSpread2$1(_objectSpread2$1({}, W), ne), U && (_extends$1(U
            .component.props, W), U.component.update())
    }
    var Q = function (te) {
        var re = globalConfigForApi,
            ae = re.prefixCls,
            oe = te.prefixCls || "".concat(ae, "-modal");
        return createVNode(ConfigProvider$1, _objectSpread2$1(_objectSpread2$1({}, re), {}, {
            notUpdateGlobalConfig: !0,
            prefixCls: ae
        }), {
            default: function () {
                return [createVNode(ConfirmDialog, _objectSpread2$1(_objectSpread2$1({}, te), {}, {
                    rootPrefixCls: ae,
                    prefixCls: oe
                }), null)]
            }
        })
    };

    function ee(ne) {
        var te = createVNode(Q, _objectSpread2$1({}, ne));
        return te.appContext = C.parentContext || C.appContext || te.appContext, render(te, H), te
    }
    return U = ee(W), destroyFns.push(X), {
        destroy: X,
        update: Z
    }
};
const confirm$1 = confirm;

function withWarn(K) {
    return _objectSpread2$1(_objectSpread2$1({
        icon: function () {
            return createVNode(ExclamationCircleOutlined$1, null, null)
        },
        okCancel: !1
    }, K), {}, {
        type: "warning"
    })
}

function withInfo(K) {
    return _objectSpread2$1(_objectSpread2$1({
        icon: function () {
            return createVNode(InfoCircleOutlined$1, null, null)
        },
        okCancel: !1
    }, K), {}, {
        type: "info"
    })
}

function withSuccess(K) {
    return _objectSpread2$1(_objectSpread2$1({
        icon: function () {
            return createVNode(CheckCircleOutlined$1, null, null)
        },
        okCancel: !1
    }, K), {}, {
        type: "success"
    })
}

function withError(K) {
    return _objectSpread2$1(_objectSpread2$1({
        icon: function () {
            return createVNode(CloseCircleOutlined$1, null, null)
        },
        okCancel: !1
    }, K), {}, {
        type: "error"
    })
}

function withConfirm(K) {
    return _objectSpread2$1(_objectSpread2$1({
        icon: function () {
            return createVNode(ExclamationCircleOutlined$1, null, null)
        },
        okCancel: !0
    }, K), {}, {
        type: "confirm"
    })
}

function modalWarn(K) {
    return confirm$1(withWarn(K))
}
Modal.info = function (C) {
    return confirm$1(withInfo(C))
};
Modal.success = function (C) {
    return confirm$1(withSuccess(C))
};
Modal.error = function (C) {
    return confirm$1(withError(C))
};
Modal.warning = modalWarn;
Modal.warn = modalWarn;
Modal.confirm = function (C) {
    return confirm$1(withConfirm(C))
};
Modal.destroyAll = function () {
    for (; destroyFns.length;) {
        var C = destroyFns.pop();
        C && C()
    }
};
Modal.install = function (K) {
    return K.component(Modal.name, Modal), K
};

function padEnd(K, C, H) {
    K = toString$1(K), C = toInteger(C);
    var W = C ? stringSize(K) : 0;
    return C && W < C ? K + createPadding(C - W, H) : K
}
var StatisticNumber = function (C) {
    var H = C.value,
        W = C.formatter,
        U = C.precision,
        G = C.decimalSeparator,
        X = C.groupSeparator,
        Z = X === void 0 ? "" : X,
        Q = C.prefixCls,
        ee;
    if (typeof W == "function") ee = W({
        value: H
    });
    else {
        var ne = String(H),
            te = ne.match(/^(-?)(\d*)(\.(\d+))?$/);
        if (!te) ee = ne;
        else {
            var re = te[1],
                ae = te[2] || "0",
                oe = te[4] || "";
            ae = ae.replace(/\B(?=(\d{3})+(?!\d))/g, Z), typeof U == "number" && (oe = padEnd(oe, U, "0").slice(0,
                U)), oe && (oe = "".concat(G).concat(oe)), ee = [createVNode("span", {
                key: "int",
                class: "".concat(Q, "-content-value-int")
            }, [re, ae]), oe && createVNode("span", {
                key: "decimal",
                class: "".concat(Q, "-content-value-decimal")
            }, [oe])]
        }
    }
    return createVNode("span", {
        class: "".concat(Q, "-content-value")
    }, [ee])
};
StatisticNumber.displayName = "StatisticNumber";
const StatisticNumber$1 = StatisticNumber;
var skeletonTitleProps = function () {
        return {
            prefixCls: String,
            width: {
                type: [Number, String]
            }
        }
    },
    SkeletonTitle = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "SkeletonTitle",
        props: skeletonTitleProps(),
        setup: function (C) {
            return function () {
                var H = C.prefixCls,
                    W = C.width,
                    U = typeof W == "number" ? "".concat(W, "px") : W;
                return createVNode("h3", {
                    class: H,
                    style: {
                        width: U
                    }
                }, null)
            }
        }
    });
const SkeletonTitle$1 = SkeletonTitle;
var skeletonParagraphProps = function () {
        return {
            prefixCls: String,
            width: {
                type: [Number, String, Array]
            },
            rows: Number
        }
    },
    SkeletonParagraph = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "SkeletonParagraph",
        props: skeletonParagraphProps(),
        setup: function (C) {
            var H = function (U) {
                var G = C.width,
                    X = C.rows,
                    Z = X === void 0 ? 2 : X;
                if (Array.isArray(G)) return G[U];
                if (Z - 1 === U) return G
            };
            return function () {
                var W = C.prefixCls,
                    U = C.rows,
                    G = _toConsumableArray(Array(U)).map(function (X, Z) {
                        var Q = H(Z);
                        return createVNode("li", {
                            key: Z,
                            style: {
                                width: typeof Q == "number" ? "".concat(Q, "px") : Q
                            }
                        }, null)
                    });
                return createVNode("ul", {
                    class: W
                }, [G])
            }
        }
    });
const Paragraph$2 = SkeletonParagraph;
var skeletonElementProps = function () {
        return {
            prefixCls: String,
            size: [String, Number],
            shape: String,
            active: {
                type: Boolean,
                default: void 0
            }
        }
    },
    Element$1 = function (C) {
        var H, W, U = C.prefixCls,
            G = C.size,
            X = C.shape,
            Z = classNames((H = {}, _defineProperty$V(H, "".concat(U, "-lg"), G === "large"), _defineProperty$V(H, "".concat(
                U, "-sm"), G === "small"), H)),
            Q = classNames((W = {}, _defineProperty$V(W, "".concat(U, "-circle"), X === "circle"), _defineProperty$V(W,
                "".concat(U, "-square"), X === "square"), _defineProperty$V(W, "".concat(U, "-round"), X ===
                "round"), W)),
            ee = typeof G == "number" ? {
                width: "".concat(G, "px"),
                height: "".concat(G, "px"),
                lineHeight: "".concat(G, "px")
            } : {};
        return createVNode("span", {
            class: classNames(U, Z, Q),
            style: ee
        }, null)
    };
Element$1.displayName = "SkeletonElement";
const Element$2 = Element$1;
var skeletonProps = function () {
    return {
        active: {
            type: Boolean,
            default: void 0
        },
        loading: {
            type: Boolean,
            default: void 0
        },
        prefixCls: String,
        avatar: {
            type: [Boolean, Object],
            default: void 0
        },
        title: {
            type: [Boolean, Object],
            default: void 0
        },
        paragraph: {
            type: [Boolean, Object],
            default: void 0
        },
        round: {
            type: Boolean,
            default: void 0
        }
    }
};

function getComponentProps(K) {
    return K && _typeof$2(K) === "object" ? K : {}
}

function getAvatarBasicProps(K, C) {
    return K && !C ? {
        size: "large",
        shape: "square"
    } : {
        size: "large",
        shape: "circle"
    }
}

function getTitleBasicProps(K, C) {
    return !K && C ? {
        width: "38%"
    } : K && C ? {
        width: "50%"
    } : {}
}

function getParagraphBasicProps(K, C) {
    var H = {};
    return (!K || !C) && (H.width = "61%"), !K && C ? H.rows = 3 : H.rows = 2, H
}
var Skeleton = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ASkeleton",
    props: initDefaultProps$1(skeletonProps(), {
        avatar: !1,
        title: !0,
        paragraph: !0
    }),
    setup: function (C, H) {
        var W = H.slots,
            U = useConfigInject("skeleton", C),
            G = U.prefixCls,
            X = U.direction;
        return function () {
            var Z, Q = C.loading,
                ee = C.avatar,
                ne = C.title,
                te = C.paragraph,
                re = C.active,
                ae = C.round,
                oe = G.value;
            if (Q || C.loading === void 0) {
                var ie, ue = !!ee || ee === "",
                    le = !!ne || ne === "",
                    se = !!te || te === "",
                    ce;
                if (ue) {
                    var de = _objectSpread2$1(_objectSpread2$1({
                        prefixCls: "".concat(oe, "-avatar")
                    }, getAvatarBasicProps(le, se)), getComponentProps(ee));
                    ce = createVNode("div", {
                        class: "".concat(oe, "-header")
                    }, [createVNode(Element$2, de, null)])
                }
                var ve;
                if (le || se) {
                    var fe;
                    if (le) {
                        var pe = _objectSpread2$1(_objectSpread2$1({
                            prefixCls: "".concat(oe, "-title")
                        }, getTitleBasicProps(ue, se)), getComponentProps(ne));
                        fe = createVNode(SkeletonTitle$1, pe, null)
                    }
                    var me;
                    if (se) {
                        var he = _objectSpread2$1(_objectSpread2$1({
                            prefixCls: "".concat(oe, "-paragraph")
                        }, getParagraphBasicProps(ue, le)), getComponentProps(te));
                        me = createVNode(Paragraph$2, he, null)
                    }
                    ve = createVNode("div", {
                        class: "".concat(oe, "-content")
                    }, [fe, me])
                }
                var Se = classNames(oe, (ie = {}, _defineProperty$V(ie, "".concat(oe, "-with-avatar"),
                        ue), _defineProperty$V(ie, "".concat(oe, "-active"), re),
                    _defineProperty$V(ie, "".concat(oe, "-rtl"), X.value === "rtl"),
                    _defineProperty$V(ie, "".concat(oe, "-round"), ae), ie));
                return createVNode("div", {
                    class: Se
                }, [ce, ve])
            }
            return (Z = W.default) === null || Z === void 0 ? void 0 : Z.call(W)
        }
    }
});
const Skeleton$1 = Skeleton;
var statisticProps = function () {
    return {
        prefixCls: String,
        decimalSeparator: String,
        groupSeparator: String,
        format: String,
        value: {
            type: [String, Number, Object]
        },
        valueStyle: {
            type: Object,
            default: void 0
        },
        valueRender: PropTypes$1.any,
        formatter: PropTypes$1.any,
        precision: Number,
        prefix: PropTypes$1.any,
        suffix: PropTypes$1.any,
        title: PropTypes$1.any,
        loading: {
            type: Boolean,
            default: void 0
        }
    }
};
const Statistic = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AStatistic",
    props: initDefaultProps$1(statisticProps(), {
        decimalSeparator: ".",
        groupSeparator: ",",
        loading: !1
    }),
    slots: ["title", "prefix", "suffix", "formatter"],
    setup: function (C, H) {
        var W = H.slots,
            U = useConfigInject("statistic", C),
            G = U.prefixCls,
            X = U.direction;
        return function () {
            var Z, Q, ee, ne, te, re, ae, oe = C.value,
                ie = oe === void 0 ? 0 : oe,
                ue = C.valueStyle,
                le = C.valueRender,
                se = G.value,
                ce = (Z = C.title) !== null && Z !== void 0 ? Z : (Q = W.title) === null || Q === void 0 ?
                void 0 : Q.call(W),
                de = (ee = C.prefix) !== null && ee !== void 0 ? ee : (ne = W.prefix) === null || ne ===
                void 0 ? void 0 : ne.call(W),
                ve = (te = C.suffix) !== null && te !== void 0 ? te : (re = W.suffix) === null || re ===
                void 0 ? void 0 : re.call(W),
                fe = (ae = C.formatter) !== null && ae !== void 0 ? ae : W.formatter,
                pe = createVNode(StatisticNumber$1, _objectSpread2$1({
                    "data-for-update": Date.now()
                }, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                    prefixCls: se,
                    value: ie,
                    formatter: fe
                })), null);
            return le && (pe = le(pe)), createVNode("div", {
                class: [se, _defineProperty$V({}, "".concat(se, "-rtl"), X.value === "rtl")]
            }, [ce && createVNode("div", {
                class: "".concat(se, "-title")
            }, [ce]), createVNode(Skeleton$1, {
                paragraph: !1,
                loading: C.loading
            }, {
                default: function () {
                    return [createVNode("div", {
                        style: ue,
                        class: "".concat(se, "-content")
                    }, [de && createVNode("span", {
                        class: "".concat(se, "-content-prefix")
                    }, [de]), pe, ve && createVNode("span", {
                        class: "".concat(se, "-content-suffix")
                    }, [ve])])]
                }
            })])
        }
    }
});
var timeUnits = [["Y", 1e3 * 60 * 60 * 24 * 365], ["M", 1e3 * 60 * 60 * 24 * 30], ["D", 1e3 * 60 * 60 * 24], ["H", 1e3 *
    60 * 60], ["m", 1e3 * 60], ["s", 1e3], ["S", 1]];

function formatTimeStr(K, C) {
    var H = K,
        W = /\[[^\]]*]/g,
        U = (C.match(W) || []).map(function (Q) {
            return Q.slice(1, -1)
        }),
        G = C.replace(W, "[]"),
        X = timeUnits.reduce(function (Q, ee) {
            var ne = _slicedToArray$2(ee, 2),
                te = ne[0],
                re = ne[1];
            if (Q.indexOf(te) !== -1) {
                var ae = Math.floor(H / re);
                return H -= ae * re, Q.replace(new RegExp("".concat(te, "+"), "g"), function (oe) {
                    var ie = oe.length;
                    return padStart(ae.toString(), ie, "0")
                })
            }
            return Q
        }, G),
        Z = 0;
    return X.replace(W, function () {
        var Q = U[Z];
        return Z += 1, Q
    })
}

function formatCountdown(K, C) {
    var H = C.format,
        W = H === void 0 ? "" : H,
        U = new Date(K).getTime(),
        G = Date.now(),
        X = Math.max(U - G, 0);
    return formatTimeStr(X, W)
}
var REFRESH_INTERVAL = 1e3 / 30;

function getTime(K) {
    return new Date(K).getTime()
}
var countdownProps = function () {
    return _objectSpread2$1(_objectSpread2$1({}, statisticProps()), {}, {
        value: [Number, String, Object],
        format: String,
        onFinish: Function,
        onChange: Function
    })
};
const Countdown = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AStatisticCountdown",
    props: initDefaultProps$1(countdownProps(), {
        format: "HH:mm:ss"
    }),
    setup: function (C, H) {
        var W = H.emit,
            U = H.slots,
            G = ref(),
            X = ref(),
            Z = function () {
                var ae = C.value,
                    oe = getTime(ae);
                oe >= Date.now() ? Q() : ee()
            },
            Q = function () {
                if (!G.value) {
                    var ae = getTime(C.value);
                    G.value = setInterval(function () {
                        X.value.$forceUpdate(), ae > Date.now() && W("change", ae - Date.now()), Z()
                    }, REFRESH_INTERVAL)
                }
            },
            ee = function () {
                var ae = C.value;
                if (G.value) {
                    clearInterval(G.value), G.value = void 0;
                    var oe = getTime(ae);
                    oe < Date.now() && W("finish")
                }
            },
            ne = function (ae) {
                var oe = ae.value,
                    ie = ae.config,
                    ue = C.format;
                return formatCountdown(oe, _objectSpread2$1(_objectSpread2$1({}, ie), {}, {
                    format: ue
                }))
            },
            te = function (ae) {
                return ae
            };
        return onMounted(function () {
                Z()
            }), onUpdated(function () {
                Z()
            }), onBeforeUnmount(function () {
                ee()
            }),
            function () {
                var re = C.value;
                return createVNode(Statistic, _objectSpread2$1({
                    ref: X
                }, _objectSpread2$1(_objectSpread2$1({}, omit$2(C, ["onFinish", "onChange"])), {}, {
                    value: re,
                    valueRender: te,
                    formatter: ne
                })), U)
            }
    }
});
Statistic.Countdown = Countdown;
Statistic.install = function (K) {
    return K.component(Statistic.name, Statistic), K.component(Statistic.Countdown.name, Statistic.Countdown), K
};
var StatisticCountdown = Statistic.Countdown,
    ArrowLeftOutlined$2 = {
        icon: {
            tag: "svg",
            attrs: {
                viewBox: "64 64 896 896",
                focusable: "false"
            },
            children: [{
                tag: "path",
                attrs: {
                    d: "M872 474H286.9l350.2-304c5.6-4.9 2.2-14-5.2-14h-88.5c-3.9 0-7.6 1.4-10.5 3.9L155 487.8a31.96 31.96 0 000 48.3L535.1 866c1.5 1.3 3.3 2 5.2 2h91.5c7.4 0 10.8-9.2 5.2-14L286.9 550H872c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z"
                }
            }]
        },
        name: "arrow-left",
        theme: "outlined"
    };
const ArrowLeftOutlinedSvg = ArrowLeftOutlined$2;

function _objectSpread$l(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$l(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$l(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var ArrowLeftOutlined = function (C, H) {
    var W = _objectSpread$l({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$l({}, W, {
        icon: ArrowLeftOutlinedSvg
    }), null)
};
ArrowLeftOutlined.displayName = "ArrowLeftOutlined";
ArrowLeftOutlined.inheritAttrs = !1;
const ArrowLeftOutlined$1 = ArrowLeftOutlined;
var ArrowRightOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M869 487.8L491.2 159.9c-2.9-2.5-6.6-3.9-10.5-3.9h-88.5c-7.4 0-10.8 9.2-5.2 14l350.2 304H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h585.1L386.9 854c-5.6 4.9-2.2 14 5.2 14h91.5c1.9 0 3.8-.7 5.2-2L869 536.2a32.07 32.07 0 000-48.4z"
            }
        }]
    },
    name: "arrow-right",
    theme: "outlined"
};
const ArrowRightOutlinedSvg = ArrowRightOutlined$2;

function _objectSpread$k(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$k(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$k(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var ArrowRightOutlined = function (C, H) {
    var W = _objectSpread$k({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$k({}, W, {
        icon: ArrowRightOutlinedSvg
    }), null)
};
ArrowRightOutlined.displayName = "ArrowRightOutlined";
ArrowRightOutlined.inheritAttrs = !1;
const ArrowRightOutlined$1 = ArrowRightOutlined;
var _excluded$l = ["noStyle", "disabled"],
    inlineStyle = {
        border: 0,
        background: "transparent",
        padding: 0,
        lineHeight: "inherit",
        display: "inline-block"
    },
    TransButton = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "TransButton",
        inheritAttrs: !1,
        props: {
            noStyle: {
                type: Boolean,
                default: void 0
            },
            onClick: Function,
            disabled: {
                type: Boolean,
                default: void 0
            },
            autofocus: {
                type: Boolean,
                default: void 0
            }
        },
        setup: function (C, H) {
            var W = H.slots,
                U = H.emit,
                G = H.attrs,
                X = H.expose,
                Z = ref(),
                Q = function (oe) {
                    var ie = oe.keyCode;
                    ie === KeyCode$1.ENTER && oe.preventDefault()
                },
                ee = function (oe) {
                    var ie = oe.keyCode;
                    ie === KeyCode$1.ENTER && U("click", oe)
                },
                ne = function (oe) {
                    U("click", oe)
                },
                te = function () {
                    Z.value && Z.value.focus()
                },
                re = function () {
                    Z.value && Z.value.blur()
                };
            return onMounted(function () {
                    C.autofocus && te()
                }), X({
                    focus: te,
                    blur: re
                }),
                function () {
                    var ae, oe = C.noStyle,
                        ie = C.disabled,
                        ue = _objectWithoutProperties$2(C, _excluded$l),
                        le = {};
                    return oe || (le = _objectSpread2$1({}, inlineStyle)), ie && (le.pointerEvents = "none"),
                        createVNode("div", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                            role: "button",
                            tabindex: 0,
                            ref: Z
                        }, ue), G), {}, {
                            onClick: ne,
                            onKeydown: Q,
                            onKeyup: ee,
                            style: _objectSpread2$1(_objectSpread2$1({}, le), G.style || {})
                        }), [(ae = W.default) === null || ae === void 0 ? void 0 : ae.call(W)])
                }
        }
    });
const TransButton$1 = TransButton;
var pageHeaderProps = function () {
        return {
            backIcon: PropTypes$1.any,
            prefixCls: String,
            title: PropTypes$1.any,
            subTitle: PropTypes$1.any,
            breadcrumb: PropTypes$1.object,
            tags: PropTypes$1.any,
            footer: PropTypes$1.any,
            extra: PropTypes$1.any,
            avatar: PropTypes$1.object,
            ghost: {
                type: Boolean,
                default: void 0
            },
            onBack: Function
        }
    },
    PageHeader = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "APageHeader",
        props: pageHeaderProps(),
        slots: ["backIcon", "avatar", "breadcrumb", "title", "subTitle", "tags", "extra", "footer"],
        setup: function (C, H) {
            var W = H.emit,
                U = H.slots,
                G = useConfigInject("page-header", C),
                X = G.prefixCls,
                Z = G.direction,
                Q = G.pageHeader,
                ee = ref(!1),
                ne = useDestroyed$1(),
                te = function (de) {
                    var ve = de.width;
                    ne.value || (ee.value = ve < 768)
                },
                re = computed(function () {
                    var ce, de, ve;
                    return (ce = (de = C.ghost) !== null && de !== void 0 ? de : (ve = Q.value) === null ||
                        ve === void 0 ? void 0 : ve.ghost) !== null && ce !== void 0 ? ce : !0
                }),
                ae = function () {
                    var de, ve, fe;
                    return (de = (ve = C.backIcon) !== null && ve !== void 0 ? ve : (fe = U.backIcon) === null ||
                            fe === void 0 ? void 0 : fe.call(U)) !== null && de !== void 0 ? de : Z.value ===
                        "rtl" ? createVNode(ArrowRightOutlined$1, null, null) : createVNode(ArrowLeftOutlined$1,
                            null, null)
                },
                oe = function (de) {
                    return !de || !C.onBack ? null : createVNode(LocaleReceiver, {
                        componentName: "PageHeader",
                        children: function (fe) {
                            var pe = fe.back;
                            return createVNode("div", {
                                class: "".concat(X.value, "-back")
                            }, [createVNode(TransButton$1, {
                                onClick: function (he) {
                                    W("back", he)
                                },
                                class: "".concat(X.value, "-back-button"),
                                "aria-label": pe
                            }, {
                                default: function () {
                                    return [de]
                                }
                            })])
                        }
                    }, null)
                },
                ie = function () {
                    var de;
                    return C.breadcrumb ? createVNode(Breadcrumb, C.breadcrumb, null) : (de = U.breadcrumb) ===
                        null || de === void 0 ? void 0 : de.call(U)
                },
                ue = function () {
                    var de, ve, fe, pe, me, he, Se, _e, be, ge = C.avatar,
                        xe = (de = C.title) !== null && de !== void 0 ? de : (ve = U.title) === null || ve ===
                        void 0 ? void 0 : ve.call(U),
                        Pe = (fe = C.subTitle) !== null && fe !== void 0 ? fe : (pe = U.subTitle) === null ||
                        pe === void 0 ? void 0 : pe.call(U),
                        $e = (me = C.tags) !== null && me !== void 0 ? me : (he = U.tags) === null || he ===
                        void 0 ? void 0 : he.call(U),
                        ye = (Se = C.extra) !== null && Se !== void 0 ? Se : (_e = U.extra) === null || _e ===
                        void 0 ? void 0 : _e.call(U),
                        Ce = "".concat(X.value, "-heading"),
                        we = xe || Pe || $e || ye;
                    if (!we) return null;
                    var Oe = ae(),
                        Ne = oe(Oe),
                        Me = Ne || ge || we;
                    return createVNode("div", {
                        class: Ce
                    }, [Me && createVNode("div", {
                        class: "".concat(Ce, "-left")
                    }, [Ne, ge ? createVNode(Avatar$1, ge, null) : (be = U.avatar) === null ||
                        be === void 0 ? void 0 : be.call(U), xe && createVNode("span", {
                            class: "".concat(Ce, "-title"),
                            title: typeof xe == "string" ? xe : void 0
                        }, [xe]), Pe && createVNode("span", {
                            class: "".concat(Ce, "-sub-title"),
                            title: typeof Pe == "string" ? Pe : void 0
                        }, [Pe]), $e && createVNode("span", {
                            class: "".concat(Ce, "-tags")
                        }, [$e])]), ye && createVNode("span", {
                        class: "".concat(Ce, "-extra")
                    }, [ye])])
                },
                le = function () {
                    var de, ve, fe = (de = C.footer) !== null && de !== void 0 ? de : filterEmpty((ve = U.footer) ===
                        null || ve === void 0 ? void 0 : ve.call(U));
                    return isEmptyContent(fe) ? null : createVNode("div", {
                        class: "".concat(X.value, "-footer")
                    }, [fe])
                },
                se = function (de) {
                    return createVNode("div", {
                        class: "".concat(X.value, "-content")
                    }, [de])
                };
            return function () {
                var ce, de, ve, fe = ((ce = C.breadcrumb) === null || ce === void 0 ? void 0 : ce.routes) ||
                    U.breadcrumb,
                    pe = C.footer || U.footer,
                    me = flattenChildren((de = U.default) === null || de === void 0 ? void 0 : de.call(U)),
                    he = classNames(X.value, (ve = {
                            "has-breadcrumb": fe,
                            "has-footer": pe
                        }, _defineProperty$V(ve, "".concat(X.value, "-ghost"), re.value),
                        _defineProperty$V(ve, "".concat(X.value, "-rtl"), Z.value === "rtl"),
                        _defineProperty$V(ve, "".concat(X.value, "-compact"), ee.value), ve));
                return createVNode(ResizeObserver$1, {
                    onResize: te
                }, {
                    default: function () {
                        return [createVNode("div", {
                            class: he
                        }, [ie(), ue(), me.length ? se(me) : null, le()])]
                    }
                })
            }
        }
    });
const index$a = withInstall(PageHeader);
var _excluded$k = ["placement", "overlayClassName"],
    popconfirmProps = function () {
        return _objectSpread2$1(_objectSpread2$1({}, abstractTooltipProps()), {}, {
            prefixCls: String,
            content: PropTypes$1.any,
            title: PropTypes$1.any,
            okType: {
                type: String,
                default: "primary"
            },
            disabled: {
                type: Boolean,
                default: !1
            },
            okText: PropTypes$1.any,
            cancelText: PropTypes$1.any,
            icon: PropTypes$1.any,
            okButtonProps: {
                type: Object,
                default: void 0
            },
            cancelButtonProps: {
                type: Object,
                default: void 0
            },
            showCancel: {
                type: Boolean,
                default: !0
            },
            onConfirm: Function,
            onCancel: Function
        })
    },
    Popconfirm = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "APopconfirm",
        props: initDefaultProps$1(popconfirmProps(), _objectSpread2$1(_objectSpread2$1({}, tooltipDefaultProps()), {}, {
            trigger: "click",
            transitionName: "zoom-big",
            placement: "top",
            mouseEnterDelay: .1,
            mouseLeaveDelay: .1,
            arrowPointAtCenter: !1,
            autoAdjustOverflow: !0,
            okType: "primary",
            disabled: !1
        })),
        slots: ["title", "content", "okText", "icon", "cancelText", "cancelButton", "okButton"],
        emits: ["update:visible", "visibleChange"],
        setup: function (C, H) {
            var W = H.slots,
                U = H.emit,
                G = H.expose;
            onMounted(function () {
                devWarning(C.defaultVisible === void 0, "Popconfirm",
                    "'defaultVisible' is deprecated, please use 'v-model:visible'")
            });
            var X = ref();
            G({
                getPopupDomNode: function () {
                    var be, ge;
                    return (be = X.value) === null || be === void 0 || (ge = be.getPopupDomNode) ===
                        null || ge === void 0 ? void 0 : ge.call(be)
                }
            });
            var Z = useMergedState(!1, {
                    value: toRef(C, "visible"),
                    defaultValue: C.defaultVisible
                }),
                Q = _slicedToArray$2(Z, 2),
                ee = Q[0],
                ne = Q[1],
                te = function (be, ge) {
                    C.visible === void 0 && ne(be), U("update:visible", be), U("visibleChange", be, ge)
                },
                re = function (be) {
                    te(!1, be)
                },
                ae = function (be) {
                    var ge;
                    return (ge = C.onConfirm) === null || ge === void 0 ? void 0 : ge.call(C, be)
                },
                oe = function (be) {
                    var ge;
                    te(!1, be), (ge = C.onCancel) === null || ge === void 0 || ge.call(C, be)
                },
                ie = function (be) {
                    be.keyCode === KeyCode$1.ESC && ee && te(!1, be)
                },
                ue = function (be) {
                    var ge = C.disabled;
                    ge || te(be)
                },
                le = useConfigInject("popconfirm", C),
                se = le.prefixCls,
                ce = le.getPrefixCls,
                de = computed(function () {
                    return ce()
                }),
                ve = computed(function () {
                    return ce("popover")
                }),
                fe = computed(function () {
                    return ce("btn")
                }),
                pe = useLocaleReceiver("Popconfirm", defaultLocale.Popconfirm),
                me = _slicedToArray$2(pe, 1),
                he = me[0],
                Se = function () {
                    var be, ge, xe, Pe, $e = C.okButtonProps,
                        ye = C.cancelButtonProps,
                        Ce = C.title,
                        we = Ce === void 0 ? (be = W.title) === null || be === void 0 ? void 0 : be.call(W) :
                        Ce,
                        Oe = C.cancelText,
                        Ne = Oe === void 0 ? (ge = W.cancel) === null || ge === void 0 ? void 0 : ge.call(W) :
                        Oe,
                        Me = C.okText,
                        Ve = Me === void 0 ? (xe = W.okText) === null || xe === void 0 ? void 0 : xe.call(W) :
                        Me,
                        ke = C.okType,
                        Ee = C.icon,
                        Ae = Ee === void 0 ? (Pe = W.icon) === null || Pe === void 0 ? void 0 : Pe.call(W) : Ee,
                        Re = C.showCancel,
                        He = Re === void 0 ? !0 : Re,
                        je = W.cancelButton,
                        Fe = W.okButton,
                        Le = _objectSpread2$1({
                            onClick: oe,
                            size: "small"
                        }, ye),
                        Ie = _objectSpread2$1(_objectSpread2$1({
                            onClick: ae
                        }, convertLegacyProps(ke)), {}, {
                            size: "small"
                        }, $e);
                    return createVNode("div", {
                        class: "".concat(ve.value, "-inner-content")
                    }, [createVNode("div", {
                        class: "".concat(ve.value, "-message")
                    }, [Ae || createVNode(ExclamationCircleFilled$1, null, null), createVNode(
                        "div", {
                            class: "".concat(ve.value, "-message-title")
                        }, [we])]), createVNode("div", {
                        class: "".concat(ve.value, "-buttons")
                    }, [He ? je ? je(Le) : createVNode(Button$1, Le, {
                        default: function () {
                            return [Ne || he.value.cancelText]
                        }
                    }) : null, Fe ? Fe(Ie) : createVNode(ActionButton, {
                        buttonProps: _objectSpread2$1(_objectSpread2$1({
                            size: "small"
                        }, convertLegacyProps(ke)), $e),
                        actionFn: ae,
                        close: re,
                        prefixCls: fe.value,
                        quitOnNullishReturnValue: !0,
                        emitEvent: !0
                    }, {
                        default: function () {
                            return [Ve || he.value.okText]
                        }
                    })])])
                };
            return function () {
                var _e, be = C.placement,
                    ge = C.overlayClassName,
                    xe = _objectWithoutProperties$2(C, _excluded$k),
                    Pe = omit$2(xe, ["title", "content", "cancelText", "okText", "onUpdate:visible",
                        "onConfirm", "onCancel"]),
                    $e = classNames(se.value, ge);
                return createVNode(Tooltip, _objectSpread2$1(_objectSpread2$1({}, Pe), {}, {
                    prefixCls: ve.value,
                    placement: be,
                    onVisibleChange: ue,
                    visible: ee.value,
                    overlayClassName: $e,
                    transitionName: getTransitionName$2(de.value, "zoom-big", C.transitionName),
                    ref: X
                }), {
                    default: function () {
                        return [cloneVNodes(((_e = W.default) === null || _e === void 0 ? void 0 :
                            _e.call(W)) || [], {
                            onKeydown: function (we) {
                                ie(we)
                            }
                        }, !1)]
                    },
                    title: Se
                })
            }
        }
    });
const index$9 = withInstall(Popconfirm);
var progressStatuses = tuple$1("normal", "exception", "active", "success"),
    ProgressType = tuple$1("line", "circle", "dashboard"),
    ProgressSize = tuple$1("default", "small"),
    progressProps = function () {
        return {
            prefixCls: String,
            type: PropTypes$1.oneOf(ProgressType),
            percent: Number,
            format: {
                type: Function
            },
            status: PropTypes$1.oneOf(progressStatuses),
            showInfo: {
                type: Boolean,
                default: void 0
            },
            strokeWidth: Number,
            strokeLinecap: String,
            strokeColor: {
                type: [String, Object],
                default: void 0
            },
            trailColor: String,
            width: Number,
            success: {
                type: Object,
                default: function () {
                    return {}
                }
            },
            gapDegree: Number,
            gapPosition: String,
            size: PropTypes$1.oneOf(ProgressSize),
            steps: Number,
            successPercent: Number,
            title: String
        }
    };

function validProgress(K) {
    return !K || K < 0 ? 0 : K > 100 ? 100 : K
}

function getSuccessPercent(K) {
    var C = K.success,
        H = K.successPercent,
        W = H;
    return C && "progress" in C && (devWarning(!1, "Progress",
            "`success.progress` is deprecated. Please use `success.percent` instead."), W = C.progress), C && "percent" in
        C && (W = C.percent), W
}
var _excluded$j = ["from", "to", "direction"],
    lineProps = function () {
        return _objectSpread2$1(_objectSpread2$1({}, progressProps()), {}, {
            prefixCls: String,
            direction: {
                type: String
            }
        })
    },
    sortGradient = function (C) {
        var H = [];
        return Object.keys(C).forEach(function (W) {
            var U = parseFloat(W.replace(/%/g, ""));
            isNaN(U) || H.push({
                key: U,
                value: C[W]
            })
        }), H = H.sort(function (W, U) {
            return W.key - U.key
        }), H.map(function (W) {
            var U = W.key,
                G = W.value;
            return "".concat(G, " ").concat(U, "%")
        }).join(", ")
    },
    handleGradient = function (C, H) {
        var W = C.from,
            U = W === void 0 ? presetPrimaryColors.blue : W,
            G = C.to,
            X = G === void 0 ? presetPrimaryColors.blue : G,
            Z = C.direction,
            Q = Z === void 0 ? H === "rtl" ? "to left" : "to right" : Z,
            ee = _objectWithoutProperties$2(C, _excluded$j);
        if (Object.keys(ee).length !== 0) {
            var ne = sortGradient(ee);
            return {
                backgroundImage: "linear-gradient(".concat(Q, ", ").concat(ne, ")")
            }
        }
        return {
            backgroundImage: "linear-gradient(".concat(Q, ", ").concat(U, ", ").concat(X, ")")
        }
    };
const Line = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Line",
    props: lineProps(),
    setup: function (C, H) {
        var W = H.slots,
            U = computed(function () {
                var ee = C.strokeColor,
                    ne = C.direction;
                return ee && typeof ee != "string" ? handleGradient(ee, ne) : {
                    background: ee
                }
            }),
            G = computed(function () {
                return C.trailColor ? {
                    backgroundColor: C.trailColor
                } : void 0
            }),
            X = computed(function () {
                var ee = C.percent,
                    ne = C.strokeWidth,
                    te = C.strokeLinecap,
                    re = C.size;
                return _objectSpread2$1({
                    width: "".concat(validProgress(ee), "%"),
                    height: "".concat(ne || (re === "small" ? 6 : 8), "px"),
                    borderRadius: te === "square" ? 0 : ""
                }, U.value)
            }),
            Z = computed(function () {
                return getSuccessPercent(C)
            }),
            Q = computed(function () {
                var ee = C.strokeWidth,
                    ne = C.size,
                    te = C.strokeLinecap,
                    re = C.success;
                return {
                    width: "".concat(validProgress(Z.value), "%"),
                    height: "".concat(ee || (ne === "small" ? 6 : 8), "px"),
                    borderRadius: te === "square" ? 0 : "",
                    backgroundColor: re == null ? void 0 : re.strokeColor
                }
            });
        return function () {
            var ee;
            return createVNode(Fragment, null, [createVNode("div", {
                class: "".concat(C.prefixCls, "-outer")
            }, [createVNode("div", {
                class: "".concat(C.prefixCls, "-inner"),
                style: G.value
            }, [createVNode("div", {
                class: "".concat(C.prefixCls, "-bg"),
                style: X.value
            }, null), Z.value !== void 0 ? createVNode("div", {
                class: "".concat(C.prefixCls, "-success-bg"),
                style: Q.value
            }, null) : null])]), (ee = W.default) === null || ee === void 0 ? void 0 : ee.call(
                W)])
        }
    }
});
var defaultProps = {
        percent: 0,
        prefixCls: "vc-progress",
        strokeColor: "#2db7f5",
        strokeLinecap: "round",
        strokeWidth: 1,
        trailColor: "#D9D9D9",
        trailWidth: 1
    },
    useTransitionDuration = function (C) {
        var H = ref(null);
        return onUpdated(function () {
            var W = Date.now(),
                U = !1;
            C.value.forEach(function (G) {
                var X = (G == null ? void 0 : G.$el) || G;
                if (X) {
                    U = !0;
                    var Z = X.style;
                    Z.transitionDuration = ".3s, .3s, .3s, .06s", H.value && W - H.value < 100 && (Z.transitionDuration =
                        "0s, 0s")
                }
            }), U && (H.value = Date.now())
        }), C
    },
    propTypes = {
        gapDegree: Number,
        gapPosition: {
            type: String
        },
        percent: {
            type: [Array, Number]
        },
        prefixCls: String,
        strokeColor: {
            type: [Object, String, Array]
        },
        strokeLinecap: {
            type: String
        },
        strokeWidth: Number,
        trailColor: String,
        trailWidth: Number,
        transition: String
    },
    _excluded$i = ["prefixCls", "strokeWidth", "trailWidth", "gapDegree", "gapPosition", "trailColor", "strokeLinecap",
        "strokeColor"],
    gradientSeed = 0;

function stripPercentToNumber(K) {
    return +K.replace("%", "")
}

function toArray$3(K) {
    return Array.isArray(K) ? K : [K]
}

function getPathStyles(K, C, H, W) {
    var U = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0,
        G = arguments.length > 5 ? arguments[5] : void 0,
        X = 50 - W / 2,
        Z = 0,
        Q = -X,
        ee = 0,
        ne = -2 * X;
    switch (G) {
        case "left":
            Z = -X, Q = 0, ee = 2 * X, ne = 0;
            break;
        case "right":
            Z = X, Q = 0, ee = -2 * X, ne = 0;
            break;
        case "bottom":
            Q = X, ne = 2 * X;
            break
    }
    var te = "M 50,50 m ".concat(Z, ",").concat(Q, `
   a `).concat(X, ",").concat(X, " 0 1 1 ").concat(ee, ",").concat(
            -ne, `
   a `).concat(X, ",").concat(X, " 0 1 1 ").concat(-ee, ",").concat(ne),
        re = Math.PI * 2 * X,
        ae = {
            stroke: H,
            strokeDasharray: "".concat(C / 100 * (re - U), "px ").concat(re, "px"),
            strokeDashoffset: "-".concat(U / 2 + K / 100 * (re - U), "px"),
            transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s"
        };
    return {
        pathString: te,
        pathStyle: ae
    }
}
const VCCircle = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "VCCircle",
    props: initDefaultProps$1(propTypes, defaultProps),
    setup: function (C) {
        gradientSeed += 1;
        var H = ref(gradientSeed),
            W = computed(function () {
                return toArray$3(C.percent)
            }),
            U = computed(function () {
                return toArray$3(C.strokeColor)
            }),
            G = useRefs$1(),
            X = _slicedToArray$2(G, 2),
            Z = X[0],
            Q = X[1];
        useTransitionDuration(Q);
        var ee = function () {
            var te = C.prefixCls,
                re = C.strokeWidth,
                ae = C.strokeLinecap,
                oe = C.gapDegree,
                ie = C.gapPosition,
                ue = 0;
            return W.value.map(function (le, se) {
                var ce = U.value[se] || U.value[U.value.length - 1],
                    de = Object.prototype.toString.call(ce) === "[object Object]" ? "url(#".concat(
                        te, "-gradient-").concat(H.value, ")") : "",
                    ve = getPathStyles(ue, le, ce, re, oe, ie),
                    fe = ve.pathString,
                    pe = ve.pathStyle;
                ue += le;
                var me = {
                    key: se,
                    d: fe,
                    stroke: de,
                    "stroke-linecap": ae,
                    "stroke-width": re,
                    opacity: le === 0 ? 0 : 1,
                    "fill-opacity": "0",
                    class: "".concat(te, "-circle-path"),
                    style: pe
                };
                return createVNode("path", _objectSpread2$1({
                    ref: Z(se)
                }, me), null)
            })
        };
        return function () {
            var ne = C.prefixCls,
                te = C.strokeWidth,
                re = C.trailWidth,
                ae = C.gapDegree,
                oe = C.gapPosition,
                ie = C.trailColor,
                ue = C.strokeLinecap;
            C.strokeColor;
            var le = _objectWithoutProperties$2(C, _excluded$i),
                se = getPathStyles(0, 100, ie, te, ae, oe),
                ce = se.pathString,
                de = se.pathStyle;
            delete le.percent;
            var ve = U.value.find(function (pe) {
                    return Object.prototype.toString.call(pe) === "[object Object]"
                }),
                fe = {
                    d: ce,
                    stroke: ie,
                    "stroke-linecap": ue,
                    "stroke-width": re || te,
                    "fill-opacity": "0",
                    class: "".concat(ne, "-circle-trail"),
                    style: de
                };
            return createVNode("svg", _objectSpread2$1({
                class: "".concat(ne, "-circle"),
                viewBox: "0 0 100 100"
            }, le), [ve && createVNode("defs", null, [createVNode("linearGradient", {
                id: "".concat(ne, "-gradient-").concat(H.value),
                x1: "100%",
                y1: "0%",
                x2: "0%",
                y2: "0%"
            }, [Object.keys(ve).sort(function (pe, me) {
                return stripPercentToNumber(pe) - stripPercentToNumber(
                    me)
            }).map(function (pe, me) {
                return createVNode("stop", {
                    key: me,
                    offset: pe,
                    "stop-color": ve[pe]
                }, null)
            })])]), createVNode("path", fe, null), ee().reverse()])
        }
    }
});

function getPercentage(K) {
    var C = K.percent,
        H = K.success,
        W = K.successPercent,
        U = validProgress(getSuccessPercent({
            success: H,
            successPercent: W
        }));
    return [U, validProgress(validProgress(C) - U)]
}

function getStrokeColor(K) {
    var C = K.success,
        H = C === void 0 ? {} : C,
        W = K.strokeColor,
        U = H.strokeColor;
    return [U || presetPrimaryColors.green, W || null]
}
const Circle = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Circle",
    inheritAttrs: !1,
    props: progressProps(),
    setup: function (C, H) {
        var W = H.slots,
            U = computed(function () {
                if (C.gapDegree || C.gapDegree === 0) return C.gapDegree;
                if (C.type === "dashboard") return 75
            }),
            G = computed(function () {
                var re = C.width || 120;
                return {
                    width: typeof re == "number" ? "".concat(re, "px") : re,
                    height: typeof re == "number" ? "".concat(re, "px") : re,
                    fontSize: "".concat(re * .15 + 6, "px")
                }
            }),
            X = computed(function () {
                return C.strokeWidth || 6
            }),
            Z = computed(function () {
                return C.gapPosition || C.type === "dashboard" && "bottom" || "top"
            }),
            Q = computed(function () {
                return getPercentage(C)
            }),
            ee = computed(function () {
                return Object.prototype.toString.call(C.strokeColor) === "[object Object]"
            }),
            ne = computed(function () {
                return getStrokeColor({
                    success: C.success,
                    strokeColor: C.strokeColor
                })
            }),
            te = computed(function () {
                var re;
                return re = {}, _defineProperty$V(re, "".concat(C.prefixCls, "-inner"), !0),
                    _defineProperty$V(re, "".concat(C.prefixCls, "-circle-gradient"), ee.value), re
            });
        return function () {
            var re;
            return createVNode("div", {
                class: te.value,
                style: G.value
            }, [createVNode(VCCircle, {
                percent: Q.value,
                strokeWidth: X.value,
                trailWidth: X.value,
                strokeColor: ne.value,
                strokeLinecap: C.strokeLinecap,
                trailColor: C.trailColor,
                prefixCls: C.prefixCls,
                gapDegree: U.value,
                gapPosition: Z.value
            }, null), (re = W.default) === null || re === void 0 ? void 0 : re.call(W)])
        }
    }
});
var stepsProps$1 = function () {
    return _objectSpread2$1(_objectSpread2$1({}, progressProps()), {}, {
        steps: Number,
        size: {
            type: String
        },
        strokeColor: String,
        trailColor: String
    })
};
const Steps$4 = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "Steps",
        props: stepsProps$1(),
        setup: function (C, H) {
            var W = H.slots,
                U = computed(function () {
                    return Math.round(C.steps * ((C.percent || 0) / 100))
                }),
                G = computed(function () {
                    return C.size === "small" ? 2 : 14
                }),
                X = computed(function () {
                    for (var Z = C.steps, Q = C.strokeWidth, ee = Q === void 0 ? 8 : Q, ne = C.strokeColor,
                            te = C.trailColor, re = C.prefixCls, ae = [], oe = 0; oe < Z; oe += 1) {
                        var ie, ue = (ie = {}, _defineProperty$V(ie, "".concat(re, "-steps-item"), !0),
                            _defineProperty$V(ie, "".concat(re, "-steps-item-active"), oe <= U.value -
                                1), ie);
                        ae.push(createVNode("div", {
                            key: oe,
                            class: ue,
                            style: {
                                backgroundColor: oe <= U.value - 1 ? ne : te,
                                width: "".concat(G.value, "px"),
                                height: "".concat(ee, "px")
                            }
                        }, null))
                    }
                    return ae
                });
            return function () {
                var Z;
                return createVNode("div", {
                    class: "".concat(C.prefixCls, "-steps-outer")
                }, [X.value, (Z = W.default) === null || Z === void 0 ? void 0 : Z.call(W)])
            }
        }
    }),
    Progress$1 = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "AProgress",
        props: initDefaultProps$1(progressProps(), {
            type: "line",
            percent: 0,
            showInfo: !0,
            trailColor: null,
            size: "default",
            strokeLinecap: "round"
        }),
        slots: ["format"],
        setup: function (C, H) {
            var W = H.slots,
                U = useConfigInject("progress", C),
                G = U.prefixCls,
                X = U.direction;
            devWarning(C.successPercent == null, "Progress",
                "`successPercent` is deprecated. Please use `success.percent` instead.");
            var Z = computed(function () {
                    var te, re = C.type,
                        ae = C.showInfo,
                        oe = C.size,
                        ie = G.value;
                    return te = {}, _defineProperty$V(te, ie, !0), _defineProperty$V(te, "".concat(ie, "-")
                            .concat(re === "dashboard" && "circle" || re), !0), _defineProperty$V(te, "".concat(
                            ie, "-show-info"), ae), _defineProperty$V(te, "".concat(ie, "-").concat(oe), oe),
                        _defineProperty$V(te, "".concat(ie, "-rtl"), X.value === "rtl"), te
                }),
                Q = computed(function () {
                    var te = C.percent,
                        re = te === void 0 ? 0 : te,
                        ae = getSuccessPercent(C);
                    return parseInt(ae !== void 0 ? ae.toString() : re.toString(), 10)
                }),
                ee = computed(function () {
                    var te = C.status;
                    return progressStatuses.indexOf(te) < 0 && Q.value >= 100 ? "success" : te || "normal"
                }),
                ne = function () {
                    var re = C.showInfo,
                        ae = C.format,
                        oe = C.type,
                        ie = C.percent,
                        ue = C.title,
                        le = getSuccessPercent(C);
                    if (!re) return null;
                    var se, ce = ae || (W == null ? void 0 : W.format) || function (ve) {
                            return "".concat(ve, "%")
                        },
                        de = oe === "line";
                    return ae || W != null && W.format || ee.value !== "exception" && ee.value !== "success" ?
                        se = ce(validProgress(ie), validProgress(le)) : ee.value === "exception" ? se =
                        createVNode(de ? CloseCircleFilled$1 : CloseOutlined$1, null, null) : ee.value ===
                        "success" && (se = createVNode(de ? CheckCircleFilled$1 : CheckOutlined$1, null, null)),
                        createVNode("span", {
                            class: "".concat(G.value, "-text"),
                            title: ue === void 0 && typeof se == "string" ? se : void 0
                        }, [se])
                };
            return function () {
                var te = C.type,
                    re = C.steps,
                    ae = C.strokeColor,
                    oe = C.title,
                    ie = ne(),
                    ue;
                te === "line" ? ue = re ? createVNode(Steps$4, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                    strokeColor: typeof ae == "string" ? ae : void 0,
                    prefixCls: G.value,
                    steps: re
                }), {
                    default: function () {
                        return [ie]
                    }
                }) : createVNode(Line, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                    prefixCls: G.value
                }), {
                    default: function () {
                        return [ie]
                    }
                }) : (te === "circle" || te === "dashboard") && (ue = createVNode(Circle,
                    _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                        prefixCls: G.value
                    }), {
                        default: function () {
                            return [ie]
                        }
                    }));
                var le = _objectSpread2$1(_objectSpread2$1({}, Z.value), {}, _defineProperty$V({}, "".concat(
                    G.value, "-status-").concat(ee.value), !0));
                return createVNode("div", {
                    class: le,
                    title: oe
                }, [ue])
            }
        }
    }),
    Progress = withInstall(Progress$1);

function getScroll(K) {
    var C = K.pageXOffset,
        H = "scrollLeft";
    if (typeof C != "number") {
        var W = K.document;
        C = W.documentElement[H], typeof C != "number" && (C = W.body[H])
    }
    return C
}

function getClientPosition(K) {
    var C, H, W = K.ownerDocument,
        U = W.body,
        G = W && W.documentElement,
        X = K.getBoundingClientRect();
    return C = X.left, H = X.top, C -= G.clientLeft || U.clientLeft || 0, H -= G.clientTop || U.clientTop || 0, {
        left: C,
        top: H
    }
}

function getOffsetLeft(K) {
    var C = getClientPosition(K),
        H = K.ownerDocument,
        W = H.defaultView || H.parentWindow;
    return C.left += getScroll(W), C.left
}
var StarFilled$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 00.6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0046.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z"
            }
        }]
    },
    name: "star",
    theme: "filled"
};
const StarFilledSvg = StarFilled$2;

function _objectSpread$j(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$j(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$j(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var StarFilled = function (C, H) {
    var W = _objectSpread$j({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$j({}, W, {
        icon: StarFilledSvg
    }), null)
};
StarFilled.displayName = "StarFilled";
StarFilled.inheritAttrs = !1;
const StarFilled$1 = StarFilled;
var starProps = {
    value: Number,
    index: Number,
    prefixCls: String,
    allowHalf: {
        type: Boolean,
        default: void 0
    },
    disabled: {
        type: Boolean,
        default: void 0
    },
    character: PropTypes$1.any,
    characterRender: Function,
    focused: {
        type: Boolean,
        default: void 0
    },
    count: Number,
    onClick: Function,
    onHover: Function
};
const Star = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Star",
    inheritAttrs: !1,
    props: starProps,
    emits: ["hover", "click"],
    setup: function (C, H) {
        var W = H.slots,
            U = H.emit,
            G = function (ne) {
                var te = C.index;
                U("hover", ne, te)
            },
            X = function (ne) {
                var te = C.index;
                U("click", ne, te)
            },
            Z = function (ne) {
                var te = C.index;
                ne.keyCode === 13 && U("click", ne, te)
            },
            Q = computed(function () {
                var ee = C.prefixCls,
                    ne = C.index,
                    te = C.value,
                    re = C.allowHalf,
                    ae = C.focused,
                    oe = ne + 1,
                    ie = ee;
                return te === 0 && ne === 0 && ae ? ie += " ".concat(ee, "-focused") : re && te + .5 >=
                    oe && te < oe ? (ie += " ".concat(ee, "-half ").concat(ee, "-active"), ae && (ie +=
                        " ".concat(ee, "-focused"))) : (ie += oe <= te ? " ".concat(ee, "-full") : " ".concat(
                        ee, "-zero"), oe === te && ae && (ie += " ".concat(ee, "-focused"))), ie
            });
        return function () {
            var ee = C.disabled,
                ne = C.prefixCls,
                te = C.characterRender,
                re = C.index,
                ae = C.count,
                oe = C.value,
                ie = getPropsSlot(W, C, "character"),
                ue = createVNode("li", {
                    class: Q.value
                }, [createVNode("div", {
                    onClick: ee ? null : X,
                    onKeydown: ee ? null : Z,
                    onMousemove: ee ? null : G,
                    role: "radio",
                    "aria-checked": oe > re ? "true" : "false",
                    "aria-posinset": re + 1,
                    "aria-setsize": ae,
                    tabindex: ee ? -1 : 0
                }, [createVNode("div", {
                    class: "".concat(ne, "-first")
                }, [ie]), createVNode("div", {
                    class: "".concat(ne, "-second")
                }, [ie])])]);
            return te && (ue = te(ue, C)), ue
        }
    }
});
var rateProps = function () {
        return {
            prefixCls: String,
            count: Number,
            value: Number,
            allowHalf: {
                type: Boolean,
                default: void 0
            },
            allowClear: {
                type: Boolean,
                default: void 0
            },
            tooltips: Array,
            disabled: {
                type: Boolean,
                default: void 0
            },
            character: PropTypes$1.any,
            autofocus: {
                type: Boolean,
                default: void 0
            },
            tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
            direction: String,
            id: String,
            onChange: Function,
            onHoverChange: Function,
            "onUpdate:value": Function,
            onFocus: Function,
            onBlur: Function,
            onKeydown: Function
        }
    },
    Rate = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ARate",
        inheritAttrs: !1,
        props: initDefaultProps$1(rateProps(), {
            value: 0,
            count: 5,
            allowHalf: !1,
            allowClear: !0,
            tabindex: 0,
            direction: "ltr"
        }),
        setup: function (C, H) {
            var W = H.slots,
                U = H.attrs,
                G = H.emit,
                X = H.expose,
                Z = useConfigInject("rate", C),
                Q = Z.prefixCls,
                ee = Z.direction,
                ne = useInjectFormItemContext(),
                te = ref(),
                re = useRefs$1(),
                ae = _slicedToArray$2(re, 2),
                oe = ae[0],
                ie = ae[1],
                ue = reactive({
                    value: C.value,
                    focused: !1,
                    cleanedValue: null,
                    hoverValue: void 0
                });
            watch(function () {
                return C.value
            }, function () {
                ue.value = C.value
            });
            var le = function (Pe) {
                    return findDOMNode(ie.value.get(Pe))
                },
                se = function (Pe, $e) {
                    var ye = ee.value === "rtl",
                        Ce = Pe + 1;
                    if (C.allowHalf) {
                        var we = le(Pe),
                            Oe = getOffsetLeft(we),
                            Ne = we.clientWidth;
                        (ye && $e - Oe > Ne / 2 || !ye && $e - Oe < Ne / 2) && (Ce -= .5)
                    }
                    return Ce
                },
                ce = function (Pe) {
                    C.value === void 0 && (ue.value = Pe), G("update:value", Pe), G("change", Pe), ne.onFieldChange()
                },
                de = function (Pe, $e) {
                    var ye = se($e, Pe.pageX);
                    ye !== ue.cleanedValue && (ue.hoverValue = ye, ue.cleanedValue = null), G("hoverChange", ye)
                },
                ve = function () {
                    ue.hoverValue = void 0, ue.cleanedValue = null, G("hoverChange", void 0)
                },
                fe = function (Pe, $e) {
                    var ye = C.allowClear,
                        Ce = se($e, Pe.pageX),
                        we = !1;
                    ye && (we = Ce === ue.value), ve(), ce(we ? 0 : Ce), ue.cleanedValue = we ? Ce : null
                },
                pe = function (Pe) {
                    ue.focused = !0, G("focus", Pe)
                },
                me = function (Pe) {
                    ue.focused = !1, G("blur", Pe), ne.onFieldBlur()
                },
                he = function (Pe) {
                    var $e = Pe.keyCode,
                        ye = C.count,
                        Ce = C.allowHalf,
                        we = ee.value === "rtl";
                    $e === KeyCode$1.RIGHT && ue.value < ye && !we ? (Ce ? ue.value += .5 : ue.value += 1, ce(
                            ue.value), Pe.preventDefault()) : $e === KeyCode$1.LEFT && ue.value > 0 && !we ||
                        $e === KeyCode$1.RIGHT && ue.value > 0 && we ? (Ce ? ue.value -= .5 : ue.value -= 1, ce(
                            ue.value), Pe.preventDefault()) : $e === KeyCode$1.LEFT && ue.value < ye && we && (
                            Ce ? ue.value += .5 : ue.value += 1, ce(ue.value), Pe.preventDefault()), G(
                            "keydown", Pe)
                },
                Se = function () {
                    C.disabled || te.value.focus()
                },
                _e = function () {
                    C.disabled || te.value.blur()
                };
            X({
                focus: Se,
                blur: _e
            }), onMounted(function () {
                var xe = C.autofocus,
                    Pe = C.disabled;
                xe && !Pe && Se()
            });
            var be = function (Pe, $e) {
                    var ye = $e.index,
                        Ce = C.tooltips;
                    return Ce ? createVNode(Tooltip, {
                        title: Ce[ye]
                    }, {
                        default: function () {
                            return [Pe]
                        }
                    }) : Pe
                },
                ge = getPropsSlot(W, C, "character") || createVNode(StarFilled$1, null, null);
            return function () {
                for (var xe = C.count, Pe = C.allowHalf, $e = C.disabled, ye = C.tabindex, Ce = C.id, we =
                        Ce === void 0 ? ne.id.value : Ce, Oe = U.class, Ne = U.style, Me = [], Ve = $e ? ""
                        .concat(Q.value, "-disabled") : "", ke = 0; ke < xe; ke++) Me.push(createVNode(Star, {
                    ref: oe(ke),
                    key: ke,
                    index: ke,
                    count: xe,
                    disabled: $e,
                    prefixCls: "".concat(Q.value, "-star"),
                    allowHalf: Pe,
                    value: ue.hoverValue === void 0 ? ue.value : ue.hoverValue,
                    onClick: fe,
                    onHover: de,
                    character: ge,
                    characterRender: be,
                    focused: ue.focused
                }, null));
                var Ee = classNames(Q.value, Ve, Oe, _defineProperty$V({}, "".concat(Q.value, "-rtl"), ee.value ===
                    "rtl"));
                return createVNode("ul", _objectSpread2$1(_objectSpread2$1({}, U), {}, {
                    id: we,
                    class: Ee,
                    style: Ne,
                    onMouseleave: $e ? null : ve,
                    tabindex: $e ? -1 : ye,
                    onFocus: $e ? null : pe,
                    onBlur: $e ? null : me,
                    onKeydown: $e ? null : he,
                    ref: te,
                    role: "radiogroup"
                }), [Me])
            }
        }
    });
const index$8 = withInstall(Rate);
var WarningFilled$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M955.7 856l-416-720c-6.2-10.7-16.9-16-27.7-16s-21.6 5.3-27.7 16l-416 720C56 877.4 71.4 904 96 904h832c24.6 0 40-26.6 27.7-48zM480 416c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v184c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V416zm32 352a48.01 48.01 0 010-96 48.01 48.01 0 010 96z"
            }
        }]
    },
    name: "warning",
    theme: "filled"
};
const WarningFilledSvg = WarningFilled$2;

function _objectSpread$i(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$i(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$i(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var WarningFilled = function (C, H) {
    var W = _objectSpread$i({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$i({}, W, {
        icon: WarningFilledSvg
    }), null)
};
WarningFilled.displayName = "WarningFilled";
WarningFilled.inheritAttrs = !1;
const WarningFilled$1 = WarningFilled;
var NoFound = function () {
    return createVNode("svg", {
        width: "252",
        height: "294"
    }, [createVNode("defs", null, [createVNode("path", {
        d: "M0 .387h251.772v251.772H0z"
    }, null)]), createVNode("g", {
        fill: "none",
        "fill-rule": "evenodd"
    }, [createVNode("g", {
        transform: "translate(0 .012)"
    }, [createVNode("mask", {
        fill: "#fff"
    }, null), createVNode("path", {
        d: "M0 127.32v-2.095C0 56.279 55.892.387 124.838.387h2.096c68.946 0 124.838 55.892 124.838 124.838v2.096c0 68.946-55.892 124.838-124.838 124.838h-2.096C55.892 252.16 0 196.267 0 127.321",
        fill: "#E4EBF7",
        mask: "url(#b)"
    }, null)]), createVNode("path", {
        d: "M39.755 130.84a8.276 8.276 0 1 1-16.468-1.66 8.276 8.276 0 0 1 16.468 1.66",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M36.975 134.297l10.482 5.943M48.373 146.508l-12.648 10.788",
        stroke: "#FFF",
        "stroke-width": "2"
    }, null), createVNode("path", {
        d: "M39.875 159.352a5.667 5.667 0 1 1-11.277-1.136 5.667 5.667 0 0 1 11.277 1.136M57.588 143.247a5.708 5.708 0 1 1-11.358-1.145 5.708 5.708 0 0 1 11.358 1.145M99.018 26.875l29.82-.014a4.587 4.587 0 1 0-.003-9.175l-29.82.013a4.587 4.587 0 1 0 .003 9.176M110.424 45.211l29.82-.013a4.588 4.588 0 0 0-.004-9.175l-29.82.013a4.587 4.587 0 1 0 .004 9.175",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M112.798 26.861v-.002l15.784-.006a4.588 4.588 0 1 0 .003 9.175l-15.783.007v-.002a4.586 4.586 0 0 0-.004-9.172M184.523 135.668c-.553 5.485-5.447 9.483-10.931 8.93-5.485-.553-9.483-5.448-8.93-10.932.552-5.485 5.447-9.483 10.932-8.93 5.485.553 9.483 5.447 8.93 10.932",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M179.26 141.75l12.64 7.167M193.006 156.477l-15.255 13.011",
        stroke: "#FFF",
        "stroke-width": "2"
    }, null), createVNode("path", {
        d: "M184.668 170.057a6.835 6.835 0 1 1-13.6-1.372 6.835 6.835 0 0 1 13.6 1.372M203.34 153.325a6.885 6.885 0 1 1-13.7-1.382 6.885 6.885 0 0 1 13.7 1.382",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M151.931 192.324a2.222 2.222 0 1 1-4.444 0 2.222 2.222 0 0 1 4.444 0zM225.27 116.056a2.222 2.222 0 1 1-4.445 0 2.222 2.222 0 0 1 4.444 0zM216.38 151.08a2.223 2.223 0 1 1-4.446-.001 2.223 2.223 0 0 1 4.446 0zM176.917 107.636a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM195.291 92.165a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM202.058 180.711a2.223 2.223 0 1 1-4.446 0 2.223 2.223 0 0 1 4.446 0z",
        stroke: "#FFF",
        "stroke-width": "2"
    }, null), createVNode("path", {
        stroke: "#FFF",
        "stroke-width": "2",
        d: "M214.404 153.302l-1.912 20.184-10.928 5.99M173.661 174.792l-6.356 9.814h-11.36l-4.508 6.484M174.941 125.168v-15.804M220.824 117.25l-12.84 7.901-15.31-7.902V94.39"
    }, null), createVNode("path", {
        d: "M166.588 65.936h-3.951a4.756 4.756 0 0 1-4.743-4.742 4.756 4.756 0 0 1 4.743-4.743h3.951a4.756 4.756 0 0 1 4.743 4.743 4.756 4.756 0 0 1-4.743 4.742",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M174.823 30.03c0-16.281 13.198-29.48 29.48-29.48 16.28 0 29.48 13.199 29.48 29.48 0 16.28-13.2 29.48-29.48 29.48-16.282 0-29.48-13.2-29.48-29.48",
        fill: "#1890FF"
    }, null), createVNode("path", {
        d: "M205.952 38.387c.5.5.785 1.142.785 1.928s-.286 1.465-.785 1.964c-.572.5-1.214.75-2 .75-.785 0-1.429-.285-1.929-.785-.572-.5-.82-1.143-.82-1.929s.248-1.428.82-1.928c.5-.5 1.144-.75 1.93-.75.785 0 1.462.25 1.999.75m4.285-19.463c1.428 1.249 2.143 2.963 2.143 5.142 0 1.712-.427 3.13-1.219 4.25-.067.096-.137.18-.218.265-.416.429-1.41 1.346-2.956 2.699a5.07 5.07 0 0 0-1.428 1.75 5.207 5.207 0 0 0-.536 2.357v.5h-4.107v-.5c0-1.357.215-2.536.714-3.5.464-.964 1.857-2.464 4.178-4.536l.43-.5c.643-.785.964-1.643.964-2.535 0-1.18-.358-2.108-1-2.785-.678-.68-1.643-1.001-2.858-1.001-1.536 0-2.642.464-3.357 1.43-.37.5-.621 1.135-.76 1.904a1.999 1.999 0 0 1-1.971 1.63h-.004c-1.277 0-2.257-1.183-1.98-2.43.337-1.518 1.02-2.78 2.073-3.784 1.536-1.5 3.607-2.25 6.25-2.25 2.32 0 4.214.607 5.642 1.894",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M52.04 76.131s21.81 5.36 27.307 15.945c5.575 10.74-6.352 9.26-15.73 4.935-10.86-5.008-24.7-11.822-11.577-20.88",
        fill: "#FFB594"
    }, null), createVNode("path", {
        d: "M90.483 67.504l-.449 2.893c-.753.49-4.748-2.663-4.748-2.663l-1.645.748-1.346-5.684s6.815-4.589 8.917-5.018c2.452-.501 9.884.94 10.7 2.278 0 0 1.32.486-2.227.69-3.548.203-5.043.447-6.79 3.132-1.747 2.686-2.412 3.624-2.412 3.624",
        fill: "#FFC6A0"
    }, null), createVNode("path", {
        d: "M128.055 111.367c-2.627-7.724-6.15-13.18-8.917-15.478-3.5-2.906-9.34-2.225-11.366-4.187-1.27-1.231-3.215-1.197-3.215-1.197s-14.98-3.158-16.828-3.479c-2.37-.41-2.124-.714-6.054-1.405-1.57-1.907-2.917-1.122-2.917-1.122l-7.11-1.383c-.853-1.472-2.423-1.023-2.423-1.023l-2.468-.897c-1.645 9.976-7.74 13.796-7.74 13.796 1.795 1.122 15.703 8.3 15.703 8.3l5.107 37.11s-3.321 5.694 1.346 9.109c0 0 19.883-3.743 34.921-.329 0 0 3.047-2.546.972-8.806.523-3.01 1.394-8.263 1.736-11.622.385.772 2.019 1.918 3.14 3.477 0 0 9.407-7.365 11.052-14.012-.832-.723-1.598-1.585-2.267-2.453-.567-.736-.358-2.056-.765-2.717-.669-1.084-1.804-1.378-1.907-1.682",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M101.09 289.998s4.295 2.041 7.354 1.021c2.821-.94 4.53.668 7.08 1.178 2.55.51 6.874 1.1 11.686-1.26-.103-5.51-6.889-3.98-11.96-6.713-2.563-1.38-3.784-4.722-3.598-8.799h-9.402s-1.392 10.52-1.16 14.573",
        fill: "#CBD1D1"
    }, null), createVNode("path", {
        d: "M101.067 289.826s2.428 1.271 6.759.653c3.058-.437 3.712.481 7.423 1.031 3.712.55 10.724-.069 11.823-.894.413 1.1-.343 2.063-.343 2.063s-1.512.603-4.812.824c-2.03.136-5.8.291-7.607-.503-1.787-1.375-5.247-1.903-5.728-.241-3.918.95-7.355-.286-7.355-.286l-.16-2.647z",
        fill: "#2B0849"
    }, null), createVNode("path", {
        d: "M108.341 276.044h3.094s-.103 6.702 4.536 8.558c-4.64.618-8.558-2.303-7.63-8.558",
        fill: "#A4AABA"
    }, null), createVNode("path", {
        d: "M57.542 272.401s-2.107 7.416-4.485 12.306c-1.798 3.695-4.225 7.492 5.465 7.492 6.648 0 8.953-.48 7.423-6.599-1.53-6.12.266-13.199.266-13.199h-8.669z",
        fill: "#CBD1D1"
    }, null), createVNode("path", {
        d: "M51.476 289.793s2.097 1.169 6.633 1.169c6.083 0 8.249-1.65 8.249-1.65s.602 1.114-.619 2.165c-.993.855-3.597 1.591-7.39 1.546-4.145-.048-5.832-.566-6.736-1.168-.825-.55-.687-1.58-.137-2.062",
        fill: "#2B0849"
    }, null), createVNode("path", {
        d: "M58.419 274.304s.033 1.519-.314 2.93c-.349 1.42-1.078 3.104-1.13 4.139-.058 1.151 4.537 1.58 5.155.034.62-1.547 1.294-6.427 1.913-7.252.619-.825-4.903-2.119-5.624.15",
        fill: "#A4AABA"
    }, null), createVNode("path", {
        d: "M99.66 278.514l13.378.092s1.298-54.52 1.853-64.403c.554-9.882 3.776-43.364 1.002-63.128l-12.547-.644-22.849.78s-.434 3.966-1.195 9.976c-.063.496-.682.843-.749 1.365-.075.585.423 1.354.32 1.966-2.364 14.08-6.377 33.104-8.744 46.677-.116.666-1.234 1.009-1.458 2.691-.04.302.211 1.525.112 1.795-6.873 18.744-10.949 47.842-14.277 61.885l14.607-.014s2.197-8.57 4.03-16.97c2.811-12.886 23.111-85.01 23.111-85.01l3.016-.521 1.043 46.35s-.224 1.234.337 2.02c.56.785-.56 1.123-.392 2.244l.392 1.794s-.449 7.178-.898 11.89c-.448 4.71-.092 39.165-.092 39.165",
        fill: "#7BB2F9"
    }, null), createVNode("path", {
        d: "M76.085 221.626c1.153.094 4.038-2.019 6.955-4.935M106.36 225.142s2.774-1.11 6.103-3.883",
        stroke: "#648BD8",
        "stroke-width": "1.051",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M107.275 222.1s2.773-1.11 6.102-3.884",
        stroke: "#648BD8",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M74.74 224.767s2.622-.591 6.505-3.365M86.03 151.634c-.27 3.106.3 8.525-4.336 9.123M103.625 149.88s.11 14.012-1.293 15.065c-2.219 1.664-2.99 1.944-2.99 1.944M99.79 150.438s.035 12.88-1.196 24.377M93.673 175.911s7.212-1.664 9.431-1.664M74.31 205.861a212.013 212.013 0 0 1-.979 4.56s-1.458 1.832-1.009 3.776c.449 1.944-.947 2.045-4.985 15.355-1.696 5.59-4.49 18.591-6.348 27.597l-.231 1.12M75.689 197.807a320.934 320.934 0 0 1-.882 4.754M82.591 152.233L81.395 162.7s-1.097.15-.5 2.244c.113 1.346-2.674 15.775-5.18 30.43M56.12 274.418h13.31",
        stroke: "#648BD8",
        "stroke-width": "1.051",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M116.241 148.22s-17.047-3.104-35.893.2c.158 2.514-.003 4.15-.003 4.15s14.687-2.818 35.67-.312c.252-2.355.226-4.038.226-4.038",
        fill: "#192064"
    }, null), createVNode("path", {
        d: "M106.322 151.165l.003-4.911a.81.81 0 0 0-.778-.815c-2.44-.091-5.066-.108-7.836-.014a.818.818 0 0 0-.789.815l-.003 4.906a.81.81 0 0 0 .831.813c2.385-.06 4.973-.064 7.73.017a.815.815 0 0 0 .842-.81",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M105.207 150.233l.002-3.076a.642.642 0 0 0-.619-.646 94.321 94.321 0 0 0-5.866-.01.65.65 0 0 0-.63.647v3.072a.64.64 0 0 0 .654.644 121.12 121.12 0 0 1 5.794.011c.362.01.665-.28.665-.642",
        fill: "#192064"
    }, null), createVNode("path", {
        d: "M100.263 275.415h12.338M101.436 270.53c.006 3.387.042 5.79.111 6.506M101.451 264.548a915.75 915.75 0 0 0-.015 4.337M100.986 174.965l.898 44.642s.673 1.57-.225 2.692c-.897 1.122 2.468.673.898 2.243-1.57 1.57.897 1.122 0 3.365-.596 1.489-.994 21.1-1.096 35.146",
        stroke: "#648BD8",
        "stroke-width": "1.051",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M46.876 83.427s-.516 6.045 7.223 5.552c11.2-.712 9.218-9.345 31.54-21.655-.786-2.708-2.447-4.744-2.447-4.744s-11.068 3.11-22.584 8.046c-6.766 2.9-13.395 6.352-13.732 12.801M104.46 91.057l.941-5.372-8.884-11.43-5.037 5.372-1.74 7.834a.321.321 0 0 0 .108.32c.965.8 6.5 5.013 14.347 3.544a.332.332 0 0 0 .264-.268",
        fill: "#FFC6A0"
    }, null), createVNode("path", {
        d: "M93.942 79.387s-4.533-2.853-2.432-6.855c1.623-3.09 4.513 1.133 4.513 1.133s.52-3.642 3.121-3.642c.52-1.04 1.561-4.162 1.561-4.162s11.445 2.601 13.526 3.121c0 5.203-2.304 19.424-7.84 19.861-8.892.703-12.449-9.456-12.449-9.456",
        fill: "#FFC6A0"
    }, null), createVNode("path", {
        d: "M113.874 73.446c2.601-2.081 3.47-9.722 3.47-9.722s-2.479-.49-6.64-2.05c-4.683-2.081-12.798-4.747-17.48.976-9.668 3.223-2.05 19.823-2.05 19.823l2.713-3.021s-3.935-3.287-2.08-6.243c2.17-3.462 3.92 1.073 3.92 1.073s.637-2.387 3.581-3.342c.355-.71 1.036-2.674 1.432-3.85a1.073 1.073 0 0 1 1.263-.704c2.4.558 8.677 2.019 11.356 2.662.522.125.871.615.82 1.15l-.305 3.248z",
        fill: "#520038"
    }, null), createVNode("path", {
        d: "M104.977 76.064c-.103.61-.582 1.038-1.07.956-.489-.083-.801-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.644.698 1.254M112.132 77.694c-.103.61-.582 1.038-1.07.956-.488-.083-.8-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.643.698 1.254",
        fill: "#552950"
    }, null), createVNode("path", {
        stroke: "#DB836E",
        "stroke-width": "1.118",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M110.13 74.84l-.896 1.61-.298 4.357h-2.228"
    }, null), createVNode("path", {
        d: "M110.846 74.481s1.79-.716 2.506.537",
        stroke: "#5C2552",
        "stroke-width": "1.118",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M92.386 74.282s.477-1.114 1.113-.716c.637.398 1.274 1.433.558 1.99-.717.556.159 1.67.159 1.67",
        stroke: "#DB836E",
        "stroke-width": "1.118",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M103.287 72.93s1.83 1.113 4.137.954",
        stroke: "#5C2552",
        "stroke-width": "1.118",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M103.685 81.762s2.227 1.193 4.376 1.193M104.64 84.308s.954.398 1.511.318M94.693 81.205s2.308 7.4 10.424 7.639",
        stroke: "#DB836E",
        "stroke-width": "1.118",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M81.45 89.384s.45 5.647-4.935 12.787M69 82.654s-.726 9.282-8.204 14.206",
        stroke: "#E4EBF7",
        "stroke-width": "1.101",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M129.405 122.865s-5.272 7.403-9.422 10.768",
        stroke: "#E4EBF7",
        "stroke-width": "1.051",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M119.306 107.329s.452 4.366-2.127 32.062",
        stroke: "#E4EBF7",
        "stroke-width": "1.101",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M150.028 151.232h-49.837a1.01 1.01 0 0 1-1.01-1.01v-31.688c0-.557.452-1.01 1.01-1.01h49.837c.558 0 1.01.453 1.01 1.01v31.688a1.01 1.01 0 0 1-1.01 1.01",
        fill: "#F2D7AD"
    }, null), createVNode("path", {
        d: "M150.29 151.232h-19.863v-33.707h20.784v32.786a.92.92 0 0 1-.92.92",
        fill: "#F4D19D"
    }, null), createVNode("path", {
        d: "M123.554 127.896H92.917a.518.518 0 0 1-.425-.816l6.38-9.113c.193-.277.51-.442.85-.442h31.092l-7.26 10.371z",
        fill: "#F2D7AD"
    }, null), createVNode("path", {
        fill: "#CC9B6E",
        d: "M123.689 128.447H99.25v-.519h24.169l7.183-10.26.424.298z"
    }, null), createVNode("path", {
        d: "M158.298 127.896h-18.669a2.073 2.073 0 0 1-1.659-.83l-7.156-9.541h19.965c.49 0 .95.23 1.244.622l6.69 8.92a.519.519 0 0 1-.415.83",
        fill: "#F4D19D"
    }, null), createVNode("path", {
        fill: "#CC9B6E",
        d: "M157.847 128.479h-19.384l-7.857-10.475.415-.31 7.7 10.266h19.126zM130.554 150.685l-.032-8.177.519-.002.032 8.177z"
    }, null), createVNode("path", {
        fill: "#CC9B6E",
        d: "M130.511 139.783l-.08-21.414.519-.002.08 21.414zM111.876 140.932l-.498-.143 1.479-5.167.498.143zM108.437 141.06l-2.679-2.935 2.665-3.434.41.318-2.397 3.089 2.384 2.612zM116.607 141.06l-.383-.35 2.383-2.612-2.397-3.089.41-.318 2.665 3.434z"
    }, null), createVNode("path", {
        d: "M154.316 131.892l-3.114-1.96.038 3.514-1.043.092c-1.682.115-3.634.23-4.789.23-1.902 0-2.693 2.258 2.23 2.648l-2.645-.596s-2.168 1.317.504 2.3c0 0-1.58 1.217.561 2.58-.584 3.504 5.247 4.058 7.122 3.59 1.876-.47 4.233-2.359 4.487-5.16.28-3.085-.89-5.432-3.35-7.238",
        fill: "#FFC6A0"
    }, null), createVNode("path", {
        d: "M153.686 133.577s-6.522.47-8.36.372c-1.836-.098-1.904 2.19 2.359 2.264 3.739.15 5.451-.044 5.451-.044",
        stroke: "#DB836E",
        "stroke-width": "1.051",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M145.16 135.877c-1.85 1.346.561 2.355.561 2.355s3.478.898 6.73.617",
        stroke: "#DB836E",
        "stroke-width": "1.051",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M151.89 141.71s-6.28.111-6.73-2.132c-.223-1.346.45-1.402.45-1.402M146.114 140.868s-1.103 3.16 5.44 3.533M151.202 129.932v3.477M52.838 89.286c3.533-.337 8.423-1.248 13.582-7.754",
        stroke: "#DB836E",
        "stroke-width": "1.051",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M168.567 248.318a6.647 6.647 0 0 1-6.647-6.647v-66.466a6.647 6.647 0 1 1 13.294 0v66.466a6.647 6.647 0 0 1-6.647 6.647",
        fill: "#5BA02E"
    }, null), createVNode("path", {
        d: "M176.543 247.653a6.647 6.647 0 0 1-6.646-6.647v-33.232a6.647 6.647 0 1 1 13.293 0v33.232a6.647 6.647 0 0 1-6.647 6.647",
        fill: "#92C110"
    }, null), createVNode("path", {
        d: "M186.443 293.613H158.92a3.187 3.187 0 0 1-3.187-3.187v-46.134a3.187 3.187 0 0 1 3.187-3.187h27.524a3.187 3.187 0 0 1 3.187 3.187v46.134a3.187 3.187 0 0 1-3.187 3.187",
        fill: "#F2D7AD"
    }, null), createVNode("path", {
        d: "M88.979 89.48s7.776 5.384 16.6 2.842",
        stroke: "#E4EBF7",
        "stroke-width": "1.101",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null)])])
};
const noFound = NoFound;
var ServerError = function () {
    return createVNode("svg", {
        width: "254",
        height: "294"
    }, [createVNode("defs", null, [createVNode("path", {
        d: "M0 .335h253.49v253.49H0z"
    }, null), createVNode("path", {
        d: "M0 293.665h253.49V.401H0z"
    }, null)]), createVNode("g", {
        fill: "none",
        "fill-rule": "evenodd"
    }, [createVNode("g", {
        transform: "translate(0 .067)"
    }, [createVNode("mask", {
        fill: "#fff"
    }, null), createVNode("path", {
        d: "M0 128.134v-2.11C0 56.608 56.273.334 125.69.334h2.11c69.416 0 125.69 56.274 125.69 125.69v2.11c0 69.417-56.274 125.69-125.69 125.69h-2.11C56.273 253.824 0 197.551 0 128.134",
        fill: "#E4EBF7",
        mask: "url(#b)"
    }, null)]), createVNode("path", {
        d: "M39.989 132.108a8.332 8.332 0 1 1-16.581-1.671 8.332 8.332 0 0 1 16.58 1.671",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M37.19 135.59l10.553 5.983M48.665 147.884l-12.734 10.861",
        stroke: "#FFF",
        "stroke-width": "2"
    }, null), createVNode("path", {
        d: "M40.11 160.816a5.706 5.706 0 1 1-11.354-1.145 5.706 5.706 0 0 1 11.354 1.145M57.943 144.6a5.747 5.747 0 1 1-11.436-1.152 5.747 5.747 0 0 1 11.436 1.153M99.656 27.434l30.024-.013a4.619 4.619 0 1 0-.004-9.238l-30.024.013a4.62 4.62 0 0 0 .004 9.238M111.14 45.896l30.023-.013a4.62 4.62 0 1 0-.004-9.238l-30.024.013a4.619 4.619 0 1 0 .004 9.238",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M113.53 27.421v-.002l15.89-.007a4.619 4.619 0 1 0 .005 9.238l-15.892.007v-.002a4.618 4.618 0 0 0-.004-9.234M150.167 70.091h-3.979a4.789 4.789 0 0 1-4.774-4.775 4.788 4.788 0 0 1 4.774-4.774h3.979a4.789 4.789 0 0 1 4.775 4.774 4.789 4.789 0 0 1-4.775 4.775",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M171.687 30.234c0-16.392 13.289-29.68 29.681-29.68 16.392 0 29.68 13.288 29.68 29.68 0 16.393-13.288 29.681-29.68 29.681s-29.68-13.288-29.68-29.68",
        fill: "#FF603B"
    }, null), createVNode("path", {
        d: "M203.557 19.435l-.676 15.035a1.514 1.514 0 0 1-3.026 0l-.675-15.035a2.19 2.19 0 1 1 4.377 0m-.264 19.378c.513.477.77 1.1.77 1.87s-.257 1.393-.77 1.907c-.55.476-1.21.733-1.943.733a2.545 2.545 0 0 1-1.87-.77c-.55-.514-.806-1.136-.806-1.87 0-.77.256-1.393.806-1.87.513-.513 1.137-.733 1.87-.733.77 0 1.43.22 1.943.733",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M119.3 133.275c4.426-.598 3.612-1.204 4.079-4.778.675-5.18-3.108-16.935-8.262-25.118-1.088-10.72-12.598-11.24-12.598-11.24s4.312 4.895 4.196 16.199c1.398 5.243.804 14.45.804 14.45s5.255 11.369 11.78 10.487",
        fill: "#FFB594"
    }, null), createVNode("path", {
        d: "M100.944 91.61s1.463-.583 3.211.582c8.08 1.398 10.368 6.706 11.3 11.368 1.864 1.282 1.864 2.33 1.864 3.496.365.777 1.515 3.03 1.515 3.03s-7.225 1.748-10.954 6.758c-1.399-6.41-6.936-25.235-6.936-25.235",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M94.008 90.5l1.019-5.815-9.23-11.874-5.233 5.581-2.593 9.863s8.39 5.128 16.037 2.246",
        fill: "#FFB594"
    }, null), createVNode("path", {
        d: "M82.931 78.216s-4.557-2.868-2.445-6.892c1.632-3.107 4.537 1.139 4.537 1.139s.524-3.662 3.139-3.662c.523-1.046 1.569-4.184 1.569-4.184s11.507 2.615 13.6 3.138c-.001 5.23-2.317 19.529-7.884 19.969-8.94.706-12.516-9.508-12.516-9.508",
        fill: "#FFC6A0"
    }, null), createVNode("path", {
        d: "M102.971 72.243c2.616-2.093 3.489-9.775 3.489-9.775s-2.492-.492-6.676-2.062c-4.708-2.092-12.867-4.771-17.575.982-9.54 4.41-2.062 19.93-2.062 19.93l2.729-3.037s-3.956-3.304-2.092-6.277c2.183-3.48 3.943 1.08 3.943 1.08s.64-2.4 3.6-3.36c.356-.714 1.04-2.69 1.44-3.872a1.08 1.08 0 0 1 1.27-.707c2.41.56 8.723 2.03 11.417 2.676.524.126.876.619.825 1.156l-.308 3.266z",
        fill: "#520038"
    }, null), createVNode("path", {
        d: "M101.22 76.514c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.961.491.083.805.647.702 1.26M94.26 75.074c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.96.491.082.805.646.702 1.26",
        fill: "#552950"
    }, null), createVNode("path", {
        stroke: "#DB836E",
        "stroke-width": "1.063",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M99.206 73.644l-.9 1.62-.3 4.38h-2.24"
    }, null), createVNode("path", {
        d: "M99.926 73.284s1.8-.72 2.52.54",
        stroke: "#5C2552",
        "stroke-width": "1.117",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M81.367 73.084s.48-1.12 1.12-.72c.64.4 1.28 1.44.56 2s.16 1.68.16 1.68",
        stroke: "#DB836E",
        "stroke-width": "1.117",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M92.326 71.724s1.84 1.12 4.16.96",
        stroke: "#5C2552",
        "stroke-width": "1.117",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M92.726 80.604s2.24 1.2 4.4 1.2M93.686 83.164s.96.4 1.52.32M83.687 80.044s1.786 6.547 9.262 7.954",
        stroke: "#DB836E",
        "stroke-width": "1.063",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M95.548 91.663s-1.068 2.821-8.298 2.105c-7.23-.717-10.29-5.044-10.29-5.044",
        stroke: "#E4EBF7",
        "stroke-width": "1.136",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M78.126 87.478s6.526 4.972 16.47 2.486c0 0 9.577 1.02 11.536 5.322 5.36 11.77.543 36.835 0 39.962 3.496 4.055-.466 8.483-.466 8.483-15.624-3.548-35.81-.6-35.81-.6-4.849-3.546-1.223-9.044-1.223-9.044L62.38 110.32c-2.485-15.227.833-19.803 3.549-20.743 3.03-1.049 8.04-1.282 8.04-1.282.496-.058 1.08-.076 1.37-.233 2.36-1.282 2.787-.583 2.787-.583",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M65.828 89.81s-6.875.465-7.59 8.156c-.466 8.857 3.03 10.954 3.03 10.954s6.075 22.102 16.796 22.957c8.39-2.176 4.758-6.702 4.661-11.42-.233-11.304-7.108-16.897-7.108-16.897s-4.212-13.75-9.789-13.75",
        fill: "#FFC6A0"
    }, null), createVNode("path", {
        d: "M71.716 124.225s.855 11.264 9.828 6.486c4.765-2.536 7.581-13.828 9.789-22.568 1.456-5.768 2.58-12.197 2.58-12.197l-4.973-1.709s-2.408 5.516-7.769 12.275c-4.335 5.467-9.144 11.11-9.455 17.713",
        fill: "#FFC6A0"
    }, null), createVNode("path", {
        d: "M108.463 105.191s1.747 2.724-2.331 30.535c2.376 2.216 1.053 6.012-.233 7.51",
        stroke: "#E4EBF7",
        "stroke-width": "1.085",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M123.262 131.527s-.427 2.732-11.77 1.981c-15.187-1.006-25.326-3.25-25.326-3.25l.933-5.8s.723.215 9.71-.068c11.887-.373 18.714-6.07 24.964-1.022 4.039 3.263 1.489 8.16 1.489 8.16",
        fill: "#FFC6A0"
    }, null), createVNode("path", {
        d: "M70.24 90.974s-5.593-4.739-11.054 2.68c-3.318 7.223.517 15.284 2.664 19.578-.31 3.729 2.33 4.311 2.33 4.311s.108.895 1.516 2.68c4.078-7.03 6.72-9.166 13.711-12.546-.328-.656-1.877-3.265-1.825-3.767.175-1.69-1.282-2.623-1.282-2.623s-.286-.156-1.165-2.738c-.788-2.313-2.036-5.177-4.895-7.575",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M90.232 288.027s4.855 2.308 8.313 1.155c3.188-1.063 5.12.755 8.002 1.331 2.881.577 7.769 1.243 13.207-1.424-.117-6.228-7.786-4.499-13.518-7.588-2.895-1.56-4.276-5.336-4.066-9.944H91.544s-1.573 11.89-1.312 16.47",
        fill: "#CBD1D1"
    }, null), createVNode("path", {
        d: "M90.207 287.833s2.745 1.437 7.639.738c3.456-.494 3.223.66 7.418 1.282 4.195.621 13.092-.194 14.334-1.126.466 1.242-.388 2.33-.388 2.33s-1.709.682-5.438.932c-2.295.154-8.098.276-10.14-.621-2.02-1.554-4.894-1.515-6.06-.234-4.427 1.075-7.184-.31-7.184-.31l-.181-2.991z",
        fill: "#2B0849"
    }, null), createVNode("path", {
        d: "M98.429 272.257h3.496s-.117 7.574 5.127 9.671c-5.244.7-9.672-2.602-8.623-9.671",
        fill: "#A4AABA"
    }, null), createVNode("path", {
        d: "M44.425 272.046s-2.208 7.774-4.702 12.899c-1.884 3.874-4.428 7.854 5.729 7.854 6.97 0 9.385-.503 7.782-6.917-1.604-6.415.279-13.836.279-13.836h-9.088z",
        fill: "#CBD1D1"
    }, null), createVNode("path", {
        d: "M38.066 290.277s2.198 1.225 6.954 1.225c6.376 0 8.646-1.73 8.646-1.73s.63 1.168-.649 2.27c-1.04.897-3.77 1.668-7.745 1.621-4.347-.05-6.115-.593-7.062-1.224-.864-.577-.72-1.657-.144-2.162",
        fill: "#2B0849"
    }, null), createVNode("path", {
        d: "M45.344 274.041s.035 1.592-.329 3.07c-.365 1.49-1.13 3.255-1.184 4.34-.061 1.206 4.755 1.657 5.403.036.65-1.622 1.357-6.737 2.006-7.602.648-.865-5.14-2.222-5.896.156",
        fill: "#A4AABA"
    }, null), createVNode("path", {
        d: "M89.476 277.57l13.899.095s1.349-56.643 1.925-66.909c.576-10.267 3.923-45.052 1.042-65.585l-13.037-.669-23.737.81s-.452 4.12-1.243 10.365c-.065.515-.708.874-.777 1.417-.078.608.439 1.407.332 2.044-2.455 14.627-5.797 32.736-8.256 46.837-.121.693-1.282 1.048-1.515 2.796-.042.314.22 1.584.116 1.865-7.14 19.473-12.202 52.601-15.66 67.19l15.176-.015s2.282-10.145 4.185-18.871c2.922-13.389 24.012-88.32 24.012-88.32l3.133-.954-.158 48.568s-.233 1.282.35 2.098c.583.815-.581 1.167-.408 2.331l.408 1.864s-.466 7.458-.932 12.352c-.467 4.895 1.145 40.69 1.145 40.69",
        fill: "#7BB2F9"
    }, null), createVNode("path", {
        d: "M64.57 218.881c1.197.099 4.195-2.097 7.225-5.127M96.024 222.534s2.881-1.152 6.34-4.034",
        stroke: "#648BD8",
        "stroke-width": "1.085",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M96.973 219.373s2.882-1.153 6.34-4.034",
        stroke: "#648BD8",
        "stroke-width": "1.032",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M63.172 222.144s2.724-.614 6.759-3.496M74.903 146.166c-.281 3.226.31 8.856-4.506 9.478M93.182 144.344s.115 14.557-1.344 15.65c-2.305 1.73-3.107 2.02-3.107 2.02M89.197 144.923s.269 13.144-1.01 25.088M83.525 170.71s6.81-1.051 9.116-1.051M46.026 270.045l-.892 4.538M46.937 263.289l-.815 4.157M62.725 202.503c-.33 1.618-.102 1.904-.449 3.438 0 0-2.756 1.903-2.29 3.923.466 2.02-.31 3.424-4.505 17.252-1.762 5.807-4.233 18.922-6.165 28.278-.03.144-.521 2.646-1.14 5.8M64.158 194.136c-.295 1.658-.6 3.31-.917 4.938M71.33 146.787l-1.244 10.877s-1.14.155-.519 2.33c.117 1.399-2.778 16.39-5.382 31.615M44.242 273.727H58.07",
        stroke: "#648BD8",
        "stroke-width": "1.085",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M106.18 142.117c-3.028-.489-18.825-2.744-36.219.2a.625.625 0 0 0-.518.644c.063 1.307.044 2.343.015 2.995a.617.617 0 0 0 .716.636c3.303-.534 17.037-2.412 35.664-.266.347.04.66-.214.692-.56.124-1.347.16-2.425.17-3.029a.616.616 0 0 0-.52-.62",
        fill: "#192064"
    }, null), createVNode("path", {
        d: "M96.398 145.264l.003-5.102a.843.843 0 0 0-.809-.847 114.104 114.104 0 0 0-8.141-.014.85.85 0 0 0-.82.847l-.003 5.097c0 .476.388.857.864.845 2.478-.064 5.166-.067 8.03.017a.848.848 0 0 0 .876-.843",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M95.239 144.296l.002-3.195a.667.667 0 0 0-.643-.672c-1.9-.061-3.941-.073-6.094-.01a.675.675 0 0 0-.654.672l-.002 3.192c0 .376.305.677.68.669 1.859-.042 3.874-.043 6.02.012.376.01.69-.291.691-.668",
        fill: "#192064"
    }, null), createVNode("path", {
        d: "M90.102 273.522h12.819M91.216 269.761c.006 3.519-.072 5.55 0 6.292M90.923 263.474c-.009 1.599-.016 2.558-.016 4.505M90.44 170.404l.932 46.38s.7 1.631-.233 2.796c-.932 1.166 2.564.7.932 2.33-1.63 1.633.933 1.166 0 3.497-.618 1.546-1.031 21.921-1.138 36.513",
        stroke: "#648BD8",
        "stroke-width": "1.085",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M73.736 98.665l2.214 4.312s2.098.816 1.865 2.68l.816 2.214M64.297 116.611c.233-.932 2.176-7.147 12.585-10.488M77.598 90.042s7.691 6.137 16.547 2.72",
        stroke: "#E4EBF7",
        "stroke-width": "1.085",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M91.974 86.954s5.476-.816 7.574-4.545c1.297-.345.72 2.212-.33 3.671-.7.971-1.01 1.554-1.01 1.554s.194.31.155.816c-.053.697-.175.653-.272 1.048-.081.335.108.657 0 1.049-.046.17-.198.5-.382.878-.12.249-.072.687-.2.948-.231.469-1.562 1.87-2.622 2.855-3.826 3.554-5.018 1.644-6.001-.408-.894-1.865-.661-5.127-.874-6.875-.35-2.914-2.622-3.03-1.923-4.429.343-.685 2.87.69 3.263 1.748.757 2.04 2.952 1.807 2.622 1.69",
        fill: "#FFC6A0"
    }, null), createVNode("path", {
        d: "M99.8 82.429c-.465.077-.35.272-.97 1.243-.622.971-4.817 2.932-6.39 3.224-2.589.48-2.278-1.56-4.254-2.855-1.69-1.107-3.562-.638-1.398 1.398.99.932.932 1.107 1.398 3.205.335 1.506-.64 3.67.7 5.593",
        stroke: "#DB836E",
        "stroke-width": ".774",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M79.543 108.673c-2.1 2.926-4.266 6.175-5.557 8.762",
        stroke: "#E59788",
        "stroke-width": ".774",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M87.72 124.768s-2.098-1.942-5.127-2.719c-3.03-.777-3.574-.155-5.516.078-1.942.233-3.885-.932-3.652.7.233 1.63 5.05 1.01 5.206 2.097.155 1.087-6.37 2.796-8.313 2.175-.777.777.466 1.864 2.02 2.175.233 1.554 2.253 1.554 2.253 1.554s.699 1.01 2.641 1.088c2.486 1.32 8.934-.7 10.954-1.554 2.02-.855-.466-5.594-.466-5.594",
        fill: "#FFC6A0"
    }, null), createVNode("path", {
        d: "M73.425 122.826s.66 1.127 3.167 1.418c2.315.27 2.563.583 2.563.583s-2.545 2.894-9.07 2.272M72.416 129.274s3.826.097 4.933-.718M74.98 130.75s1.961.136 3.36-.505M77.232 131.916s1.748.019 2.914-.505M73.328 122.321s-.595-1.032 1.262-.427c1.671.544 2.833.055 5.128.155 1.389.061 3.067-.297 3.982.15 1.606.784 3.632 2.181 3.632 2.181s10.526 1.204 19.033-1.127M78.864 108.104s-8.39 2.758-13.168 12.12",
        stroke: "#E59788",
        "stroke-width": ".774",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M109.278 112.533s3.38-3.613 7.575-4.662",
        stroke: "#E4EBF7",
        "stroke-width": "1.085",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M107.375 123.006s9.697-2.745 11.445-.88",
        stroke: "#E59788",
        "stroke-width": ".774",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M194.605 83.656l3.971-3.886M187.166 90.933l3.736-3.655M191.752 84.207l-4.462-4.56M198.453 91.057l-4.133-4.225M129.256 163.074l3.718-3.718M122.291 170.039l3.498-3.498M126.561 163.626l-4.27-4.27M132.975 170.039l-3.955-3.955",
        stroke: "#BFCDDD",
        "stroke-width": "2",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M190.156 211.779h-1.604a4.023 4.023 0 0 1-4.011-4.011V175.68a4.023 4.023 0 0 1 4.01-4.01h1.605a4.023 4.023 0 0 1 4.011 4.01v32.088a4.023 4.023 0 0 1-4.01 4.01",
        fill: "#A3B4C6"
    }, null), createVNode("path", {
        d: "M237.824 212.977a4.813 4.813 0 0 1-4.813 4.813h-86.636a4.813 4.813 0 0 1 0-9.626h86.636a4.813 4.813 0 0 1 4.813 4.813",
        fill: "#A3B4C6"
    }, null), createVNode("mask", {
        fill: "#fff"
    }, null), createVNode("path", {
        fill: "#A3B4C6",
        mask: "url(#d)",
        d: "M154.098 190.096h70.513v-84.617h-70.513z"
    }, null), createVNode("path", {
        d: "M224.928 190.096H153.78a3.219 3.219 0 0 1-3.208-3.209V167.92a3.219 3.219 0 0 1 3.208-3.21h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.219 3.219 0 0 1-3.21 3.209M224.928 130.832H153.78a3.218 3.218 0 0 1-3.208-3.208v-18.968a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.218 3.218 0 0 1-3.21 3.208",
        fill: "#BFCDDD",
        mask: "url(#d)"
    }, null), createVNode("path", {
        d: "M159.563 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 120.546h-22.461a.802.802 0 0 1-.802-.802v-3.208c0-.443.359-.803.802-.803h22.46c.444 0 .803.36.803.803v3.208c0 .443-.36.802-.802.802",
        fill: "#FFF",
        mask: "url(#d)"
    }, null), createVNode("path", {
        d: "M224.928 160.464H153.78a3.218 3.218 0 0 1-3.208-3.209v-18.967a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.209v18.967a3.218 3.218 0 0 1-3.21 3.209",
        fill: "#BFCDDD",
        mask: "url(#d)"
    }, null), createVNode("path", {
        d: "M173.455 130.832h49.301M164.984 130.832h6.089M155.952 130.832h6.75M173.837 160.613h49.3M165.365 160.613h6.089M155.57 160.613h6.751",
        stroke: "#7C90A5",
        "stroke-width": "1.124",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        mask: "url(#d)"
    }, null), createVNode("path", {
        d: "M159.563 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M166.98 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M174.397 151.038a2.407 2.407 0 1 1 .001-4.814 2.407 2.407 0 0 1 0 4.814M222.539 151.038h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802M159.563 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 179.987h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802",
        fill: "#FFF",
        mask: "url(#d)"
    }, null), createVNode("path", {
        d: "M203.04 221.108h-27.372a2.413 2.413 0 0 1-2.406-2.407v-11.448a2.414 2.414 0 0 1 2.406-2.407h27.372a2.414 2.414 0 0 1 2.407 2.407V218.7a2.413 2.413 0 0 1-2.407 2.407",
        fill: "#BFCDDD",
        mask: "url(#d)"
    }, null), createVNode("path", {
        d: "M177.259 207.217v11.52M201.05 207.217v11.52",
        stroke: "#A3B4C6",
        "stroke-width": "1.124",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        mask: "url(#d)"
    }, null), createVNode("path", {
        d: "M162.873 267.894a9.422 9.422 0 0 1-9.422-9.422v-14.82a9.423 9.423 0 0 1 18.845 0v14.82a9.423 9.423 0 0 1-9.423 9.422",
        fill: "#5BA02E",
        mask: "url(#d)"
    }, null), createVNode("path", {
        d: "M171.22 267.83a9.422 9.422 0 0 1-9.422-9.423v-3.438a9.423 9.423 0 0 1 18.845 0v3.438a9.423 9.423 0 0 1-9.422 9.423",
        fill: "#92C110",
        mask: "url(#d)"
    }, null), createVNode("path", {
        d: "M181.31 293.666h-27.712a3.209 3.209 0 0 1-3.209-3.21V269.79a3.209 3.209 0 0 1 3.209-3.21h27.711a3.209 3.209 0 0 1 3.209 3.21v20.668a3.209 3.209 0 0 1-3.209 3.209",
        fill: "#F2D7AD",
        mask: "url(#d)"
    }, null)])])
};
const serverError = ServerError;
var Unauthorized = function () {
    return createVNode("svg", {
        width: "251",
        height: "294"
    }, [createVNode("g", {
        fill: "none",
        "fill-rule": "evenodd"
    }, [createVNode("path", {
        d: "M0 129.023v-2.084C0 58.364 55.591 2.774 124.165 2.774h2.085c68.574 0 124.165 55.59 124.165 124.165v2.084c0 68.575-55.59 124.166-124.165 124.166h-2.085C55.591 253.189 0 197.598 0 129.023",
        fill: "#E4EBF7"
    }, null), createVNode("path", {
        d: "M41.417 132.92a8.231 8.231 0 1 1-16.38-1.65 8.231 8.231 0 0 1 16.38 1.65",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M38.652 136.36l10.425 5.91M49.989 148.505l-12.58 10.73",
        stroke: "#FFF",
        "stroke-width": "2"
    }, null), createVNode("path", {
        d: "M41.536 161.28a5.636 5.636 0 1 1-11.216-1.13 5.636 5.636 0 0 1 11.216 1.13M59.154 145.261a5.677 5.677 0 1 1-11.297-1.138 5.677 5.677 0 0 1 11.297 1.138M100.36 29.516l29.66-.013a4.562 4.562 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 0 0 .005 9.126M111.705 47.754l29.659-.013a4.563 4.563 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 1 0 .005 9.126",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M114.066 29.503V29.5l15.698-.007a4.563 4.563 0 1 0 .004 9.126l-15.698.007v-.002a4.562 4.562 0 0 0-.004-9.122M185.405 137.723c-.55 5.455-5.418 9.432-10.873 8.882-5.456-.55-9.432-5.418-8.882-10.873.55-5.455 5.418-9.432 10.873-8.882 5.455.55 9.432 5.418 8.882 10.873",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M180.17 143.772l12.572 7.129M193.841 158.42L178.67 171.36",
        stroke: "#FFF",
        "stroke-width": "2"
    }, null), createVNode("path", {
        d: "M185.55 171.926a6.798 6.798 0 1 1-13.528-1.363 6.798 6.798 0 0 1 13.527 1.363M204.12 155.285a6.848 6.848 0 1 1-13.627-1.375 6.848 6.848 0 0 1 13.626 1.375",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M152.988 194.074a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0zM225.931 118.217a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM217.09 153.051a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.42 0zM177.84 109.842a2.21 2.21 0 1 1-4.422 0 2.21 2.21 0 0 1 4.421 0zM196.114 94.454a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM202.844 182.523a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0z",
        stroke: "#FFF",
        "stroke-width": "2"
    }, null), createVNode("path", {
        stroke: "#FFF",
        "stroke-width": "2",
        d: "M215.125 155.262l-1.902 20.075-10.87 5.958M174.601 176.636l-6.322 9.761H156.98l-4.484 6.449M175.874 127.28V111.56M221.51 119.404l-12.77 7.859-15.228-7.86V96.668"
    }, null), createVNode("path", {
        d: "M180.68 29.32C180.68 13.128 193.806 0 210 0c16.193 0 29.32 13.127 29.32 29.32 0 16.194-13.127 29.322-29.32 29.322-16.193 0-29.32-13.128-29.32-29.321",
        fill: "#A26EF4"
    }, null), createVNode("path", {
        d: "M221.45 41.706l-21.563-.125a1.744 1.744 0 0 1-1.734-1.754l.071-12.23a1.744 1.744 0 0 1 1.754-1.734l21.562.125c.964.006 1.74.791 1.735 1.755l-.071 12.229a1.744 1.744 0 0 1-1.754 1.734",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M215.106 29.192c-.015 2.577-2.049 4.654-4.543 4.64-2.494-.014-4.504-2.115-4.489-4.693l.04-6.925c.016-2.577 2.05-4.654 4.543-4.64 2.494.015 4.504 2.116 4.49 4.693l-.04 6.925zm-4.53-14.074a6.877 6.877 0 0 0-6.916 6.837l-.043 7.368a6.877 6.877 0 0 0 13.754.08l.042-7.368a6.878 6.878 0 0 0-6.837-6.917zM167.566 68.367h-3.93a4.73 4.73 0 0 1-4.717-4.717 4.73 4.73 0 0 1 4.717-4.717h3.93a4.73 4.73 0 0 1 4.717 4.717 4.73 4.73 0 0 1-4.717 4.717",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M168.214 248.838a6.611 6.611 0 0 1-6.61-6.611v-66.108a6.611 6.611 0 0 1 13.221 0v66.108a6.611 6.611 0 0 1-6.61 6.61",
        fill: "#5BA02E"
    }, null), createVNode("path", {
        d: "M176.147 248.176a6.611 6.611 0 0 1-6.61-6.61v-33.054a6.611 6.611 0 1 1 13.221 0v33.053a6.611 6.611 0 0 1-6.61 6.611",
        fill: "#92C110"
    }, null), createVNode("path", {
        d: "M185.994 293.89h-27.376a3.17 3.17 0 0 1-3.17-3.17v-45.887a3.17 3.17 0 0 1 3.17-3.17h27.376a3.17 3.17 0 0 1 3.17 3.17v45.886a3.17 3.17 0 0 1-3.17 3.17",
        fill: "#F2D7AD"
    }, null), createVNode("path", {
        d: "M81.972 147.673s6.377-.927 17.566-1.28c11.729-.371 17.57 1.086 17.57 1.086s3.697-3.855.968-8.424c1.278-12.077 5.982-32.827.335-48.273-1.116-1.339-3.743-1.512-7.536-.62-1.337.315-7.147-.149-7.983-.1l-15.311-.347s-3.487-.17-8.035-.508c-1.512-.113-4.227-1.683-5.458-.338-.406.443-2.425 5.669-1.97 16.077l8.635 35.642s-3.141 3.61 1.219 7.085",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M75.768 73.325l-.9-6.397 11.982-6.52s7.302-.118 8.038 1.205c.737 1.324-5.616.993-5.616.993s-1.836 1.388-2.615 2.5c-1.654 2.363-.986 6.471-8.318 5.986-1.708.284-2.57 2.233-2.57 2.233",
        fill: "#FFC6A0"
    }, null), createVNode("path", {
        d: "M52.44 77.672s14.217 9.406 24.973 14.444c1.061.497-2.094 16.183-11.892 11.811-7.436-3.318-20.162-8.44-21.482-14.496-.71-3.258 2.543-7.643 8.401-11.76M141.862 80.113s-6.693 2.999-13.844 6.876c-3.894 2.11-10.137 4.704-12.33 7.988-6.224 9.314 3.536 11.22 12.947 7.503 6.71-2.651 28.999-12.127 13.227-22.367",
        fill: "#FFB594"
    }, null), createVNode("path", {
        d: "M76.166 66.36l3.06 3.881s-2.783 2.67-6.31 5.747c-7.103 6.195-12.803 14.296-15.995 16.44-3.966 2.662-9.754 3.314-12.177-.118-3.553-5.032.464-14.628 31.422-25.95",
        fill: "#FFC6A0"
    }, null), createVNode("path", {
        d: "M64.674 85.116s-2.34 8.413-8.912 14.447c.652.548 18.586 10.51 22.144 10.056 5.238-.669 6.417-18.968 1.145-20.531-.702-.208-5.901-1.286-8.853-2.167-.87-.26-1.611-1.71-3.545-.936l-1.98-.869zM128.362 85.826s5.318 1.956 7.325 13.734c-.546.274-17.55 12.35-21.829 7.805-6.534-6.94-.766-17.393 4.275-18.61 4.646-1.121 5.03-1.37 10.23-2.929",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M78.18 94.656s.911 7.41-4.914 13.078",
        stroke: "#E4EBF7",
        "stroke-width": "1.051",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M87.397 94.68s3.124 2.572 10.263 2.572c7.14 0 9.074-3.437 9.074-3.437",
        stroke: "#E4EBF7",
        "stroke-width": ".932",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M117.184 68.639l-6.781-6.177s-5.355-4.314-9.223-.893c-3.867 3.422 4.463 2.083 5.653 4.165 1.19 2.082.848 1.143-2.083.446-5.603-1.331-2.082.893 2.975 5.355 2.091 1.845 6.992.955 6.992.955l2.467-3.851z",
        fill: "#FFC6A0"
    }, null), createVNode("path", {
        d: "M105.282 91.315l-.297-10.937-15.918-.027-.53 10.45c-.026.403.17.788.515.999 2.049 1.251 9.387 5.093 15.799.424.287-.21.443-.554.431-.91",
        fill: "#FFB594"
    }, null), createVNode("path", {
        d: "M107.573 74.24c.817-1.147.982-9.118 1.015-11.928a1.046 1.046 0 0 0-.965-1.055l-4.62-.365c-7.71-1.044-17.071.624-18.253 6.346-5.482 5.813-.421 13.244-.421 13.244s1.963 3.566 4.305 6.791c.756 1.041.398-3.731 3.04-5.929 5.524-4.594 15.899-7.103 15.899-7.103",
        fill: "#5C2552"
    }, null), createVNode("path", {
        d: "M88.426 83.206s2.685 6.202 11.602 6.522c7.82.28 8.973-7.008 7.434-17.505l-.909-5.483c-6.118-2.897-15.478.54-15.478.54s-.576 2.044-.19 5.504c-2.276 2.066-1.824 5.618-1.824 5.618s-.905-1.922-1.98-2.321c-.86-.32-1.897.089-2.322 1.98-1.04 4.632 3.667 5.145 3.667 5.145",
        fill: "#FFC6A0"
    }, null), createVNode("path", {
        stroke: "#DB836E",
        "stroke-width": "1.145",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M100.843 77.099l1.701-.928-1.015-4.324.674-1.406"
    }, null), createVNode("path", {
        d: "M105.546 74.092c-.022.713-.452 1.279-.96 1.263-.51-.016-.904-.607-.882-1.32.021-.713.452-1.278.96-1.263.51.016.904.607.882 1.32M97.592 74.349c-.022.713-.452 1.278-.961 1.263-.509-.016-.904-.607-.882-1.32.022-.713.452-1.279.961-1.263.51.016.904.606.882 1.32",
        fill: "#552950"
    }, null), createVNode("path", {
        d: "M91.132 86.786s5.269 4.957 12.679 2.327",
        stroke: "#DB836E",
        "stroke-width": "1.145",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M99.776 81.903s-3.592.232-1.44-2.79c1.59-1.496 4.897-.46 4.897-.46s1.156 3.906-3.457 3.25",
        fill: "#DB836E"
    }, null), createVNode("path", {
        d: "M102.88 70.6s2.483.84 3.402.715M93.883 71.975s2.492-1.144 4.778-1.073",
        stroke: "#5C2552",
        "stroke-width": "1.526",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M86.32 77.374s.961.879 1.458 2.106c-.377.48-1.033 1.152-.236 1.809M99.337 83.719s1.911.151 2.509-.254",
        stroke: "#DB836E",
        "stroke-width": "1.145",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M87.782 115.821l15.73-3.012M100.165 115.821l10.04-2.008",
        stroke: "#E4EBF7",
        "stroke-width": "1.051",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M66.508 86.763s-1.598 8.83-6.697 14.078",
        stroke: "#E4EBF7",
        "stroke-width": "1.114",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M128.31 87.934s3.013 4.121 4.06 11.785",
        stroke: "#E4EBF7",
        "stroke-width": "1.051",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M64.09 84.816s-6.03 9.912-13.607 9.903",
        stroke: "#DB836E",
        "stroke-width": ".795",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M112.366 65.909l-.142 5.32s5.993 4.472 11.945 9.202c4.482 3.562 8.888 7.455 10.985 8.662 4.804 2.766 8.9 3.355 11.076 1.808 4.071-2.894 4.373-9.878-8.136-15.263-4.271-1.838-16.144-6.36-25.728-9.73",
        fill: "#FFC6A0"
    }, null), createVNode("path", {
        d: "M130.532 85.488s4.588 5.757 11.619 6.214",
        stroke: "#DB836E",
        "stroke-width": ".75",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M121.708 105.73s-.393 8.564-1.34 13.612",
        stroke: "#E4EBF7",
        "stroke-width": "1.051",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M115.784 161.512s-3.57-1.488-2.678-7.14",
        stroke: "#648BD8",
        "stroke-width": "1.051",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M101.52 290.246s4.326 2.057 7.408 1.03c2.842-.948 4.564.673 7.132 1.186 2.57.514 6.925 1.108 11.772-1.269-.104-5.551-6.939-4.01-12.048-6.763-2.582-1.39-3.812-4.757-3.625-8.863h-9.471s-1.402 10.596-1.169 14.68",
        fill: "#CBD1D1"
    }, null), createVNode("path", {
        d: "M101.496 290.073s2.447 1.281 6.809.658c3.081-.44 3.74.485 7.479 1.039 3.739.554 10.802-.07 11.91-.9.415 1.108-.347 2.077-.347 2.077s-1.523.608-4.847.831c-2.045.137-5.843.293-7.663-.507-1.8-1.385-5.286-1.917-5.77-.243-3.947.958-7.41-.288-7.41-.288l-.16-2.667z",
        fill: "#2B0849"
    }, null), createVNode("path", {
        d: "M108.824 276.19h3.116s-.103 6.751 4.57 8.62c-4.673.624-8.62-2.32-7.686-8.62",
        fill: "#A4AABA"
    }, null), createVNode("path", {
        d: "M57.65 272.52s-2.122 7.47-4.518 12.396c-1.811 3.724-4.255 7.548 5.505 7.548 6.698 0 9.02-.483 7.479-6.648-1.541-6.164.268-13.296.268-13.296H57.65z",
        fill: "#CBD1D1"
    }, null), createVNode("path", {
        d: "M51.54 290.04s2.111 1.178 6.682 1.178c6.128 0 8.31-1.662 8.31-1.662s.605 1.122-.624 2.18c-1 .862-3.624 1.603-7.444 1.559-4.177-.049-5.876-.57-6.786-1.177-.831-.554-.692-1.593-.138-2.078",
        fill: "#2B0849"
    }, null), createVNode("path", {
        d: "M58.533 274.438s.034 1.529-.315 2.95c-.352 1.431-1.087 3.127-1.139 4.17-.058 1.16 4.57 1.592 5.194.035.623-1.559 1.303-6.475 1.927-7.306.622-.831-4.94-2.135-5.667.15",
        fill: "#A4AABA"
    }, null), createVNode("path", {
        d: "M100.885 277.015l13.306.092s1.291-54.228 1.843-64.056c.552-9.828 3.756-43.13.997-62.788l-12.48-.64-22.725.776s-.433 3.944-1.19 9.921c-.062.493-.677.838-.744 1.358-.075.582.42 1.347.318 1.956-2.35 14.003-6.343 32.926-8.697 46.425-.116.663-1.227 1.004-1.45 2.677-.04.3.21 1.516.112 1.785-6.836 18.643-10.89 47.584-14.2 61.551l14.528-.014s2.185-8.524 4.008-16.878c2.796-12.817 22.987-84.553 22.987-84.553l3-.517 1.037 46.1s-.223 1.228.334 2.008c.558.782-.556 1.117-.39 2.233l.39 1.784s-.446 7.14-.892 11.826c-.446 4.685-.092 38.954-.092 38.954",
        fill: "#7BB2F9"
    }, null), createVNode("path", {
        d: "M77.438 220.434c1.146.094 4.016-2.008 6.916-4.91M107.55 223.931s2.758-1.103 6.069-3.862",
        stroke: "#648BD8",
        "stroke-width": "1.051",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M108.459 220.905s2.759-1.104 6.07-3.863",
        stroke: "#648BD8",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M76.099 223.557s2.608-.587 6.47-3.346M87.33 150.82c-.27 3.088.297 8.478-4.315 9.073M104.829 149.075s.11 13.936-1.286 14.983c-2.207 1.655-2.975 1.934-2.975 1.934M101.014 149.63s.035 12.81-1.19 24.245M94.93 174.965s7.174-1.655 9.38-1.655M75.671 204.754c-.316 1.55-.64 3.067-.973 4.535 0 0-1.45 1.822-1.003 3.756.446 1.934-.943 2.034-4.96 15.273-1.686 5.559-4.464 18.49-6.313 27.447-.078.38-4.018 18.06-4.093 18.423M77.043 196.743a313.269 313.269 0 0 1-.877 4.729M83.908 151.414l-1.19 10.413s-1.091.148-.496 2.23c.111 1.34-2.66 15.692-5.153 30.267M57.58 272.94h13.238",
        stroke: "#648BD8",
        "stroke-width": "1.051",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null), createVNode("path", {
        d: "M117.377 147.423s-16.955-3.087-35.7.199c.157 2.501-.002 4.128-.002 4.128s14.607-2.802 35.476-.31c.251-2.342.226-4.017.226-4.017",
        fill: "#192064"
    }, null), createVNode("path", {
        d: "M107.511 150.353l.004-4.885a.807.807 0 0 0-.774-.81c-2.428-.092-5.04-.108-7.795-.014a.814.814 0 0 0-.784.81l-.003 4.88c0 .456.371.82.827.808a140.76 140.76 0 0 1 7.688.017.81.81 0 0 0 .837-.806",
        fill: "#FFF"
    }, null), createVNode("path", {
        d: "M106.402 149.426l.002-3.06a.64.64 0 0 0-.616-.643 94.135 94.135 0 0 0-5.834-.009.647.647 0 0 0-.626.643l-.001 3.056c0 .36.291.648.651.64 1.78-.04 3.708-.041 5.762.012.36.009.662-.279.662-.64",
        fill: "#192064"
    }, null), createVNode("path", {
        d: "M101.485 273.933h12.272M102.652 269.075c.006 3.368.04 5.759.11 6.47M102.667 263.125c-.009 1.53-.015 2.98-.016 4.313M102.204 174.024l.893 44.402s.669 1.561-.224 2.677c-.892 1.116 2.455.67.893 2.231-1.562 1.562.893 1.116 0 3.347-.592 1.48-.988 20.987-1.09 34.956",
        stroke: "#648BD8",
        "stroke-width": "1.051",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null)])])
};
const unauthorized = Unauthorized;
var IconMap = {
        success: CheckCircleFilled$1,
        error: CloseCircleFilled$1,
        info: ExclamationCircleFilled$1,
        warning: WarningFilled$1
    },
    ExceptionMap = {
        404: noFound,
        500: serverError,
        403: unauthorized
    },
    ExceptionStatus = Object.keys(ExceptionMap),
    resultProps = function () {
        return {
            prefixCls: String,
            icon: PropTypes$1.any,
            status: {
                type: [Number, String],
                default: "info"
            },
            title: PropTypes$1.any,
            subTitle: PropTypes$1.any,
            extra: PropTypes$1.any
        }
    },
    renderIcon = function (C, H) {
        var W = H.status,
            U = H.icon;
        if (ExceptionStatus.includes("".concat(W))) {
            var G = ExceptionMap[W];
            return createVNode("div", {
                class: "".concat(C, "-icon ").concat(C, "-image")
            }, [createVNode(G, null, null)])
        }
        var X = IconMap[W],
            Z = U || createVNode(X, null, null);
        return createVNode("div", {
            class: "".concat(C, "-icon")
        }, [Z])
    },
    renderExtra = function (C, H) {
        return H && createVNode("div", {
            class: "".concat(C, "-extra")
        }, [H])
    },
    Result = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "AResult",
        props: resultProps(),
        slots: ["title", "subTitle", "icon", "extra"],
        setup: function (C, H) {
            var W = H.slots,
                U = useConfigInject("result", C),
                G = U.prefixCls,
                X = U.direction,
                Z = computed(function () {
                    return classNames(G.value, "".concat(G.value, "-").concat(C.status), _defineProperty$V({},
                        "".concat(G.value, "-rtl"), X.value === "rtl"))
                });
            return function () {
                var Q, ee, ne, te, re, ae, oe, ie, ue = (Q = C.title) !== null && Q !== void 0 ? Q : (ee =
                        W.title) === null || ee === void 0 ? void 0 : ee.call(W),
                    le = (ne = C.subTitle) !== null && ne !== void 0 ? ne : (te = W.subTitle) === null ||
                    te === void 0 ? void 0 : te.call(W),
                    se = (re = C.icon) !== null && re !== void 0 ? re : (ae = W.icon) === null || ae ===
                    void 0 ? void 0 : ae.call(W),
                    ce = (oe = C.extra) !== null && oe !== void 0 ? oe : (ie = W.extra) === null || ie ===
                    void 0 ? void 0 : ie.call(W),
                    de = G.value;
                return createVNode("div", {
                    class: Z.value
                }, [renderIcon(de, {
                    status: C.status,
                    icon: se
                }), createVNode("div", {
                    class: "".concat(de, "-title")
                }, [ue]), le && createVNode("div", {
                    class: "".concat(de, "-subtitle")
                }, [le]), renderExtra(de, ce), W.default && createVNode("div", {
                    class: "".concat(de, "-content")
                }, [W.default()])])
            }
        }
    });
Result.PRESENTED_IMAGE_403 = ExceptionMap[403];
Result.PRESENTED_IMAGE_404 = ExceptionMap[404];
Result.PRESENTED_IMAGE_500 = ExceptionMap[500];
Result.install = function (K) {
    return K.component(Result.name, Result), K
};
const Result$1 = Result;
var skeletonButtonProps = function () {
        return _objectSpread2$1(_objectSpread2$1({}, skeletonElementProps()), {}, {
            size: String,
            block: Boolean
        })
    },
    SkeletonButton = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ASkeletonButton",
        props: initDefaultProps$1(skeletonButtonProps(), {
            size: "default"
        }),
        setup: function (C) {
            var H = useConfigInject("skeleton", C),
                W = H.prefixCls,
                U = computed(function () {
                    var G;
                    return classNames(W.value, "".concat(W.value, "-element"), (G = {}, _defineProperty$V(G,
                        "".concat(W.value, "-active"), C.active), _defineProperty$V(G, "".concat(
                        W.value, "-block"), C.block), G))
                });
            return function () {
                return createVNode("div", {
                    class: U.value
                }, [createVNode(Element$2, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                    prefixCls: "".concat(W.value, "-button")
                }), null)])
            }
        }
    });
const SkeletonButton$1 = SkeletonButton;
var SkeletonInput = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ASkeletonInput",
    props: _objectSpread2$1(_objectSpread2$1({}, omit$2(skeletonElementProps(), ["shape"])), {}, {
        size: String
    }),
    setup: function (C) {
        var H = useConfigInject("skeleton", C),
            W = H.prefixCls,
            U = computed(function () {
                return classNames(W.value, "".concat(W.value, "-element"), _defineProperty$V({}, "".concat(
                    W.value, "-active"), C.active))
            });
        return function () {
            return createVNode("div", {
                class: U.value
            }, [createVNode(Element$2, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                prefixCls: "".concat(W.value, "-input")
            }), null)])
        }
    }
});
const SkeletonInput$1 = SkeletonInput;
var path$1 =
    "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z",
    SkeletonImage = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ASkeletonImage",
        props: omit$2(skeletonElementProps(), ["size", "shape", "active"]),
        setup: function (C) {
            var H = useConfigInject("skeleton", C),
                W = H.prefixCls,
                U = computed(function () {
                    return classNames(W.value, "".concat(W.value, "-element"))
                });
            return function () {
                return createVNode("div", {
                    class: U.value
                }, [createVNode("div", {
                    class: "".concat(W.value, "-image")
                }, [createVNode("svg", {
                    viewBox: "0 0 1098 1024",
                    xmlns: "http://www.w3.org/2000/svg",
                    class: "".concat(W.value, "-image-svg")
                }, [createVNode("path", {
                    d: path$1,
                    class: "".concat(W.value, "-image-path")
                }, null)])])])
            }
        }
    });
const SkeletonImage$1 = SkeletonImage;
var avatarProps = function () {
        return _objectSpread2$1(_objectSpread2$1({}, skeletonElementProps()), {}, {
            shape: String
        })
    },
    SkeletonAvatar = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ASkeletonAvatar",
        props: initDefaultProps$1(avatarProps(), {
            size: "default",
            shape: "circle"
        }),
        setup: function (C) {
            var H = useConfigInject("skeleton", C),
                W = H.prefixCls,
                U = computed(function () {
                    return classNames(W.value, "".concat(W.value, "-element"), _defineProperty$V({}, "".concat(
                        W.value, "-active"), C.active))
                });
            return function () {
                return createVNode("div", {
                    class: U.value
                }, [createVNode(Element$2, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                    prefixCls: "".concat(W.value, "-avatar")
                }), null)])
            }
        }
    });
const SkeletonAvatar$1 = SkeletonAvatar;
Skeleton$1.Button = SkeletonButton$1;
Skeleton$1.Avatar = SkeletonAvatar$1;
Skeleton$1.Input = SkeletonInput$1;
Skeleton$1.Image = SkeletonImage$1;
Skeleton$1.Title = SkeletonTitle$1;
Skeleton$1.install = function (K) {
    return K.component(Skeleton$1.name, Skeleton$1), K.component(Skeleton$1.Button.name, SkeletonButton$1), K.component(
        Skeleton$1.Avatar.name, SkeletonAvatar$1), K.component(Skeleton$1.Input.name, SkeletonInput$1), K.component(
        Skeleton$1.Image.name, SkeletonImage$1), K.component(Skeleton$1.Title.name, SkeletonTitle$1), K
};
var Track = function (C, H) {
    var W, U, G = H.attrs,
        X = G.included,
        Z = G.vertical,
        Q = G.style,
        ee = G.class,
        ne = G.length,
        te = G.offset,
        re = G.reverse;
    ne < 0 && (re = !re, ne = Math.abs(ne), te = 100 - te);
    var ae = Z ? (W = {}, _defineProperty$V(W, re ? "top" : "bottom", "".concat(te, "%")), _defineProperty$V(W, re ?
            "bottom" : "top", "auto"), _defineProperty$V(W, "height", "".concat(ne, "%")), W) : (U = {},
            _defineProperty$V(U, re ? "right" : "left", "".concat(te, "%")), _defineProperty$V(U, re ? "left" :
                "right", "auto"), _defineProperty$V(U, "width", "".concat(ne, "%")), U),
        oe = _objectSpread2$1(_objectSpread2$1({}, Q), ae);
    return X ? createVNode("div", {
        class: ee,
        style: oe
    }, null) : null
};
Track.inheritAttrs = !1;
const Track$1 = Track;
var calcPoints = function (C, H, W, U, G, X) {
        warning$2(W ? U > 0 : !0, "Slider",
            "`Slider[step]` should be a positive number in order to make Slider[dots] work.");
        var Z = Object.keys(H).map(parseFloat).sort(function (ee, ne) {
            return ee - ne
        });
        if (W && U)
            for (var Q = G; Q <= X; Q += U) Z.indexOf(Q) === -1 && Z.push(Q);
        return Z
    },
    Steps$2 = function (C, H) {
        var W = H.attrs,
            U = W.prefixCls,
            G = W.vertical,
            X = W.reverse,
            Z = W.marks,
            Q = W.dots,
            ee = W.step,
            ne = W.included,
            te = W.lowerBound,
            re = W.upperBound,
            ae = W.max,
            oe = W.min,
            ie = W.dotStyle,
            ue = W.activeDotStyle,
            le = ae - oe,
            se = calcPoints(G, Z, Q, ee, oe, ae).map(function (ce) {
                var de, ve = "".concat(Math.abs(ce - oe) / le * 100, "%"),
                    fe = !ne && ce === re || ne && ce <= re && ce >= te,
                    pe = G ? _objectSpread2$1(_objectSpread2$1({}, ie), {}, _defineProperty$V({}, X ? "top" :
                        "bottom", ve)) : _objectSpread2$1(_objectSpread2$1({}, ie), {}, _defineProperty$V({}, X ?
                        "right" : "left", ve));
                fe && (pe = _objectSpread2$1(_objectSpread2$1({}, pe), ue));
                var me = classNames((de = {}, _defineProperty$V(de, "".concat(U, "-dot"), !0), _defineProperty$V(de,
                    "".concat(U, "-dot-active"), fe), _defineProperty$V(de, "".concat(U, "-dot-reverse"),
                    X), de));
                return createVNode("span", {
                    class: me,
                    style: pe,
                    key: ce
                }, null)
            });
        return createVNode("div", {
            class: "".concat(U, "-step")
        }, [se])
    };
Steps$2.inheritAttrs = !1;
const Steps$3 = Steps$2;
var Marks = function (C, H) {
    var W = H.attrs,
        U = H.slots,
        G = W.class,
        X = W.vertical,
        Z = W.reverse,
        Q = W.marks,
        ee = W.included,
        ne = W.upperBound,
        te = W.lowerBound,
        re = W.max,
        ae = W.min,
        oe = W.onClickLabel,
        ie = Object.keys(Q),
        ue = U.mark,
        le = re - ae,
        se = ie.map(parseFloat).sort(function (ce, de) {
            return ce - de
        }).map(function (ce) {
            var de, ve = typeof Q[ce] == "function" ? Q[ce]() : Q[ce],
                fe = _typeof$2(ve) === "object" && !isValidElement(ve),
                pe = fe ? ve.label : ve;
            if (!pe && pe !== 0) return null;
            ue && (pe = ue({
                point: ce,
                label: pe
            }));
            var me = !ee && ce === ne || ee && ce <= ne && ce >= te,
                he = classNames((de = {}, _defineProperty$V(de, "".concat(G, "-text"), !0), _defineProperty$V(
                    de, "".concat(G, "-text-active"), me), de)),
                Se = _defineProperty$V({
                    marginBottom: "-50%"
                }, Z ? "top" : "bottom", "".concat((ce - ae) / le * 100, "%")),
                _e = _defineProperty$V({
                    transform: "translateX(".concat(Z ? "50%" : "-50%", ")"),
                    msTransform: "translateX(".concat(Z ? "50%" : "-50%", ")")
                }, Z ? "right" : "left", "".concat((ce - ae) / le * 100, "%")),
                be = X ? Se : _e,
                ge = fe ? _objectSpread2$1(_objectSpread2$1({}, be), ve.style) : be,
                xe = _defineProperty$V({}, supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart", function (
                    Pe) {
                    return oe(Pe, ce)
                });
            return createVNode("span", _objectSpread2$1({
                class: he,
                style: ge,
                key: ce,
                onMousedown: function ($e) {
                    return oe($e, ce)
                }
            }, xe), [pe])
        });
    return createVNode("div", {
        class: G
    }, [se])
};
Marks.inheritAttrs = !1;
const Marks$1 = Marks,
    VcHandle = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "Handle",
        inheritAttrs: !1,
        props: {
            prefixCls: String,
            vertical: {
                type: Boolean,
                default: void 0
            },
            offset: Number,
            disabled: {
                type: Boolean,
                default: void 0
            },
            min: Number,
            max: Number,
            value: Number,
            tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
            reverse: {
                type: Boolean,
                default: void 0
            },
            ariaLabel: String,
            ariaLabelledBy: String,
            ariaValueTextFormatter: Function,
            onMouseenter: {
                type: Function
            },
            onMouseleave: {
                type: Function
            },
            onMousedown: {
                type: Function
            }
        },
        setup: function (C, H) {
            var W = H.attrs,
                U = H.emit,
                G = H.expose,
                X = ref(!1),
                Z = ref(),
                Q = function () {
                    document.activeElement === Z.value && (X.value = !0)
                },
                ee = function (se) {
                    X.value = !1, U("blur", se)
                },
                ne = function () {
                    X.value = !1
                },
                te = function () {
                    var se;
                    (se = Z.value) === null || se === void 0 || se.focus()
                },
                re = function () {
                    var se;
                    (se = Z.value) === null || se === void 0 || se.blur()
                },
                ae = function () {
                    X.value = !0, te()
                },
                oe = function (se) {
                    se.preventDefault(), te(), U("mousedown", se)
                };
            G({
                focus: te,
                blur: re,
                clickFocus: ae,
                ref: Z
            });
            var ie = null;
            onMounted(function () {
                ie = addEventListenerWrap(document, "mouseup", Q)
            }), onBeforeUnmount(function () {
                var le;
                (le = ie) === null || le === void 0 || le.remove()
            });
            var ue = computed(function () {
                var le, se, ce = C.vertical,
                    de = C.offset,
                    ve = C.reverse;
                return ce ? (le = {}, _defineProperty$V(le, ve ? "top" : "bottom", "".concat(de, "%")),
                    _defineProperty$V(le, ve ? "bottom" : "top", "auto"), _defineProperty$V(le,
                        "transform", ve ? null : "translateY(+50%)"), le) : (se = {},
                    _defineProperty$V(se, ve ? "right" : "left", "".concat(de, "%")),
                    _defineProperty$V(se, ve ? "left" : "right", "auto"), _defineProperty$V(se,
                        "transform", "translateX(".concat(ve ? "+" : "-", "50%)")), se)
            });
            return function () {
                var le = C.prefixCls,
                    se = C.disabled,
                    ce = C.min,
                    de = C.max,
                    ve = C.value,
                    fe = C.tabindex,
                    pe = C.ariaLabel,
                    me = C.ariaLabelledBy,
                    he = C.ariaValueTextFormatter,
                    Se = C.onMouseenter,
                    _e = C.onMouseleave,
                    be = classNames(W.class, _defineProperty$V({}, "".concat(le, "-handle-click-focused"),
                        X.value)),
                    ge = {
                        "aria-valuemin": ce,
                        "aria-valuemax": de,
                        "aria-valuenow": ve,
                        "aria-disabled": !!se
                    },
                    xe = [W.style, ue.value],
                    Pe = fe || 0;
                (se || fe === null) && (Pe = null);
                var $e;
                he && ($e = he(ve));
                var ye = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, W), {}, {
                    role: "slider",
                    tabindex: Pe
                }, ge), {}, {
                    class: be,
                    onBlur: ee,
                    onKeydown: ne,
                    onMousedown: oe,
                    onMouseenter: Se,
                    onMouseleave: _e,
                    ref: Z,
                    style: xe
                });
                return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, ye), {}, {
                    "aria-label": pe,
                    "aria-labelledby": me,
                    "aria-valuetext": $e
                }), null)
            }
        }
    });

function isEventFromHandle(K, C) {
    try {
        return Object.keys(C).some(function (H) {
            return K.target === C[H].ref
        })
    } catch {
        return !1
    }
}

function isValueOutOfRange(K, C) {
    var H = C.min,
        W = C.max;
    return K < H || K > W
}

function isNotTouchEvent(K) {
    return K.touches.length > 1 || K.type.toLowerCase() === "touchend" && K.touches.length > 0
}

function getClosestPoint(K, C) {
    var H = C.marks,
        W = C.step,
        U = C.min,
        G = C.max,
        X = Object.keys(H).map(parseFloat);
    if (W !== null) {
        var Z = Math.pow(10, getPrecision(W)),
            Q = Math.floor((G * Z - U * Z) / (W * Z)),
            ee = Math.min((K - U) / W, Q),
            ne = Math.round(ee) * W + U;
        X.push(ne)
    }
    var te = X.map(function (re) {
        return Math.abs(K - re)
    });
    return X[te.indexOf(Math.min.apply(Math, _toConsumableArray(te)))]
}

function getPrecision(K) {
    var C = K.toString(),
        H = 0;
    return C.indexOf(".") >= 0 && (H = C.length - C.indexOf(".") - 1), H
}

function getMousePosition(K, C) {
    var H = 1;
    return window.visualViewport && (H = +(window.visualViewport.width / document.body.getBoundingClientRect().width).toFixed(
        2)), (K ? C.clientY : C.pageX) / H
}

function getTouchPosition(K, C) {
    var H = 1;
    return window.visualViewport && (H = +(window.visualViewport.width / document.body.getBoundingClientRect().width).toFixed(
        2)), (K ? C.touches[0].clientY : C.touches[0].pageX) / H
}

function getHandleCenterPosition(K, C) {
    var H = C.getBoundingClientRect();
    return K ? H.top + H.height * .5 : window.pageXOffset + H.left + H.width * .5
}

function ensureValueInRange(K, C) {
    var H = C.max,
        W = C.min;
    return K <= W ? W : K >= H ? H : K
}

function ensureValuePrecision(K, C) {
    var H = C.step,
        W = isFinite(getClosestPoint(K, C)) ? getClosestPoint(K, C) : 0;
    return H === null ? W : parseFloat(W.toFixed(getPrecision(H)))
}

function pauseEvent(K) {
    K.stopPropagation(), K.preventDefault()
}

function calculateNextValue(K, C, H) {
    var W = {
            increase: function (Z, Q) {
                return Z + Q
            },
            decrease: function (Z, Q) {
                return Z - Q
            }
        },
        U = W[K](Object.keys(H.marks).indexOf(JSON.stringify(C)), 1),
        G = Object.keys(H.marks)[U];
    return H.step ? W[K](C, H.step) : Object.keys(H.marks).length && H.marks[G] ? H.marks[G] : C
}

function getKeyboardValueMutator(K, C, H) {
    var W = "increase",
        U = "decrease",
        G = W;
    switch (K.keyCode) {
        case KeyCode$1.UP:
            G = C && H ? U : W;
            break;
        case KeyCode$1.RIGHT:
            G = !C && H ? U : W;
            break;
        case KeyCode$1.DOWN:
            G = C && H ? W : U;
            break;
        case KeyCode$1.LEFT:
            G = !C && H ? W : U;
            break;
        case KeyCode$1.END:
            return function (X, Z) {
                return Z.max
            };
        case KeyCode$1.HOME:
            return function (X, Z) {
                return Z.min
            };
        case KeyCode$1.PAGE_UP:
            return function (X, Z) {
                return X + Z.step * 2
            };
        case KeyCode$1.PAGE_DOWN:
            return function (X, Z) {
                return X - Z.step * 2
            };
        default:
            return
    }
    return function (X, Z) {
        return calculateNextValue(G, X, Z)
    }
}
var _excluded$h = ["index", "directives", "className", "style"];

function noop$5() {}

function createSlider(K) {
    var C = {
        id: String,
        min: Number,
        max: Number,
        step: Number,
        marks: PropTypes$1.object,
        included: {
            type: Boolean,
            default: void 0
        },
        prefixCls: String,
        disabled: {
            type: Boolean,
            default: void 0
        },
        handle: Function,
        dots: {
            type: Boolean,
            default: void 0
        },
        vertical: {
            type: Boolean,
            default: void 0
        },
        reverse: {
            type: Boolean,
            default: void 0
        },
        minimumTrackStyle: PropTypes$1.object,
        maximumTrackStyle: PropTypes$1.object,
        handleStyle: PropTypes$1.oneOfType([PropTypes$1.object, PropTypes$1.arrayOf(PropTypes$1.object)]),
        trackStyle: PropTypes$1.oneOfType([PropTypes$1.object, PropTypes$1.arrayOf(PropTypes$1.object)]),
        railStyle: PropTypes$1.object,
        dotStyle: PropTypes$1.object,
        activeDotStyle: PropTypes$1.object,
        autofocus: {
            type: Boolean,
            default: void 0
        },
        draggableTrack: {
            type: Boolean,
            default: void 0
        }
    };
    return defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "CreateSlider",
        mixins: [BaseMixin, K],
        inheritAttrs: !1,
        slots: ["mark"],
        props: initDefaultProps$1(C, {
            prefixCls: "rc-slider",
            min: 0,
            max: 100,
            step: 1,
            marks: {},
            included: !0,
            disabled: !1,
            dots: !1,
            vertical: !1,
            reverse: !1,
            trackStyle: [{}],
            handleStyle: [{}],
            railStyle: {},
            dotStyle: {},
            activeDotStyle: {}
        }),
        emits: ["change", "blur", "focus"],
        data: function () {
            var W = this.step,
                U = this.max,
                G = this.min,
                X = isFinite(U - G) ? (U - G) % W === 0 : !0;
            return warning$2(W && Math.floor(W) === W ? X : !0, "Slider[max] - Slider[min] (".concat(U - G,
                ") should be a multiple of Slider[step] (").concat(W, ")")), this.handlesRefs = {}, {}
        },
        mounted: function () {
            var W = this;
            this.$nextTick(function () {
                W.document = W.sliderRef && W.sliderRef.ownerDocument;
                var U = W.autofocus,
                    G = W.disabled;
                U && !G && W.focus()
            })
        },
        beforeUnmount: function () {
            var W = this;
            this.$nextTick(function () {
                W.removeDocumentEvents()
            })
        },
        methods: {
            defaultHandle: function (W) {
                var U = W.index;
                W.directives;
                var G = W.className,
                    X = W.style,
                    Z = _objectWithoutProperties$2(W, _excluded$h);
                if (delete Z.dragging, Z.value === null) return null;
                var Q = _objectSpread2$1(_objectSpread2$1({}, Z), {}, {
                    class: G,
                    style: X,
                    key: U
                });
                return createVNode(VcHandle, Q, null)
            },
            onDown: function (W, U) {
                var G = U,
                    X = this.$props,
                    Z = X.draggableTrack,
                    Q = X.vertical,
                    ee = this.$data.bounds,
                    ne = Z && this.positionGetValue ? this.positionGetValue(G) || [] : [],
                    te = isEventFromHandle(W, this.handlesRefs);
                if (this.dragTrack = Z && ee.length >= 2 && !te && !ne.map(function (ae, oe) {
                        var ie = oe ? !0 : ae >= ee[oe];
                        return oe === ne.length - 1 ? ae <= ee[oe] : ie
                    }).some(function (ae) {
                        return !ae
                    }), this.dragTrack) this.dragOffset = G, this.startBounds = _toConsumableArray(ee);
                else {
                    if (!te) this.dragOffset = 0;
                    else {
                        var re = getHandleCenterPosition(Q, W.target);
                        this.dragOffset = G - re, G = re
                    }
                    this.onStart(G)
                }
            },
            onMouseDown: function (W) {
                if (W.button === 0) {
                    this.removeDocumentEvents();
                    var U = this.$props.vertical,
                        G = getMousePosition(U, W);
                    this.onDown(W, G), this.addDocumentMouseEvents()
                }
            },
            onTouchStart: function (W) {
                if (!isNotTouchEvent(W)) {
                    var U = this.vertical,
                        G = getTouchPosition(U, W);
                    this.onDown(W, G), this.addDocumentTouchEvents(), pauseEvent(W)
                }
            },
            onFocus: function (W) {
                var U = this.vertical;
                if (isEventFromHandle(W, this.handlesRefs) && !this.dragTrack) {
                    var G = getHandleCenterPosition(U, W.target);
                    this.dragOffset = 0, this.onStart(G), pauseEvent(W), this.$emit("focus", W)
                }
            },
            onBlur: function (W) {
                this.dragTrack || this.onEnd(), this.$emit("blur", W)
            },
            onMouseUp: function () {
                this.handlesRefs[this.prevMovedHandleIndex] && this.handlesRefs[this.prevMovedHandleIndex].clickFocus()
            },
            onMouseMove: function (W) {
                if (!this.sliderRef) {
                    this.onEnd();
                    return
                }
                var U = getMousePosition(this.vertical, W);
                this.onMove(W, U - this.dragOffset, this.dragTrack, this.startBounds)
            },
            onTouchMove: function (W) {
                if (isNotTouchEvent(W) || !this.sliderRef) {
                    this.onEnd();
                    return
                }
                var U = getTouchPosition(this.vertical, W);
                this.onMove(W, U - this.dragOffset, this.dragTrack, this.startBounds)
            },
            onKeyDown: function (W) {
                this.sliderRef && isEventFromHandle(W, this.handlesRefs) && this.onKeyboard(W)
            },
            onClickMarkLabel: function (W, U) {
                var G = this;
                W.stopPropagation(), this.onChange({
                    sValue: U
                }), this.setState({
                    sValue: U
                }, function () {
                    return G.onEnd(!0)
                })
            },
            getSliderStart: function () {
                var W = this.sliderRef,
                    U = this.vertical,
                    G = this.reverse,
                    X = W.getBoundingClientRect();
                return U ? G ? X.bottom : X.top : window.pageXOffset + (G ? X.right : X.left)
            },
            getSliderLength: function () {
                var W = this.sliderRef;
                if (!W) return 0;
                var U = W.getBoundingClientRect();
                return this.vertical ? U.height : U.width
            },
            addDocumentTouchEvents: function () {
                this.onTouchMoveListener = addEventListenerWrap(this.document, "touchmove", this.onTouchMove),
                    this.onTouchUpListener = addEventListenerWrap(this.document, "touchend", this.onEnd)
            },
            addDocumentMouseEvents: function () {
                this.onMouseMoveListener = addEventListenerWrap(this.document, "mousemove", this.onMouseMove),
                    this.onMouseUpListener = addEventListenerWrap(this.document, "mouseup", this.onEnd)
            },
            removeDocumentEvents: function () {
                this.onTouchMoveListener && this.onTouchMoveListener.remove(), this.onTouchUpListener &&
                    this.onTouchUpListener.remove(), this.onMouseMoveListener && this.onMouseMoveListener.remove(),
                    this.onMouseUpListener && this.onMouseUpListener.remove()
            },
            focus: function () {
                var W;
                this.$props.disabled || (W = this.handlesRefs[0]) === null || W === void 0 || W.focus()
            },
            blur: function () {
                var W = this;
                this.$props.disabled || Object.keys(this.handlesRefs).forEach(function (U) {
                    var G, X;
                    (G = W.handlesRefs[U]) === null || G === void 0 || (X = G.blur) === null || X ===
                        void 0 || X.call(G)
                })
            },
            calcValue: function (W) {
                var U = this.vertical,
                    G = this.min,
                    X = this.max,
                    Z = Math.abs(Math.max(W, 0) / this.getSliderLength()),
                    Q = U ? (1 - Z) * (X - G) + G : Z * (X - G) + G;
                return Q
            },
            calcValueByPos: function (W) {
                var U = this.reverse ? -1 : 1,
                    G = U * (W - this.getSliderStart()),
                    X = this.trimAlignValue(this.calcValue(G));
                return X
            },
            calcOffset: function (W) {
                var U = this.min,
                    G = this.max,
                    X = (W - U) / (G - U);
                return Math.max(0, X * 100)
            },
            saveSlider: function (W) {
                this.sliderRef = W
            },
            saveHandle: function (W, U) {
                this.handlesRefs[W] = U
            }
        },
        render: function () {
            var W, U = this.prefixCls,
                G = this.marks,
                X = this.dots,
                Z = this.step,
                Q = this.included,
                ee = this.disabled,
                ne = this.vertical,
                te = this.reverse,
                re = this.min,
                ae = this.max,
                oe = this.maximumTrackStyle,
                ie = this.railStyle,
                ue = this.dotStyle,
                le = this.activeDotStyle,
                se = this.id,
                ce = this.$attrs,
                de = ce.class,
                ve = ce.style,
                fe = this.renderSlider(),
                pe = fe.tracks,
                me = fe.handles,
                he = classNames(U, de, (W = {}, _defineProperty$V(W, "".concat(U, "-with-marks"), Object.keys(
                        G).length), _defineProperty$V(W, "".concat(U, "-disabled"), ee),
                    _defineProperty$V(W, "".concat(U, "-vertical"), ne), W)),
                Se = {
                    vertical: ne,
                    marks: G,
                    included: Q,
                    lowerBound: this.getLowerBound(),
                    upperBound: this.getUpperBound(),
                    max: ae,
                    min: re,
                    reverse: te,
                    class: "".concat(U, "-mark"),
                    onClickLabel: ee ? noop$5 : this.onClickMarkLabel
                },
                _e = _defineProperty$V({}, supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart", ee ?
                    noop$5 : this.onTouchStart);
            return createVNode("div", _objectSpread2$1(_objectSpread2$1({
                id: se,
                ref: this.saveSlider,
                tabindex: "-1",
                class: he
            }, _e), {}, {
                onMousedown: ee ? noop$5 : this.onMouseDown,
                onMouseup: ee ? noop$5 : this.onMouseUp,
                onKeydown: ee ? noop$5 : this.onKeyDown,
                onFocus: ee ? noop$5 : this.onFocus,
                onBlur: ee ? noop$5 : this.onBlur,
                style: ve
            }), [createVNode("div", {
                class: "".concat(U, "-rail"),
                style: _objectSpread2$1(_objectSpread2$1({}, oe), ie)
            }, null), pe, createVNode(Steps$3, {
                prefixCls: U,
                vertical: ne,
                reverse: te,
                marks: G,
                dots: X,
                step: Z,
                included: Q,
                lowerBound: this.getLowerBound(),
                upperBound: this.getUpperBound(),
                max: ae,
                min: re,
                dotStyle: ue,
                activeDotStyle: le
            }, null), me, createVNode(Marks$1, Se, {
                mark: this.$slots.mark
            }), getSlot(this)])
        }
    })
}
var Slider$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Slider",
    mixins: [BaseMixin],
    inheritAttrs: !1,
    props: {
        defaultValue: Number,
        value: Number,
        disabled: {
            type: Boolean,
            default: void 0
        },
        autofocus: {
            type: Boolean,
            default: void 0
        },
        tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
        reverse: {
            type: Boolean,
            default: void 0
        },
        min: Number,
        max: Number,
        ariaLabelForHandle: String,
        ariaLabelledByForHandle: String,
        ariaValueTextFormatterForHandle: String,
        startPoint: Number
    },
    emits: ["beforeChange", "afterChange", "change"],
    data: function () {
        var C = this.defaultValue !== void 0 ? this.defaultValue : this.min,
            H = this.value !== void 0 ? this.value : C;
        return {
            sValue: this.trimAlignValue(H),
            dragging: !1
        }
    },
    watch: {
        value: {
            handler: function (C) {
                this.setChangeValue(C)
            },
            deep: !0
        },
        min: function () {
            var C = this.sValue;
            this.setChangeValue(C)
        },
        max: function () {
            var C = this.sValue;
            this.setChangeValue(C)
        }
    },
    methods: {
        setChangeValue: function (C) {
            var H = C !== void 0 ? C : this.sValue,
                W = this.trimAlignValue(H, this.$props);
            W !== this.sValue && (this.setState({
                sValue: W
            }), isValueOutOfRange(H, this.$props) && this.$emit("change", W))
        },
        onChange: function (C) {
            var H = !hasProp(this, "value"),
                W = C.sValue > this.max ? _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                    sValue: this.max
                }) : C;
            H && this.setState(W);
            var U = W.sValue;
            this.$emit("change", U)
        },
        onStart: function (C) {
            this.setState({
                dragging: !0
            });
            var H = this.sValue;
            this.$emit("beforeChange", H);
            var W = this.calcValueByPos(C);
            this.startValue = W, this.startPosition = C, W !== H && (this.prevMovedHandleIndex = 0, this.onChange({
                sValue: W
            }))
        },
        onEnd: function (C) {
            var H = this.dragging;
            this.removeDocumentEvents(), (H || C) && this.$emit("afterChange", this.sValue), this.setState({
                dragging: !1
            })
        },
        onMove: function (C, H) {
            pauseEvent(C);
            var W = this.sValue,
                U = this.calcValueByPos(H);
            U !== W && this.onChange({
                sValue: U
            })
        },
        onKeyboard: function (C) {
            var H = this.$props,
                W = H.reverse,
                U = H.vertical,
                G = getKeyboardValueMutator(C, U, W);
            if (G) {
                pauseEvent(C);
                var X = this.sValue,
                    Z = G(X, this.$props),
                    Q = this.trimAlignValue(Z);
                if (Q === X) return;
                this.onChange({
                    sValue: Q
                }), this.$emit("afterChange", Q), this.onEnd()
            }
        },
        getLowerBound: function () {
            var C = this.$props.startPoint || this.$props.min;
            return this.$data.sValue > C ? C : this.$data.sValue
        },
        getUpperBound: function () {
            return this.$data.sValue < this.$props.startPoint ? this.$props.startPoint : this.$data.sValue
        },
        trimAlignValue: function (C) {
            var H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (C === null) return null;
            var W = _objectSpread2$1(_objectSpread2$1({}, this.$props), H),
                U = ensureValueInRange(C, W);
            return ensureValuePrecision(U, W)
        },
        getTrack: function (C) {
            var H = C.prefixCls,
                W = C.reverse,
                U = C.vertical,
                G = C.included,
                X = C.minimumTrackStyle,
                Z = C.mergedTrackStyle,
                Q = C.length,
                ee = C.offset;
            return createVNode(Track$1, {
                class: "".concat(H, "-track"),
                vertical: U,
                included: G,
                offset: ee,
                reverse: W,
                length: Q,
                style: _objectSpread2$1(_objectSpread2$1({}, X), Z)
            }, null)
        },
        renderSlider: function () {
            var C = this,
                H = this.prefixCls,
                W = this.vertical,
                U = this.included,
                G = this.disabled,
                X = this.minimumTrackStyle,
                Z = this.trackStyle,
                Q = this.handleStyle,
                ee = this.tabindex,
                ne = this.ariaLabelForHandle,
                te = this.ariaLabelledByForHandle,
                re = this.ariaValueTextFormatterForHandle,
                ae = this.min,
                oe = this.max,
                ie = this.startPoint,
                ue = this.reverse,
                le = this.handle,
                se = this.defaultHandle,
                ce = le || se,
                de = this.sValue,
                ve = this.dragging,
                fe = this.calcOffset(de),
                pe = ce({
                    class: "".concat(H, "-handle"),
                    prefixCls: H,
                    vertical: W,
                    offset: fe,
                    value: de,
                    dragging: ve,
                    disabled: G,
                    min: ae,
                    max: oe,
                    reverse: ue,
                    index: 0,
                    tabindex: ee,
                    ariaLabel: ne,
                    ariaLabelledBy: te,
                    ariaValueTextFormatter: re,
                    style: Q[0] || Q,
                    ref: function (_e) {
                        return C.saveHandle(0, _e)
                    },
                    onFocus: this.onFocus,
                    onBlur: this.onBlur
                }),
                me = ie !== void 0 ? this.calcOffset(ie) : 0,
                he = Z[0] || Z;
            return {
                tracks: this.getTrack({
                    prefixCls: H,
                    reverse: ue,
                    vertical: W,
                    included: U,
                    offset: me,
                    minimumTrackStyle: X,
                    mergedTrackStyle: he,
                    length: fe - me
                }),
                handles: pe
            }
        }
    }
});
const VcSlider = createSlider(Slider$1);
var _trimAlignValue = function (C) {
        var H = C.value,
            W = C.handle,
            U = C.bounds,
            G = C.props,
            X = G.allowCross,
            Z = G.pushable,
            Q = Number(Z),
            ee = ensureValueInRange(H, G),
            ne = ee;
        return !X && W != null && U !== void 0 && (W > 0 && ee <= U[W - 1] + Q && (ne = U[W - 1] + Q), W < U.length - 1 &&
            ee >= U[W + 1] - Q && (ne = U[W + 1] - Q)), ensureValuePrecision(ne, G)
    },
    rangeProps = {
        defaultValue: PropTypes$1.arrayOf(PropTypes$1.number),
        value: PropTypes$1.arrayOf(PropTypes$1.number),
        count: Number,
        pushable: withUndefined(PropTypes$1.oneOfType([PropTypes$1.looseBool, PropTypes$1.number])),
        allowCross: {
            type: Boolean,
            default: void 0
        },
        disabled: {
            type: Boolean,
            default: void 0
        },
        reverse: {
            type: Boolean,
            default: void 0
        },
        tabindex: PropTypes$1.arrayOf(PropTypes$1.number),
        prefixCls: String,
        min: Number,
        max: Number,
        autofocus: {
            type: Boolean,
            default: void 0
        },
        ariaLabelGroupForHandles: Array,
        ariaLabelledByGroupForHandles: Array,
        ariaValueTextFormatterGroupForHandles: Array,
        draggableTrack: {
            type: Boolean,
            default: void 0
        }
    },
    Range = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "Range",
        mixins: [BaseMixin],
        inheritAttrs: !1,
        props: initDefaultProps$1(rangeProps, {
            count: 1,
            allowCross: !0,
            pushable: !1,
            tabindex: [],
            draggableTrack: !1,
            ariaLabelGroupForHandles: [],
            ariaLabelledByGroupForHandles: [],
            ariaValueTextFormatterGroupForHandles: []
        }),
        emits: ["beforeChange", "afterChange", "change"],
        displayName: "Range",
        data: function () {
            var C = this,
                H = this.count,
                W = this.min,
                U = this.max,
                G = Array.apply(void 0, _toConsumableArray(Array(H + 1))).map(function () {
                    return W
                }),
                X = hasProp(this, "defaultValue") ? this.defaultValue : G,
                Z = this.value;
            Z === void 0 && (Z = X);
            var Q = Z.map(function (ne, te) {
                    return _trimAlignValue({
                        value: ne,
                        handle: te,
                        props: C.$props
                    })
                }),
                ee = Q[0] === U ? 0 : Q.length - 1;
            return {
                sHandle: null,
                recent: ee,
                bounds: Q
            }
        },
        watch: {
            value: {
                handler: function (C) {
                    var H = this.bounds;
                    this.setChangeValue(C || H)
                },
                deep: !0
            },
            min: function () {
                var C = this.value;
                this.setChangeValue(C || this.bounds)
            },
            max: function () {
                var C = this.value;
                this.setChangeValue(C || this.bounds)
            }
        },
        methods: {
            setChangeValue: function (C) {
                var H = this,
                    W = this.bounds,
                    U = C.map(function (X, Z) {
                        return _trimAlignValue({
                            value: X,
                            handle: Z,
                            bounds: W,
                            props: H.$props
                        })
                    });
                if (W.length === U.length) {
                    if (U.every(function (X, Z) {
                            return X === W[Z]
                        })) return null
                } else U = C.map(function (X, Z) {
                    return _trimAlignValue({
                        value: X,
                        handle: Z,
                        props: H.$props
                    })
                });
                if (this.setState({
                        bounds: U
                    }), C.some(function (X) {
                        return isValueOutOfRange(X, H.$props)
                    })) {
                    var G = C.map(function (X) {
                        return ensureValueInRange(X, H.$props)
                    });
                    this.$emit("change", G)
                }
            },
            onChange: function (C) {
                var H = !hasProp(this, "value");
                if (H) this.setState(C);
                else {
                    var W = {};
                    ["sHandle", "recent"].forEach(function (X) {
                        C[X] !== void 0 && (W[X] = C[X])
                    }), Object.keys(W).length && this.setState(W)
                }
                var U = _objectSpread2$1(_objectSpread2$1({}, this.$data), C),
                    G = U.bounds;
                this.$emit("change", G)
            },
            positionGetValue: function (C) {
                var H = this.getValue(),
                    W = this.calcValueByPos(C),
                    U = this.getClosestBound(W),
                    G = this.getBoundNeedMoving(W, U),
                    X = H[G];
                if (W === X) return null;
                var Z = _toConsumableArray(H);
                return Z[G] = W, Z
            },
            onStart: function (C) {
                var H = this.bounds;
                this.$emit("beforeChange", H);
                var W = this.calcValueByPos(C);
                this.startValue = W, this.startPosition = C;
                var U = this.getClosestBound(W);
                this.prevMovedHandleIndex = this.getBoundNeedMoving(W, U), this.setState({
                    sHandle: this.prevMovedHandleIndex,
                    recent: this.prevMovedHandleIndex
                });
                var G = H[this.prevMovedHandleIndex];
                if (W !== G) {
                    var X = _toConsumableArray(H);
                    X[this.prevMovedHandleIndex] = W, this.onChange({
                        bounds: X
                    })
                }
            },
            onEnd: function (C) {
                var H = this.sHandle;
                this.removeDocumentEvents(), H || (this.dragTrack = !1), (H !== null || C) && this.$emit(
                    "afterChange", this.bounds), this.setState({
                    sHandle: null
                })
            },
            onMove: function (C, H, W, U) {
                pauseEvent(C);
                var G = this.$data,
                    X = this.$props,
                    Z = X.max || 100,
                    Q = X.min || 0;
                if (W) {
                    var ee = X.vertical ? -H : H;
                    ee = X.reverse ? -ee : ee;
                    var ne = Z - Math.max.apply(Math, _toConsumableArray(U)),
                        te = Q - Math.min.apply(Math, _toConsumableArray(U)),
                        re = Math.min(Math.max(ee / (this.getSliderLength() / 100), te), ne),
                        ae = U.map(function (se) {
                            return Math.floor(Math.max(Math.min(se + re, Z), Q))
                        });
                    G.bounds.map(function (se, ce) {
                        return se === ae[ce]
                    }).some(function (se) {
                        return !se
                    }) && this.onChange({
                        bounds: ae
                    });
                    return
                }
                var oe = this.bounds,
                    ie = this.sHandle,
                    ue = this.calcValueByPos(H),
                    le = oe[ie];
                ue !== le && this.moveTo(ue)
            },
            onKeyboard: function (C) {
                var H = this.$props,
                    W = H.reverse,
                    U = H.vertical,
                    G = getKeyboardValueMutator(C, U, W);
                if (G) {
                    pauseEvent(C);
                    var X = this.bounds,
                        Z = this.sHandle,
                        Q = X[Z === null ? this.recent : Z],
                        ee = G(Q, this.$props),
                        ne = _trimAlignValue({
                            value: ee,
                            handle: Z,
                            bounds: X,
                            props: this.$props
                        });
                    if (ne === Q) return;
                    var te = !0;
                    this.moveTo(ne, te)
                }
            },
            getClosestBound: function (C) {
                for (var H = this.bounds, W = 0, U = 1; U < H.length - 1; U += 1) C >= H[U] && (W = U);
                return Math.abs(H[W + 1] - C) < Math.abs(H[W] - C) && (W += 1), W
            },
            getBoundNeedMoving: function (C, H) {
                var W = this.bounds,
                    U = this.recent,
                    G = H,
                    X = W[H + 1] === W[H];
                return X && W[U] === W[H] && (G = U), X && C !== W[H + 1] && (G = C < W[H + 1] ? H : H + 1), G
            },
            getLowerBound: function () {
                return this.bounds[0]
            },
            getUpperBound: function () {
                var C = this.bounds;
                return C[C.length - 1]
            },
            getPoints: function () {
                var C = this.marks,
                    H = this.step,
                    W = this.min,
                    U = this.max,
                    G = this.internalPointsCache;
                if (!G || G.marks !== C || G.step !== H) {
                    var X = _objectSpread2$1({}, C);
                    if (H !== null)
                        for (var Z = W; Z <= U; Z += H) X[Z] = Z;
                    var Q = Object.keys(X).map(parseFloat);
                    Q.sort(function (ee, ne) {
                        return ee - ne
                    }), this.internalPointsCache = {
                        marks: C,
                        step: H,
                        points: Q
                    }
                }
                return this.internalPointsCache.points
            },
            moveTo: function (C, H) {
                var W = this,
                    U = _toConsumableArray(this.bounds),
                    G = this.sHandle,
                    X = this.recent,
                    Z = G === null ? X : G;
                U[Z] = C;
                var Q = Z;
                this.$props.pushable !== !1 ? this.pushSurroundingHandles(U, Q) : this.$props.allowCross && (U.sort(
                    function (ee, ne) {
                        return ee - ne
                    }), Q = U.indexOf(C)), this.onChange({
                    recent: Q,
                    sHandle: Q,
                    bounds: U
                }), H && (this.$emit("afterChange", U), this.setState({}, function () {
                    W.handlesRefs[Q].focus()
                }), this.onEnd())
            },
            pushSurroundingHandles: function (C, H) {
                var W = C[H],
                    U = this.pushable,
                    G = Number(U),
                    X = 0;
                if (C[H + 1] - W < G && (X = 1), W - C[H - 1] < G && (X = -1), X !== 0) {
                    var Z = H + X,
                        Q = X * (C[Z] - W);
                    this.pushHandle(C, Z, X, G - Q) || (C[H] = C[Z] - X * G)
                }
            },
            pushHandle: function (C, H, W, U) {
                for (var G = C[H], X = C[H]; W * (X - G) < U;) {
                    if (!this.pushHandleOnePoint(C, H, W)) return C[H] = G, !1;
                    X = C[H]
                }
                return !0
            },
            pushHandleOnePoint: function (C, H, W) {
                var U = this.getPoints(),
                    G = U.indexOf(C[H]),
                    X = G + W;
                if (X >= U.length || X < 0) return !1;
                var Z = H + W,
                    Q = U[X],
                    ee = this.pushable,
                    ne = Number(ee),
                    te = W * (C[Z] - Q);
                return this.pushHandle(C, Z, W, ne - te) ? (C[H] = Q, !0) : !1
            },
            trimAlignValue: function (C) {
                var H = this.sHandle,
                    W = this.bounds;
                return _trimAlignValue({
                    value: C,
                    handle: H,
                    bounds: W,
                    props: this.$props
                })
            },
            ensureValueNotConflict: function (C, H, W) {
                var U = W.allowCross,
                    G = W.pushable,
                    X = this.$data || {},
                    Z = X.bounds;
                if (C = C === void 0 ? X.sHandle : C, G = Number(G), !U && C != null && Z !== void 0) {
                    if (C > 0 && H <= Z[C - 1] + G) return Z[C - 1] + G;
                    if (C < Z.length - 1 && H >= Z[C + 1] - G) return Z[C + 1] - G
                }
                return H
            },
            getTrack: function (C) {
                var H = C.bounds,
                    W = C.prefixCls,
                    U = C.reverse,
                    G = C.vertical,
                    X = C.included,
                    Z = C.offsets,
                    Q = C.trackStyle;
                return H.slice(0, -1).map(function (ee, ne) {
                    var te, re = ne + 1,
                        ae = classNames((te = {}, _defineProperty$V(te, "".concat(W, "-track"), !0),
                            _defineProperty$V(te, "".concat(W, "-track-").concat(re), !0), te));
                    return createVNode(Track$1, {
                        class: ae,
                        vertical: G,
                        reverse: U,
                        included: X,
                        offset: Z[re - 1],
                        length: Z[re] - Z[re - 1],
                        style: Q[ne],
                        key: re
                    }, null)
                })
            },
            renderSlider: function () {
                var C = this,
                    H = this.sHandle,
                    W = this.bounds,
                    U = this.prefixCls,
                    G = this.vertical,
                    X = this.included,
                    Z = this.disabled,
                    Q = this.min,
                    ee = this.max,
                    ne = this.reverse,
                    te = this.handle,
                    re = this.defaultHandle,
                    ae = this.trackStyle,
                    oe = this.handleStyle,
                    ie = this.tabindex,
                    ue = this.ariaLabelGroupForHandles,
                    le = this.ariaLabelledByGroupForHandles,
                    se = this.ariaValueTextFormatterGroupForHandles,
                    ce = te || re,
                    de = W.map(function (pe) {
                        return C.calcOffset(pe)
                    }),
                    ve = "".concat(U, "-handle"),
                    fe = W.map(function (pe, me) {
                        var he, Se = ie[me] || 0;
                        (Z || ie[me] === null) && (Se = null);
                        var _e = H === me;
                        return ce({
                            class: classNames((he = {}, _defineProperty$V(he, ve, !0),
                                _defineProperty$V(he, "".concat(ve, "-").concat(me + 1), !0),
                                _defineProperty$V(he, "".concat(ve, "-dragging"), _e), he)),
                            prefixCls: U,
                            vertical: G,
                            dragging: _e,
                            offset: de[me],
                            value: pe,
                            index: me,
                            tabindex: Se,
                            min: Q,
                            max: ee,
                            reverse: ne,
                            disabled: Z,
                            style: oe[me],
                            ref: function (ge) {
                                return C.saveHandle(me, ge)
                            },
                            onFocus: C.onFocus,
                            onBlur: C.onBlur,
                            ariaLabel: ue[me],
                            ariaLabelledBy: le[me],
                            ariaValueTextFormatter: se[me]
                        })
                    });
                return {
                    tracks: this.getTrack({
                        bounds: W,
                        prefixCls: U,
                        reverse: ne,
                        vertical: G,
                        included: X,
                        offsets: de,
                        trackStyle: ae
                    }),
                    handles: fe
                }
            }
        }
    });
const VcRange = createSlider(Range),
    SliderTooltip = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "SliderTooltip",
        inheritAttrs: !1,
        props: tooltipProps(),
        setup: function (C, H) {
            var W = H.attrs,
                U = H.slots,
                G = ref(null),
                X = ref(null);

            function Z() {
                wrapperRaf.cancel(X.value), X.value = null
            }

            function Q() {
                X.value = wrapperRaf(function () {
                    var ne;
                    (ne = G.value) === null || ne === void 0 || ne.forcePopupAlign(), X.value = null
                })
            }
            var ee = function () {
                Z(), C.visible && Q()
            };
            return watch([function () {
                    return C.visible
                }, function () {
                    return C.title
                }], function () {
                    ee()
                }, {
                    flush: "post",
                    immediate: !0
                }), onActivated(function () {
                    ee()
                }), onBeforeUnmount(function () {
                    Z()
                }),
                function () {
                    return createVNode(Tooltip, _objectSpread2$1(_objectSpread2$1({
                        ref: G
                    }, C), W), U)
                }
        }
    });
var _excluded$g = ["value", "dragging", "index"],
    _excluded2$1 = ["tooltipPrefixCls", "range", "id"],
    defaultTipFormatter = function (C) {
        return typeof C == "number" ? C.toString() : ""
    },
    sliderProps = function () {
        return {
            id: String,
            prefixCls: String,
            tooltipPrefixCls: String,
            range: {
                type: [Boolean, Object],
                default: void 0
            },
            reverse: {
                type: Boolean,
                default: void 0
            },
            min: Number,
            max: Number,
            step: {
                type: [Number, Object]
            },
            marks: {
                type: Object
            },
            dots: {
                type: Boolean,
                default: void 0
            },
            value: {
                type: [Number, Array]
            },
            defaultValue: {
                type: [Number, Array]
            },
            included: {
                type: Boolean,
                default: void 0
            },
            disabled: {
                type: Boolean,
                default: void 0
            },
            vertical: {
                type: Boolean,
                default: void 0
            },
            tipFormatter: {
                type: [Function, Object],
                default: function () {
                    return defaultTipFormatter
                }
            },
            tooltipVisible: {
                type: Boolean,
                default: void 0
            },
            tooltipPlacement: {
                type: String
            },
            getTooltipPopupContainer: {
                type: Function
            },
            autofocus: {
                type: Boolean,
                default: void 0
            },
            handleStyle: {
                type: [Object, Array]
            },
            trackStyle: {
                type: [Object, Array]
            },
            onChange: {
                type: Function
            },
            onAfterChange: {
                type: Function
            },
            onFocus: {
                type: Function
            },
            onBlur: {
                type: Function
            },
            "onUpdate:value": {
                type: Function
            }
        }
    },
    Slider = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ASlider",
        inheritAttrs: !1,
        props: sliderProps(),
        slots: ["mark"],
        setup: function (C, H) {
            var W = H.attrs,
                U = H.slots,
                G = H.emit,
                X = H.expose,
                Z = useConfigInject("slider", C),
                Q = Z.prefixCls,
                ee = Z.rootPrefixCls,
                ne = Z.direction,
                te = Z.getPopupContainer,
                re = Z.configProvider,
                ae = useInjectFormItemContext(),
                oe = ref(),
                ie = ref({}),
                ue = function (me, he) {
                    ie.value[me] = he
                },
                le = computed(function () {
                    return C.tooltipPlacement ? C.tooltipPlacement : C.vertical ? ne.value === "rtl" ?
                        "left" : "right" : "top"
                }),
                se = function () {
                    var me;
                    (me = oe.value) === null || me === void 0 || me.focus()
                },
                ce = function () {
                    var me;
                    (me = oe.value) === null || me === void 0 || me.blur()
                },
                de = function (me) {
                    G("update:value", me), G("change", me), ae.onFieldChange()
                },
                ve = function (me) {
                    G("blur", me)
                };
            X({
                focus: se,
                blur: ce
            });
            var fe = function (me) {
                var he = me.tooltipPrefixCls,
                    Se = me.info,
                    _e = Se.value,
                    be = Se.dragging,
                    ge = Se.index,
                    xe = _objectWithoutProperties$2(Se, _excluded$g),
                    Pe = C.tipFormatter,
                    $e = C.tooltipVisible,
                    ye = C.getTooltipPopupContainer,
                    Ce = Pe ? ie.value[ge] || be : !1,
                    we = $e || $e === void 0 && Ce;
                return createVNode(SliderTooltip, {
                    prefixCls: he,
                    title: Pe ? Pe(_e) : "",
                    visible: we,
                    placement: le.value,
                    transitionName: "".concat(ee.value, "-zoom-down"),
                    key: ge,
                    overlayClassName: "".concat(Q.value, "-tooltip"),
                    getPopupContainer: ye || te.value
                }, {
                    default: function () {
                        return [createVNode(VcHandle, _objectSpread2$1(_objectSpread2$1({}, xe), {}, {
                            value: _e,
                            onMouseenter: function () {
                                return ue(ge, !0)
                            },
                            onMouseleave: function () {
                                return ue(ge, !1)
                            }
                        }), null)]
                    }
                })
            };
            return function () {
                var pe = C.tooltipPrefixCls,
                    me = C.range,
                    he = C.id,
                    Se = he === void 0 ? ae.id.value : he,
                    _e = _objectWithoutProperties$2(C, _excluded2$1),
                    be = re.getPrefixCls("tooltip", pe),
                    ge = classNames(W.class, _defineProperty$V({}, "".concat(Q.value, "-rtl"), ne.value ===
                        "rtl"));
                ne.value === "rtl" && !_e.vertical && (_e.reverse = !_e.reverse);
                var xe;
                return _typeof$2(me) === "object" && (xe = me.draggableTrack), me ? createVNode(VcRange,
                    _objectSpread2$1(_objectSpread2$1({}, _e), {}, {
                        step: _e.step,
                        draggableTrack: xe,
                        class: ge,
                        ref: oe,
                        handle: function ($e) {
                            return fe({
                                tooltipPrefixCls: be,
                                prefixCls: Q.value,
                                info: $e
                            })
                        },
                        prefixCls: Q.value,
                        onChange: de,
                        onBlur: ve
                    }), {
                        mark: U.mark
                    }) : createVNode(VcSlider, _objectSpread2$1(_objectSpread2$1({}, _e), {}, {
                    id: Se,
                    step: _e.step,
                    class: ge,
                    ref: oe,
                    handle: function ($e) {
                        return fe({
                            tooltipPrefixCls: be,
                            prefixCls: Q.value,
                            info: $e
                        })
                    },
                    prefixCls: Q.value,
                    onChange: de,
                    onBlur: ve
                }), {
                    mark: U.mark
                })
            }
        }
    });
const index$7 = withInstall(Slider);
var spaceSize = {
        small: 8,
        middle: 16,
        large: 24
    },
    spaceProps = function () {
        return {
            prefixCls: String,
            size: {
                type: [String, Number, Array]
            },
            direction: PropTypes$1.oneOf(tuple$1("horizontal", "vertical")).def("horizontal"),
            align: PropTypes$1.oneOf(tuple$1("start", "end", "center", "baseline")),
            wrap: {
                type: Boolean,
                default: void 0
            }
        }
    };

function getNumberSize(K) {
    return typeof K == "string" ? spaceSize[K] : K || 0
}
var Space = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ASpace",
    props: spaceProps(),
    slots: ["split"],
    setup: function (C, H) {
        var W = H.slots,
            U = useConfigInject("space", C),
            G = U.prefixCls,
            X = U.space,
            Z = U.direction,
            Q = useFlexGapSupport(),
            ee = computed(function () {
                var ue, le, se;
                return (ue = (le = C.size) !== null && le !== void 0 ? le : (se = X.value) === null ||
                    se === void 0 ? void 0 : se.size) !== null && ue !== void 0 ? ue : "small"
            }),
            ne = ref(),
            te = ref();
        watch(ee, function () {
            var ue = (Array.isArray(ee.value) ? ee.value : [ee.value, ee.value]).map(function (se) {
                    return getNumberSize(se)
                }),
                le = _slicedToArray$2(ue, 2);
            ne.value = le[0], te.value = le[1]
        }, {
            immediate: !0
        });
        var re = computed(function () {
                return C.align === void 0 && C.direction === "horizontal" ? "center" : C.align
            }),
            ae = computed(function () {
                var ue;
                return classNames(G.value, "".concat(G.value, "-").concat(C.direction), (ue = {},
                    _defineProperty$V(ue, "".concat(G.value, "-rtl"), Z.value === "rtl"),
                    _defineProperty$V(ue, "".concat(G.value, "-align-").concat(re.value), re.value),
                    ue))
            }),
            oe = computed(function () {
                return Z.value === "rtl" ? "marginLeft" : "marginRight"
            }),
            ie = computed(function () {
                var ue = {};
                return Q.value && (ue.columnGap = "".concat(ne.value, "px"), ue.rowGap = "".concat(te.value,
                    "px")), _objectSpread2$1(_objectSpread2$1({}, ue), C.wrap && {
                    flexWrap: "wrap",
                    marginBottom: "".concat(-te.value, "px")
                })
            });
        return function () {
            var ue, le, se = C.wrap,
                ce = C.direction,
                de = ce === void 0 ? "horizontal" : ce,
                ve = filterEmpty((ue = W.default) === null || ue === void 0 ? void 0 : ue.call(W)),
                fe = ve.length;
            if (fe === 0) return null;
            var pe = (le = W.split) === null || le === void 0 ? void 0 : le.call(W),
                me = "".concat(G.value, "-item"),
                he = ne.value,
                Se = fe - 1;
            return createVNode("div", {
                class: ae.value,
                style: ie.value
            }, [ve.map(function (_e, be) {
                var ge = {};
                return Q.value || (de === "vertical" ? be < Se && (ge = {
                    marginBottom: "".concat(he / (pe ? 2 : 1), "px")
                }) : ge = _objectSpread2$1(_objectSpread2$1({}, be < Se &&
                    _defineProperty$V({}, oe.value, "".concat(he / (pe ? 2 :
                        1), "px"))), se && {
                    paddingBottom: "".concat(te.value, "px")
                })), createVNode(Fragment, null, [createVNode("div", {
                    class: me,
                    style: ge
                }, [_e]), be < Se && pe && createVNode("span", {
                    class: "".concat(me, "-split"),
                    style: ge
                }, [pe])])
            })])
        }
    }
});
const index$6 = withInstall(Space);
var _excluded$f = ["prefixCls"];
const Steps$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Steps",
    props: {
        type: PropTypes$1.string.def("default"),
        prefixCls: PropTypes$1.string.def("vc-steps"),
        iconPrefix: PropTypes$1.string.def("vc"),
        direction: PropTypes$1.string.def("horizontal"),
        labelPlacement: PropTypes$1.string.def("horizontal"),
        status: PropTypes$1.string.def("process"),
        size: PropTypes$1.string.def(""),
        progressDot: PropTypes$1.oneOfType([PropTypes$1.looseBool, PropTypes$1.func]).def(void 0),
        initial: PropTypes$1.number.def(0),
        current: PropTypes$1.number.def(0),
        icons: PropTypes$1.shape({
            finish: PropTypes$1.any,
            error: PropTypes$1.any
        }).loose,
        stepIcon: Function
    },
    slots: ["stepIcon", "progressDot"],
    emits: ["change"],
    setup: function (C, H) {
        var W = H.slots,
            U = H.emit,
            G = function (Z) {
                var Q = C.current;
                Q !== Z && U("change", Z)
            };
        return function () {
            var X, Z, Q = C.prefixCls,
                ee = C.direction,
                ne = C.type,
                te = C.labelPlacement,
                re = C.iconPrefix,
                ae = C.status,
                oe = C.size,
                ie = C.current,
                ue = C.progressDot,
                le = ue === void 0 ? W.progressDot : ue,
                se = C.initial,
                ce = C.icons,
                de = C.stepIcon,
                ve = de === void 0 ? W.stepIcon : de,
                fe = ne === "navigation",
                pe = le ? "vertical" : te,
                me = classNames(Q, "".concat(Q, "-").concat(ee), (X = {}, _defineProperty$V(X, "".concat(
                        Q, "-").concat(oe), oe), _defineProperty$V(X, "".concat(Q, "-label-").concat(
                        pe), ee === "horizontal"), _defineProperty$V(X, "".concat(Q, "-dot"), !!le),
                    _defineProperty$V(X, "".concat(Q, "-navigation"), fe), X)),
                he = filterEmpty((Z = W.default) === null || Z === void 0 ? void 0 : Z.call(W));
            return createVNode("div", {
                class: me
            }, [he.map(function (Se, _e) {
                var be = Se.props || {},
                    ge = be.prefixCls,
                    xe = ge === void 0 ? Q : ge,
                    Pe = _objectWithoutProperties$2(be, _excluded$f),
                    $e = se + _e,
                    ye = _objectSpread2$1(_objectSpread2$1({}, Pe), {}, {
                        stepNumber: $e + 1,
                        stepIndex: $e,
                        key: $e,
                        prefixCls: xe,
                        iconPrefix: re,
                        progressDot: le,
                        icons: ce,
                        stepIcon: ve,
                        onStepClick: G
                    });
                return ae === "error" && _e === ie - 1 && (ye.class = "".concat(Q,
                        "-next-error")), Pe.status || ($e === ie ? ye.status = ae : $e <
                        ie ? ye.status = "finish" : ye.status = "wait"), ye.active = $e ===
                    ie, cloneElement(Se, ye)
            })])
        }
    }
});

function isString$1(K) {
    return typeof K == "string"
}

function noop$4() {}
var VcStepProps = function () {
    return {
        prefixCls: String,
        wrapperStyle: {
            type: Object,
            default: void 0
        },
        itemWidth: String,
        active: {
            type: Boolean,
            default: void 0
        },
        disabled: {
            type: Boolean,
            default: void 0
        },
        status: String,
        iconPrefix: String,
        icon: PropTypes$1.any,
        adjustMarginRight: String,
        stepNumber: Number,
        stepIndex: Number,
        description: PropTypes$1.any,
        title: PropTypes$1.any,
        subTitle: PropTypes$1.any,
        progressDot: withUndefined(PropTypes$1.oneOfType([PropTypes$1.looseBool, PropTypes$1.func])),
        tailContent: PropTypes$1.any,
        icons: PropTypes$1.shape({
            finish: PropTypes$1.any,
            error: PropTypes$1.any
        }).loose,
        onClick: Function,
        onStepClick: Function,
        stepIcon: Function
    }
};
const VcStep = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Step",
    props: VcStepProps(),
    slots: ["title", "subTitle", "description", "tailContent", "stepIcon", "progressDot"],
    emits: ["click", "stepClick"],
    setup: function (C, H) {
        var W = H.slots,
            U = H.emit,
            G = function (Q) {
                U("click", Q), U("stepClick", C.stepIndex)
            },
            X = function (Q) {
                var ee, ne = Q.icon,
                    te = Q.title,
                    re = Q.description,
                    ae = C.prefixCls,
                    oe = C.stepNumber,
                    ie = C.status,
                    ue = C.iconPrefix,
                    le = C.icons,
                    se = C.progressDot,
                    ce = se === void 0 ? W.progressDot : se,
                    de = C.stepIcon,
                    ve = de === void 0 ? W.stepIcon : de,
                    fe, pe = (ee = {}, _defineProperty$V(ee, "".concat(ae, "-icon"), !0), _defineProperty$V(
                        ee, "".concat(ue, "icon"), !0), _defineProperty$V(ee, "".concat(ue, "icon-").concat(
                        ne), ne && isString$1(ne)), _defineProperty$V(ee, "".concat(ue, "icon-check"),
                        !ne && ie === "finish" && le && !le.finish), _defineProperty$V(ee, "".concat(ue,
                        "icon-close"), !ne && ie === "error" && le && !le.error), ee),
                    me = createVNode("span", {
                        class: "".concat(ae, "-icon-dot")
                    }, null);
                return ce ? typeof ce == "function" ? fe = createVNode("span", {
                    class: "".concat(ae, "-icon")
                }, [ce({
                    iconDot: me,
                    index: oe - 1,
                    status: ie,
                    title: te,
                    description: re,
                    prefixCls: ae
                })]) : fe = createVNode("span", {
                    class: "".concat(ae, "-icon")
                }, [me]) : ne && !isString$1(ne) ? fe = createVNode("span", {
                    class: "".concat(ae, "-icon")
                }, [ne]) : le && le.finish && ie === "finish" ? fe = createVNode("span", {
                    class: "".concat(ae, "-icon")
                }, [le.finish]) : le && le.error && ie === "error" ? fe = createVNode("span", {
                    class: "".concat(ae, "-icon")
                }, [le.error]) : ne || ie === "finish" || ie === "error" ? fe = createVNode("span", {
                    class: pe
                }, null) : fe = createVNode("span", {
                    class: "".concat(ae, "-icon")
                }, [oe]), ve && (fe = ve({
                    index: oe - 1,
                    status: ie,
                    title: te,
                    description: re,
                    node: fe
                })), fe
            };
        return function () {
            var Z, Q, ee, ne, te, re = C.prefixCls,
                ae = C.itemWidth,
                oe = C.active,
                ie = C.status,
                ue = ie === void 0 ? "wait" : ie,
                le = C.tailContent,
                se = C.adjustMarginRight,
                ce = C.disabled,
                de = C.title,
                ve = de === void 0 ? (Z = W.title) === null || Z === void 0 ? void 0 : Z.call(W) : de,
                fe = C.description,
                pe = fe === void 0 ? (Q = W.description) === null || Q === void 0 ? void 0 : Q.call(W) :
                fe,
                me = C.subTitle,
                he = me === void 0 ? (ee = W.subTitle) === null || ee === void 0 ? void 0 : ee.call(W) :
                me,
                Se = C.icon,
                _e = Se === void 0 ? (ne = W.icon) === null || ne === void 0 ? void 0 : ne.call(W) : Se,
                be = C.onClick,
                ge = C.onStepClick,
                xe = (te = {}, _defineProperty$V(te, "".concat(re, "-item"), !0), _defineProperty$V(te,
                        "".concat(re, "-item-").concat(ue), !0), _defineProperty$V(te, "".concat(re,
                        "-item-custom"), _e), _defineProperty$V(te, "".concat(re, "-item-active"), oe),
                    _defineProperty$V(te, "".concat(re, "-item-disabled"), ce === !0), te),
                Pe = {
                    class: xe
                },
                $e = {};
            ae && ($e.width = ae), se && ($e.marginRight = se);
            var ye = {
                onClick: be || noop$4
            };
            return ge && !ce && (ye.role = "button", ye.tabindex = 0, ye.onClick = G), createVNode(
                "div", _objectSpread2$1(_objectSpread2$1({}, Pe), {}, {
                    style: $e
                }), [createVNode("div", _objectSpread2$1(_objectSpread2$1({}, ye), {}, {
                    class: "".concat(re, "-item-container")
                }), [createVNode("div", {
                    class: "".concat(re, "-item-tail")
                }, [le]), createVNode("div", {
                    class: "".concat(re, "-item-icon")
                }, [X({
                    icon: _e,
                    title: ve,
                    description: pe
                })]), createVNode("div", {
                    class: "".concat(re, "-item-content")
                }, [createVNode("div", {
                    class: "".concat(re, "-item-title")
                }, [ve, he && createVNode("div", {
                    title: he,
                    class: "".concat(re, "-item-subtitle")
                }, [he])]), pe && createVNode("div", {
                    class: "".concat(re, "-item-description")
                }, [pe])])])])
        }
    }
});
var stepsProps = function () {
        return {
            prefixCls: String,
            iconPrefix: String,
            current: Number,
            initial: Number,
            percent: Number,
            responsive: {
                type: Boolean,
                default: void 0
            },
            labelPlacement: String,
            status: String,
            size: String,
            direction: String,
            progressDot: {
                type: [Boolean, Function],
                default: void 0
            },
            type: String,
            onChange: Function,
            "onUpdate:current": Function
        }
    },
    Steps = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ASteps",
        inheritAttrs: !1,
        props: initDefaultProps$1(stepsProps(), {
            current: 0,
            responsive: !0,
            labelPlacement: "horizontal"
        }),
        slots: ["progressDot"],
        setup: function (C, H) {
            var W = H.attrs,
                U = H.slots,
                G = H.emit,
                X = useConfigInject("steps", C),
                Z = X.prefixCls,
                Q = X.direction,
                ee = X.configProvider,
                ne = useBreakpoint(),
                te = computed(function () {
                    return C.responsive && ne.value.xs ? "vertical" : C.direction
                }),
                re = computed(function () {
                    return ee.getPrefixCls("", C.iconPrefix)
                }),
                ae = function (ue) {
                    G("update:current", ue), G("change", ue)
                },
                oe = function (ue) {
                    var le = ue.node,
                        se = ue.status;
                    if (se === "process" && C.percent !== void 0) {
                        var ce = C.size === "small" ? 32 : 40,
                            de = createVNode("div", {
                                class: "".concat(Z, "-progress-icon")
                            }, [createVNode(Progress, {
                                type: "circle",
                                percent: C.percent,
                                width: ce,
                                strokeWidth: 4,
                                format: function () {
                                    return null
                                }
                            }, null), le]);
                        return de
                    }
                    return le
                };
            return function () {
                var ie, ue = classNames((ie = {}, _defineProperty$V(ie, "".concat(Z.value, "-rtl"), Q.value ===
                        "rtl"), _defineProperty$V(ie, "".concat(Z.value, "-with-progress"), C.percent !==
                        void 0), ie), W.class),
                    le = {
                        finish: createVNode(CheckOutlined$1, {
                            class: "".concat(Z, "-finish-icon")
                        }, null),
                        error: createVNode(CloseOutlined$1, {
                            class: "".concat(Z, "-error-icon")
                        }, null)
                    };
                return createVNode(Steps$1, _objectSpread2$1(_objectSpread2$1({
                    icons: le
                }, omit$2(C, ["percent", "responsive"])), {}, {
                    direction: te.value,
                    prefixCls: Z.value,
                    iconPrefix: re.value,
                    class: ue,
                    onChange: ae
                }), _objectSpread2$1(_objectSpread2$1({}, U), {}, {
                    stepIcon: oe
                }))
            }
        }
    }),
    Step = defineComponent(_objectSpread2$1(_objectSpread2$1({
        compatConfig: {
            MODE: 3
        }
    }, VcStep), {}, {
        name: "AStep",
        props: VcStepProps()
    }));
const index$5 = _extends$1(Steps, {
    Step,
    install: function (C) {
        return C.component(Steps.name, Steps), C.component(Step.name, Step), C
    }
});
var SwitchSizes = tuple$1("small", "default"),
    switchProps = function () {
        return {
            id: String,
            prefixCls: String,
            size: PropTypes$1.oneOf(SwitchSizes),
            disabled: {
                type: Boolean,
                default: void 0
            },
            checkedChildren: PropTypes$1.any,
            unCheckedChildren: PropTypes$1.any,
            tabindex: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number]),
            autofocus: {
                type: Boolean,
                default: void 0
            },
            loading: {
                type: Boolean,
                default: void 0
            },
            checked: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number, PropTypes$1.looseBool]),
            checkedValue: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number, PropTypes$1.looseBool]).def(!0),
            unCheckedValue: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number, PropTypes$1.looseBool]).def(
                !1),
            onChange: {
                type: Function
            },
            onClick: {
                type: Function
            },
            onKeydown: {
                type: Function
            },
            onMouseup: {
                type: Function
            },
            "onUpdate:checked": {
                type: Function
            },
            onBlur: Function,
            onFocus: Function
        }
    },
    Switch = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ASwitch",
        __ANT_SWITCH: !0,
        inheritAttrs: !1,
        props: switchProps(),
        slots: ["checkedChildren", "unCheckedChildren"],
        setup: function (C, H) {
            var W = H.attrs,
                U = H.slots,
                G = H.expose,
                X = H.emit,
                Z = useInjectFormItemContext();
            onBeforeMount(function () {
                warning$2(!("defaultChecked" in W), "Switch",
                    "'defaultChecked' is deprecated, please use 'v-model:checked'"), warning$2(!(
                        "value" in W), "Switch",
                    "`value` is not validate prop, do you mean `checked`?")
            });
            var Q = ref(C.checked !== void 0 ? C.checked : W.defaultChecked),
                ee = computed(function () {
                    return Q.value === C.checkedValue
                });
            watch(function () {
                return C.checked
            }, function () {
                Q.value = C.checked
            });
            var ne = useConfigInject("switch", C),
                te = ne.prefixCls,
                re = ne.direction,
                ae = ne.size,
                oe = ref(),
                ie = function () {
                    var me;
                    (me = oe.value) === null || me === void 0 || me.focus()
                },
                ue = function () {
                    var me;
                    (me = oe.value) === null || me === void 0 || me.blur()
                };
            G({
                focus: ie,
                blur: ue
            }), onMounted(function () {
                nextTick(function () {
                    C.autofocus && !C.disabled && oe.value.focus()
                })
            });
            var le = function (me, he) {
                    C.disabled || (X("update:checked", me), X("change", me, he), Z.onFieldChange())
                },
                se = function (me) {
                    X("blur", me)
                },
                ce = function (me) {
                    ie();
                    var he = ee.value ? C.unCheckedValue : C.checkedValue;
                    le(he, me), X("click", he, me)
                },
                de = function (me) {
                    me.keyCode === KeyCode$1.LEFT ? le(C.unCheckedValue, me) : me.keyCode === KeyCode$1.RIGHT &&
                        le(C.checkedValue, me), X("keydown", me)
                },
                ve = function (me) {
                    var he;
                    (he = oe.value) === null || he === void 0 || he.blur(), X("mouseup", me)
                },
                fe = computed(function () {
                    var pe;
                    return pe = {}, _defineProperty$V(pe, "".concat(te.value, "-small"), ae.value ===
                            "small"), _defineProperty$V(pe, "".concat(te.value, "-loading"), C.loading),
                        _defineProperty$V(pe, "".concat(te.value, "-checked"), ee.value), _defineProperty$V(
                            pe, "".concat(te.value, "-disabled"), C.disabled), _defineProperty$V(pe, te.value,
                            !0), _defineProperty$V(pe, "".concat(te.value, "-rtl"), re.value === "rtl"), pe
                });
            return function () {
                var pe;
                return createVNode(Wave, {
                    insertExtraNode: !0
                }, {
                    default: function () {
                        return [createVNode("button", _objectSpread2$1(_objectSpread2$1(
                            _objectSpread2$1({}, omit$2(C, ["prefixCls",
                                "checkedChildren", "unCheckedChildren",
                                "checked", "autofocus", "checkedValue",
                                "unCheckedValue", "id", "onChange",
                                "onUpdate:checked"])), W), {}, {
                            id: (pe = C.id) !== null && pe !== void 0 ? pe : Z.id
                                .value,
                            onKeydown: de,
                            onClick: ce,
                            onBlur: se,
                            onMouseup: ve,
                            type: "button",
                            role: "switch",
                            "aria-checked": Q.value,
                            disabled: C.disabled || C.loading,
                            class: [W.class, fe.value],
                            ref: oe
                        }), [createVNode("div", {
                            class: "".concat(te.value, "-handle")
                        }, [C.loading ? createVNode(LoadingOutlined$1, {
                            class: "".concat(te.value,
                                "-loading-icon")
                        }, null) : null]), createVNode("span", {
                            class: "".concat(te.value, "-inner")
                        }, [ee.value ? getPropsSlot(U, C, "checkedChildren") :
                            getPropsSlot(U, C, "unCheckedChildren")])])]
                    }
                })
            }
        }
    });
const index$4 = withInstall(Switch);
var TableContextKey = Symbol("TableContextProps"),
    useProvideTable = function (C) {
        provide(TableContextKey, C)
    },
    useInjectTable = function () {
        return inject(TableContextKey, {})
    },
    INTERNAL_KEY_PREFIX = "RC_TABLE_KEY";

function toArray$2(K) {
    return K == null ? [] : Array.isArray(K) ? K : [K]
}

function getPathValue(K, C) {
    if (!C && typeof C != "number") return K;
    for (var H = toArray$2(C), W = K, U = 0; U < H.length; U += 1) {
        if (!W) return null;
        var G = H[U];
        W = W[G]
    }
    return W
}

function getColumnsKey(K) {
    var C = [],
        H = {};
    return K.forEach(function (W) {
        for (var U = W || {}, G = U.key, X = U.dataIndex, Z = G || toArray$2(X).join("-") ||
                INTERNAL_KEY_PREFIX; H[Z];) Z = "".concat(Z, "_next");
        H[Z] = !0, C.push(Z)
    }), C
}

function mergeObject() {
    var K = {};

    function C(G, X) {
        X && Object.keys(X).forEach(function (Z) {
            var Q = X[Z];
            Q && _typeof$2(Q) === "object" ? (G[Z] = G[Z] || {}, C(G[Z], Q)) : G[Z] = Q
        })
    }
    for (var H = arguments.length, W = new Array(H), U = 0; U < H; U++) W[U] = arguments[U];
    return W.forEach(function (G) {
        C(K, G)
    }), K
}

function validateValue(K) {
    return K != null
}
var SlotsContextKey = Symbol("SlotsContextProps"),
    useProvideSlots = function (C) {
        provide(SlotsContextKey, C)
    },
    useInjectSlots = function () {
        return inject(SlotsContextKey, computed(function () {
            return {}
        }))
    },
    ContextKey = Symbol("ContextProps"),
    useProvideTableContext = function (C) {
        provide(ContextKey, C)
    },
    useInjectTableContext = function () {
        return inject(ContextKey, {
            onResizeColumn: function () {}
        })
    },
    INTERNAL_COL_DEFINE = "RC_TABLE_INTERNAL_COL_DEFINE",
    HoverContextKey = Symbol("HoverContextProps"),
    useProvideHover = function (C) {
        provide(HoverContextKey, C)
    },
    useInjectHover = function () {
        return inject(HoverContextKey, {
            startRow: ref(-1),
            endRow: ref(-1),
            onHover: function () {}
        })
    },
    supportSticky = ref(!1),
    useProvideSticky = function () {
        onMounted(function () {
            supportSticky.value = supportSticky.value || isStyleSupport("position", "sticky")
        })
    },
    useInjectSticky = function () {
        return supportSticky
    },
    _excluded$e = ["colSpan", "rowSpan", "style", "class"];

function inHoverRange(K, C, H, W) {
    var U = K + C - 1;
    return K <= W && U >= H
}

function isRenderCell(K) {
    return K && _typeof$2(K) === "object" && !Array.isArray(K) && !isVNode(K)
}
const Cell = defineComponent({
    name: "Cell",
    props: ["prefixCls", "record", "index", "renderIndex", "dataIndex", "customRender", "component", "colSpan",
        "rowSpan", "fixLeft", "fixRight", "firstFixLeft", "lastFixLeft", "firstFixRight", "lastFixRight",
        "appendNode", "additionalProps", "ellipsis", "align", "rowType", "isSticky", "column", "cellType",
        "transformCellText"],
    slots: ["appendNode"],
    setup: function (C, H) {
        var W = H.slots,
            U = useInjectSlots(),
            G = useInjectHover(),
            X = G.onHover,
            Z = G.startRow,
            Q = G.endRow,
            ee = computed(function () {
                var ue, le, se, ce;
                return (ue = (le = C.colSpan) !== null && le !== void 0 ? le : (se = C.additionalProps) ===
                    null || se === void 0 ? void 0 : se.colSpan) !== null && ue !== void 0 ? ue : (
                    ce = C.additionalProps) === null || ce === void 0 ? void 0 : ce.colspan
            }),
            ne = computed(function () {
                var ue, le, se, ce;
                return (ue = (le = C.rowSpan) !== null && le !== void 0 ? le : (se = C.additionalProps) ===
                    null || se === void 0 ? void 0 : se.rowSpan) !== null && ue !== void 0 ? ue : (
                    ce = C.additionalProps) === null || ce === void 0 ? void 0 : ce.rowspan
            }),
            te = eagerComputed(function () {
                var ue = C.index;
                return inHoverRange(ue, ne.value || 1, Z.value, Q.value)
            }),
            re = useInjectSticky(),
            ae = function (le, se) {
                var ce, de = C.record,
                    ve = C.index,
                    fe = C.additionalProps;
                de && X(ve, ve + se - 1), fe == null || (ce = fe.onMouseenter) === null || ce === void 0 ||
                    ce.call(fe, le)
            },
            oe = function (le) {
                var se, ce = C.record,
                    de = C.additionalProps;
                ce && X(-1, -1), de == null || (se = de.onMouseleave) === null || se === void 0 || se.call(
                    de, le)
            },
            ie = function ue(le) {
                var se = filterEmpty(le)[0];
                return isVNode(se) ? se.type === Text$2 ? se.children : Array.isArray(se.children) ? ue(se.children) :
                    void 0 : se
            };
        return function () {
            var ue, le, se, ce, de, ve, fe = C.prefixCls,
                pe = C.record,
                me = C.index,
                he = C.renderIndex,
                Se = C.dataIndex,
                _e = C.customRender,
                be = C.component,
                ge = be === void 0 ? "td" : be,
                xe = C.fixLeft,
                Pe = C.fixRight,
                $e = C.firstFixLeft,
                ye = C.lastFixLeft,
                Ce = C.firstFixRight,
                we = C.lastFixRight,
                Oe = C.appendNode,
                Ne = Oe === void 0 ? (ue = W.appendNode) === null || ue === void 0 ? void 0 : ue.call(W) :
                Oe,
                Me = C.additionalProps,
                Ve = Me === void 0 ? {} : Me,
                ke = C.ellipsis,
                Ee = C.align,
                Ae = C.rowType,
                Re = C.isSticky,
                He = C.column,
                je = He === void 0 ? {} : He,
                Fe = C.cellType,
                Le = "".concat(fe, "-cell"),
                Ie, Te, De = (le = W.default) === null || le === void 0 ? void 0 : le.call(W);
            if (validateValue(De) || Fe === "header") Te = De;
            else {
                var Ke, We = getPathValue(pe, Se);
                if (Te = We, _e) {
                    var Ue = _e({
                        text: We,
                        value: We,
                        record: pe,
                        index: me,
                        renderIndex: he,
                        column: je.__originColumn__
                    });
                    isRenderCell(Ue) ? (Te = Ue.children, Ie = Ue.props) : Te = Ue
                }
                if (!(INTERNAL_COL_DEFINE in je) && Fe === "body" && U.value.bodyCell && !((Ke = je.slots) !==
                        null && Ke !== void 0 && Ke.customRender)) {
                    var et = renderSlot(U.value, "bodyCell", {
                        text: We,
                        value: We,
                        record: pe,
                        index: me,
                        column: je.__originColumn__
                    }, function () {
                        var Je = Te === void 0 ? We : Te;
                        return [_typeof$2(Je) === "object" && isValidElement(Je) || _typeof$2(
                            Je) !== "object" ? Je : null]
                    });
                    Te = flattenChildren(et)
                }
                C.transformCellText && (Te = C.transformCellText({
                    text: Te,
                    record: pe,
                    index: me,
                    column: je.__originColumn__
                }))
            }
            _typeof$2(Te) === "object" && !Array.isArray(Te) && !isVNode(Te) && (Te = null), ke && (ye ||
                Ce) && (Te = createVNode("span", {
                class: "".concat(Le, "-content")
            }, [Te])), Array.isArray(Te) && Te.length === 1 && (Te = Te[0]);
            var Ye = Ie || {},
                ze = Ye.colSpan,
                Be = Ye.rowSpan,
                Ge = Ye.style,
                Xe = Ye.class,
                nt = _objectWithoutProperties$2(Ye, _excluded$e),
                it = (se = ze !== void 0 ? ze : ee.value) !== null && se !== void 0 ? se : 1,
                ft = (ce = Be !== void 0 ? Be : ne.value) !== null && ce !== void 0 ? ce : 1;
            if (it === 0 || ft === 0) return null;
            var pt = {},
                ot = typeof xe == "number" && re.value,
                Ze = typeof Pe == "number" && re.value;
            ot && (pt.position = "sticky", pt.left = "".concat(xe, "px")), Ze && (pt.position =
                "sticky", pt.right = "".concat(Pe, "px"));
            var ut = {};
            Ee && (ut.textAlign = Ee);
            var st, rt = ke === !0 ? {
                showTitle: !0
            } : ke;
            rt && (rt.showTitle || Ae === "header") && (typeof Te == "string" || typeof Te == "number" ?
                st = Te.toString() : isVNode(Te) && (st = ie([Te])));
            var qe = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                title: st
            }, nt), Ve), {}, {
                colSpan: it !== 1 ? it : null,
                rowSpan: ft !== 1 ? ft : null,
                class: classNames(Le, (de = {}, _defineProperty$V(de, "".concat(Le, "-fix-left"),
                        ot && re.value), _defineProperty$V(de, "".concat(Le,
                        "-fix-left-first"), $e && re.value), _defineProperty$V(de, "".concat(
                        Le, "-fix-left-last"), ye && re.value), _defineProperty$V(de,
                        "".concat(Le, "-fix-right"), Ze && re.value), _defineProperty$V(
                        de, "".concat(Le, "-fix-right-first"), Ce && re.value),
                    _defineProperty$V(de, "".concat(Le, "-fix-right-last"), we && re.value),
                    _defineProperty$V(de, "".concat(Le, "-ellipsis"), ke),
                    _defineProperty$V(de, "".concat(Le, "-with-append"), Ne),
                    _defineProperty$V(de, "".concat(Le, "-fix-sticky"), (ot || Ze) &&
                        Re && re.value), _defineProperty$V(de, "".concat(Le,
                        "-row-hover"), !Ie && te.value), de), Ve.class, Xe),
                onMouseenter: function (Qe) {
                    ae(Qe, ft)
                },
                onMouseleave: oe,
                style: _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({},
                    parseStyleText(Ve.style)), ut), pt), Ge)
            });
            return createVNode(ge, qe, {
                default: function () {
                    return [Ne, Te, (ve = W.dragHandle) === null || ve === void 0 ? void 0 :
                        ve.call(W)]
                }
            })
        }
    }
});

function getCellFixedInfo(K, C, H, W, U) {
    var G = H[K] || {},
        X = H[C] || {},
        Z, Q;
    G.fixed === "left" ? Z = W.left[K] : X.fixed === "right" && (Q = W.right[C]);
    var ee = !1,
        ne = !1,
        te = !1,
        re = !1,
        ae = H[C + 1],
        oe = H[K - 1];
    if (U === "rtl") {
        if (Z !== void 0) {
            var ie = oe && oe.fixed === "left";
            re = !ie
        } else if (Q !== void 0) {
            var ue = ae && ae.fixed === "right";
            te = !ue
        }
    } else if (Z !== void 0) {
        var le = ae && ae.fixed === "left";
        ee = !le
    } else if (Q !== void 0) {
        var se = oe && oe.fixed === "right";
        ne = !se
    }
    return {
        fixLeft: Z,
        fixRight: Q,
        lastFixLeft: ee,
        firstFixRight: ne,
        lastFixRight: te,
        firstFixLeft: re,
        isSticky: W.isSticky
    }
}
var events = {
        mouse: {
            start: "mousedown",
            move: "mousemove",
            stop: "mouseup"
        },
        touch: {
            start: "touchstart",
            move: "touchmove",
            stop: "touchend"
        }
    },
    defaultMinWidth = 50;
const DragHandleVue = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "DragHandle",
        props: {
            prefixCls: String,
            width: {
                type: Number,
                required: !0
            },
            minWidth: {
                type: Number,
                default: defaultMinWidth
            },
            maxWidth: {
                type: Number,
                default: 1 / 0
            },
            column: {
                type: Object,
                default: void 0
            }
        },
        setup: function (C) {
            var H = 0,
                W = {
                    remove: function () {}
                },
                U = {
                    remove: function () {}
                },
                G = function () {
                    W.remove(), U.remove()
                };
            onUnmounted(function () {
                G()
            }), watchEffect(function () {
                devWarning(!isNaN(C.width), "Table", "width must be a number when use resizable")
            });
            var X = useInjectTableContext(),
                Z = X.onResizeColumn,
                Q = computed(function () {
                    return typeof C.minWidth == "number" && !isNaN(C.minWidth) ? C.minWidth :
                        defaultMinWidth
                }),
                ee = computed(function () {
                    return typeof C.maxWidth == "number" && !isNaN(C.maxWidth) ? C.maxWidth : 1 / 0
                }),
                ne = getCurrentInstance(),
                te = 0,
                re = ref(!1),
                ae, oe = function (fe) {
                    var pe = 0;
                    fe.touches ? fe.touches.length ? pe = fe.touches[0].pageX : pe = fe.changedTouches[0].pageX :
                        pe = fe.pageX;
                    var me = H - pe,
                        he = Math.max(te - me, Q.value);
                    he = Math.min(he, ee.value), wrapperRaf.cancel(ae), ae = wrapperRaf(function () {
                        Z(he, C.column.__originColumn__)
                    })
                },
                ie = function (fe) {
                    oe(fe)
                },
                ue = function (fe) {
                    re.value = !1, oe(fe), G()
                },
                le = function (fe, pe) {
                    re.value = !0, G(), te = ne.vnode.el.parentNode.getBoundingClientRect().width, !(fe instanceof MouseEvent &&
                        fe.which !== 1) && (fe.stopPropagation && fe.stopPropagation(), H = fe.touches ? fe
                        .touches[0].pageX : fe.pageX, W = addEventListenerWrap(document.documentElement, pe
                            .move, ie), U = addEventListenerWrap(document.documentElement, pe.stop, ue))
                },
                se = function (fe) {
                    fe.stopPropagation(), fe.preventDefault(), le(fe, events.mouse)
                },
                ce = function (fe) {
                    fe.stopPropagation(), fe.preventDefault(), le(fe, events.touch)
                },
                de = function (fe) {
                    fe.stopPropagation(), fe.preventDefault()
                };
            return function () {
                var ve = C.prefixCls,
                    fe = _defineProperty$V({}, supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart",
                        function (pe) {
                            return ce(pe)
                        });
                return createVNode("div", _objectSpread2$1(_objectSpread2$1({
                    class: "".concat(ve, "-resize-handle ").concat(re.value ? "dragging" :
                        ""),
                    onMousedown: se
                }, fe), {}, {
                    onClick: de
                }), [createVNode("div", {
                    class: "".concat(ve, "-resize-handle-line")
                }, null)])
            }
        }
    }),
    HeaderRow = defineComponent({
        name: "HeaderRow",
        props: ["cells", "stickyOffsets", "flattenColumns", "rowComponent", "cellComponent", "index",
            "customHeaderRow"],
        setup: function (C) {
            var H = useInjectTable();
            return function () {
                var W = H.prefixCls,
                    U = H.direction,
                    G = C.cells,
                    X = C.stickyOffsets,
                    Z = C.flattenColumns,
                    Q = C.rowComponent,
                    ee = C.cellComponent,
                    ne = C.customHeaderRow,
                    te = C.index,
                    re;
                ne && (re = ne(G.map(function (oe) {
                    return oe.column
                }), te));
                var ae = getColumnsKey(G.map(function (oe) {
                    return oe.column
                }));
                return createVNode(Q, re, {
                    default: function () {
                        return [G.map(function (ie, ue) {
                            var le = ie.column,
                                se = getCellFixedInfo(ie.colStart, ie.colEnd, Z, X,
                                    U),
                                ce;
                            le && le.customHeaderCell && (ce = ie.column.customHeaderCell(
                                le));
                            var de = le;
                            return createVNode(Cell, _objectSpread2$1(
                                _objectSpread2$1(_objectSpread2$1({}, ie), {}, {
                                    cellType: "header",
                                    ellipsis: le.ellipsis,
                                    align: le.align,
                                    component: ee,
                                    prefixCls: W,
                                    key: ae[ue]
                                }, se), {}, {
                                    additionalProps: ce,
                                    rowType: "header",
                                    column: le
                                }), {
                                default: function () {
                                    return le.title
                                },
                                dragHandle: function () {
                                    return de.resizable ? createVNode(
                                        DragHandleVue, {
                                            prefixCls: W,
                                            width: de.width,
                                            minWidth: de.minWidth,
                                            maxWidth: de.maxWidth,
                                            column: de
                                        }, null) : null
                                }
                            })
                        })]
                    }
                })
            }
        }
    });

function parseHeaderRows(K) {
    var C = [];

    function H(X, Z) {
        var Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        C[Q] = C[Q] || [];
        var ee = Z,
            ne = X.filter(Boolean).map(function (te) {
                var re = {
                        key: te.key,
                        class: classNames(te.className, te.class),
                        column: te,
                        colStart: ee
                    },
                    ae = 1,
                    oe = te.children;
                return oe && oe.length > 0 && (ae = H(oe, ee, Q + 1).reduce(function (ie, ue) {
                    return ie + ue
                }, 0), re.hasSubColumns = !0), "colSpan" in te && (ae = te.colSpan), "rowSpan" in te && (re.rowSpan =
                    te.rowSpan), re.colSpan = ae, re.colEnd = re.colStart + ae - 1, C[Q].push(re), ee += ae, ae
            });
        return ne
    }
    H(K, 0);
    for (var W = C.length, U = function (Z) {
            C[Z].forEach(function (Q) {
                !("rowSpan" in Q) && !Q.hasSubColumns && (Q.rowSpan = W - Z)
            })
        }, G = 0; G < W; G += 1) U(G);
    return C
}
const Header = defineComponent({
    name: "Header",
    inheritAttrs: !1,
    props: ["columns", "flattenColumns", "stickyOffsets", "customHeaderRow"],
    setup: function (C) {
        var H = useInjectTable(),
            W = computed(function () {
                return parseHeaderRows(C.columns)
            });
        return function () {
            var U = H.prefixCls,
                G = H.getComponent,
                X = C.stickyOffsets,
                Z = C.flattenColumns,
                Q = C.customHeaderRow,
                ee = G(["header", "wrapper"], "thead"),
                ne = G(["header", "row"], "tr"),
                te = G(["header", "cell"], "th");
            return createVNode(ee, {
                class: "".concat(U, "-thead")
            }, {
                default: function () {
                    return [W.value.map(function (ae, oe) {
                        var ie = createVNode(HeaderRow, {
                            key: oe,
                            flattenColumns: Z,
                            cells: ae,
                            stickyOffsets: X,
                            rowComponent: ne,
                            cellComponent: te,
                            customHeaderRow: Q,
                            index: oe
                        }, null);
                        return ie
                    })]
                }
            })
        }
    }
});
var ExpandedRowContextKey = Symbol("ExpandedRowProps"),
    useProvideExpandedRow = function (C) {
        provide(ExpandedRowContextKey, C)
    },
    useInjectExpandedRow = function () {
        return inject(ExpandedRowContextKey, {})
    };
const ExpandedRow = defineComponent({
        name: "ExpandedRow",
        inheritAttrs: !1,
        props: ["prefixCls", "component", "cellComponent", "expanded", "colSpan", "isEmpty"],
        setup: function (C, H) {
            var W = H.slots,
                U = H.attrs,
                G = useInjectTable(),
                X = useInjectExpandedRow(),
                Z = X.fixHeader,
                Q = X.fixColumn,
                ee = X.componentWidth,
                ne = X.horizonScroll;
            return function () {
                var te = C.prefixCls,
                    re = C.component,
                    ae = C.cellComponent,
                    oe = C.expanded,
                    ie = C.colSpan,
                    ue = C.isEmpty;
                return createVNode(re, {
                    class: U.class,
                    style: {
                        display: oe ? null : "none"
                    }
                }, {
                    default: function () {
                        return [createVNode(Cell, {
                            component: ae,
                            prefixCls: te,
                            colSpan: ie
                        }, {
                            default: function () {
                                var ce, de = (ce = W.default) === null || ce ===
                                    void 0 ? void 0 : ce.call(W);
                                return (ue ? ne.value : Q.value) && (de =
                                    createVNode("div", {
                                        style: {
                                            width: "".concat(ee.value -
                                                (Z.value ? G.scrollbarSize :
                                                    0), "px"),
                                            position: "sticky",
                                            left: 0,
                                            overflow: "hidden"
                                        },
                                        class: "".concat(te,
                                            "-expanded-row-fixed")
                                    }, [de])), de
                            }
                        })]
                    }
                })
            }
        }
    }),
    MeasureCell = defineComponent({
        name: "MeasureCell",
        props: ["columnKey"],
        setup: function (C, H) {
            var W = H.emit,
                U = ref();
            return onMounted(function () {
                    U.value && W("columnResize", C.columnKey, U.value.offsetWidth)
                }),
                function () {
                    return createVNode(ResizeObserver$1, {
                        onResize: function (X) {
                            var Z = X.offsetWidth;
                            W("columnResize", C.columnKey, Z)
                        }
                    }, {
                        default: function () {
                            return [createVNode("td", {
                                ref: U,
                                style: {
                                    padding: 0,
                                    border: 0,
                                    height: 0
                                }
                            }, [createVNode("div", {
                                style: {
                                    height: 0,
                                    overflow: "hidden"
                                }
                            }, [createTextVNode(" ")])])]
                        }
                    })
                }
        }
    });
var BodyContextKey = Symbol("BodyContextProps"),
    useProvideBody = function (C) {
        provide(BodyContextKey, C)
    },
    useInjectBody = function () {
        return inject(BodyContextKey, {})
    };
const BodyRow = defineComponent({
    name: "BodyRow",
    inheritAttrs: !1,
    props: ["record", "index", "renderIndex", "recordKey", "expandedKeys", "rowComponent", "cellComponent",
        "customRow", "rowExpandable", "indent", "rowKey", "getRowKey", "childrenColumnName"],
    setup: function (C, H) {
        var W = H.attrs,
            U = useInjectTable(),
            G = useInjectBody(),
            X = ref(!1),
            Z = computed(function () {
                return C.expandedKeys && C.expandedKeys.has(C.recordKey)
            });
        watchEffect(function () {
            Z.value && (X.value = !0)
        });
        var Q = computed(function () {
                return G.expandableType === "row" && (!C.rowExpandable || C.rowExpandable(C.record))
            }),
            ee = computed(function () {
                return G.expandableType === "nest"
            }),
            ne = computed(function () {
                return C.childrenColumnName && C.record && C.record[C.childrenColumnName]
            }),
            te = computed(function () {
                return Q.value || ee.value
            }),
            re = function (se, ce) {
                G.onTriggerExpand(se, ce)
            },
            ae = computed(function () {
                var le;
                return ((le = C.customRow) === null || le === void 0 ? void 0 : le.call(C, C.record, C.index)) ||
                    {}
            }),
            oe = function (se) {
                var ce, de;
                G.expandRowByClick && te.value && re(C.record, se);
                for (var ve = arguments.length, fe = new Array(ve > 1 ? ve - 1 : 0), pe = 1; pe < ve; pe++)
                    fe[pe - 1] = arguments[pe];
                (ce = ae.value) === null || ce === void 0 || (de = ce.onClick) === null || de === void 0 ||
                    de.call.apply(de, [ce, se].concat(fe))
            },
            ie = computed(function () {
                var le = C.record,
                    se = C.index,
                    ce = C.indent,
                    de = G.rowClassName;
                return typeof de == "string" ? de : typeof de == "function" ? de(le, se, ce) : ""
            }),
            ue = computed(function () {
                return getColumnsKey(G.flattenColumns)
            });
        return function () {
            var le = W.class,
                se = W.style,
                ce = C.record,
                de = C.index,
                ve = C.rowKey,
                fe = C.indent,
                pe = fe === void 0 ? 0 : fe,
                me = C.rowComponent,
                he = C.cellComponent,
                Se = U.prefixCls,
                _e = U.fixedInfoList,
                be = U.transformCellText,
                ge = G.flattenColumns,
                xe = G.expandedRowClassName,
                Pe = G.indentSize,
                $e = G.expandIcon,
                ye = G.expandedRowRender,
                Ce = G.expandIconColumnIndex,
                we = createVNode(me, _objectSpread2$1(_objectSpread2$1({}, ae.value), {}, {
                    "data-row-key": ve,
                    class: classNames(le, "".concat(Se, "-row"), "".concat(Se, "-row-level-").concat(
                        pe), ie.value, ae.value.class),
                    style: _objectSpread2$1(_objectSpread2$1({}, se), parseStyleText(ae.value.style)),
                    onClick: oe
                }), {
                    default: function () {
                        return [ge.map(function (ke, Ee) {
                            var Ae = ke.customRender,
                                Re = ke.dataIndex,
                                He = ke.className,
                                je = ue[Ee],
                                Fe = _e[Ee],
                                Le;
                            ke.customCell && (Le = ke.customCell(ce, de, ke));
                            var Ie = Ee === (Ce || 0) && ee.value ? createVNode(
                                Fragment, null, [createVNode("span", {
                                    style: {
                                        paddingLeft: "".concat(Pe * pe,
                                            "px")
                                    },
                                    class: "".concat(Se,
                                        "-row-indent indent-level-"
                                    ).concat(pe)
                                }, null), $e({
                                    prefixCls: Se,
                                    expanded: Z.value,
                                    expandable: ne.value,
                                    record: ce,
                                    onExpand: re
                                })]) : null;
                            return createVNode(Cell, _objectSpread2$1(
                                _objectSpread2$1({
                                    cellType: "body",
                                    class: He,
                                    ellipsis: ke.ellipsis,
                                    align: ke.align,
                                    component: he,
                                    prefixCls: Se,
                                    key: je,
                                    record: ce,
                                    index: de,
                                    renderIndex: C.renderIndex,
                                    dataIndex: Re,
                                    customRender: Ae
                                }, Fe), {}, {
                                    additionalProps: Le,
                                    column: ke,
                                    transformCellText: be,
                                    appendNode: Ie
                                }), null)
                        })]
                    }
                }),
                Oe;
            if (Q.value && (X.value || Z.value)) {
                var Ne = ye({
                        record: ce,
                        index: de,
                        indent: pe + 1,
                        expanded: Z.value
                    }),
                    Me = xe && xe(ce, de, pe);
                Oe = createVNode(ExpandedRow, {
                    expanded: Z.value,
                    class: classNames("".concat(Se, "-expanded-row"), "".concat(Se,
                        "-expanded-row-level-").concat(pe + 1), Me),
                    prefixCls: Se,
                    component: me,
                    cellComponent: he,
                    colSpan: ge.length,
                    isEmpty: !1
                }, {
                    default: function () {
                        return [Ne]
                    }
                })
            }
            return createVNode(Fragment, null, [we, Oe])
        }
    }
});

function flatRecord(K, C, H, W, U, G) {
    var X = [];
    X.push({
        record: K,
        indent: C,
        index: G
    });
    var Z = U(K),
        Q = W == null ? void 0 : W.has(Z);
    if (K && Array.isArray(K[H]) && Q)
        for (var ee = 0; ee < K[H].length; ee += 1) {
            var ne = flatRecord(K[H][ee], C + 1, H, W, U, ee);
            X.push.apply(X, _toConsumableArray(ne))
        }
    return X
}

function useFlattenRecords(K, C, H, W) {
    var U = computed(function () {
        var G = C.value,
            X = H.value,
            Z = K.value;
        if (X != null && X.size) {
            for (var Q = [], ee = 0; ee < (Z == null ? void 0 : Z.length); ee += 1) {
                var ne = Z[ee];
                Q.push.apply(Q, _toConsumableArray(flatRecord(ne, 0, G, X, W.value, ee)))
            }
            return Q
        }
        return Z == null ? void 0 : Z.map(function (te, re) {
            return {
                record: te,
                indent: 0,
                index: re
            }
        })
    });
    return U
}
var ResizeContextKey = Symbol("ResizeContextProps"),
    useProvideResize = function (C) {
        provide(ResizeContextKey, C)
    },
    useInjectResize = function () {
        return inject(ResizeContextKey, {
            onColumnResize: function () {}
        })
    };
const Body = defineComponent({
    name: "Body",
    props: ["data", "getRowKey", "measureColumnWidth", "expandedKeys", "customRow", "rowExpandable",
        "childrenColumnName"],
    slots: ["emptyNode"],
    setup: function (C, H) {
        var W = H.slots,
            U = useInjectResize(),
            G = useInjectTable(),
            X = useInjectBody(),
            Z = useFlattenRecords(toRef(C, "data"), toRef(C, "childrenColumnName"), toRef(C, "expandedKeys"),
                toRef(C, "getRowKey")),
            Q = ref(-1),
            ee = ref(-1),
            ne;
        return useProvideHover({
                startRow: Q,
                endRow: ee,
                onHover: function (re, ae) {
                    clearTimeout(ne), ne = setTimeout(function () {
                        Q.value = re, ee.value = ae
                    }, 100)
                }
            }),
            function () {
                var te = C.data,
                    re = C.getRowKey,
                    ae = C.measureColumnWidth,
                    oe = C.expandedKeys,
                    ie = C.customRow,
                    ue = C.rowExpandable,
                    le = C.childrenColumnName,
                    se = U.onColumnResize,
                    ce = G.prefixCls,
                    de = G.getComponent,
                    ve = X.flattenColumns,
                    fe = de(["body", "wrapper"], "tbody"),
                    pe = de(["body", "row"], "tr"),
                    me = de(["body", "cell"], "td"),
                    he;
                if (te.length) he = Z.value.map(function (be, ge) {
                    var xe = be.record,
                        Pe = be.indent,
                        $e = be.index,
                        ye = re(xe, ge);
                    return createVNode(BodyRow, {
                        key: ye,
                        rowKey: ye,
                        record: xe,
                        recordKey: ye,
                        index: ge,
                        renderIndex: $e,
                        rowComponent: pe,
                        cellComponent: me,
                        expandedKeys: oe,
                        customRow: ie,
                        getRowKey: re,
                        rowExpandable: ue,
                        childrenColumnName: le,
                        indent: Pe
                    }, null)
                });
                else {
                    var Se;
                    he = createVNode(ExpandedRow, {
                        expanded: !0,
                        class: "".concat(ce, "-placeholder"),
                        prefixCls: ce,
                        component: pe,
                        cellComponent: me,
                        colSpan: ve.length,
                        isEmpty: !0
                    }, {
                        default: function () {
                            return [(Se = W.emptyNode) === null || Se === void 0 ? void 0 : Se.call(
                                W)]
                        }
                    })
                }
                var _e = getColumnsKey(ve);
                return createVNode(fe, {
                    class: "".concat(ce, "-tbody")
                }, {
                    default: function () {
                        return [ae && createVNode("tr", {
                            "aria-hidden": "true",
                            class: "".concat(ce, "-measure-row"),
                            style: {
                                height: 0,
                                fontSize: 0
                            }
                        }, [_e.map(function (ge) {
                            return createVNode(MeasureCell, {
                                key: ge,
                                columnKey: ge,
                                onColumnResize: se
                            }, null)
                        })]), he]
                    }
                })
            }
    }
});
var EXPAND_COLUMN = {},
    _excluded$d = ["fixed"];

function flatColumns(K) {
    return K.reduce(function (C, H) {
        var W = H.fixed,
            U = W === !0 ? "left" : W,
            G = H.children;
        return G && G.length > 0 ? [].concat(_toConsumableArray(C), _toConsumableArray(flatColumns(G).map(
            function (X) {
                return _objectSpread2$1({
                    fixed: U
                }, X)
            }))) : [].concat(_toConsumableArray(C), [_objectSpread2$1(_objectSpread2$1({}, H), {}, {
            fixed: U
        })])
    }, [])
}

function revertForRtl(K) {
    return K.map(function (C) {
        var H = C.fixed,
            W = _objectWithoutProperties$2(C, _excluded$d),
            U = H;
        return H === "left" ? U = "right" : H === "right" && (U = "left"), _objectSpread2$1({
            fixed: U
        }, W)
    })
}

function useColumns$1(K, C) {
    var H = K.prefixCls,
        W = K.columns,
        U = K.expandable,
        G = K.expandedKeys,
        X = K.getRowKey,
        Z = K.onTriggerExpand,
        Q = K.expandIcon,
        ee = K.rowExpandable,
        ne = K.expandIconColumnIndex,
        te = K.direction,
        re = K.expandRowByClick,
        ae = K.expandColumnWidth,
        oe = K.expandFixed,
        ie = computed(function () {
            if (U.value) {
                var se, ce = W.value.slice();
                if (!ce.includes(EXPAND_COLUMN)) {
                    var de = ne.value || 0;
                    de >= 0 && ce.splice(de, 0, EXPAND_COLUMN)
                }
                var ve = ce.indexOf(EXPAND_COLUMN);
                ce = ce.filter(function (xe, Pe) {
                    return xe !== EXPAND_COLUMN || Pe === ve
                });
                var fe = W.value[ve],
                    pe;
                (oe.value === "left" || oe.value) && !ne.value ? pe = "left" : (oe.value === "right" || oe.value) &&
                    ne.value === W.value.length ? pe = "right" : pe = fe ? fe.fixed : null;
                var me = G.value,
                    he = ee.value,
                    Se = Q.value,
                    _e = H.value,
                    be = re.value,
                    ge = (se = {}, _defineProperty$V(se, INTERNAL_COL_DEFINE, {
                            class: "".concat(H.value, "-expand-icon-col"),
                            columnType: "EXPAND_COLUMN"
                        }), _defineProperty$V(se, "title", ""), _defineProperty$V(se, "fixed", pe),
                        _defineProperty$V(se, "class", "".concat(H.value, "-row-expand-icon-cell")),
                        _defineProperty$V(se, "width", ae.value), _defineProperty$V(se, "customRender", function (
                            Pe) {
                            var $e = Pe.record,
                                ye = Pe.index,
                                Ce = X.value($e, ye),
                                we = me.has(Ce),
                                Oe = he ? he($e) : !0,
                                Ne = Se({
                                    prefixCls: _e,
                                    expanded: we,
                                    expandable: Oe,
                                    record: $e,
                                    onExpand: Z
                                });
                            return be ? createVNode("span", {
                                onClick: function (Ve) {
                                    return Ve.stopPropagation()
                                }
                            }, [Ne]) : Ne
                        }), se);
                return ce.map(function (xe) {
                    return xe === EXPAND_COLUMN ? ge : xe
                })
            }
            return W.value.filter(function (xe) {
                return xe !== EXPAND_COLUMN
            })
        }),
        ue = computed(function () {
            var se = ie.value;
            return C.value && (se = C.value(se)), se.length || (se = [{
                customRender: function () {
                    return null
                }
            }]), se
        }),
        le = computed(function () {
            return te.value === "rtl" ? revertForRtl(flatColumns(ue.value)) : flatColumns(ue.value)
        });
    return [ue, le]
}

function useLayoutState(K) {
    var C = shallowRef(K),
        H, W = shallowRef([]);

    function U(G) {
        W.value.push(G), wrapperRaf.cancel(H), H = wrapperRaf(function () {
            var X = W.value;
            W.value = [], X.forEach(function (Z) {
                C.value = Z(C.value)
            })
        })
    }
    return onBeforeUnmount(function () {
        wrapperRaf.cancel(H)
    }), [C, U]
}

function useTimeoutLock(K) {
    var C = ref(K || null),
        H = ref();

    function W() {
        clearTimeout(H.value)
    }

    function U(X) {
        C.value = X, W(), H.value = setTimeout(function () {
            C.value = null, H.value = void 0
        }, 100)
    }

    function G() {
        return C.value
    }
    return onBeforeUnmount(function () {
        W()
    }), [U, G]
}

function useStickyOffsets(K, C, H) {
    var W = computed(function () {
        for (var U = [], G = [], X = 0, Z = 0, Q = K.value, ee = C.value, ne = H.value, te = 0; te < ee; te +=
            1)
            if (ne === "rtl") {
                G[te] = Z, Z += Q[te] || 0;
                var re = ee - te - 1;
                U[re] = X, X += Q[re] || 0
            } else {
                U[te] = X, X += Q[te] || 0;
                var ae = ee - te - 1;
                G[ae] = Z, Z += Q[ae] || 0
            } return {
            left: U,
            right: G
        }
    });
    return W
}
var _excluded$c = ["columnType"];

function ColGroup(K) {
    for (var C = K.colWidths, H = K.columns, W = K.columCount, U = [], G = W || H.length, X = !1, Z = G - 1; Z >= 0; Z -=
        1) {
        var Q = C[Z],
            ee = H && H[Z],
            ne = ee && ee[INTERNAL_COL_DEFINE];
        if (Q || ne || X) {
            var te = ne || {};
            te.columnType;
            var re = _objectWithoutProperties$2(te, _excluded$c);
            U.unshift(createVNode("col", _objectSpread2$1({
                key: Z,
                style: {
                    width: typeof Q == "number" ? "".concat(Q, "px") : Q
                }
            }, re), null)), X = !0
        }
    }
    return createVNode("colgroup", null, [U])
}

function Panel(K, C) {
    var H, W = C.slots;
    return createVNode("div", null, [(H = W.default) === null || H === void 0 ? void 0 : H.call(W)])
}
Panel.displayName = "Panel";
var indexGuid = 0,
    Summary = defineComponent({
        name: "Summary",
        props: ["fixed"],
        setup: function (C, H) {
            var W = H.slots,
                U = useInjectTable(),
                G = "table-summary-uni-key-".concat(++indexGuid),
                X = computed(function () {
                    return C.fixed === "" || C.fixed
                });
            return watchEffect(function () {
                    U.summaryCollect(G, X.value)
                }), onBeforeUnmount(function () {
                    U.summaryCollect(G, !1)
                }),
                function () {
                    var Z;
                    return (Z = W.default) === null || Z === void 0 ? void 0 : Z.call(W)
                }
        }
    });
const Summary$1 = Summary,
    SummaryRow = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "FooterRow",
        setup: function (C, H) {
            var W = H.slots;
            return function () {
                var U;
                return createVNode("tr", null, [(U = W.default) === null || U === void 0 ? void 0 : U.call(
                    W)])
            }
        }
    });
var SummaryContextKey = Symbol("SummaryContextProps"),
    useProvideSummary = function (C) {
        provide(SummaryContextKey, C)
    },
    useInjectSummary = function () {
        return inject(SummaryContextKey, {})
    };
const SummaryCell = defineComponent({
        name: "SummaryCell",
        props: ["index", "colSpan", "rowSpan", "align"],
        setup: function (C, H) {
            var W = H.attrs,
                U = H.slots,
                G = useInjectTable(),
                X = useInjectSummary();
            return function () {
                var Z = C.index,
                    Q = C.colSpan,
                    ee = Q === void 0 ? 1 : Q,
                    ne = C.rowSpan,
                    te = C.align,
                    re = G.prefixCls,
                    ae = G.direction,
                    oe = X.scrollColumnIndex,
                    ie = X.stickyOffsets,
                    ue = X.flattenColumns,
                    le = Z + ee - 1,
                    se = le + 1 === oe ? ee + 1 : ee,
                    ce = getCellFixedInfo(Z, Z + se - 1, ue, ie, ae);
                return createVNode(Cell, _objectSpread2$1({
                    class: W.class,
                    index: Z,
                    component: "td",
                    prefixCls: re,
                    record: null,
                    dataIndex: null,
                    align: te,
                    colSpan: se,
                    rowSpan: ne,
                    customRender: function () {
                        var ve;
                        return (ve = U.default) === null || ve === void 0 ? void 0 : ve.call(
                            U)
                    }
                }, ce), null)
            }
        }
    }),
    Footer = defineComponent({
        name: "Footer",
        inheritAttrs: !1,
        props: ["stickyOffsets", "flattenColumns"],
        setup: function (C, H) {
            var W = H.slots,
                U = useInjectTable();
            return useProvideSummary(reactive({
                    stickyOffsets: toRef(C, "stickyOffsets"),
                    flattenColumns: toRef(C, "flattenColumns"),
                    scrollColumnIndex: computed(function () {
                        var G = C.flattenColumns.length - 1,
                            X = C.flattenColumns[G];
                        return X != null && X.scrollbar ? G : null
                    })
                })),
                function () {
                    var G, X = U.prefixCls;
                    return createVNode("tfoot", {
                        class: "".concat(X, "-summary")
                    }, [(G = W.default) === null || G === void 0 ? void 0 : G.call(W)])
                }
        }
    });
var FooterComponents = Summary$1;

function renderExpandIcon$1(K) {
    var C, H = K.prefixCls,
        W = K.record,
        U = K.onExpand,
        G = K.expanded,
        X = K.expandable,
        Z = "".concat(H, "-row-expand-icon");
    if (!X) return createVNode("span", {
        class: [Z, "".concat(H, "-row-spaced")]
    }, null);
    var Q = function (ne) {
        U(W, ne), ne.stopPropagation()
    };
    return createVNode("span", {
        class: (C = {}, _defineProperty$V(C, Z, !0), _defineProperty$V(C, "".concat(H, "-row-expanded"), G),
            _defineProperty$V(C, "".concat(H, "-row-collapsed"), !G), C),
        onClick: Q
    }, null)
}

function findAllChildrenKeys(K, C, H) {
    var W = [];

    function U(G) {
        (G || []).forEach(function (X, Z) {
            W.push(C(X, Z)), U(X[H])
        })
    }
    return U(K), W
}
const StickyScrollBar = defineComponent({
    name: "StickyScrollBar",
    inheritAttrs: !1,
    props: ["offsetScroll", "container", "scrollBodyRef", "scrollBodySizeInfo"],
    emits: ["scroll"],
    setup: function (C, H) {
        var W = H.emit,
            U = H.expose,
            G = useInjectTable(),
            X = ref(0),
            Z = ref(0),
            Q = ref(0);
        watchEffect(function () {
            X.value = C.scrollBodySizeInfo.scrollWidth || 0, Z.value = C.scrollBodySizeInfo.clientWidth ||
                0, Q.value = X.value && Z.value * (Z.value / X.value)
        }, {
            flush: "post"
        });
        var ee = ref(),
            ne = useLayoutState({
                scrollLeft: 0,
                isHiddenScrollBar: !0
            }),
            te = _slicedToArray$2(ne, 2),
            re = te[0],
            ae = te[1],
            oe = ref({
                delta: 0,
                x: 0
            }),
            ie = ref(!1),
            ue = function () {
                ie.value = !1
            },
            le = function (_e) {
                oe.value = {
                    delta: _e.pageX - re.value.scrollLeft,
                    x: 0
                }, ie.value = !0, _e.preventDefault()
            },
            se = function (_e) {
                var be, ge = _e || ((be = window) === null || be === void 0 ? void 0 : be.event),
                    xe = ge.buttons;
                if (!ie.value || xe === 0) {
                    ie.value && (ie.value = !1);
                    return
                }
                var Pe = oe.value.x + _e.pageX - oe.value.x - oe.value.delta;
                Pe <= 0 && (Pe = 0), Pe + Q.value >= Z.value && (Pe = Z.value - Q.value), W("scroll", {
                    scrollLeft: Pe / Z.value * (X.value + 2)
                }), oe.value.x = _e.pageX
            },
            ce = function () {
                if (C.scrollBodyRef.value) {
                    var _e = getOffset(C.scrollBodyRef.value).top,
                        be = _e + C.scrollBodyRef.value.offsetHeight,
                        ge = C.container === window ? document.documentElement.scrollTop + window.innerHeight :
                        getOffset(C.container).top + C.container.clientHeight;
                    be - getScrollBarSize() <= ge || _e >= ge - C.offsetScroll ? ae(function (xe) {
                        return _objectSpread2$1(_objectSpread2$1({}, xe), {}, {
                            isHiddenScrollBar: !0
                        })
                    }) : ae(function (xe) {
                        return _objectSpread2$1(_objectSpread2$1({}, xe), {}, {
                            isHiddenScrollBar: !1
                        })
                    })
                }
            },
            de = function (_e) {
                ae(function (be) {
                    return _objectSpread2$1(_objectSpread2$1({}, be), {}, {
                        scrollLeft: _e / X.value * Z.value || 0
                    })
                })
            };
        U({
            setScrollLeft: de
        });
        var ve = null,
            fe = null,
            pe = null,
            me = null;
        onMounted(function () {
            ve = addEventListenerWrap(document.body, "mouseup", ue, !1), fe = addEventListenerWrap(
                document.body, "mousemove", se, !1), pe = addEventListenerWrap(window, "resize",
                ce, !1)
        }), onActivated(function () {
            nextTick(function () {
                ce()
            })
        }), onMounted(function () {
            setTimeout(function () {
                watch([Q, ie], function () {
                    ce()
                }, {
                    immediate: !0,
                    flush: "post"
                })
            })
        }), watch(function () {
            return C.container
        }, function () {
            var Se;
            (Se = me) === null || Se === void 0 || Se.remove(), me = addEventListenerWrap(C.container,
                "scroll", ce, !1)
        }, {
            immediate: !0,
            flush: "post"
        }), onBeforeUnmount(function () {
            var Se, _e, be, ge;
            (Se = ve) === null || Se === void 0 || Se.remove(), (_e = fe) === null || _e === void 0 ||
                _e.remove(), (be = me) === null || be === void 0 || be.remove(), (ge = pe) === null ||
                ge === void 0 || ge.remove()
        }), watch(function () {
            return _objectSpread2$1({}, re.value)
        }, function (Se, _e) {
            Se.isHiddenScrollBar !== (_e == null ? void 0 : _e.isHiddenScrollBar) && !Se.isHiddenScrollBar &&
                ae(function (be) {
                    var ge = C.scrollBodyRef.value;
                    return ge ? _objectSpread2$1(_objectSpread2$1({}, be), {}, {
                        scrollLeft: ge.scrollLeft / ge.scrollWidth * ge.clientWidth
                    }) : be
                })
        }, {
            immediate: !0
        });
        var he = getScrollBarSize();
        return function () {
            if (X.value <= Z.value || !Q.value || re.value.isHiddenScrollBar) return null;
            var Se = G.prefixCls;
            return createVNode("div", {
                style: {
                    height: "".concat(he, "px"),
                    width: "".concat(Z.value, "px"),
                    bottom: "".concat(C.offsetScroll, "px")
                },
                class: "".concat(Se, "-sticky-scroll")
            }, [createVNode("div", {
                onMousedown: le,
                ref: ee,
                class: classNames("".concat(Se, "-sticky-scroll-bar"),
                    _defineProperty$V({}, "".concat(Se, "-sticky-scroll-bar-active"),
                        ie.value)),
                style: {
                    width: "".concat(Q.value, "px"),
                    transform: "translate3d(".concat(re.value.scrollLeft, "px, 0, 0)")
                }
            }, null)])
        }
    }
});
var defaultContainer = canUseDom() ? window : null;

function useSticky(K, C) {
    return computed(function () {
        var H = _typeof$2(K.value) === "object" ? K.value : {},
            W = H.offsetHeader,
            U = W === void 0 ? 0 : W,
            G = H.offsetSummary,
            X = G === void 0 ? 0 : G,
            Z = H.offsetScroll,
            Q = Z === void 0 ? 0 : Z,
            ee = H.getContainer,
            ne = ee === void 0 ? function () {
                return defaultContainer
            } : ee,
            te = ne() || defaultContainer,
            re = !!K.value;
        return {
            isSticky: re,
            stickyClassName: re ? "".concat(C.value, "-sticky-holder") : "",
            offsetHeader: U,
            offsetSummary: X,
            offsetScroll: Q,
            container: te
        }
    })
}

function useColumnWidth(K, C) {
    return computed(function () {
        for (var H = [], W = K.value, U = C.value, G = 0; G < U; G += 1) {
            var X = W[G];
            if (X !== void 0) H[G] = X;
            else return null
        }
        return H
    })
}
const FixedHolder = defineComponent({
    name: "FixedHolder",
    inheritAttrs: !1,
    props: ["columns", "flattenColumns", "stickyOffsets", "customHeaderRow", "noData", "maxContentScroll",
        "colWidths", "columCount", "direction", "fixHeader", "stickyTopOffset", "stickyBottomOffset",
        "stickyClassName"],
    emits: ["scroll"],
    setup: function (C, H) {
        var W = H.attrs,
            U = H.slots,
            G = H.emit,
            X = useInjectTable(),
            Z = computed(function () {
                return X.isSticky && !C.fixHeader ? 0 : X.scrollbarSize
            }),
            Q = ref(),
            ee = function (le) {
                var se = le.currentTarget,
                    ce = le.deltaX;
                ce && (G("scroll", {
                    currentTarget: se,
                    scrollLeft: se.scrollLeft + ce
                }), le.preventDefault())
            },
            ne = ref();
        onMounted(function () {
            nextTick(function () {
                ne.value = addEventListenerWrap(Q.value, "wheel", ee)
            })
        }), onBeforeUnmount(function () {
            var ue;
            (ue = ne.value) === null || ue === void 0 || ue.remove()
        });
        var te = computed(function () {
                return C.flattenColumns.every(function (ue) {
                    return ue.width && ue.width !== 0 && ue.width !== "0px"
                })
            }),
            re = ref([]),
            ae = ref([]);
        watchEffect(function () {
            var ue = C.flattenColumns[C.flattenColumns.length - 1],
                le = {
                    fixed: ue ? ue.fixed : null,
                    scrollbar: !0,
                    customHeaderCell: function () {
                        return {
                            class: "".concat(X.prefixCls, "-cell-scrollbar")
                        }
                    }
                };
            re.value = Z.value ? [].concat(_toConsumableArray(C.columns), [le]) : C.columns, ae.value =
                Z.value ? [].concat(_toConsumableArray(C.flattenColumns), [le]) : C.flattenColumns
        });
        var oe = computed(function () {
                var ue = C.stickyOffsets,
                    le = C.direction,
                    se = ue.right,
                    ce = ue.left;
                return _objectSpread2$1(_objectSpread2$1({}, ue), {}, {
                    left: le === "rtl" ? [].concat(_toConsumableArray(ce.map(function (de) {
                        return de + Z.value
                    })), [0]) : ce,
                    right: le === "rtl" ? se : [].concat(_toConsumableArray(se.map(function (de) {
                        return de + Z.value
                    })), [0]),
                    isSticky: X.isSticky
                })
            }),
            ie = useColumnWidth(toRef(C, "colWidths"), toRef(C, "columCount"));
        return function () {
            var ue, le = C.noData,
                se = C.columCount,
                ce = C.stickyTopOffset,
                de = C.stickyBottomOffset,
                ve = C.stickyClassName,
                fe = C.maxContentScroll,
                pe = X.isSticky;
            return createVNode("div", {
                style: _objectSpread2$1({
                    overflow: "hidden"
                }, pe ? {
                    top: "".concat(ce, "px"),
                    bottom: "".concat(de, "px")
                } : {}),
                ref: Q,
                class: classNames(W.class, _defineProperty$V({}, ve, !!ve))
            }, [createVNode("table", {
                style: {
                    tableLayout: "fixed",
                    visibility: le || ie.value ? null : "hidden"
                }
            }, [(!le || !fe || te.value) && createVNode(ColGroup, {
                colWidths: ie.value ? [].concat(_toConsumableArray(ie.value), [
                    Z.value]) : [],
                columCount: se + 1,
                columns: ae.value
            }, null), (ue = U.default) === null || ue === void 0 ? void 0 : ue.call(
                U, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                    stickyOffsets: oe.value,
                    columns: re.value,
                    flattenColumns: ae.value
                }))])])
        }
    }
});

function fromPairs(K) {
    for (var C = -1, H = K == null ? 0 : K.length, W = {}; ++C < H;) {
        var U = K[C];
        W[U[0]] = U[1]
    }
    return W
}

function reactivePick(K) {
    for (var C = arguments.length, H = new Array(C > 1 ? C - 1 : 0), W = 1; W < C; W++) H[W - 1] = arguments[W];
    return reactive(fromPairs(H.map(function (U) {
        return [U, toRef(K, U)]
    })))
}
var EMPTY_DATA = [],
    EMPTY_SCROLL_TARGET = {},
    INTERNAL_HOOKS = "rc-table-internal-hook";
const Table$2 = defineComponent({
    name: "Table",
    inheritAttrs: !1,
    props: ["prefixCls", "data", "columns", "rowKey", "tableLayout", "scroll", "rowClassName", "title",
        "footer", "id", "showHeader", "components", "customRow", "customHeaderRow", "direction",
        "expandFixed", "expandColumnWidth", "expandedRowKeys", "defaultExpandedRowKeys",
        "expandedRowRender", "expandRowByClick", "expandIcon", "onExpand", "onExpandedRowsChange",
        "onUpdate:expandedRowKeys", "defaultExpandAllRows", "indentSize", "expandIconColumnIndex",
        "expandedRowClassName", "childrenColumnName", "rowExpandable", "sticky", "transformColumns",
        "internalHooks", "internalRefs", "canExpandable", "onUpdateInternalRefs", "transformCellText"],
    slots: ["title", "footer", "summary", "emptyText"],
    emits: ["expand", "expandedRowsChange", "updateInternalRefs", "update:expandedRowKeys"],
    setup: function (C, H) {
        var W = H.attrs,
            U = H.slots,
            G = H.emit,
            X = computed(function () {
                return C.data || EMPTY_DATA
            }),
            Z = computed(function () {
                return !!X.value.length
            }),
            Q = computed(function () {
                return mergeObject(C.components, {})
            }),
            ee = function (at, vt) {
                return getPathValue(Q.value, at) || vt
            },
            ne = computed(function () {
                var tt = C.rowKey;
                return typeof tt == "function" ? tt : function (at) {
                    var vt = at && at[tt];
                    return vt
                }
            }),
            te = computed(function () {
                return C.expandIcon || renderExpandIcon$1
            }),
            re = computed(function () {
                return C.childrenColumnName || "children"
            }),
            ae = computed(function () {
                return C.expandedRowRender ? "row" : C.canExpandable || X.value.some(function (tt) {
                    return tt && _typeof$2(tt) === "object" && tt[re.value]
                }) ? "nest" : !1
            }),
            oe = shallowRef([]),
            ie = watchEffect(function () {
                C.defaultExpandedRowKeys && (oe.value = C.defaultExpandedRowKeys), C.defaultExpandAllRows &&
                    (oe.value = findAllChildrenKeys(X.value, ne.value, re.value))
            });
        ie();
        var ue = computed(function () {
                return new Set(C.expandedRowKeys || oe.value || [])
            }),
            le = function (at) {
                var vt = ne.value(at, X.value.indexOf(at)),
                    gt, mt = ue.value.has(vt);
                mt ? (ue.value.delete(vt), gt = _toConsumableArray(ue.value)) : gt = [].concat(
                    _toConsumableArray(ue.value), [vt]), oe.value = gt, G("expand", !mt, at), G(
                    "update:expandedRowKeys", gt), G("expandedRowsChange", gt)
            },
            se = ref(0),
            ce = useColumns$1(_objectSpread2$1(_objectSpread2$1({}, toRefs(C)), {}, {
                expandable: computed(function () {
                    return !!C.expandedRowRender
                }),
                expandedKeys: ue,
                getRowKey: ne,
                onTriggerExpand: le,
                expandIcon: te
            }), computed(function () {
                return C.internalHooks === INTERNAL_HOOKS ? C.transformColumns : null
            })),
            de = _slicedToArray$2(ce, 2),
            ve = de[0],
            fe = de[1],
            pe = computed(function () {
                return {
                    columns: ve.value,
                    flattenColumns: fe.value
                }
            }),
            me = ref(),
            he = ref(),
            Se = ref(),
            _e = ref({
                scrollWidth: 0,
                clientWidth: 0
            }),
            be = ref(),
            ge = useState(!1),
            xe = _slicedToArray$2(ge, 2),
            Pe = xe[0],
            $e = xe[1],
            ye = useState(!1),
            Ce = _slicedToArray$2(ye, 2),
            we = Ce[0],
            Oe = Ce[1],
            Ne = useLayoutState(new Map),
            Me = _slicedToArray$2(Ne, 2),
            Ve = Me[0],
            ke = Me[1],
            Ee = computed(function () {
                return getColumnsKey(fe.value)
            }),
            Ae = computed(function () {
                return Ee.value.map(function (tt) {
                    return Ve.value.get(tt)
                })
            }),
            Re = computed(function () {
                return fe.value.length
            }),
            He = useStickyOffsets(Ae, Re, toRef(C, "direction")),
            je = computed(function () {
                return C.scroll && validateValue(C.scroll.y)
            }),
            Fe = computed(function () {
                return C.scroll && validateValue(C.scroll.x) || !!C.expandFixed
            }),
            Le = computed(function () {
                return Fe.value && fe.value.some(function (tt) {
                    var at = tt.fixed;
                    return at
                })
            }),
            Ie = ref(),
            Te = useSticky(toRef(C, "sticky"), toRef(C, "prefixCls")),
            De = reactive({}),
            Ke = computed(function () {
                var tt = Object.values(De)[0];
                return (je.value || Te.value.isSticky) && tt
            }),
            We = function (at, vt) {
                vt ? De[at] = vt : delete De[at]
            },
            Ue = ref({}),
            et = ref({}),
            Ye = ref({});
        watchEffect(function () {
            je.value && (et.value = {
                overflowY: "scroll",
                maxHeight: toPx(C.scroll.y)
            }), Fe.value && (Ue.value = {
                overflowX: "auto"
            }, je.value || (et.value = {
                overflowY: "hidden"
            }), Ye.value = {
                width: C.scroll.x === !0 ? "auto" : toPx(C.scroll.x),
                minWidth: "100%"
            })
        });
        var ze = function (at, vt) {
                isVisible(me.value) && ke(function (gt) {
                    if (gt.get(at) !== vt) {
                        var mt = new Map(gt);
                        return mt.set(at, vt), mt
                    }
                    return gt
                })
            },
            Be = useTimeoutLock(null),
            Ge = _slicedToArray$2(Be, 2),
            Xe = Ge[0],
            nt = Ge[1];

        function it(tt, at) {
            if (at) {
                if (typeof at == "function") {
                    at(tt);
                    return
                }
                var vt = at.$el || at;
                vt.scrollLeft !== tt && (vt.scrollLeft = tt)
            }
        }
        var ft = function (at) {
                var vt = at.currentTarget,
                    gt = at.scrollLeft,
                    mt = C.direction === "rtl",
                    ht = typeof gt == "number" ? gt : vt.scrollLeft,
                    yt = vt || EMPTY_SCROLL_TARGET;
                if (!nt() || nt() === yt) {
                    var St;
                    Xe(yt), it(ht, he.value), it(ht, Se.value), it(ht, be.value), it(ht, (St = Ie.value) ===
                        null || St === void 0 ? void 0 : St.setScrollLeft)
                }
                if (vt) {
                    var Ct = vt.scrollWidth,
                        _t = vt.clientWidth;
                    mt ? ($e(-ht < Ct - _t), Oe(-ht > 0)) : ($e(ht > 0), Oe(ht < Ct - _t))
                }
            },
            pt = function () {
                Fe.value && Se.value ? ft({
                    currentTarget: Se.value
                }) : ($e(!1), Oe(!1))
            },
            ot, Ze = function (at) {
                at !== se.value && (pt(), se.value = me.value ? me.value.offsetWidth : at)
            },
            ut = function (at) {
                var vt = at.width;
                if (clearTimeout(ot), se.value === 0) {
                    Ze(vt);
                    return
                }
                ot = setTimeout(function () {
                    Ze(vt)
                }, 100)
            };
        watch([Fe, function () {
            return C.data
        }, function () {
            return C.columns
        }], function () {
            Fe.value && pt()
        }, {
            flush: "post"
        });
        var st = useState(0),
            rt = _slicedToArray$2(st, 2),
            qe = rt[0],
            Je = rt[1];
        useProvideSticky(), onMounted(function () {
            nextTick(function () {
                var tt, at;
                pt(), Je(getTargetScrollBarSize(Se.value).width), _e.value = {
                    scrollWidth: ((tt = Se.value) === null || tt === void 0 ? void 0 :
                        tt.scrollWidth) || 0,
                    clientWidth: ((at = Se.value) === null || at === void 0 ? void 0 :
                        at.clientWidth) || 0
                }
            })
        }), onUpdated(function () {
            nextTick(function () {
                var tt, at, vt = ((tt = Se.value) === null || tt === void 0 ? void 0 : tt.scrollWidth) ||
                    0,
                    gt = ((at = Se.value) === null || at === void 0 ? void 0 : at.clientWidth) ||
                    0;
                (_e.value.scrollWidth !== vt || _e.value.clientWidth !== gt) && (_e.value = {
                    scrollWidth: vt,
                    clientWidth: gt
                })
            })
        }), watchEffect(function () {
            C.internalHooks === INTERNAL_HOOKS && C.internalRefs && C.onUpdateInternalRefs({
                body: Se.value ? Se.value.$el || Se.value : null
            })
        }, {
            flush: "post"
        });
        var Qe = computed(function () {
                return C.tableLayout ? C.tableLayout : Le.value ? C.scroll.x === "max-content" ? "auto" :
                    "fixed" : je.value || Te.value.isSticky || fe.value.some(function (tt) {
                        var at = tt.ellipsis;
                        return at
                    }) ? "fixed" : "auto"
            }),
            lt = function () {
                var at;
                return Z.value ? null : ((at = U.emptyText) === null || at === void 0 ? void 0 : at.call(U)) ||
                    "No Data"
            };
        useProvideTable(reactive(_objectSpread2$1(_objectSpread2$1({}, toRefs(reactivePick(C, "prefixCls",
            "direction", "transformCellText"))), {}, {
            getComponent: ee,
            scrollbarSize: qe,
            fixedInfoList: computed(function () {
                return fe.value.map(function (tt, at) {
                    return getCellFixedInfo(at, at, fe.value, He.value, C.direction)
                })
            }),
            isSticky: computed(function () {
                return Te.value.isSticky
            }),
            summaryCollect: We
        }))), useProvideBody(reactive(_objectSpread2$1(_objectSpread2$1({}, toRefs(reactivePick(C,
            "rowClassName", "expandedRowClassName", "expandRowByClick",
            "expandedRowRender", "expandIconColumnIndex", "indentSize"))), {}, {
            columns: ve,
            flattenColumns: fe,
            tableLayout: Qe,
            expandIcon: te,
            expandableType: ae,
            onTriggerExpand: le
        }))), useProvideResize({
            onColumnResize: ze
        }), useProvideExpandedRow({
            componentWidth: se,
            fixHeader: je,
            fixColumn: Le,
            horizonScroll: Fe
        });
        var ct = function () {
                return createVNode(Body, {
                    data: X.value,
                    measureColumnWidth: je.value || Fe.value || Te.value.isSticky,
                    expandedKeys: ue.value,
                    rowExpandable: C.rowExpandable,
                    getRowKey: ne.value,
                    customRow: C.customRow,
                    childrenColumnName: re.value
                }, {
                    emptyNode: lt
                })
            },
            dt = function () {
                return createVNode(ColGroup, {
                    colWidths: fe.value.map(function (at) {
                        var vt = at.width;
                        return vt
                    }),
                    columns: fe.value
                }, null)
            };
        return function () {
            var tt, at = C.prefixCls,
                vt = C.scroll,
                gt = C.tableLayout,
                mt = C.direction,
                ht = C.title,
                yt = ht === void 0 ? U.title : ht,
                St = C.footer,
                Ct = St === void 0 ? U.footer : St,
                _t = C.id,
                wt = C.showHeader,
                Et = C.customHeaderRow,
                xt = Te.value,
                kt = xt.isSticky,
                Nt = xt.offsetHeader,
                Rt = xt.offsetSummary,
                It = xt.offsetScroll,
                Lt = xt.stickyClassName,
                jt = xt.container,
                Mt = ee(["table"], "table"),
                Vt = ee(["body"]),
                Dt = (tt = U.summary) === null || tt === void 0 ? void 0 : tt.call(U, {
                    pageData: X.value
                }),
                zt = function () {
                    return null
                },
                At = {
                    colWidths: Ae.value,
                    columCount: fe.value.length,
                    stickyOffsets: He.value,
                    customHeaderRow: Et,
                    fixHeader: je.value,
                    scroll: vt
                };
            if (je.value || kt) {
                var Wt = function () {
                    return null
                };
                typeof Vt == "function" ? (Wt = function () {
                    return Vt(X.value, {
                        scrollbarSize: qe.value,
                        ref: Se,
                        onScroll: ft
                    })
                }, At.colWidths = fe.value.map(function (Ht, Ft) {
                    var Ut = Ht.width,
                        nn = Ft === ve.value.length - 1 ? Ut - qe.value : Ut;
                    return typeof nn == "number" && !Number.isNaN(nn) ? nn : 0
                })) : Wt = function () {
                    return createVNode("div", {
                        style: _objectSpread2$1(_objectSpread2$1({}, Ue.value), et.value),
                        onScroll: ft,
                        ref: Se,
                        class: classNames("".concat(at, "-body"))
                    }, [createVNode(Mt, {
                        style: _objectSpread2$1(_objectSpread2$1({}, Ye.value), {}, {
                            tableLayout: Qe.value
                        })
                    }, {
                        default: function () {
                            return [dt(), ct(), !Ke.value && Dt && createVNode(
                                Footer, {
                                    stickyOffsets: He.value,
                                    flattenColumns: fe.value
                                }, {
                                    default: function () {
                                        return [Dt]
                                    }
                                })]
                        }
                    })])
                };
                var Yt = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                    noData: !X.value.length,
                    maxContentScroll: Fe.value && vt.x === "max-content"
                }, At), pe.value), {}, {
                    direction: mt,
                    stickyClassName: Lt,
                    onScroll: ft
                });
                zt = function () {
                    return createVNode(Fragment, null, [wt !== !1 && createVNode(FixedHolder,
                        _objectSpread2$1(_objectSpread2$1({}, Yt), {}, {
                            stickyTopOffset: Nt,
                            class: "".concat(at, "-header"),
                            ref: he
                        }), {
                            default: function (Ut) {
                                return createVNode(Fragment, null, [createVNode(
                                        Header, Ut, null), Ke.value ===
                                    "top" && createVNode(Footer, Ut, {
                                        default: function () {
                                            return [Dt]
                                        }
                                    })])
                            }
                        }), Wt(), Ke.value && Ke.value !== "top" && createVNode(
                        FixedHolder, _objectSpread2$1(_objectSpread2$1({}, Yt), {}, {
                            stickyBottomOffset: Rt,
                            class: "".concat(at, "-summary"),
                            ref: be
                        }), {
                            default: function (Ut) {
                                return createVNode(Footer, Ut, {
                                    default: function () {
                                        return [Dt]
                                    }
                                })
                            }
                        }), kt && Se.value && createVNode(StickyScrollBar, {
                        ref: Ie,
                        offsetScroll: It,
                        scrollBodyRef: Se,
                        onScroll: ft,
                        container: jt,
                        scrollBodySizeInfo: _e.value
                    }, null)])
                }
            } else zt = function () {
                return createVNode("div", {
                    style: _objectSpread2$1(_objectSpread2$1({}, Ue.value), et.value),
                    class: classNames("".concat(at, "-content")),
                    onScroll: ft,
                    ref: Se
                }, [createVNode(Mt, {
                    style: _objectSpread2$1(_objectSpread2$1({}, Ye.value), {}, {
                        tableLayout: Qe.value
                    })
                }, {
                    default: function () {
                        return [dt(), wt !== !1 && createVNode(Header,
                                _objectSpread2$1(_objectSpread2$1({}, At),
                                    pe.value), null), ct(), Dt &&
                            createVNode(Footer, {
                                stickyOffsets: He.value,
                                flattenColumns: fe.value
                            }, {
                                default: function () {
                                    return [Dt]
                                }
                            })]
                    }
                })])
            };
            var Zt = pickAttrs(W, {
                    aria: !0,
                    data: !0
                }),
                Kt = function () {
                    var Ft;
                    return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, Zt), {}, {
                        class: classNames(at, (Ft = {}, _defineProperty$V(Ft, "".concat(at,
                                "-rtl"), mt === "rtl"), _defineProperty$V(Ft, "".concat(
                                at, "-ping-left"), Pe.value), _defineProperty$V(Ft,
                                "".concat(at, "-ping-right"), we.value),
                            _defineProperty$V(Ft, "".concat(at, "-layout-fixed"),
                                gt === "fixed"), _defineProperty$V(Ft, "".concat(at,
                                "-fixed-header"), je.value), _defineProperty$V(Ft,
                                "".concat(at, "-fixed-column"), Le.value),
                            _defineProperty$V(Ft, "".concat(at,
                                "-scroll-horizontal"), Fe.value), _defineProperty$V(
                                Ft, "".concat(at, "-has-fix-left"), fe.value[0] &&
                                fe.value[0].fixed), _defineProperty$V(Ft, "".concat(
                                    at, "-has-fix-right"), fe.value[Re.value - 1] &&
                                fe.value[Re.value - 1].fixed === "right"),
                            _defineProperty$V(Ft, W.class, W.class), Ft)),
                        style: W.style,
                        id: _t,
                        ref: me
                    }), [yt && createVNode(Panel, {
                        class: "".concat(at, "-title")
                    }, {
                        default: function () {
                            return [yt(X.value)]
                        }
                    }), createVNode("div", {
                        class: "".concat(at, "-container")
                    }, [zt()]), Ct && createVNode(Panel, {
                        class: "".concat(at, "-footer")
                    }, {
                        default: function () {
                            return [Ct(X.value)]
                        }
                    })])
                };
            return Fe.value ? createVNode(ResizeObserver$1, {
                onResize: ut
            }, {
                default: Kt
            }) : Kt()
        }
    }
});
var DEFAULT_PAGE_SIZE = 10;

function getPaginationParam(K, C) {
    var H = {
            current: C.current,
            pageSize: C.pageSize
        },
        W = K && _typeof$2(K) === "object" ? K : {};
    return Object.keys(W).forEach(function (U) {
        var G = C[U];
        typeof G != "function" && (H[U] = G)
    }), H
}

function extendsObject() {
    for (var K = {}, C = arguments.length, H = new Array(C), W = 0; W < C; W++) H[W] = arguments[W];
    return H.forEach(function (U) {
        U && Object.keys(U).forEach(function (G) {
            var X = U[G];
            X !== void 0 && (K[G] = X)
        })
    }), K
}

function usePagination(K, C, H) {
    var W = computed(function () {
            return C.value && _typeof$2(C.value) === "object" ? C.value : {}
        }),
        U = computed(function () {
            return W.value.total || 0
        }),
        G = useState(function () {
            return {
                current: "defaultCurrent" in W.value ? W.value.defaultCurrent : 1,
                pageSize: "defaultPageSize" in W.value ? W.value.defaultPageSize : DEFAULT_PAGE_SIZE
            }
        }),
        X = _slicedToArray$2(G, 2),
        Z = X[0],
        Q = X[1],
        ee = computed(function () {
            var re = extendsObject(Z.value, W.value, {
                    total: U.value > 0 ? U.value : K.value
                }),
                ae = Math.ceil((U.value || K.value) / re.pageSize);
            return re.current > ae && (re.current = ae || 1), re
        }),
        ne = function (ae, oe) {
            W.value !== !1 && Q({
                current: ae || 1,
                pageSize: oe || ee.value.pageSize
            })
        },
        te = function (ae, oe) {
            if (W.value) {
                var ie, ue;
                (ie = (ue = W.value).onChange) === null || ie === void 0 || ie.call(ue, ae, oe)
            }
            ne(ae, oe), H(ae, oe || ee.value.pageSize)
        };
    return [computed(function () {
        return W.value === !1 ? {} : _objectSpread2$1(_objectSpread2$1({}, ee.value), {}, {
            onChange: te
        })
    }), ne]
}

function useLazyKVMap(K, C, H) {
    var W = shallowRef({});
    watch([K, C, H], function () {
        var G = new Map,
            X = H.value,
            Z = C.value;

        function Q(ee) {
            ee.forEach(function (ne, te) {
                var re = X(ne, te);
                G.set(re, ne), ne && _typeof$2(ne) === "object" && Z in ne && Q(ne[Z] || [])
            })
        }
        Q(K.value), W.value = {
            kvMap: G
        }
    }, {
        deep: !0,
        immediate: !0
    });

    function U(G) {
        return W.value.kvMap.get(G)
    }
    return [U]
}
var SELECTION_COLUMN = {},
    SELECTION_ALL = "SELECT_ALL",
    SELECTION_INVERT = "SELECT_INVERT",
    SELECTION_NONE = "SELECT_NONE",
    EMPTY_LIST$1 = [];

function flattenData(K, C) {
    var H = [];
    return (K || []).forEach(function (W) {
        H.push(W), W && _typeof$2(W) === "object" && C in W && (H = [].concat(_toConsumableArray(H),
            _toConsumableArray(flattenData(W[C], C))))
    }), H
}

function useSelection(K, C) {
    var H = computed(function () {
            var xe = K.value || {},
                Pe = xe.checkStrictly,
                $e = Pe === void 0 ? !0 : Pe;
            return _objectSpread2$1(_objectSpread2$1({}, xe), {}, {
                checkStrictly: $e
            })
        }),
        W = useMergedState(H.value.selectedRowKeys || H.value.defaultSelectedRowKeys || EMPTY_LIST$1, {
            value: computed(function () {
                return H.value.selectedRowKeys
            })
        }),
        U = _slicedToArray$2(W, 2),
        G = U[0],
        X = U[1],
        Z = shallowRef(new Map),
        Q = function (Pe) {
            if (H.value.preserveSelectedRowKeys) {
                var $e = new Map;
                Pe.forEach(function (ye) {
                    var Ce = C.getRecordByKey(ye);
                    !Ce && Z.value.has(ye) && (Ce = Z.value.get(ye)), $e.set(ye, Ce)
                }), Z.value = $e
            }
        };
    watchEffect(function () {
        Q(G.value)
    });
    var ee = computed(function () {
            return H.value.checkStrictly ? null : convertDataToEntities(C.data.value, {
                externalGetKey: C.getRowKey.value,
                childrenPropName: C.childrenColumnName.value
            }).keyEntities
        }),
        ne = computed(function () {
            return flattenData(C.pageData.value, C.childrenColumnName.value)
        }),
        te = computed(function () {
            var xe = new Map,
                Pe = C.getRowKey.value,
                $e = H.value.getCheckboxProps;
            return ne.value.forEach(function (ye, Ce) {
                var we = Pe(ye, Ce),
                    Oe = ($e ? $e(ye) : null) || {};
                xe.set(we, Oe)
            }), xe
        }),
        re = useMaxLevel(ee),
        ae = re.maxLevel,
        oe = re.levelEntities,
        ie = function (Pe) {
            var $e;
            return !!(($e = te.value.get(C.getRowKey.value(Pe))) !== null && $e !== void 0 && $e.disabled)
        },
        ue = computed(function () {
            if (H.value.checkStrictly) return [G.value || [], []];
            var xe = conductCheck(G.value, !0, ee.value, ae.value, oe.value, ie),
                Pe = xe.checkedKeys,
                $e = xe.halfCheckedKeys;
            return [Pe || [], $e]
        }),
        le = computed(function () {
            return ue.value[0]
        }),
        se = computed(function () {
            return ue.value[1]
        }),
        ce = computed(function () {
            var xe = H.value.type === "radio" ? le.value.slice(0, 1) : le.value;
            return new Set(xe)
        }),
        de = computed(function () {
            return H.value.type === "radio" ? new Set : new Set(se.value)
        }),
        ve = useState(null),
        fe = _slicedToArray$2(ve, 2),
        pe = fe[0],
        me = fe[1],
        he = function (Pe) {
            var $e, ye;
            Q(Pe);
            var Ce = H.value,
                we = Ce.preserveSelectedRowKeys,
                Oe = Ce.onChange,
                Ne = C.getRecordByKey;
            we ? ($e = Pe, ye = Pe.map(function (Me) {
                return Z.value.get(Me)
            })) : ($e = [], ye = [], Pe.forEach(function (Me) {
                var Ve = Ne(Me);
                Ve !== void 0 && ($e.push(Me), ye.push(Ve))
            })), X($e), Oe == null || Oe($e, ye)
        },
        Se = function (Pe, $e, ye, Ce) {
            var we = H.value.onSelect,
                Oe = C || {},
                Ne = Oe.getRecordByKey;
            if (we) {
                var Me = ye.map(function (Ve) {
                    return Ne(Ve)
                });
                we(Ne(Pe), $e, Me, Ce)
            }
            he(ye)
        },
        _e = computed(function () {
            var xe = H.value,
                Pe = xe.onSelectInvert,
                $e = xe.onSelectNone,
                ye = xe.selections,
                Ce = xe.hideSelectAll,
                we = C.data,
                Oe = C.pageData,
                Ne = C.getRowKey,
                Me = C.locale;
            if (!ye || Ce) return null;
            var Ve = ye === !0 ? [SELECTION_ALL, SELECTION_INVERT, SELECTION_NONE] : ye;
            return Ve.map(function (ke) {
                return ke === SELECTION_ALL ? {
                    key: "all",
                    text: Me.value.selectionAll,
                    onSelect: function () {
                        he(we.value.map(function (Ae, Re) {
                            return Ne.value(Ae, Re)
                        }).filter(function (Ae) {
                            var Re = te.value.get(Ae);
                            return !(Re != null && Re.disabled) || ce.value.has(Ae)
                        }))
                    }
                } : ke === SELECTION_INVERT ? {
                    key: "invert",
                    text: Me.value.selectInvert,
                    onSelect: function () {
                        var Ae = new Set(ce.value);
                        Oe.value.forEach(function (He, je) {
                            var Fe = Ne.value(He, je),
                                Le = te.value.get(Fe);
                            Le != null && Le.disabled || (Ae.has(Fe) ? Ae.delete(Fe) : Ae.add(
                                Fe))
                        });
                        var Re = Array.from(Ae);
                        Pe && (devWarning(!1, "Table",
                            "`onSelectInvert` will be removed in future. Please use `onChange` instead."
                        ), Pe(Re)), he(Re)
                    }
                } : ke === SELECTION_NONE ? {
                    key: "none",
                    text: Me.value.selectNone,
                    onSelect: function () {
                        $e == null || $e(), he(Array.from(ce.value).filter(function (Ae) {
                            var Re = te.value.get(Ae);
                            return Re == null ? void 0 : Re.disabled
                        }))
                    }
                } : ke
            })
        }),
        be = computed(function () {
            return ne.value.length
        }),
        ge = function (Pe) {
            var $e, ye = H.value,
                Ce = ye.onSelectAll,
                we = ye.onSelectMultiple,
                Oe = ye.columnWidth,
                Ne = ye.type,
                Me = ye.fixed,
                Ve = ye.renderCell,
                ke = ye.hideSelectAll,
                Ee = ye.checkStrictly,
                Ae = C.prefixCls,
                Re = C.getRecordByKey,
                He = C.getRowKey,
                je = C.expandType,
                Fe = C.getPopupContainer;
            if (!K.value) return Pe.filter(function (Qe) {
                return Qe !== SELECTION_COLUMN
            });
            var Le = Pe.slice(),
                Ie = new Set(ce.value),
                Te = ne.value.map(He.value).filter(function (Qe) {
                    return !te.value.get(Qe).disabled
                }),
                De = Te.every(function (Qe) {
                    return Ie.has(Qe)
                }),
                Ke = Te.some(function (Qe) {
                    return Ie.has(Qe)
                }),
                We = function () {
                    var lt = [];
                    De ? Te.forEach(function (dt) {
                        Ie.delete(dt), lt.push(dt)
                    }) : Te.forEach(function (dt) {
                        Ie.has(dt) || (Ie.add(dt), lt.push(dt))
                    });
                    var ct = Array.from(Ie);
                    Ce == null || Ce(!De, ct.map(function (dt) {
                        return Re(dt)
                    }), lt.map(function (dt) {
                        return Re(dt)
                    })), he(ct)
                },
                Ue;
            if (Ne !== "radio") {
                var et;
                if (_e.value) {
                    var Ye = createVNode(Menu, {
                        getPopupContainer: Fe.value
                    }, {
                        default: function () {
                            return [_e.value.map(function (lt, ct) {
                                var dt = lt.key,
                                    tt = lt.text,
                                    at = lt.onSelect;
                                return createVNode(Menu.Item, {
                                    key: dt || ct,
                                    onClick: function () {
                                        at == null || at(Te)
                                    }
                                }, {
                                    default: function () {
                                        return [tt]
                                    }
                                })
                            })]
                        }
                    });
                    et = createVNode("div", {
                        class: "".concat(Ae.value, "-selection-extra")
                    }, [createVNode(Dropdown$1, {
                        overlay: Ye,
                        getPopupContainer: Fe.value
                    }, {
                        default: function () {
                            return [createVNode("span", null, [createVNode(DownOutlined$1, null,
                                null)])]
                        }
                    })])
                }
                var ze = ne.value.map(function (Qe, lt) {
                        var ct = He.value(Qe, lt),
                            dt = te.value.get(ct) || {};
                        return _objectSpread2$1({
                            checked: Ie.has(ct)
                        }, dt)
                    }).filter(function (Qe) {
                        var lt = Qe.disabled;
                        return lt
                    }),
                    Be = !!ze.length && ze.length === be.value,
                    Ge = Be && ze.every(function (Qe) {
                        var lt = Qe.checked;
                        return lt
                    }),
                    Xe = Be && ze.some(function (Qe) {
                        var lt = Qe.checked;
                        return lt
                    });
                Ue = !ke && createVNode("div", {
                    class: "".concat(Ae.value, "-selection")
                }, [createVNode(Checkbox, {
                    checked: Be ? Ge : !!be.value && De,
                    indeterminate: Be ? !Ge && Xe : !De && Ke,
                    onChange: We,
                    disabled: be.value === 0 || Be,
                    skipGroup: !0
                }, null), et])
            }
            var nt;
            Ne === "radio" ? nt = function (lt) {
                var ct = lt.record,
                    dt = lt.index,
                    tt = He.value(ct, dt),
                    at = Ie.has(tt);
                return {
                    node: createVNode(Radio, _objectSpread2$1(_objectSpread2$1({}, te.value.get(tt)), {}, {
                        checked: at,
                        onClick: function (gt) {
                            return gt.stopPropagation()
                        },
                        onChange: function (gt) {
                            Ie.has(tt) || Se(tt, !0, [tt], gt.nativeEvent)
                        }
                    }), null),
                    checked: at
                }
            } : nt = function (lt) {
                var ct = lt.record,
                    dt = lt.index,
                    tt = He.value(ct, dt),
                    at = Ie.has(tt),
                    vt = de.value.has(tt),
                    gt = te.value.get(tt),
                    mt;
                if (je.value === "nest") mt = vt, devWarning(typeof (gt == null ? void 0 : gt.indeterminate) !=
                    "boolean", "Table",
                    "set `indeterminate` using `rowSelection.getCheckboxProps` is not allowed with tree structured dataSource."
                );
                else {
                    var ht;
                    mt = (ht = gt == null ? void 0 : gt.indeterminate) !== null && ht !== void 0 ? ht : vt
                }
                return {
                    node: createVNode(Checkbox, _objectSpread2$1(_objectSpread2$1({}, gt), {}, {
                        indeterminate: mt,
                        checked: at,
                        skipGroup: !0,
                        onClick: function (St) {
                            return St.stopPropagation()
                        },
                        onChange: function (St) {
                            var Ct = St.nativeEvent,
                                _t = Ct.shiftKey,
                                wt = -1,
                                Et = -1;
                            if (_t && Ee) {
                                var xt = new Set([pe.value, tt]);
                                Te.some(function (At, Wt) {
                                    if (xt.has(At))
                                        if (wt === -1) wt = Wt;
                                        else return Et = Wt, !0;
                                    return !1
                                })
                            }
                            if (Et !== -1 && wt !== Et && Ee) {
                                var kt = Te.slice(wt, Et + 1),
                                    Nt = [];
                                at ? kt.forEach(function (At) {
                                    Ie.has(At) && (Nt.push(At), Ie.delete(At))
                                }) : kt.forEach(function (At) {
                                    Ie.has(At) || (Nt.push(At), Ie.add(At))
                                });
                                var Rt = Array.from(Ie);
                                we == null || we(!at, Rt.map(function (At) {
                                    return Re(At)
                                }), Nt.map(function (At) {
                                    return Re(At)
                                })), he(Rt)
                            } else {
                                var It = le.value;
                                if (Ee) {
                                    var Lt = at ? arrDel(It, tt) : arrAdd(It, tt);
                                    Se(tt, !at, Lt, Ct)
                                } else {
                                    var jt = conductCheck([].concat(_toConsumableArray(It), [tt]),
                                            !0, ee.value, ae.value, oe.value, ie),
                                        Mt = jt.checkedKeys,
                                        Vt = jt.halfCheckedKeys,
                                        Dt = Mt;
                                    if (at) {
                                        var zt = new Set(Mt);
                                        zt.delete(tt), Dt = conductCheck(Array.from(zt), {
                                            checked: !1,
                                            halfCheckedKeys: Vt
                                        }, ee.value, ae.value, oe.value, ie).checkedKeys
                                    }
                                    Se(tt, !at, Dt, Ct)
                                }
                            }
                            me(tt)
                        }
                    }), null),
                    checked: at
                }
            };
            var it = function (lt) {
                var ct = lt.record,
                    dt = lt.index,
                    tt = nt({
                        record: ct,
                        index: dt
                    }),
                    at = tt.node,
                    vt = tt.checked;
                return Ve ? Ve(vt, ct, dt, at) : at
            };
            if (!Le.includes(SELECTION_COLUMN))
                if (Le.findIndex(function (Qe) {
                        var lt;
                        return ((lt = Qe[INTERNAL_COL_DEFINE]) === null || lt === void 0 ? void 0 : lt.columnType) ===
                            "EXPAND_COLUMN"
                    }) === 0) {
                    var ft = Le,
                        pt = _toArray(ft),
                        ot = pt[0],
                        Ze = pt.slice(1);
                    Le = [ot, SELECTION_COLUMN].concat(_toConsumableArray(Ze))
                } else Le = [SELECTION_COLUMN].concat(_toConsumableArray(Le));
            var ut = Le.indexOf(SELECTION_COLUMN);
            Le = Le.filter(function (Qe, lt) {
                return Qe !== SELECTION_COLUMN || lt === ut
            });
            var st = Le[ut - 1],
                rt = Le[ut + 1],
                qe = Me;
            qe === void 0 && ((rt == null ? void 0 : rt.fixed) !== void 0 ? qe = rt.fixed : (st == null ? void 0 : st.fixed) !==
                void 0 && (qe = st.fixed)), qe && st && (($e = st[INTERNAL_COL_DEFINE]) === null || $e === void 0 ?
                void 0 : $e.columnType) === "EXPAND_COLUMN" && st.fixed === void 0 && (st.fixed = qe);
            var Je = _defineProperty$V({
                fixed: qe,
                width: Oe,
                className: "".concat(Ae.value, "-selection-column"),
                title: H.value.columnTitle || Ue,
                customRender: it
            }, INTERNAL_COL_DEFINE, {
                class: "".concat(Ae.value, "-selection-col")
            });
            return Le.map(function (Qe) {
                return Qe === SELECTION_COLUMN ? Je : Qe
            })
        };
    return [ge, ce]
}
var CaretDownOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "0 0 1024 1024",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z"
            }
        }]
    },
    name: "caret-down",
    theme: "outlined"
};
const CaretDownOutlinedSvg = CaretDownOutlined$2;

function _objectSpread$h(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$h(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$h(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var CaretDownOutlined = function (C, H) {
    var W = _objectSpread$h({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$h({}, W, {
        icon: CaretDownOutlinedSvg
    }), null)
};
CaretDownOutlined.displayName = "CaretDownOutlined";
CaretDownOutlined.inheritAttrs = !1;
const CaretDownOutlined$1 = CaretDownOutlined;
var CaretUpOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "0 0 1024 1024",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M858.9 689L530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z"
            }
        }]
    },
    name: "caret-up",
    theme: "outlined"
};
const CaretUpOutlinedSvg = CaretUpOutlined$2;

function _objectSpread$g(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$g(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$g(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var CaretUpOutlined = function (C, H) {
    var W = _objectSpread$g({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$g({}, W, {
        icon: CaretUpOutlinedSvg
    }), null)
};
CaretUpOutlined.displayName = "CaretUpOutlined";
CaretUpOutlined.inheritAttrs = !1;
const CaretUpOutlined$1 = CaretUpOutlined;
var _excluded$b = ["default"];

function getColumnKey(K, C) {
    return "key" in K && K.key !== void 0 && K.key !== null ? K.key : K.dataIndex ? Array.isArray(K.dataIndex) ? K.dataIndex
        .join(".") : K.dataIndex : C
}

function getColumnPos(K, C) {
    return C ? "".concat(C, "-").concat(K) : "".concat(K)
}

function renderColumnTitle(K, C) {
    return typeof K == "function" ? K(C) : K
}

function convertChildrenToColumns() {
    var K = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
        C = flattenChildren(K),
        H = [];
    return C.forEach(function (W) {
        var U, G, X;
        if (W) {
            for (var Z = W.key, Q = ((U = W.props) === null || U === void 0 ? void 0 : U.style) || {}, ee = ((G =
                        W.props) === null || G === void 0 ? void 0 : G.class) || "", ne = W.props || {}, te = 0,
                    re = Object.entries(ne); te < re.length; te++) {
                var ae = _slicedToArray$2(re[te], 2),
                    oe = ae[0],
                    ie = ae[1];
                ne[camelize$1(oe)] = ie
            }
            var ue = W.children || {},
                le = ue.default,
                se = _objectWithoutProperties$2(ue, _excluded$b),
                ce = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, se), ne), {}, {
                    style: Q,
                    class: ee
                });
            if (Z && (ce.key = Z), (X = W.type) !== null && X !== void 0 && X.__ANT_TABLE_COLUMN_GROUP) ce.children =
                convertChildrenToColumns(typeof le == "function" ? le() : le);
            else {
                var de, ve = (de = W.children) === null || de === void 0 ? void 0 : de.default;
                ce.customRender = ce.customRender || ve
            }
            H.push(ce)
        }
    }), H
}
var ASCEND = "ascend",
    DESCEND = "descend";

function getMultiplePriority(K) {
    return _typeof$2(K.sorter) === "object" && typeof K.sorter.multiple == "number" ? K.sorter.multiple : !1
}

function getSortFunction(K) {
    return typeof K == "function" ? K : K && _typeof$2(K) === "object" && K.compare ? K.compare : !1
}

function nextSortDirection(K, C) {
    return C ? K[K.indexOf(C) + 1] : K[0]
}

function collectSortStates(K, C, H) {
    var W = [];

    function U(G, X) {
        W.push({
            column: G,
            key: getColumnKey(G, X),
            multiplePriority: getMultiplePriority(G),
            sortOrder: G.sortOrder
        })
    }
    return (K || []).forEach(function (G, X) {
        var Z = getColumnPos(X, H);
        G.children ? ("sortOrder" in G && U(G, Z), W = [].concat(_toConsumableArray(W), _toConsumableArray(
            collectSortStates(G.children, C, Z)))) : G.sorter && ("sortOrder" in G ? U(G, Z) : C && G.defaultSortOrder &&
            W.push({
                column: G,
                key: getColumnKey(G, Z),
                multiplePriority: getMultiplePriority(G),
                sortOrder: G.defaultSortOrder
            }))
    }), W
}

function injectSorter(K, C, H, W, U, G, X, Z) {
    return (C || []).map(function (Q, ee) {
        var ne = getColumnPos(ee, Z),
            te = Q;
        if (te.sorter) {
            var re = te.sortDirections || U,
                ae = te.showSorterTooltip === void 0 ? X : te.showSorterTooltip,
                oe = getColumnKey(te, ne),
                ie = H.find(function (Se) {
                    var _e = Se.key;
                    return _e === oe
                }),
                ue = ie ? ie.sortOrder : null,
                le = nextSortDirection(re, ue),
                se = re.includes(ASCEND) && createVNode(CaretUpOutlined$1, {
                    class: classNames("".concat(K, "-column-sorter-up"), {
                        active: ue === ASCEND
                    })
                }, null),
                ce = re.includes(DESCEND) && createVNode(CaretDownOutlined$1, {
                    class: classNames("".concat(K, "-column-sorter-down"), {
                        active: ue === DESCEND
                    })
                }, null),
                de = G || {},
                ve = de.cancelSort,
                fe = de.triggerAsc,
                pe = de.triggerDesc,
                me = ve;
            le === DESCEND ? me = pe : le === ASCEND && (me = fe);
            var he = _typeof$2(ae) === "object" ? ae : {
                title: me
            };
            te = _objectSpread2$1(_objectSpread2$1({}, te), {}, {
                className: classNames(te.className, _defineProperty$V({}, "".concat(K, "-column-sort"),
                    ue)),
                title: function (_e) {
                    var be = createVNode("div", {
                        class: "".concat(K, "-column-sorters")
                    }, [createVNode("span", {
                        class: "".concat(K, "-column-title")
                    }, [renderColumnTitle(Q.title, _e)]), createVNode("span", {
                        class: classNames("".concat(K, "-column-sorter"),
                            _defineProperty$V({}, "".concat(K,
                                "-column-sorter-full"), !!(se && ce)))
                    }, [createVNode("span", {
                        class: "".concat(K, "-column-sorter-inner")
                    }, [se, ce])])]);
                    return ae ? createVNode(Tooltip, he, {
                        default: function () {
                            return [be]
                        }
                    }) : be
                },
                customHeaderCell: function (_e) {
                    var be = Q.customHeaderCell && Q.customHeaderCell(_e) || {},
                        ge = be.onClick;
                    return be.onClick = function (xe) {
                        W({
                            column: Q,
                            key: oe,
                            sortOrder: le,
                            multiplePriority: getMultiplePriority(Q)
                        }), ge && ge(xe)
                    }, be.class = classNames(be.class, "".concat(K, "-column-has-sorters")), be
                }
            })
        }
        return "children" in te && (te = _objectSpread2$1(_objectSpread2$1({}, te), {}, {
            children: injectSorter(K, te.children, H, W, U, G, X, ne)
        })), te
    })
}

function stateToInfo(K) {
    var C = K.column,
        H = K.sortOrder;
    return {
        column: C,
        order: H,
        field: C.dataIndex,
        columnKey: C.key
    }
}

function generateSorterInfo(K) {
    var C = K.filter(function (H) {
        var W = H.sortOrder;
        return W
    }).map(stateToInfo);
    return C.length === 0 && K.length ? _objectSpread2$1(_objectSpread2$1({}, stateToInfo(K[K.length - 1])), {}, {
        column: void 0
    }) : C.length <= 1 ? C[0] || {} : C
}

function getSortData(K, C, H) {
    var W = C.slice().sort(function (X, Z) {
            return Z.multiplePriority - X.multiplePriority
        }),
        U = K.slice(),
        G = W.filter(function (X) {
            var Z = X.column.sorter,
                Q = X.sortOrder;
            return getSortFunction(Z) && Q
        });
    return G.length ? U.sort(function (X, Z) {
        for (var Q = 0; Q < G.length; Q += 1) {
            var ee = G[Q],
                ne = ee.column.sorter,
                te = ee.sortOrder,
                re = getSortFunction(ne);
            if (re && te) {
                var ae = re(X, Z, te);
                if (ae !== 0) return te === ASCEND ? ae : -ae
            }
        }
        return 0
    }).map(function (X) {
        var Z = X[H];
        return Z ? _objectSpread2$1(_objectSpread2$1({}, X), {}, _defineProperty$V({}, H, getSortData(Z, C, H))) :
            X
    }) : U
}

function useFilterSorter(K) {
    var C = K.prefixCls,
        H = K.mergedColumns,
        W = K.onSorterChange,
        U = K.sortDirections,
        G = K.tableLocale,
        X = K.showSorterTooltip,
        Z = useState(collectSortStates(H.value, !0)),
        Q = _slicedToArray$2(Z, 2),
        ee = Q[0],
        ne = Q[1],
        te = computed(function () {
            var ue = !0,
                le = collectSortStates(H.value, !1);
            if (!le.length) return ee.value;
            var se = [];

            function ce(ve) {
                ue ? se.push(ve) : se.push(_objectSpread2$1(_objectSpread2$1({}, ve), {}, {
                    sortOrder: null
                }))
            }
            var de = null;
            return le.forEach(function (ve) {
                de === null ? (ce(ve), ve.sortOrder && (ve.multiplePriority === !1 ? ue = !1 : de = !0)) :
                    (de && ve.multiplePriority !== !1 || (ue = !1), ce(ve))
            }), se
        }),
        re = computed(function () {
            var ue = te.value.map(function (le) {
                var se = le.column,
                    ce = le.sortOrder;
                return {
                    column: se,
                    order: ce
                }
            });
            return {
                sortColumns: ue,
                sortColumn: ue[0] && ue[0].column,
                sortOrder: ue[0] && ue[0].order
            }
        });

    function ae(ue) {
        var le;
        ue.multiplePriority === !1 || !te.value.length || te.value[0].multiplePriority === !1 ? le = [ue] : le = [].concat(
            _toConsumableArray(te.value.filter(function (se) {
                var ce = se.key;
                return ce !== ue.key
            })), [ue]), ne(le), W(generateSorterInfo(le), le)
    }
    var oe = function (le) {
            return injectSorter(C.value, le, te.value, ae, U.value, G.value, X.value)
        },
        ie = computed(function () {
            return generateSorterInfo(te.value)
        });
    return [oe, te, re, ie]
}
var FilterFilled$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M349 838c0 17.7 14.2 32 31.8 32h262.4c17.6 0 31.8-14.3 31.8-32V642H349v196zm531.1-684H143.9c-24.5 0-39.8 26.7-27.5 48l221.3 376h348.8l221.3-376c12.1-21.3-3.2-48-27.7-48z"
            }
        }]
    },
    name: "filter",
    theme: "filled"
};
const FilterFilledSvg = FilterFilled$2;

function _objectSpread$f(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$f(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$f(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var FilterFilled = function (C, H) {
    var W = _objectSpread$f({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$f({}, W, {
        icon: FilterFilledSvg
    }), null)
};
FilterFilled.displayName = "FilterFilled";
FilterFilled.inheritAttrs = !1;
const FilterFilled$1 = FilterFilled;
var FilterDropdownMenuWrapper = function (C, H) {
    var W, U = H.slots;
    return createVNode("div", {
        onClick: function (X) {
            return X.stopPropagation()
        }
    }, [(W = U.default) === null || W === void 0 ? void 0 : W.call(U)])
};
const FilterDropdownMenuWrapper$1 = FilterDropdownMenuWrapper,
    FilterSearch = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "FilterSearch",
        inheritAttrs: !1,
        props: {
            value: String,
            onChange: Function,
            filterSearch: Boolean,
            tablePrefixCls: String,
            locale: {
                type: Object,
                default: void 0
            }
        },
        setup: function (C) {
            return function () {
                var H = C.value,
                    W = C.onChange,
                    U = C.filterSearch,
                    G = C.tablePrefixCls,
                    X = C.locale;
                return U ? createVNode("div", {
                    class: "".concat(G, "-filter-dropdown-search")
                }, [createVNode(Input, {
                    placeholder: X.filterSearchPlaceholder,
                    onChange: W,
                    value: H,
                    htmlSize: 1,
                    class: "".concat(G, "-filter-dropdown-search-input")
                }, {
                    prefix: function () {
                        return createVNode(SearchOutlined$1, null, null)
                    }
                })]) : null
            }
        }
    });
var _excluded$a = ["motion", "motionNodes", "motionType", "active", "eventKey"];
const MotionTreeNode = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "MotionTreeNode",
    inheritAttrs: !1,
    props: _objectSpread2$1(_objectSpread2$1({}, treeNodeProps), {}, {
        active: Boolean,
        motion: Object,
        motionNodes: {
            type: Array
        },
        onMotionStart: Function,
        onMotionEnd: Function,
        motionType: String
    }),
    slots: ["title", "icon", "switcherIcon", "checkable"],
    setup: function (C, H) {
        var W = H.attrs,
            U = H.slots,
            G = ref(!0),
            X = useInjectTreeContext(),
            Z = ref(!1),
            Q = computed(function () {
                return C.motion ? C.motion : collapseMotion$1()
            }),
            ee = function (te, re) {
                if (re === "appear") {
                    var ae, oe;
                    (ae = Q.value) === null || ae === void 0 || (oe = ae.onAfterEnter) === null || oe ===
                        void 0 || oe.call(ae, te)
                } else if (re === "leave") {
                    var ie, ue;
                    (ie = Q.value) === null || ie === void 0 || (ue = ie.onAfterLeave) === null || ue ===
                        void 0 || ue.call(ie, te)
                }
                Z.value || C.onMotionEnd(), Z.value = !0
            };
        return watch(function () {
                return C.motionNodes
            }, function () {
                C.motionNodes && C.motionType === "hide" && G.value && nextTick(function () {
                    G.value = !1
                })
            }, {
                immediate: !0,
                flush: "post"
            }), onMounted(function () {
                C.motionNodes && C.onMotionStart()
            }), onBeforeUnmount(function () {
                C.motionNodes && ee()
            }),
            function () {
                C.motion;
                var ne = C.motionNodes,
                    te = C.motionType,
                    re = C.active,
                    ae = C.eventKey,
                    oe = _objectWithoutProperties$2(C, _excluded$a);
                return ne ? createVNode(Transition, _objectSpread2$1(_objectSpread2$1({}, Q.value), {}, {
                    appear: te === "show",
                    onAfterAppear: function (ue) {
                        return ee(ue, "appear")
                    },
                    onAfterLeave: function (ue) {
                        return ee(ue, "leave")
                    }
                }), {
                    default: function () {
                        return [withDirectives(createVNode("div", {
                            class: "".concat(X.value.prefixCls,
                                "-treenode-motion")
                        }, [ne.map(function (ue) {
                            var le = _extends$1({}, (
                                    _objectDestructuringEmpty(ue.data),
                                    ue.data)),
                                se = ue.title,
                                ce = ue.key,
                                de = ue.isStart,
                                ve = ue.isEnd;
                            return delete le.children, createVNode(
                                VcTreeNode, _objectSpread2$1(
                                    _objectSpread2$1({}, le), {}, {
                                        title: se,
                                        active: re,
                                        data: ue.data,
                                        key: ce,
                                        eventKey: ce,
                                        isStart: de,
                                        isEnd: ve
                                    }), U)
                        })]), [[vShow, G.value]])]
                    }
                }) : createVNode(VcTreeNode, _objectSpread2$1(_objectSpread2$1({
                    domRef: ref,
                    class: W.class,
                    style: W.style
                }, oe), {}, {
                    active: re,
                    eventKey: ae
                }), U)
            }
    }
});

function findExpandedKeys() {
    var K = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
        C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
        H = K.length,
        W = C.length;
    if (Math.abs(H - W) !== 1) return {
        add: !1,
        key: null
    };

    function U(G, X) {
        var Z = new Map;
        G.forEach(function (ee) {
            Z.set(ee, !0)
        });
        var Q = X.filter(function (ee) {
            return !Z.has(ee)
        });
        return Q.length === 1 ? Q[0] : null
    }
    return H < W ? {
        add: !0,
        key: U(K, C)
    } : {
        add: !1,
        key: U(C, K)
    }
}

function getExpandRange(K, C, H) {
    var W = K.findIndex(function (Z) {
            return Z.key === H
        }),
        U = K[W + 1],
        G = C.findIndex(function (Z) {
            return Z.key === H
        });
    if (U) {
        var X = C.findIndex(function (Z) {
            return Z.key === U.key
        });
        return C.slice(G + 1, X)
    }
    return C.slice(G + 1)
}
var _excluded$9 = ["prefixCls", "selectable", "checkable", "disabled", "motion", "height", "itemHeight", "virtual",
        "focusable", "activeItem", "focused", "tabindex", "onKeydown", "onFocus", "onBlur", "onListChangeStart",
        "onListChangeEnd"],
    HIDDEN_STYLE$1 = {
        width: 0,
        height: 0,
        display: "flex",
        overflow: "hidden",
        opacity: 0,
        border: 0,
        padding: 0,
        margin: 0
    },
    noop$3 = function () {},
    MOTION_KEY = "RC_TREE_MOTION_".concat(Math.random()),
    MotionNode = {
        key: MOTION_KEY
    },
    MotionEntity = {
        key: MOTION_KEY,
        level: 0,
        index: 0,
        pos: "0",
        node: MotionNode,
        nodes: [MotionNode]
    },
    MotionFlattenData = {
        parent: null,
        children: [],
        pos: MotionEntity.pos,
        data: MotionNode,
        title: null,
        key: MOTION_KEY,
        isStart: [],
        isEnd: []
    };

function getMinimumRangeTransitionRange(K, C, H, W) {
    return C === !1 || !H ? K : K.slice(0, Math.ceil(H / W) + 1)
}

function itemKey(K) {
    var C = K.key,
        H = K.pos;
    return getKey(C, H)
}

function getAccessibilityPath(K) {
    for (var C = String(K.key), H = K; H.parent;) H = H.parent, C = "".concat(H.key, " > ").concat(C);
    return C
}
const NodeList = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "NodeList",
    inheritAttrs: !1,
    props: nodeListProps,
    setup: function (C, H) {
        var W = H.expose,
            U = H.attrs,
            G = ref(),
            X = ref(),
            Z = useInjectKeysState(),
            Q = Z.expandedKeys,
            ee = Z.flattenNodes;
        W({
            scrollTo: function (se) {
                G.value.scrollTo(se)
            },
            getIndentWidth: function () {
                return X.value.offsetWidth
            }
        });
        var ne = shallowRef(ee.value),
            te = shallowRef([]),
            re = ref(null);

        function ae() {
            ne.value = ee.value, te.value = [], re.value = null, C.onListChangeEnd()
        }
        var oe = useInjectTreeContext();
        watch([function () {
            return Q.value.slice()
        }, ee], function (le, se) {
            var ce = _slicedToArray$2(le, 2),
                de = ce[0],
                ve = ce[1],
                fe = _slicedToArray$2(se, 2),
                pe = fe[0],
                me = fe[1],
                he = findExpandedKeys(pe, de);
            if (he.key !== null) {
                var Se = C.virtual,
                    _e = C.height,
                    be = C.itemHeight;
                if (he.add) {
                    var ge = me.findIndex(function (we) {
                            var Oe = we.key;
                            return Oe === he.key
                        }),
                        xe = getMinimumRangeTransitionRange(getExpandRange(me, ve, he.key), Se, _e,
                            be),
                        Pe = me.slice();
                    Pe.splice(ge + 1, 0, MotionFlattenData), ne.value = Pe, te.value = xe, re.value =
                        "show"
                } else {
                    var $e = ve.findIndex(function (we) {
                            var Oe = we.key;
                            return Oe === he.key
                        }),
                        ye = getMinimumRangeTransitionRange(getExpandRange(ve, me, he.key), Se, _e,
                            be),
                        Ce = ve.slice();
                    Ce.splice($e + 1, 0, MotionFlattenData), ne.value = Ce, te.value = ye, re.value =
                        "hide"
                }
            } else me !== ve && (ne.value = ve)
        }), watch(function () {
            return oe.value.dragging
        }, function (le) {
            le || ae()
        });
        var ie = computed(function () {
                return C.motion === void 0 ? ne.value : ee.value
            }),
            ue = function () {
                C.onActiveChange(null)
            };
        return function () {
            var le = _objectSpread2$1(_objectSpread2$1({}, C), U),
                se = le.prefixCls;
            le.selectable, le.checkable;
            var ce = le.disabled,
                de = le.motion,
                ve = le.height,
                fe = le.itemHeight,
                pe = le.virtual,
                me = le.focusable,
                he = le.activeItem,
                Se = le.focused,
                _e = le.tabindex,
                be = le.onKeydown,
                ge = le.onFocus,
                xe = le.onBlur,
                Pe = le.onListChangeStart;
            le.onListChangeEnd;
            var $e = _objectWithoutProperties$2(le, _excluded$9);
            return createVNode(Fragment, null, [Se && he && createVNode("span", {
                style: HIDDEN_STYLE$1,
                "aria-live": "assertive"
            }, [getAccessibilityPath(he)]), createVNode("div", null, [createVNode("input", {
                style: HIDDEN_STYLE$1,
                disabled: me === !1 || ce,
                tabindex: me !== !1 ? _e : null,
                onKeydown: be,
                onFocus: ge,
                onBlur: xe,
                value: "",
                onChange: noop$3,
                "aria-label": "for screen reader"
            }, null)]), createVNode("div", {
                class: "".concat(se, "-treenode"),
                "aria-hidden": !0,
                style: {
                    position: "absolute",
                    pointerEvents: "none",
                    visibility: "hidden",
                    height: 0,
                    overflow: "hidden"
                }
            }, [createVNode("div", {
                class: "".concat(se, "-indent")
            }, [createVNode("div", {
                ref: X,
                class: "".concat(se, "-indent-unit")
            }, null)])]), createVNode(List$4, _objectSpread2$1(_objectSpread2$1({}, omit$2(
                $e, ["onActiveChange"])), {}, {
                data: ie.value,
                itemKey,
                height: ve,
                fullHeight: !1,
                virtual: pe,
                itemHeight: fe,
                prefixCls: "".concat(se, "-list"),
                ref: G,
                onVisibleChange: function (Ce, we) {
                    var Oe = new Set(Ce),
                        Ne = we.filter(function (Me) {
                            return !Oe.has(Me)
                        });
                    Ne.some(function (Me) {
                        return itemKey(Me) === MOTION_KEY
                    }) && ae()
                }
            }), {
                default: function (Ce) {
                    var we = Ce.pos,
                        Oe = _extends$1({}, (_objectDestructuringEmpty(Ce.data), Ce
                            .data)),
                        Ne = Ce.title,
                        Me = Ce.key,
                        Ve = Ce.isStart,
                        ke = Ce.isEnd,
                        Ee = getKey(Me, we);
                    return delete Oe.key, delete Oe.children, createVNode(
                        MotionTreeNode, _objectSpread2$1(_objectSpread2$1({},
                            Oe), {}, {
                            eventKey: Ee,
                            title: Ne,
                            active: !!he && Me === he.key,
                            data: Ce.data,
                            isStart: Ve,
                            isEnd: ke,
                            motion: de,
                            motionNodes: Me === MOTION_KEY ? te.value : null,
                            motionType: re.value,
                            onMotionStart: Pe,
                            onMotionEnd: ae,
                            onMousemove: ue
                        }), null)
                }
            })])
        }
    }
});

function DropIndicator(K) {
    var C = K.dropPosition,
        H = K.dropLevelOffset,
        W = K.indent,
        U = {
            pointerEvents: "none",
            position: "absolute",
            right: 0,
            backgroundColor: "red",
            height: "".concat(2, "px")
        };
    switch (C) {
        case -1:
            U.top = 0, U.left = "".concat(-H * W, "px");
            break;
        case 1:
            U.bottom = 0, U.left = "".concat(-H * W, "px");
            break;
        case 0:
            U.bottom = 0, U.left = "".concat(W);
            break
    }
    return createVNode("div", {
        style: U
    }, null)
}
var MAX_RETRY_TIMES = 10;
const Tree$2 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Tree",
    inheritAttrs: !1,
    slots: ["checkable", "title", "icon", "titleRender"],
    props: initDefaultProps$1(treeProps$1(), {
        prefixCls: "vc-tree",
        showLine: !1,
        showIcon: !0,
        selectable: !0,
        multiple: !1,
        checkable: !1,
        disabled: !1,
        checkStrictly: !1,
        draggable: !1,
        defaultExpandParent: !0,
        autoExpandParent: !1,
        defaultExpandAll: !1,
        defaultExpandedKeys: [],
        defaultCheckedKeys: [],
        defaultSelectedKeys: [],
        dropIndicatorRender: DropIndicator,
        allowDrop: function () {
            return !0
        }
    }),
    setup: function (C, H) {
        var W = H.attrs,
            U = H.slots,
            G = H.expose,
            X = ref(!1),
            Z = {},
            Q = ref(),
            ee = shallowRef([]),
            ne = shallowRef([]),
            te = shallowRef([]),
            re = shallowRef([]),
            ae = shallowRef([]),
            oe = shallowRef([]),
            ie = {},
            ue = reactive({
                draggingNodeKey: null,
                dragChildrenKeys: [],
                dropTargetKey: null,
                dropPosition: null,
                dropContainerKey: null,
                dropLevelOffset: null,
                dropTargetPos: null,
                dropAllowed: !0,
                dragOverNodeKey: null
            }),
            le = shallowRef([]);
        watch([function () {
            return C.treeData
        }, function () {
            return C.children
        }], function () {
            le.value = C.treeData !== void 0 ? toRaw(C.treeData).slice() : convertTreeToData(toRaw(
                C.children))
        }, {
            immediate: !0,
            deep: !0
        });
        var se = shallowRef({}),
            ce = ref(!1),
            de = ref(null),
            ve = ref(!1),
            fe = computed(function () {
                return fillFieldNames$1(C.fieldNames)
            }),
            pe = ref(),
            me = null,
            he = null,
            Se = null,
            _e = computed(function () {
                return {
                    expandedKeysSet: be.value,
                    selectedKeysSet: ge.value,
                    loadedKeysSet: xe.value,
                    loadingKeysSet: Pe.value,
                    checkedKeysSet: $e.value,
                    halfCheckedKeysSet: ye.value,
                    dragOverNodeKey: ue.dragOverNodeKey,
                    dropPosition: ue.dropPosition,
                    keyEntities: se.value
                }
            }),
            be = computed(function () {
                return new Set(oe.value)
            }),
            ge = computed(function () {
                return new Set(ee.value)
            }),
            xe = computed(function () {
                return new Set(re.value)
            }),
            Pe = computed(function () {
                return new Set(ae.value)
            }),
            $e = computed(function () {
                return new Set(ne.value)
            }),
            ye = computed(function () {
                return new Set(te.value)
            });
        watchEffect(function () {
            if (le.value) {
                var rt = convertDataToEntities(le.value, {
                    fieldNames: fe.value
                });
                se.value = _objectSpread2$1(_defineProperty$V({}, MOTION_KEY, MotionEntity), rt.keyEntities)
            }
        });
        var Ce = !1;
        watch([function () {
            return C.expandedKeys
        }, function () {
            return C.autoExpandParent
        }, se], function (rt, qe) {
            var Je = _slicedToArray$2(rt, 2);
            Je[0];
            var Qe = Je[1],
                lt = _slicedToArray$2(qe, 2);
            lt[0];
            var ct = lt[1],
                dt = oe.value;
            if (C.expandedKeys !== void 0 || Ce && Qe !== ct) dt = C.autoExpandParent || !Ce && C.defaultExpandParent ?
                conductExpandParent(C.expandedKeys, se.value) : C.expandedKeys;
            else if (!Ce && C.defaultExpandAll) {
                var tt = _objectSpread2$1({}, se.value);
                delete tt[MOTION_KEY], dt = Object.keys(tt).map(function (at) {
                    return tt[at].key
                })
            } else !Ce && C.defaultExpandedKeys && (dt = C.autoExpandParent || C.defaultExpandParent ?
                conductExpandParent(C.defaultExpandedKeys, se.value) : C.defaultExpandedKeys);
            dt && (oe.value = dt), Ce = !0
        }, {
            immediate: !0
        });
        var we = shallowRef([]);
        watchEffect(function () {
            we.value = flattenTreeData(le.value, oe.value, fe.value)
        }), watchEffect(function () {
            C.selectable && (C.selectedKeys !== void 0 ? ee.value = calcSelectedKeys(C.selectedKeys,
                C) : !Ce && C.defaultSelectedKeys && (ee.value = calcSelectedKeys(C.defaultSelectedKeys,
                C)))
        });
        var Oe = useMaxLevel(se),
            Ne = Oe.maxLevel,
            Me = Oe.levelEntities;
        watchEffect(function () {
            if (C.checkable) {
                var rt;
                if (C.checkedKeys !== void 0 ? rt = parseCheckedKeys(C.checkedKeys) || {} : !Ce &&
                    C.defaultCheckedKeys ? rt = parseCheckedKeys(C.defaultCheckedKeys) || {} : le.value &&
                    (rt = parseCheckedKeys(C.checkedKeys) || {
                        checkedKeys: ne.value,
                        halfCheckedKeys: te.value
                    }), rt) {
                    var qe = rt,
                        Je = qe.checkedKeys,
                        Qe = Je === void 0 ? [] : Je,
                        lt = qe.halfCheckedKeys,
                        ct = lt === void 0 ? [] : lt;
                    if (!C.checkStrictly) {
                        var dt = conductCheck(Qe, !0, se.value, Ne.value, Me.value);
                        Qe = dt.checkedKeys, ct = dt.halfCheckedKeys
                    }
                    ne.value = Qe, te.value = ct
                }
            }
        }), watchEffect(function () {
            C.loadedKeys && (re.value = C.loadedKeys)
        });
        var Ve = function () {
                _extends$1(ue, {
                    dragOverNodeKey: null,
                    dropPosition: null,
                    dropLevelOffset: null,
                    dropTargetKey: null,
                    dropContainerKey: null,
                    dropTargetPos: null,
                    dropAllowed: !1
                })
            },
            ke = function (qe) {
                pe.value.scrollTo(qe)
            };
        watch(function () {
            return C.activeKey
        }, function () {
            C.activeKey !== void 0 && (de.value = C.activeKey)
        }, {
            immediate: !0
        }), watch(de, function (rt) {
            nextTick(function () {
                rt !== null && ke({
                    key: rt
                })
            })
        }, {
            immediate: !0,
            flush: "post"
        });
        var Ee = function (qe) {
                C.expandedKeys === void 0 && (oe.value = qe)
            },
            Ae = function () {
                ue.draggingNodeKey !== null && _extends$1(ue, {
                    draggingNodeKey: null,
                    dropPosition: null,
                    dropContainerKey: null,
                    dropTargetKey: null,
                    dropLevelOffset: null,
                    dropAllowed: !0,
                    dragOverNodeKey: null
                }), me = null, Se = null
            },
            Re = function (qe, Je) {
                var Qe = C.onDragend;
                ue.dragOverNodeKey = null, Ae(), Qe == null || Qe({
                    event: qe,
                    node: Je.eventData
                }), he = null
            },
            He = function rt(qe) {
                Re(qe, null), window.removeEventListener("dragend", rt)
            },
            je = function (qe, Je) {
                var Qe = C.onDragstart,
                    lt = Je.eventKey,
                    ct = Je.eventData;
                he = Je, me = {
                    x: qe.clientX,
                    y: qe.clientY
                };
                var dt = arrDel(oe.value, lt);
                ue.draggingNodeKey = lt, ue.dragChildrenKeys = getDragChildrenKeys(lt, se.value), Q.value =
                    pe.value.getIndentWidth(), Ee(dt), window.addEventListener("dragend", He), Qe && Qe({
                        event: qe,
                        node: ct
                    })
            },
            Fe = function (qe, Je) {
                var Qe = C.onDragenter,
                    lt = C.onExpand,
                    ct = C.allowDrop,
                    dt = C.direction,
                    tt = Je.pos,
                    at = Je.eventKey;
                if (Se !== at && (Se = at), !he) {
                    Ve();
                    return
                }
                var vt = calcDropPosition(qe, he, Je, Q.value, me, ct, we.value, se.value, be.value, dt),
                    gt = vt.dropPosition,
                    mt = vt.dropLevelOffset,
                    ht = vt.dropTargetKey,
                    yt = vt.dropContainerKey,
                    St = vt.dropTargetPos,
                    Ct = vt.dropAllowed,
                    _t = vt.dragOverNodeKey;
                if (ue.dragChildrenKeys.indexOf(ht) !== -1 || !Ct) {
                    Ve();
                    return
                }
                if (Z || (Z = {}), Object.keys(Z).forEach(function (wt) {
                        clearTimeout(Z[wt])
                    }), he.eventKey !== Je.eventKey && (Z[tt] = window.setTimeout(function () {
                        if (ue.draggingNodeKey !== null) {
                            var wt = oe.value.slice(),
                                Et = se.value[Je.eventKey];
                            Et && (Et.children || []).length && (wt = arrAdd(oe.value, Je.eventKey)),
                                Ee(wt), lt && lt(wt, {
                                    node: Je.eventData,
                                    expanded: !0,
                                    nativeEvent: qe
                                })
                        }
                    }, 800)), he.eventKey === ht && mt === 0) {
                    Ve();
                    return
                }
                _extends$1(ue, {
                    dragOverNodeKey: _t,
                    dropPosition: gt,
                    dropLevelOffset: mt,
                    dropTargetKey: ht,
                    dropContainerKey: yt,
                    dropTargetPos: St,
                    dropAllowed: Ct
                }), Qe && Qe({
                    event: qe,
                    node: Je.eventData,
                    expandedKeys: oe.value
                })
            },
            Le = function (qe, Je) {
                var Qe = C.onDragover,
                    lt = C.allowDrop,
                    ct = C.direction;
                if (he) {
                    var dt = calcDropPosition(qe, he, Je, Q.value, me, lt, we.value, se.value, be.value, ct),
                        tt = dt.dropPosition,
                        at = dt.dropLevelOffset,
                        vt = dt.dropTargetKey,
                        gt = dt.dropContainerKey,
                        mt = dt.dropAllowed,
                        ht = dt.dropTargetPos,
                        yt = dt.dragOverNodeKey;
                    ue.dragChildrenKeys.indexOf(vt) !== -1 || !mt || (he.eventKey === vt && at === 0 ? ue.dropPosition ===
                        null && ue.dropLevelOffset === null && ue.dropTargetKey === null && ue.dropContainerKey ===
                        null && ue.dropTargetPos === null && ue.dropAllowed === !1 && ue.dragOverNodeKey ===
                        null || Ve() : tt === ue.dropPosition && at === ue.dropLevelOffset && vt === ue
                        .dropTargetKey && gt === ue.dropContainerKey && ht === ue.dropTargetPos && mt ===
                        ue.dropAllowed && yt === ue.dragOverNodeKey || _extends$1(ue, {
                            dropPosition: tt,
                            dropLevelOffset: at,
                            dropTargetKey: vt,
                            dropContainerKey: gt,
                            dropTargetPos: ht,
                            dropAllowed: mt,
                            dragOverNodeKey: yt
                        }), Qe && Qe({
                            event: qe,
                            node: Je.eventData
                        }))
                }
            },
            Ie = function (qe, Je) {
                Se === Je.eventKey && !qe.currentTarget.contains(qe.relatedTarget) && (Ve(), Se = null);
                var Qe = C.onDragleave;
                Qe && Qe({
                    event: qe,
                    node: Je.eventData
                })
            },
            Te = function (qe, Je) {
                var Qe, lt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
                    ct = ue.dragChildrenKeys,
                    dt = ue.dropPosition,
                    tt = ue.dropTargetKey,
                    at = ue.dropTargetPos,
                    vt = ue.dropAllowed;
                if (vt) {
                    var gt = C.onDrop;
                    if (ue.dragOverNodeKey = null, Ae(), tt !== null) {
                        var mt = _objectSpread2$1(_objectSpread2$1({}, getTreeNodeProps(tt, toRaw(_e.value))), {}, {
                            active: ((Qe = ot.value) === null || Qe === void 0 ? void 0 : Qe.key) ===
                                tt,
                            data: se.value[tt].node
                        });
                        ct.indexOf(tt);
                        var ht = posToArr(at),
                            yt = {
                                event: qe,
                                node: convertNodePropsToEventData(mt),
                                dragNode: he ? he.eventData : null,
                                dragNodesKeys: [he.eventKey].concat(ct),
                                dropToGap: dt !== 0,
                                dropPosition: dt + Number(ht[ht.length - 1])
                            };
                        lt || gt == null || gt(yt), he = null
                    }
                }
            },
            De = function (qe, Je) {
                var Qe = C.onClick;
                Qe && Qe(qe, Je)
            },
            Ke = function (qe, Je) {
                var Qe = C.onDblclick;
                Qe && Qe(qe, Je)
            },
            We = function (qe, Je) {
                var Qe = ee.value,
                    lt = C.onSelect,
                    ct = C.multiple,
                    dt = Je.selected,
                    tt = Je[fe.value.key],
                    at = !dt;
                at ? ct ? Qe = arrAdd(Qe, tt) : Qe = [tt] : Qe = arrDel(Qe, tt);
                var vt = se.value,
                    gt = Qe.map(function (mt) {
                        var ht = vt[mt];
                        return ht ? ht.node : null
                    }).filter(function (mt) {
                        return mt
                    });
                C.selectedKeys === void 0 && (ee.value = Qe), lt && lt(Qe, {
                    event: "select",
                    selected: at,
                    node: Je,
                    selectedNodes: gt,
                    nativeEvent: qe
                })
            },
            Ue = function (qe, Je, Qe) {
                var lt = C.checkStrictly,
                    ct = C.onCheck,
                    dt = Je[fe.value.key],
                    tt, at = {
                        event: "check",
                        node: Je,
                        checked: Qe,
                        nativeEvent: qe
                    },
                    vt = se.value;
                if (lt) {
                    var gt = Qe ? arrAdd(ne.value, dt) : arrDel(ne.value, dt),
                        mt = arrDel(te.value, dt);
                    tt = {
                        checked: gt,
                        halfChecked: mt
                    }, at.checkedNodes = gt.map(function (wt) {
                        return vt[wt]
                    }).filter(function (wt) {
                        return wt
                    }).map(function (wt) {
                        return wt.node
                    }), C.checkedKeys === void 0 && (ne.value = gt)
                } else {
                    var ht = conductCheck([].concat(_toConsumableArray(ne.value), [dt]), !0, vt, Ne.value,
                            Me.value),
                        yt = ht.checkedKeys,
                        St = ht.halfCheckedKeys;
                    if (!Qe) {
                        var Ct = new Set(yt);
                        Ct.delete(dt);
                        var _t = conductCheck(Array.from(Ct), {
                            checked: !1,
                            halfCheckedKeys: St
                        }, vt, Ne.value, Me.value);
                        yt = _t.checkedKeys, St = _t.halfCheckedKeys
                    }
                    tt = yt, at.checkedNodes = [], at.checkedNodesPositions = [], at.halfCheckedKeys = St,
                        yt.forEach(function (wt) {
                            var Et = vt[wt];
                            if (Et) {
                                var xt = Et.node,
                                    kt = Et.pos;
                                at.checkedNodes.push(xt), at.checkedNodesPositions.push({
                                    node: xt,
                                    pos: kt
                                })
                            }
                        }), C.checkedKeys === void 0 && (ne.value = yt, te.value = St)
                }
                ct && ct(tt, at)
            },
            et = function (qe) {
                var Je = qe[fe.value.key],
                    Qe = new Promise(function (lt, ct) {
                        var dt = C.loadData,
                            tt = C.onLoad;
                        if (!dt || xe.value.has(Je) || Pe.value.has(Je)) return null;
                        var at = dt(qe);
                        at.then(function () {
                            var vt = arrAdd(re.value, Je),
                                gt = arrDel(ae.value, Je);
                            tt && tt(vt, {
                                    event: "load",
                                    node: qe
                                }), C.loadedKeys === void 0 && (re.value = vt), ae.value = gt,
                                lt()
                        }).catch(function (vt) {
                            var gt = arrDel(ae.value, Je);
                            if (ae.value = gt, ie[Je] = (ie[Je] || 0) + 1, ie[Je] >=
                                MAX_RETRY_TIMES) {
                                var mt = arrAdd(re.value, Je);
                                C.loadedKeys === void 0 && (re.value = mt), lt()
                            }
                            ct(vt)
                        }), ae.value = arrAdd(ae.value, Je)
                    });
                return Qe.catch(function () {}), Qe
            },
            Ye = function (qe, Je) {
                var Qe = C.onMouseenter;
                Qe && Qe({
                    event: qe,
                    node: Je
                })
            },
            ze = function (qe, Je) {
                var Qe = C.onMouseleave;
                Qe && Qe({
                    event: qe,
                    node: Je
                })
            },
            Be = function (qe, Je) {
                var Qe = C.onRightClick;
                Qe && (qe.preventDefault(), Qe({
                    event: qe,
                    node: Je
                }))
            },
            Ge = function (qe) {
                var Je = C.onFocus;
                ce.value = !0, Je && Je(qe)
            },
            Xe = function (qe) {
                var Je = C.onBlur;
                ce.value = !1, pt(null), Je && Je(qe)
            },
            nt = function (qe, Je) {
                var Qe = oe.value,
                    lt = C.onExpand,
                    ct = C.loadData,
                    dt = Je.expanded,
                    tt = Je[fe.value.key];
                if (!ve.value) {
                    Qe.indexOf(tt);
                    var at = !dt;
                    if (at ? Qe = arrAdd(Qe, tt) : Qe = arrDel(Qe, tt), Ee(Qe), lt && lt(Qe, {
                            node: Je,
                            expanded: at,
                            nativeEvent: qe
                        }), at && ct) {
                        var vt = et(Je);
                        vt && vt.then(function () {}).catch(function (gt) {
                            var mt = arrDel(oe.value, tt);
                            Ee(mt), Promise.reject(gt)
                        })
                    }
                }
            },
            it = function () {
                ve.value = !0
            },
            ft = function () {
                setTimeout(function () {
                    ve.value = !1
                })
            },
            pt = function (qe) {
                var Je = C.onActiveChange;
                de.value !== qe && (C.activeKey !== void 0 && (de.value = qe), qe !== null && ke({
                    key: qe
                }), Je && Je(qe))
            },
            ot = computed(function () {
                return de.value === null ? null : we.value.find(function (rt) {
                    var qe = rt.key;
                    return qe === de.value
                }) || null
            }),
            Ze = function (qe) {
                var Je = we.value.findIndex(function (ct) {
                    var dt = ct.key;
                    return dt === de.value
                });
                Je === -1 && qe < 0 && (Je = we.value.length), Je = (Je + qe + we.value.length) % we.value.length;
                var Qe = we.value[Je];
                if (Qe) {
                    var lt = Qe.key;
                    pt(lt)
                } else pt(null)
            },
            ut = computed(function () {
                return convertNodePropsToEventData(_objectSpread2$1(_objectSpread2$1({},
                    getTreeNodeProps(de.value, _e.value)), {}, {
                    data: ot.value.data,
                    active: !0
                }))
            }),
            st = function (qe) {
                var Je = C.onKeydown,
                    Qe = C.checkable,
                    lt = C.selectable;
                switch (qe.which) {
                    case KeyCode$1.UP:
                        {
                            Ze(-1),
                            qe.preventDefault();
                            break
                        }
                    case KeyCode$1.DOWN:
                        {
                            Ze(1),
                            qe.preventDefault();
                            break
                        }
                }
                var ct = ot.value;
                if (ct && ct.data) {
                    var dt = ct.data.isLeaf === !1 || !!(ct.data.children || []).length,
                        tt = ut.value;
                    switch (qe.which) {
                        case KeyCode$1.LEFT:
                            {
                                dt && be.value.has(de.value) ? nt({}, tt) : ct.parent && pt(ct.parent.key),
                                qe.preventDefault();
                                break
                            }
                        case KeyCode$1.RIGHT:
                            {
                                dt && !be.value.has(de.value) ? nt({}, tt) : ct.children && ct.children.length &&
                                    pt(ct.children[0].key),
                                qe.preventDefault();
                                break
                            }
                        case KeyCode$1.ENTER:
                        case KeyCode$1.SPACE:
                            {
                                Qe && !tt.disabled && tt.checkable !== !1 && !tt.disableCheckbox ? Ue({},
                                    tt, !$e.value.has(de.value)) : !Qe && lt && !tt.disabled && tt.selectable !==
                                    !1 && We({}, tt);
                                break
                            }
                    }
                }
                Je && Je(qe)
            };
        return G({
                onNodeExpand: nt,
                scrollTo: ke,
                onKeydown: st,
                selectedKeys: computed(function () {
                    return ee.value
                }),
                checkedKeys: computed(function () {
                    return ne.value
                }),
                halfCheckedKeys: computed(function () {
                    return te.value
                }),
                loadedKeys: computed(function () {
                    return re.value
                }),
                loadingKeys: computed(function () {
                    return ae.value
                }),
                expandedKeys: computed(function () {
                    return oe.value
                })
            }), onUnmounted(function () {
                window.removeEventListener("dragend", He), X.value = !0
            }), useProvideKeysState({
                expandedKeys: oe,
                selectedKeys: ee,
                loadedKeys: re,
                loadingKeys: ae,
                checkedKeys: ne,
                halfCheckedKeys: te,
                expandedKeysSet: be,
                selectedKeysSet: ge,
                loadedKeysSet: xe,
                loadingKeysSet: Pe,
                checkedKeysSet: $e,
                halfCheckedKeysSet: ye,
                flattenNodes: we
            }),
            function () {
                var rt, qe = ue.draggingNodeKey,
                    Je = ue.dropLevelOffset,
                    Qe = ue.dropContainerKey,
                    lt = ue.dropTargetKey,
                    ct = ue.dropPosition,
                    dt = ue.dragOverNodeKey,
                    tt = C.prefixCls,
                    at = C.showLine,
                    vt = C.focusable,
                    gt = C.tabindex,
                    mt = gt === void 0 ? 0 : gt,
                    ht = C.selectable,
                    yt = C.showIcon,
                    St = C.icon,
                    Ct = St === void 0 ? U.icon : St,
                    _t = C.switcherIcon,
                    wt = C.draggable,
                    Et = C.checkable,
                    xt = C.checkStrictly,
                    kt = C.disabled,
                    Nt = C.motion,
                    Rt = C.loadData,
                    It = C.filterTreeNode,
                    Lt = C.height,
                    jt = C.itemHeight,
                    Mt = C.virtual,
                    Vt = C.dropIndicatorRender,
                    Dt = C.onContextmenu,
                    zt = C.onScroll,
                    At = C.direction,
                    Wt = W.class,
                    Yt = W.style,
                    Zt = pickAttrs(_objectSpread2$1(_objectSpread2$1({}, C), W), {
                        aria: !0,
                        data: !0
                    }),
                    Kt;
                return wt && (_typeof$2(wt) === "object" ? Kt = wt : typeof wt == "function" ? Kt = {
                    nodeDraggable: wt
                } : Kt = {}), createVNode(TreeContext, {
                    value: {
                        prefixCls: tt,
                        selectable: ht,
                        showIcon: yt,
                        icon: Ct,
                        switcherIcon: _t,
                        draggable: Kt,
                        draggingNodeKey: qe,
                        checkable: Et,
                        customCheckable: U.checkable,
                        checkStrictly: xt,
                        disabled: kt,
                        keyEntities: se.value,
                        dropLevelOffset: Je,
                        dropContainerKey: Qe,
                        dropTargetKey: lt,
                        dropPosition: ct,
                        dragOverNodeKey: dt,
                        dragging: qe !== null,
                        indent: Q.value,
                        direction: At,
                        dropIndicatorRender: Vt,
                        loadData: Rt,
                        filterTreeNode: It,
                        onNodeClick: De,
                        onNodeDoubleClick: Ke,
                        onNodeExpand: nt,
                        onNodeSelect: We,
                        onNodeCheck: Ue,
                        onNodeLoad: et,
                        onNodeMouseEnter: Ye,
                        onNodeMouseLeave: ze,
                        onNodeContextMenu: Be,
                        onNodeDragStart: je,
                        onNodeDragEnter: Fe,
                        onNodeDragOver: Le,
                        onNodeDragLeave: Ie,
                        onNodeDragEnd: Re,
                        onNodeDrop: Te,
                        slots: U
                    }
                }, {
                    default: function () {
                        return [createVNode("div", {
                            role: "tree",
                            class: classNames(tt, Wt, (rt = {}, _defineProperty$V(
                                    rt, "".concat(tt, "-show-line"), at),
                                _defineProperty$V(rt, "".concat(tt,
                                    "-focused"), ce.value),
                                _defineProperty$V(rt, "".concat(tt,
                                        "-active-focused"), de.value !==
                                    null), rt))
                        }, [createVNode(NodeList, _objectSpread2$1({
                            ref: pe,
                            prefixCls: tt,
                            style: Yt,
                            disabled: kt,
                            selectable: ht,
                            checkable: !!Et,
                            motion: Nt,
                            height: Lt,
                            itemHeight: jt,
                            virtual: Mt,
                            focusable: vt,
                            focused: ce.value,
                            tabindex: mt,
                            activeItem: ot.value,
                            onFocus: Ge,
                            onBlur: Xe,
                            onKeydown: st,
                            onActiveChange: pt,
                            onListChangeStart: it,
                            onListChangeEnd: ft,
                            onContextmenu: Dt,
                            onScroll: zt
                        }, Zt), null)])]
                    }
                })
            }
    }
});
var FileOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z"
            }
        }]
    },
    name: "file",
    theme: "outlined"
};
const FileOutlinedSvg = FileOutlined$2;

function _objectSpread$e(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$e(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$e(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var FileOutlined = function (C, H) {
    var W = _objectSpread$e({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$e({}, W, {
        icon: FileOutlinedSvg
    }), null)
};
FileOutlined.displayName = "FileOutlined";
FileOutlined.inheritAttrs = !1;
const FileOutlined$1 = FileOutlined;
var MinusSquareOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z"
            }
        }, {
            tag: "path",
            attrs: {
                d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z"
            }
        }]
    },
    name: "minus-square",
    theme: "outlined"
};
const MinusSquareOutlinedSvg = MinusSquareOutlined$2;

function _objectSpread$d(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$d(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$d(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var MinusSquareOutlined = function (C, H) {
    var W = _objectSpread$d({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$d({}, W, {
        icon: MinusSquareOutlinedSvg
    }), null)
};
MinusSquareOutlined.displayName = "MinusSquareOutlined";
MinusSquareOutlined.inheritAttrs = !1;
const MinusSquareOutlined$1 = MinusSquareOutlined;
var PlusSquareOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z"
            }
        }, {
            tag: "path",
            attrs: {
                d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z"
            }
        }]
    },
    name: "plus-square",
    theme: "outlined"
};
const PlusSquareOutlinedSvg = PlusSquareOutlined$2;

function _objectSpread$c(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$c(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$c(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var PlusSquareOutlined = function (C, H) {
    var W = _objectSpread$c({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$c({}, W, {
        icon: PlusSquareOutlinedSvg
    }), null)
};
PlusSquareOutlined.displayName = "PlusSquareOutlined";
PlusSquareOutlined.inheritAttrs = !1;
const PlusSquareOutlined$1 = PlusSquareOutlined;
var CaretDownFilled$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "0 0 1024 1024",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z"
            }
        }]
    },
    name: "caret-down",
    theme: "filled"
};
const CaretDownFilledSvg = CaretDownFilled$2;

function _objectSpread$b(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$b(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$b(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var CaretDownFilled = function (C, H) {
    var W = _objectSpread$b({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$b({}, W, {
        icon: CaretDownFilledSvg
    }), null)
};
CaretDownFilled.displayName = "CaretDownFilled";
CaretDownFilled.inheritAttrs = !1;
const CaretDownFilled$1 = CaretDownFilled;

function renderSwitcherIcon(K, C, H, W) {
    var U = W.isLeaf,
        G = W.expanded,
        X = W.loading,
        Z = C;
    if (X) return createVNode(LoadingOutlined$1, {
        class: "".concat(K, "-switcher-loading-icon")
    }, null);
    var Q;
    H && _typeof$2(H) === "object" && (Q = H.showLeafIcon);
    var ee = null,
        ne = "".concat(K, "-switcher-icon");
    return U ? (H && (_typeof$2(H) === "object" && !Q ? ee = createVNode("span", {
        class: "".concat(K, "-switcher-leaf-line")
    }, null) : ee = createVNode(FileOutlined$1, {
        class: "".concat(K, "-switcher-line-icon")
    }, null)), ee) : (ee = createVNode(CaretDownFilled$1, {
        class: ne
    }, null), H && (ee = G ? createVNode(MinusSquareOutlined$1, {
        class: "".concat(K, "-switcher-line-icon")
    }, null) : createVNode(PlusSquareOutlined$1, {
        class: "".concat(K, "-switcher-line-icon")
    }, null)), typeof C == "function" ? Z = C(_objectSpread2$1(_objectSpread2$1({}, W), {}, {
        defaultIcon: ee,
        switcherCls: ne
    })) : isValidElement(Z) && (Z = cloneVNode(Z, {
        class: ne
    })), Z || ee)
}
var offset$1 = 4;

function dropIndicatorRender(K) {
    var C, H = K.dropPosition,
        W = K.dropLevelOffset,
        U = K.prefixCls,
        G = K.indent,
        X = K.direction,
        Z = X === void 0 ? "ltr" : X,
        Q = Z === "ltr" ? "left" : "right",
        ee = Z === "ltr" ? "right" : "left",
        ne = (C = {}, _defineProperty$V(C, Q, "".concat(-W * G + offset$1, "px")), _defineProperty$V(C, ee, 0), C);
    switch (H) {
        case -1:
            ne.top = "".concat(-3, "px");
            break;
        case 1:
            ne.bottom = "".concat(-3, "px");
            break;
        default:
            ne.bottom = "".concat(-3, "px"), ne[Q] = "".concat(G + offset$1, "px");
            break
    }
    return createVNode("div", {
        style: ne,
        class: "".concat(U, "-drop-indicator")
    }, null)
}
var treeProps = function () {
    var C = treeProps$1();
    return _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        showLine: {
            type: [Boolean, Object],
            default: void 0
        },
        multiple: {
            type: Boolean,
            default: void 0
        },
        autoExpandParent: {
            type: Boolean,
            default: void 0
        },
        checkStrictly: {
            type: Boolean,
            default: void 0
        },
        checkable: {
            type: Boolean,
            default: void 0
        },
        disabled: {
            type: Boolean,
            default: void 0
        },
        defaultExpandAll: {
            type: Boolean,
            default: void 0
        },
        defaultExpandParent: {
            type: Boolean,
            default: void 0
        },
        defaultExpandedKeys: {
            type: Array
        },
        expandedKeys: {
            type: Array
        },
        checkedKeys: {
            type: [Array, Object]
        },
        defaultCheckedKeys: {
            type: Array
        },
        selectedKeys: {
            type: Array
        },
        defaultSelectedKeys: {
            type: Array
        },
        selectable: {
            type: Boolean,
            default: void 0
        },
        loadedKeys: {
            type: Array
        },
        draggable: {
            type: Boolean,
            default: void 0
        },
        showIcon: {
            type: Boolean,
            default: void 0
        },
        icon: {
            type: Function
        },
        switcherIcon: PropTypes$1.any,
        prefixCls: String,
        replaceFields: {
            type: Object
        },
        blockNode: {
            type: Boolean,
            default: void 0
        },
        openAnimation: PropTypes$1.any,
        onDoubleclick: C.onDblclick,
        "onUpdate:selectedKeys": Function,
        "onUpdate:checkedKeys": Function,
        "onUpdate:expandedKeys": Function
    })
};
const Tree$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ATree",
    inheritAttrs: !1,
    props: initDefaultProps$1(treeProps(), {
        checkable: !1,
        selectable: !0,
        showIcon: !1,
        blockNode: !1
    }),
    slots: ["icon", "title", "switcherIcon", "titleRender"],
    setup: function (C, H) {
        var W = H.attrs,
            U = H.expose,
            G = H.emit,
            X = H.slots;
        C.treeData === void 0 && X.default;
        var Z = useConfigInject("tree", C),
            Q = Z.prefixCls,
            ee = Z.direction,
            ne = Z.virtual,
            te = ref(),
            re = function (le) {
                var se;
                (se = te.value) === null || se === void 0 || se.scrollTo(le)
            };
        U({
            treeRef: te,
            onNodeExpand: function () {
                for (var le, se = arguments.length, ce = new Array(se), de = 0; de < se; de++)
                    ce[de] = arguments[de];
                (le = te.value) === null || le === void 0 || le.onNodeExpand.apply(le, ce)
            },
            scrollTo: re,
            selectedKeys: computed(function () {
                var ue;
                return (ue = te.value) === null || ue === void 0 ? void 0 : ue.selectedKeys
            }),
            checkedKeys: computed(function () {
                var ue;
                return (ue = te.value) === null || ue === void 0 ? void 0 : ue.checkedKeys
            }),
            halfCheckedKeys: computed(function () {
                var ue;
                return (ue = te.value) === null || ue === void 0 ? void 0 : ue.halfCheckedKeys
            }),
            loadedKeys: computed(function () {
                var ue;
                return (ue = te.value) === null || ue === void 0 ? void 0 : ue.loadedKeys
            }),
            loadingKeys: computed(function () {
                var ue;
                return (ue = te.value) === null || ue === void 0 ? void 0 : ue.loadingKeys
            }),
            expandedKeys: computed(function () {
                var ue;
                return (ue = te.value) === null || ue === void 0 ? void 0 : ue.expandedKeys
            })
        }), watchEffect(function () {
            devWarning(C.replaceFields === void 0, "Tree",
                "`replaceFields` is deprecated, please use fieldNames instead")
        });
        var ae = function (le, se) {
                G("update:checkedKeys", le), G("check", le, se)
            },
            oe = function (le, se) {
                G("update:expandedKeys", le), G("expand", le, se)
            },
            ie = function (le, se) {
                G("update:selectedKeys", le), G("select", le, se)
            };
        return function () {
            var ue, le = C.showIcon,
                se = C.showLine,
                ce = C.switcherIcon,
                de = ce === void 0 ? X.switcherIcon : ce,
                ve = C.icon,
                fe = ve === void 0 ? X.icon : ve,
                pe = C.blockNode,
                me = C.checkable,
                he = C.selectable,
                Se = C.fieldNames,
                _e = Se === void 0 ? C.replaceFields : Se,
                be = C.motion,
                ge = be === void 0 ? C.openAnimation : be,
                xe = C.itemHeight,
                Pe = xe === void 0 ? 28 : xe,
                $e = C.onDoubleclick,
                ye = C.onDblclick,
                Ce = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, W), omit$2(C, [
                    "onUpdate:checkedKeys", "onUpdate:expandedKeys",
                    "onUpdate:selectedKeys", "onDoubleclick"])), {}, {
                    showLine: !!se,
                    dropIndicatorRender,
                    fieldNames: _e,
                    icon: fe,
                    itemHeight: Pe
                }),
                we = X.default ? filterEmpty(X.default()) : void 0;
            return createVNode(Tree$2, _objectSpread2$1(_objectSpread2$1({}, Ce), {}, {
                virtual: ne.value,
                motion: ge,
                ref: te,
                prefixCls: Q.value,
                class: classNames((ue = {}, _defineProperty$V(ue, "".concat(Q.value,
                    "-icon-hide"), !le), _defineProperty$V(ue, "".concat(Q.value,
                    "-block-node"), pe), _defineProperty$V(ue, "".concat(Q.value,
                    "-unselectable"), !he), _defineProperty$V(ue, "".concat(Q.value,
                    "-rtl"), ee.value === "rtl"), ue), W.class),
                direction: ee.value,
                checkable: me,
                selectable: he,
                switcherIcon: function (Ne) {
                    return renderSwitcherIcon(Q.value, de, se, Ne)
                },
                onCheck: ae,
                onExpand: oe,
                onSelect: ie,
                onDblclick: ye || $e,
                children: we
            }), _objectSpread2$1(_objectSpread2$1({}, X), {}, {
                checkable: function () {
                    return createVNode("span", {
                        class: "".concat(Q.value, "-checkbox-inner")
                    }, null)
                }
            }))
        }
    }
});
var FolderOpenOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M928 444H820V330.4c0-17.7-14.3-32-32-32H473L355.7 186.2a8.15 8.15 0 00-5.5-2.2H96c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h698c13 0 24.8-7.9 29.7-20l134-332c1.5-3.8 2.3-7.9 2.3-12 0-17.7-14.3-32-32-32zM136 256h188.5l119.6 114.4H748V444H238c-13 0-24.8 7.9-29.7 20L136 643.2V256zm635.3 512H159l103.3-256h612.4L771.3 768z"
            }
        }]
    },
    name: "folder-open",
    theme: "outlined"
};
const FolderOpenOutlinedSvg = FolderOpenOutlined$2;

function _objectSpread$a(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$a(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$a(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var FolderOpenOutlined = function (C, H) {
    var W = _objectSpread$a({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$a({}, W, {
        icon: FolderOpenOutlinedSvg
    }), null)
};
FolderOpenOutlined.displayName = "FolderOpenOutlined";
FolderOpenOutlined.inheritAttrs = !1;
const FolderOpenOutlined$1 = FolderOpenOutlined;
var FolderOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32zM840 768H184V256h188.5l119.6 114.4H840V768z"
            }
        }]
    },
    name: "folder",
    theme: "outlined"
};
const FolderOutlinedSvg = FolderOutlined$2;

function _objectSpread$9(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$9(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$9(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var FolderOutlined = function (C, H) {
    var W = _objectSpread$9({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$9({}, W, {
        icon: FolderOutlinedSvg
    }), null)
};
FolderOutlined.displayName = "FolderOutlined";
FolderOutlined.inheritAttrs = !1;
const FolderOutlined$1 = FolderOutlined;
var Record;
(function (K) {
    K[K.None = 0] = "None", K[K.Start = 1] = "Start", K[K.End = 2] = "End"
})(Record || (Record = {}));

function traverseNodesKey(K, C, H) {
    function W(U) {
        var G = U[C.key],
            X = U[C.children];
        H(G, U) !== !1 && traverseNodesKey(X || [], C, H)
    }
    K.forEach(W)
}

function calcRangeKeys(K) {
    var C = K.treeData,
        H = K.expandedKeys,
        W = K.startKey,
        U = K.endKey,
        G = K.fieldNames,
        X = G === void 0 ? {
            title: "title",
            key: "key",
            children: "children"
        } : G,
        Z = [],
        Q = Record.None;
    if (W && W === U) return [W];
    if (!W || !U) return [];

    function ee(ne) {
        return ne === W || ne === U
    }
    return traverseNodesKey(C, X, function (ne) {
        if (Q === Record.End) return !1;
        if (ee(ne)) {
            if (Z.push(ne), Q === Record.None) Q = Record.Start;
            else if (Q === Record.Start) return Q = Record.End, !1
        } else Q === Record.Start && Z.push(ne);
        return H.indexOf(ne) !== -1
    }), Z
}

function convertDirectoryKeysToNodes(K, C, H) {
    var W = _toConsumableArray(C),
        U = [];
    return traverseNodesKey(K, H, function (G, X) {
        var Z = W.indexOf(G);
        return Z !== -1 && (U.push(X), W.splice(Z, 1)), !!W.length
    }), U
}
var _excluded$8 = ["icon", "blockNode"],
    directoryTreeProps = function () {
        return _objectSpread2$1(_objectSpread2$1({}, treeProps()), {}, {
            expandAction: {
                type: [Boolean, String]
            }
        })
    };

function getIcon(K) {
    var C = K.isLeaf,
        H = K.expanded;
    return createVNode(C ? FileOutlined$1 : H ? FolderOpenOutlined$1 : FolderOutlined$1, null, null)
}
const DirectoryTree = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ADirectoryTree",
    inheritAttrs: !1,
    props: initDefaultProps$1(directoryTreeProps(), {
        showIcon: !0,
        expandAction: "click"
    }),
    slots: ["icon", "title", "switcherIcon", "titleRender"],
    setup: function (C, H) {
        var W, U = H.attrs,
            G = H.slots,
            X = H.emit,
            Z = H.expose,
            Q = ref(C.treeData || convertTreeToData(filterEmpty((W = G.default) === null || W === void 0 ?
                void 0 : W.call(G))));
        watch(function () {
            return C.treeData
        }, function () {
            Q.value = C.treeData
        }), onUpdated(function () {
            nextTick(function () {
                if (C.treeData === void 0 && G.default) {
                    var _e;
                    Q.value = convertTreeToData(filterEmpty((_e = G.default) === null || _e ===
                        void 0 ? void 0 : _e.call(G)))
                }
            })
        });
        var ee = ref(),
            ne = ref(),
            te = computed(function () {
                return fillFieldNames$1(C.fieldNames)
            }),
            re = ref(),
            ae = function (be) {
                var ge;
                (ge = re.value) === null || ge === void 0 || ge.scrollTo(be)
            };
        Z({
            scrollTo: ae,
            selectedKeys: computed(function () {
                var _e;
                return (_e = re.value) === null || _e === void 0 ? void 0 : _e.selectedKeys
            }),
            checkedKeys: computed(function () {
                var _e;
                return (_e = re.value) === null || _e === void 0 ? void 0 : _e.checkedKeys
            }),
            halfCheckedKeys: computed(function () {
                var _e;
                return (_e = re.value) === null || _e === void 0 ? void 0 : _e.halfCheckedKeys
            }),
            loadedKeys: computed(function () {
                var _e;
                return (_e = re.value) === null || _e === void 0 ? void 0 : _e.loadedKeys
            }),
            loadingKeys: computed(function () {
                var _e;
                return (_e = re.value) === null || _e === void 0 ? void 0 : _e.loadingKeys
            }),
            expandedKeys: computed(function () {
                var _e;
                return (_e = re.value) === null || _e === void 0 ? void 0 : _e.expandedKeys
            })
        });
        var oe = function () {
                var be = convertDataToEntities(Q.value, {
                        fieldNames: te.value
                    }),
                    ge = be.keyEntities,
                    xe;
                return C.defaultExpandAll ? xe = Object.keys(ge) : C.defaultExpandParent ? xe =
                    conductExpandParent(C.expandedKeys || C.defaultExpandedKeys || [], ge) : xe = C.expandedKeys ||
                    C.defaultExpandedKeys, xe
            },
            ie = ref(C.selectedKeys || C.defaultSelectedKeys || []),
            ue = ref(oe());
        watch(function () {
            return C.selectedKeys
        }, function () {
            C.selectedKeys !== void 0 && (ie.value = C.selectedKeys)
        }, {
            immediate: !0
        }), watch(function () {
            return C.expandedKeys
        }, function () {
            C.expandedKeys !== void 0 && (ue.value = C.expandedKeys)
        }, {
            immediate: !0
        });
        var le = function (be, ge) {
                var xe = ge.isLeaf;
                xe || be.shiftKey || be.metaKey || be.ctrlKey || re.value.onNodeExpand(be, ge)
            },
            se = debounce(le, 200, {
                leading: !0
            }),
            ce = function (be, ge) {
                C.expandedKeys === void 0 && (ue.value = be), X("update:expandedKeys", be), X("expand", be,
                    ge)
            },
            de = function (be, ge) {
                var xe = C.expandAction;
                xe === "click" && se(be, ge), X("click", be, ge)
            },
            ve = function (be, ge) {
                var xe = C.expandAction;
                (xe === "dblclick" || xe === "doubleclick") && se(be, ge), X("doubleclick", be, ge), X(
                    "dblclick", be, ge)
            },
            fe = function (be, ge) {
                var xe = C.multiple,
                    Pe = ge.node,
                    $e = ge.nativeEvent,
                    ye = Pe[te.value.key],
                    Ce = _objectSpread2$1(_objectSpread2$1({}, ge), {}, {
                        selected: !0
                    }),
                    we = ($e == null ? void 0 : $e.ctrlKey) || ($e == null ? void 0 : $e.metaKey),
                    Oe = $e == null ? void 0 : $e.shiftKey,
                    Ne;
                xe && we ? (Ne = be, ee.value = ye, ne.value = Ne, Ce.selectedNodes =
                        convertDirectoryKeysToNodes(Q.value, Ne, te.value)) : xe && Oe ? (Ne = Array.from(
                        new Set([].concat(_toConsumableArray(ne.value || []), _toConsumableArray(
                            calcRangeKeys({
                                treeData: Q.value,
                                expandedKeys: ue.value,
                                startKey: ye,
                                endKey: ee.value,
                                fieldNames: te.value
                            }))))), Ce.selectedNodes = convertDirectoryKeysToNodes(Q.value, Ne, te.value)) :
                    (Ne = [ye], ee.value = ye, ne.value = Ne, Ce.selectedNodes =
                        convertDirectoryKeysToNodes(Q.value, Ne, te.value)), X("update:selectedKeys", Ne),
                    X("select", Ne, Ce), C.selectedKeys === void 0 && (ie.value = Ne)
            },
            pe = function (be, ge) {
                X("update:checkedKeys", be), X("check", be, ge)
            },
            me = useConfigInject("tree", C),
            he = me.prefixCls,
            Se = me.direction;
        return function () {
            var _e = classNames("".concat(he.value, "-directory"), _defineProperty$V({}, "".concat(he.value,
                    "-directory-rtl"), Se.value === "rtl"), U.class),
                be = C.icon,
                ge = be === void 0 ? G.icon : be,
                xe = C.blockNode,
                Pe = xe === void 0 ? !0 : xe,
                $e = _objectWithoutProperties$2(C, _excluded$8);
            return createVNode(Tree$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, U), {}, {
                icon: ge || getIcon,
                ref: re,
                blockNode: Pe
            }, $e), {}, {
                prefixCls: he.value,
                class: _e,
                expandedKeys: ue.value,
                selectedKeys: ie.value,
                onSelect: fe,
                onClick: de,
                onDblclick: ve,
                onExpand: ce,
                onCheck: pe
            }), G)
        }
    }
});
var TreeNode$2 = defineComponent(_objectSpread2$1(_objectSpread2$1({}, VcTreeNode), {}, {
    name: "ATreeNode",
    props: treeNodeProps
}));
const Tree = _extends$1(Tree$1, {
    DirectoryTree,
    TreeNode: TreeNode$2,
    install: function (C) {
        return C.component(Tree$1.name, Tree$1), C.component(TreeNode$2.name, TreeNode$2), C.component(
            DirectoryTree.name, DirectoryTree), C
    }
});
var SubMenu = Menu.SubMenu,
    MenuItem = Menu.Item;

function hasSubMenu(K) {
    return K.some(function (C) {
        var H = C.children;
        return H && H.length > 0
    })
}

function searchValueMatched(K, C) {
    return typeof C == "string" || typeof C == "number" ? C == null ? void 0 : C.toString().toLowerCase().includes(K.trim()
        .toLowerCase()) : !1
}

function renderFilterItems(K) {
    var C = K.filters,
        H = K.prefixCls,
        W = K.filteredKeys,
        U = K.filterMultiple,
        G = K.searchValue,
        X = K.filterSearch;
    return C.map(function (Z, Q) {
        var ee = String(Z.value);
        if (Z.children) return createVNode(SubMenu, {
            key: ee || Q,
            title: Z.text,
            popupClassName: "".concat(H, "-dropdown-submenu")
        }, {
            default: function () {
                return [renderFilterItems({
                    filters: Z.children,
                    prefixCls: H,
                    filteredKeys: W,
                    filterMultiple: U,
                    searchValue: G,
                    filterSearch: X
                })]
            }
        });
        var ne = U ? Checkbox : Radio,
            te = createVNode(MenuItem, {
                key: Z.value !== void 0 ? ee : Q
            }, {
                default: function () {
                    return [createVNode(ne, {
                        checked: W.includes(ee)
                    }, null), createVNode("span", null, [Z.text])]
                }
            });
        return G.trim() ? typeof X == "function" ? X(G, Z) ? te : void 0 : searchValueMatched(G, Z.text) ? te :
            void 0 : te
    })
}
const FilterDropdown = defineComponent({
    name: "FilterDropdown",
    props: ["tablePrefixCls", "prefixCls", "dropdownPrefixCls", "column", "filterState", "filterMultiple",
        "filterMode", "filterSearch", "columnKey", "triggerFilter", "locale", "getPopupContainer"],
    setup: function (C, H) {
        var W = H.slots,
            U = useInjectSlots(),
            G = computed(function () {
                var Ne;
                return (Ne = C.filterMode) !== null && Ne !== void 0 ? Ne : "menu"
            }),
            X = computed(function () {
                var Ne;
                return (Ne = C.filterSearch) !== null && Ne !== void 0 ? Ne : !1
            }),
            Z = computed(function () {
                return C.column.filterDropdownVisible
            }),
            Q = ref(!1),
            ee = computed(function () {
                var Ne;
                return !!(C.filterState && ((Ne = C.filterState.filteredKeys) !== null && Ne !== void 0 &&
                    Ne.length || C.filterState.forceFiltered))
            }),
            ne = computed(function () {
                var Ne;
                return flattenKeys((Ne = C.column) === null || Ne === void 0 ? void 0 : Ne.filters)
            }),
            te = computed(function () {
                var Ne = C.column,
                    Me = Ne.filterDropdown,
                    Ve = Ne.slots,
                    ke = Ve === void 0 ? {} : Ve,
                    Ee = Ne.customFilterDropdown;
                return Me || ke.filterDropdown && U.value[ke.filterDropdown] || Ee && U.value.customFilterDropdown
            }),
            re = computed(function () {
                var Ne = C.column,
                    Me = Ne.filterIcon,
                    Ve = Ne.slots,
                    ke = Ve === void 0 ? {} : Ve;
                return Me || ke.filterIcon && U.value[ke.filterIcon] || U.value.customFilterIcon
            }),
            ae = function (Me) {
                var Ve, ke;
                Q.value = Me, (Ve = (ke = C.column).onFilterDropdownVisibleChange) === null || Ve === void 0 ||
                    Ve.call(ke, Me)
            },
            oe = computed(function () {
                return typeof Z.value == "boolean" ? Z.value : Q.value
            }),
            ie = computed(function () {
                var Ne;
                return (Ne = C.filterState) === null || Ne === void 0 ? void 0 : Ne.filteredKeys
            }),
            ue = shallowRef([]),
            le = function (Me) {
                var Ve = Me.selectedKeys;
                ue.value = Ve
            },
            se = function (Me, Ve) {
                var ke = Ve.node,
                    Ee = Ve.checked;
                C.filterMultiple ? le({
                    selectedKeys: Me
                }) : le({
                    selectedKeys: Ee && ke.key ? [ke.key] : []
                })
            };
        watch(ie, function () {
            Q.value && le({
                selectedKeys: ie.value || []
            })
        }, {
            immediate: !0
        });
        var ce = shallowRef([]),
            de = ref(),
            ve = function (Me) {
                de.value = setTimeout(function () {
                    ce.value = Me
                })
            },
            fe = function () {
                clearTimeout(de.value)
            };
        onBeforeUnmount(function () {
            clearTimeout(de.value)
        });
        var pe = ref(""),
            me = function (Me) {
                var Ve = Me.target.value;
                pe.value = Ve
            };
        watch(Q, function () {
            Q.value || (pe.value = "")
        });
        var he = function (Me) {
                var Ve = C.column,
                    ke = C.columnKey,
                    Ee = C.filterState,
                    Ae = Me && Me.length ? Me : null;
                if (Ae === null && (!Ee || !Ee.filteredKeys) || isEqual$1(Ae, Ee == null ? void 0 : Ee.filteredKeys))
                    return null;
                C.triggerFilter({
                    column: Ve,
                    key: ke,
                    filteredKeys: Ae
                })
            },
            Se = function () {
                ae(!1), he(ue.value)
            },
            _e = function () {
                var Me = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
                        confirm: !1,
                        closeDropdown: !1
                    },
                    Ve = Me.confirm,
                    ke = Me.closeDropdown;
                Ve && he([]), ke && ae(!1), pe.value = "", ue.value = []
            },
            be = function () {
                var Me = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
                        closeDropdown: !0
                    },
                    Ve = Me.closeDropdown;
                Ve && ae(!1), he(ue.value)
            },
            ge = function (Me) {
                Me && ie.value !== void 0 && (ue.value = ie.value || []), ae(Me), !Me && !te.value && Se()
            },
            xe = useConfigInject("", C),
            Pe = xe.direction,
            $e = function (Me) {
                if (Me.target.checked) {
                    var Ve = ne.value;
                    ue.value = Ve
                } else ue.value = []
            },
            ye = function Ne(Me) {
                var Ve = Me.filters;
                return (Ve || []).map(function (ke, Ee) {
                    var Ae = String(ke.value),
                        Re = {
                            title: ke.text,
                            key: ke.value !== void 0 ? Ae : Ee
                        };
                    return ke.children && (Re.children = Ne({
                        filters: ke.children
                    })), Re
                })
            },
            Ce = computed(function () {
                return ye({
                    filters: C.column.filters
                })
            }),
            we = computed(function () {
                return classNames(_defineProperty$V({}, "".concat(C.dropdownPrefixCls,
                    "-menu-without-submenu"), !hasSubMenu(C.column.filters || [])))
            }),
            Oe = function () {
                var Me = ue.value,
                    Ve = C.column,
                    ke = C.locale,
                    Ee = C.tablePrefixCls,
                    Ae = C.filterMultiple,
                    Re = C.dropdownPrefixCls,
                    He = C.getPopupContainer,
                    je = C.prefixCls;
                return (Ve.filters || []).length === 0 ? createVNode(Empty$1, {
                    image: Empty$1.PRESENTED_IMAGE_SIMPLE,
                    description: ke.filterEmptyText,
                    imageStyle: {
                        height: 24
                    },
                    style: {
                        margin: 0,
                        padding: "16px 0"
                    }
                }, null) : G.value === "tree" ? createVNode(Fragment, null, [createVNode(FilterSearch, {
                    filterSearch: X.value,
                    value: pe.value,
                    onChange: me,
                    tablePrefixCls: Ee,
                    locale: ke
                }, null), createVNode("div", {
                    class: "".concat(Ee, "-filter-dropdown-tree")
                }, [Ae ? createVNode(Checkbox, {
                    class: "".concat(Ee, "-filter-dropdown-checkall"),
                    onChange: $e,
                    checked: Me.length === ne.value.length,
                    indeterminate: Me.length > 0 && Me.length < ne.value.length
                }, {
                    default: function () {
                        return [ke.filterCheckall]
                    }
                }) : null, createVNode(Tree, {
                    checkable: !0,
                    selectable: !1,
                    blockNode: !0,
                    multiple: Ae,
                    checkStrictly: !Ae,
                    class: "".concat(Re, "-menu"),
                    onCheck: se,
                    checkedKeys: Me,
                    selectedKeys: Me,
                    showIcon: !1,
                    treeData: Ce.value,
                    autoExpandParent: !0,
                    defaultExpandAll: !0,
                    filterTreeNode: pe.value.trim() ? function (Fe) {
                        return searchValueMatched(pe.value, Fe.title)
                    } : void 0
                }, null)])]) : createVNode(Fragment, null, [createVNode(FilterSearch, {
                    filterSearch: X.value,
                    value: pe.value,
                    onChange: me,
                    tablePrefixCls: Ee,
                    locale: ke
                }, null), createVNode(Menu, {
                    multiple: Ae,
                    prefixCls: "".concat(Re, "-menu"),
                    class: we.value,
                    onClick: fe,
                    onSelect: le,
                    onDeselect: le,
                    selectedKeys: Me,
                    getPopupContainer: He,
                    openKeys: ce.value,
                    onOpenChange: ve
                }, {
                    default: function () {
                        return renderFilterItems({
                            filters: Ve.filters || [],
                            filterSearch: X.value,
                            prefixCls: je,
                            filteredKeys: ue.value,
                            filterMultiple: Ae,
                            searchValue: pe.value
                        })
                    }
                })])
            };
        return function () {
            var Ne, Me = C.tablePrefixCls,
                Ve = C.prefixCls,
                ke = C.column,
                Ee = C.dropdownPrefixCls,
                Ae = C.locale,
                Re = C.getPopupContainer,
                He;
            if (typeof te.value == "function") He = te.value({
                prefixCls: "".concat(Ee, "-custom"),
                setSelectedKeys: function (Te) {
                    return le({
                        selectedKeys: Te
                    })
                },
                selectedKeys: ue.value,
                confirm: be,
                clearFilters: _e,
                filters: ke.filters,
                visible: oe.value,
                column: ke.__originColumn__
            });
            else if (te.value) He = te.value;
            else {
                var je = ue.value;
                He = createVNode(Fragment, null, [Oe(), createVNode("div", {
                    class: "".concat(Ve, "-dropdown-btns")
                }, [createVNode(Button$1, {
                    type: "link",
                    size: "small",
                    disabled: je.length === 0,
                    onClick: function () {
                        return _e()
                    }
                }, {
                    default: function () {
                        return [Ae.filterReset]
                    }
                }), createVNode(Button$1, {
                    type: "primary",
                    size: "small",
                    onClick: Se
                }, {
                    default: function () {
                        return [Ae.filterConfirm]
                    }
                })])])
            }
            var Fe = createVNode(FilterDropdownMenuWrapper$1, {
                    class: "".concat(Ve, "-dropdown")
                }, {
                    default: function () {
                        return [He]
                    }
                }),
                Le;
            return typeof re.value == "function" ? Le = re.value({
                    filtered: ee.value,
                    column: ke.__originColumn__
                }) : re.value ? Le = re.value : Le = createVNode(FilterFilled$1, null, null),
                createVNode("div", {
                    class: "".concat(Ve, "-column")
                }, [createVNode("span", {
                        class: "".concat(Me, "-column-title")
                    }, [(Ne = W.default) === null || Ne === void 0 ? void 0 : Ne.call(W)]),
                    createVNode(Dropdown$1, {
                        overlay: Fe,
                        trigger: ["click"],
                        visible: oe.value,
                        onVisibleChange: ge,
                        getPopupContainer: Re,
                        placement: Pe.value === "rtl" ? "bottomLeft" : "bottomRight"
                    }, {
                        default: function () {
                            return [createVNode("span", {
                                role: "button",
                                tabindex: -1,
                                class: classNames("".concat(Ve, "-trigger"), {
                                    active: ee.value
                                }),
                                onClick: function (De) {
                                    De.stopPropagation()
                                }
                            }, [Le])]
                        }
                    })])
        }
    }
});

function collectFilterStates(K, C, H) {
    var W = [];
    return (K || []).forEach(function (U, G) {
        var X, Z = getColumnPos(G, H),
            Q = U.filterDropdown || (U == null || (X = U.slots) === null || X === void 0 ? void 0 : X.filterDropdown) ||
            U.customFilterDropdown;
        if (U.filters || Q || "onFilter" in U)
            if ("filteredValue" in U) {
                var ee = U.filteredValue;
                if (!Q) {
                    var ne, te;
                    ee = (ne = (te = ee) === null || te === void 0 ? void 0 : te.map(String)) !== null && ne !==
                        void 0 ? ne : ee
                }
                W.push({
                    column: U,
                    key: getColumnKey(U, Z),
                    filteredKeys: ee,
                    forceFiltered: U.filtered
                })
            } else W.push({
                column: U,
                key: getColumnKey(U, Z),
                filteredKeys: C && U.defaultFilteredValue ? U.defaultFilteredValue : void 0,
                forceFiltered: U.filtered
            });
        "children" in U && (W = [].concat(_toConsumableArray(W), _toConsumableArray(collectFilterStates(U.children,
            C, Z))))
    }), W
}

function injectFilter(K, C, H, W, U, G, X, Z) {
    return H.map(function (Q, ee) {
        var ne, te = getColumnPos(ee, Z),
            re = Q.filterMultiple,
            ae = re === void 0 ? !0 : re,
            oe = Q.filterMode,
            ie = Q.filterSearch,
            ue = Q,
            le = Q.filterDropdown || (Q == null || (ne = Q.slots) === null || ne === void 0 ? void 0 : ne.filterDropdown) ||
            Q.customFilterDropdown;
        if (ue.filters || le) {
            var se = getColumnKey(ue, te),
                ce = W.find(function (de) {
                    var ve = de.key;
                    return se === ve
                });
            ue = _objectSpread2$1(_objectSpread2$1({}, ue), {}, {
                title: function (ve) {
                    return createVNode(FilterDropdown, {
                        tablePrefixCls: K,
                        prefixCls: "".concat(K, "-filter"),
                        dropdownPrefixCls: C,
                        column: ue,
                        columnKey: se,
                        filterState: ce,
                        filterMultiple: ae,
                        filterMode: oe,
                        filterSearch: ie,
                        triggerFilter: U,
                        locale: X,
                        getPopupContainer: G
                    }, {
                        default: function () {
                            return [renderColumnTitle(Q.title, ve)]
                        }
                    })
                }
            })
        }
        return "children" in ue && (ue = _objectSpread2$1(_objectSpread2$1({}, ue), {}, {
            children: injectFilter(K, C, ue.children, W, U, G, X, te)
        })), ue
    })
}

function flattenKeys(K) {
    var C = [];
    return (K || []).forEach(function (H) {
        var W = H.value,
            U = H.children;
        C.push(W), U && (C = [].concat(_toConsumableArray(C), _toConsumableArray(flattenKeys(U))))
    }), C
}

function generateFilterInfo(K) {
    var C = {};
    return K.forEach(function (H) {
        var W, U = H.key,
            G = H.filteredKeys,
            X = H.column,
            Z = X.filterDropdown || (X == null || (W = X.slots) === null || W === void 0 ? void 0 : W.filterDropdown) ||
            X.customFilterDropdown,
            Q = X.filters;
        if (Z) C[U] = G || null;
        else if (Array.isArray(G)) {
            var ee = flattenKeys(Q);
            C[U] = ee.filter(function (ne) {
                return G.includes(String(ne))
            })
        } else C[U] = null
    }), C
}

function getFilterData(K, C) {
    return C.reduce(function (H, W) {
        var U = W.column,
            G = U.onFilter,
            X = U.filters,
            Z = W.filteredKeys;
        return G && Z && Z.length ? H.filter(function (Q) {
            return Z.some(function (ee) {
                var ne = flattenKeys(X),
                    te = ne.findIndex(function (ae) {
                        return String(ae) === String(ee)
                    }),
                    re = te !== -1 ? ne[te] : ee;
                return G(re, Q)
            })
        }) : H
    }, K)
}

function useFilter(K) {
    var C = K.prefixCls,
        H = K.dropdownPrefixCls,
        W = K.mergedColumns,
        U = K.locale,
        G = K.onFilterChange,
        X = K.getPopupContainer,
        Z = useState(collectFilterStates(W.value, !0)),
        Q = _slicedToArray$2(Z, 2),
        ee = Q[0],
        ne = Q[1],
        te = computed(function () {
            var ie = collectFilterStates(W.value, !1),
                ue = ie.every(function (se) {
                    var ce = se.filteredKeys;
                    return ce === void 0
                });
            if (ue) return ee.value;
            var le = ie.every(function (se) {
                var ce = se.filteredKeys;
                return ce !== void 0
            });
            return devWarning(ue || le, "Table", "`FilteredKeys` should all be controlled or not controlled."), ie
        }),
        re = computed(function () {
            return generateFilterInfo(te.value)
        }),
        ae = function (ue) {
            var le = te.value.filter(function (se) {
                var ce = se.key;
                return ce !== ue.key
            });
            le.push(ue), ne(le), G(generateFilterInfo(le), le)
        },
        oe = function (ue) {
            return injectFilter(C.value, H.value, ue, te.value, ae, X.value, U.value)
        };
    return [oe, te, re]
}

function fillTitle(K, C) {
    return K.map(function (H) {
        var W = _objectSpread2$1({}, H);
        return W.title = renderColumnTitle(W.title, C), "children" in W && (W.children = fillTitle(W.children,
            C)), W
    })
}

function useTitleColumns(K) {
    var C = function (W) {
        return fillTitle(W, K.value)
    };
    return [C]
}

function renderExpandIcon(K) {
    return function (H) {
        var W, U = H.prefixCls,
            G = H.onExpand,
            X = H.record,
            Z = H.expanded,
            Q = H.expandable,
            ee = "".concat(U, "-row-expand-icon");
        return createVNode("button", {
            type: "button",
            onClick: function (te) {
                G(X, te), te.stopPropagation()
            },
            class: classNames(ee, (W = {}, _defineProperty$V(W, "".concat(ee, "-spaced"), !Q),
                _defineProperty$V(W, "".concat(ee, "-expanded"), Q && Z), _defineProperty$V(W, "".concat(
                    ee, "-collapsed"), Q && !Z), W)),
            "aria-label": Z ? K.collapse : K.expand
        }, null)
    }
}

function fillSlots(K, C) {
    var H = C.value;
    return K.map(function (W) {
        var U;
        if (W === SELECTION_COLUMN || W === EXPAND_COLUMN) return W;
        var G = _objectSpread2$1({}, W),
            X = G.slots,
            Z = X === void 0 ? {} : X;
        return G.__originColumn__ = W, devWarning(!("slots" in G), "Table",
                "`column.slots` is deprecated. Please use `v-slot:headerCell` `v-slot:bodyCell` instead."),
            Object.keys(Z).forEach(function (Q) {
                var ee = Z[Q];
                G[Q] === void 0 && H[ee] && (G[Q] = H[ee])
            }), C.value.headerCell && !((U = W.slots) !== null && U !== void 0 && U.title) && (G.title =
                renderSlot(C.value, "headerCell", {
                    title: W.title,
                    column: W
                }, function () {
                    return [W.title]
                })), "children" in G && (G.children = fillSlots(G.children, C)), G
    })
}

function useColumns(K) {
    var C = function (W) {
        return fillSlots(W, K)
    };
    return [C]
}
var EMPTY_LIST = [],
    tableProps = function () {
        return {
            prefixCls: {
                type: String,
                default: void 0
            },
            columns: {
                type: Array,
                default: void 0
            },
            rowKey: {
                type: [String, Function],
                default: void 0
            },
            tableLayout: {
                type: String,
                default: void 0
            },
            rowClassName: {
                type: [String, Function],
                default: void 0
            },
            title: {
                type: Function,
                default: void 0
            },
            footer: {
                type: Function,
                default: void 0
            },
            id: {
                type: String,
                default: void 0
            },
            showHeader: {
                type: Boolean,
                default: void 0
            },
            components: {
                type: Object,
                default: void 0
            },
            customRow: {
                type: Function,
                default: void 0
            },
            customHeaderRow: {
                type: Function,
                default: void 0
            },
            direction: {
                type: String,
                default: void 0
            },
            expandFixed: {
                type: [Boolean, String],
                default: void 0
            },
            expandColumnWidth: {
                type: Number,
                default: void 0
            },
            expandedRowKeys: {
                type: Array,
                default: void 0
            },
            defaultExpandedRowKeys: {
                type: Array,
                default: void 0
            },
            expandedRowRender: {
                type: Function,
                default: void 0
            },
            expandRowByClick: {
                type: Boolean,
                default: void 0
            },
            expandIcon: {
                type: Function,
                default: void 0
            },
            onExpand: {
                type: Function,
                default: void 0
            },
            onExpandedRowsChange: {
                type: Function,
                default: void 0
            },
            "onUpdate:expandedRowKeys": {
                type: Function,
                default: void 0
            },
            defaultExpandAllRows: {
                type: Boolean,
                default: void 0
            },
            indentSize: {
                type: Number,
                default: void 0
            },
            expandIconColumnIndex: {
                type: Number,
                default: void 0
            },
            showExpandColumn: {
                type: Boolean,
                default: void 0
            },
            expandedRowClassName: {
                type: Function,
                default: void 0
            },
            childrenColumnName: {
                type: String,
                default: void 0
            },
            rowExpandable: {
                type: Function,
                default: void 0
            },
            sticky: {
                type: [Boolean, Object],
                default: void 0
            },
            dropdownPrefixCls: String,
            dataSource: {
                type: Array,
                default: void 0
            },
            pagination: {
                type: [Boolean, Object],
                default: void 0
            },
            loading: {
                type: [Boolean, Object],
                default: void 0
            },
            size: {
                type: String,
                default: void 0
            },
            bordered: Boolean,
            locale: {
                type: Object,
                default: void 0
            },
            onChange: {
                type: Function,
                default: void 0
            },
            onResizeColumn: {
                type: Function,
                default: void 0
            },
            rowSelection: {
                type: Object,
                default: void 0
            },
            getPopupContainer: {
                type: Function,
                default: void 0
            },
            scroll: {
                type: Object,
                default: void 0
            },
            sortDirections: {
                type: Array,
                default: void 0
            },
            showSorterTooltip: {
                type: [Boolean, Object],
                default: !0
            },
            contextSlots: {
                type: Object
            },
            transformCellText: {
                type: Function
            }
        }
    },
    InteralTable = defineComponent({
        name: "InteralTable",
        inheritAttrs: !1,
        props: initDefaultProps$1(tableProps(), {
            rowKey: "key"
        }),
        slots: ["emptyText", "expandIcon", "title", "footer", "summary", "expandedRowRender", "bodyCell",
            "headerCell", "customFilterIcon", "customFilterDropdown"],
        setup: function (C, H) {
            var W = H.attrs,
                U = H.slots,
                G = H.expose,
                X = H.emit;
            devWarning(!(typeof C.rowKey == "function" && C.rowKey.length > 1), "Table",
                "`index` parameter of `rowKey` function is deprecated. There is no guarantee that it will work as expected."
            ), useProvideSlots(computed(function () {
                return C.contextSlots
            })), useProvideTableContext({
                onResizeColumn: function (qe, Je) {
                    X("resizeColumn", qe, Je)
                }
            });
            var Z = useBreakpoint(),
                Q = computed(function () {
                    var rt = new Set(Object.keys(Z.value).filter(function (qe) {
                        return Z.value[qe]
                    }));
                    return C.columns.filter(function (qe) {
                        return !qe.responsive || qe.responsive.some(function (Je) {
                            return rt.has(Je)
                        })
                    })
                }),
                ee = useConfigInject("table", C),
                ne = ee.size,
                te = ee.renderEmpty,
                re = ee.direction,
                ae = ee.prefixCls,
                oe = ee.configProvider,
                ie = computed(function () {
                    return C.transformCellText || oe.transformCellText
                }),
                ue = useLocaleReceiver("Table", defaultLocale.Table, toRef(C, "locale")),
                le = _slicedToArray$2(ue, 1),
                se = le[0],
                ce = computed(function () {
                    return C.dataSource || EMPTY_LIST
                }),
                de = computed(function () {
                    return oe.getPrefixCls("dropdown", C.dropdownPrefixCls)
                }),
                ve = computed(function () {
                    return C.childrenColumnName || "children"
                }),
                fe = computed(function () {
                    return ce.value.some(function (rt) {
                        return rt == null ? void 0 : rt[ve.value]
                    }) ? "nest" : C.expandedRowRender ? "row" : null
                }),
                pe = reactive({
                    body: null
                }),
                me = function (qe) {
                    _extends$1(pe, qe)
                },
                he = computed(function () {
                    return typeof C.rowKey == "function" ? C.rowKey : function (rt) {
                        return rt == null ? void 0 : rt[C.rowKey]
                    }
                }),
                Se = useLazyKVMap(ce, ve, he),
                _e = _slicedToArray$2(Se, 1),
                be = _e[0],
                ge = {},
                xe = function (qe, Je) {
                    var Qe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
                        lt = C.pagination,
                        ct = C.scroll,
                        dt = C.onChange,
                        tt = _objectSpread2$1(_objectSpread2$1({}, ge), qe);
                    Qe && (ge.resetPagination(), tt.pagination.current && (tt.pagination.current = 1), lt && lt
                            .onChange && lt.onChange(1, tt.pagination.pageSize)), ct && ct.scrollToFirstRowOnChange !==
                        !1 && pe.body && scrollTo$1(0, {
                            getContainer: function () {
                                return pe.body
                            }
                        }), dt == null || dt(tt.pagination, tt.filters, tt.sorter, {
                            currentDataSource: getFilterData(getSortData(ce.value, tt.sorterStates, ve.value),
                                tt.filterStates),
                            action: Je
                        })
                },
                Pe = function (qe, Je) {
                    xe({
                        sorter: qe,
                        sorterStates: Je
                    }, "sort", !1)
                },
                $e = useFilterSorter({
                    prefixCls: ae,
                    mergedColumns: Q,
                    onSorterChange: Pe,
                    sortDirections: computed(function () {
                        return C.sortDirections || ["ascend", "descend"]
                    }),
                    tableLocale: se,
                    showSorterTooltip: toRef(C, "showSorterTooltip")
                }),
                ye = _slicedToArray$2($e, 4),
                Ce = ye[0],
                we = ye[1],
                Oe = ye[2],
                Ne = ye[3],
                Me = computed(function () {
                    return getSortData(ce.value, we.value, ve.value)
                }),
                Ve = function (qe, Je) {
                    xe({
                        filters: qe,
                        filterStates: Je
                    }, "filter", !0)
                },
                ke = useFilter({
                    prefixCls: ae,
                    locale: se,
                    dropdownPrefixCls: de,
                    mergedColumns: Q,
                    onFilterChange: Ve,
                    getPopupContainer: toRef(C, "getPopupContainer")
                }),
                Ee = _slicedToArray$2(ke, 3),
                Ae = Ee[0],
                Re = Ee[1],
                He = Ee[2],
                je = computed(function () {
                    return getFilterData(Me.value, Re.value)
                }),
                Fe = useColumns(toRef(C, "contextSlots")),
                Le = _slicedToArray$2(Fe, 1),
                Ie = Le[0],
                Te = computed(function () {
                    return _objectSpread2$1({}, Oe.value)
                }),
                De = useTitleColumns(Te),
                Ke = _slicedToArray$2(De, 1),
                We = Ke[0],
                Ue = function (qe, Je) {
                    xe({
                        pagination: _objectSpread2$1(_objectSpread2$1({}, ge.pagination), {}, {
                            current: qe,
                            pageSize: Je
                        })
                    }, "paginate")
                },
                et = usePagination(computed(function () {
                    return je.value.length
                }), toRef(C, "pagination"), Ue),
                Ye = _slicedToArray$2(et, 2),
                ze = Ye[0],
                Be = Ye[1];
            watchEffect(function () {
                ge.sorter = Ne.value, ge.sorterStates = we.value, ge.filters = He.value, ge.filterStates =
                    Re.value, ge.pagination = C.pagination === !1 ? {} : getPaginationParam(C.pagination,
                        ze.value), ge.resetPagination = Be
            });
            var Ge = computed(function () {
                if (C.pagination === !1 || !ze.value.pageSize) return je.value;
                var rt = ze.value,
                    qe = rt.current,
                    Je = qe === void 0 ? 1 : qe,
                    Qe = rt.total,
                    lt = rt.pageSize,
                    ct = lt === void 0 ? DEFAULT_PAGE_SIZE : lt;
                return devWarning(Je > 0, "Table", "`current` should be positive number."), je.value.length <
                    Qe ? je.value.length > ct ? je.value.slice((Je - 1) * ct, Je * ct) : je.value : je.value
                    .slice((Je - 1) * ct, Je * ct)
            });
            watchEffect(function () {
                nextTick(function () {
                    var rt = ze.value,
                        qe = rt.total,
                        Je = rt.pageSize,
                        Qe = Je === void 0 ? DEFAULT_PAGE_SIZE : Je;
                    je.value.length < qe && je.value.length > Qe && devWarning(!1, "Table",
                        "`dataSource` length is less than `pagination.total` but large than `pagination.pageSize`. Please make sure your config correct data with async mode."
                    )
                })
            }, {
                flush: "post"
            });
            var Xe = computed(function () {
                    return C.showExpandColumn === !1 ? -1 : fe.value === "nest" && C.expandIconColumnIndex ===
                        void 0 ? C.rowSelection ? 1 : 0 : C.expandIconColumnIndex > 0 && C.rowSelection ? C
                        .expandIconColumnIndex - 1 : C.expandIconColumnIndex
                }),
                nt = ref();
            watch(function () {
                return C.rowSelection
            }, function () {
                nt.value = C.rowSelection ? _objectSpread2$1({}, C.rowSelection) : C.rowSelection
            }, {
                deep: !0,
                immediate: !0
            });
            var it = useSelection(nt, {
                    prefixCls: ae,
                    data: je,
                    pageData: Ge,
                    getRowKey: he,
                    getRecordByKey: be,
                    expandType: fe,
                    childrenColumnName: ve,
                    locale: se,
                    getPopupContainer: computed(function () {
                        return C.getPopupContainer
                    })
                }),
                ft = _slicedToArray$2(it, 2),
                pt = ft[0],
                ot = ft[1],
                Ze = function (qe, Je, Qe) {
                    var lt, ct = C.rowClassName;
                    return typeof ct == "function" ? lt = classNames(ct(qe, Je, Qe)) : lt = classNames(ct),
                        classNames(_defineProperty$V({}, "".concat(ae.value, "-row-selected"), ot.value.has(he.value(
                            qe, Je))), lt)
                };
            G({
                selectedKeySet: ot
            });
            var ut = computed(function () {
                    return typeof C.indentSize == "number" ? C.indentSize : 15
                }),
                st = function (qe) {
                    var Je = We(pt(Ae(Ce(Ie(qe)))));
                    return Je
                };
            return function () {
                var rt, qe, Je = C.expandIcon,
                    Qe = Je === void 0 ? U.expandIcon || renderExpandIcon(se.value) : Je,
                    lt = C.pagination,
                    ct = C.loading,
                    dt = C.bordered,
                    tt, at;
                if (lt !== !1 && (rt = ze.value) !== null && rt !== void 0 && rt.total) {
                    var vt;
                    ze.value.size ? vt = ze.value.size : vt = ne.value === "small" || ne.value === "middle" ?
                        "small" : void 0;
                    var gt = function (kt) {
                            return createVNode(Pagination, _objectSpread2$1(_objectSpread2$1({}, ze.value), {}, {
                                class: ["".concat(ae.value, "-pagination ").concat(ae.value,
                                    "-pagination-").concat(kt), ze.value.class],
                                size: vt
                            }), null)
                        },
                        mt = re.value === "rtl" ? "left" : "right",
                        ht = ze.value.position;
                    if (ht !== null && Array.isArray(ht)) {
                        var yt = ht.find(function (xt) {
                                return xt.indexOf("top") !== -1
                            }),
                            St = ht.find(function (xt) {
                                return xt.indexOf("bottom") !== -1
                            }),
                            Ct = ht.every(function (xt) {
                                return "".concat(xt) === "none"
                            });
                        !yt && !St && !Ct && (at = gt(mt)), yt && (tt = gt(yt.toLowerCase().replace("top",
                            ""))), St && (at = gt(St.toLowerCase().replace("bottom", "")))
                    } else at = gt(mt)
                }
                var _t;
                typeof ct == "boolean" ? _t = {
                    spinning: ct
                } : _typeof$2(ct) === "object" && (_t = _objectSpread2$1({
                    spinning: !0
                }, ct));
                var wt = classNames("".concat(ae.value, "-wrapper"), _defineProperty$V({}, "".concat(ae.value,
                        "-wrapper-rtl"), re.value === "rtl"), W.class),
                    Et = omit$2(C, ["columns"]);
                return createVNode("div", {
                    class: wt,
                    style: W.style
                }, [createVNode(Spin, _objectSpread2$1({
                    spinning: !1
                }, _t), {
                    default: function () {
                        return [tt, createVNode(Table$2, _objectSpread2$1(
                            _objectSpread2$1(_objectSpread2$1({}, W), Et), {}, {
                                expandedRowKeys: C.expandedRowKeys,
                                defaultExpandedRowKeys: C.defaultExpandedRowKeys,
                                expandIconColumnIndex: Xe.value,
                                indentSize: ut.value,
                                expandIcon: Qe,
                                columns: Q.value,
                                direction: re.value,
                                prefixCls: ae.value,
                                class: classNames((qe = {},
                                    _defineProperty$V(qe, "".concat(
                                            ae.value, "-middle"),
                                        ne.value === "middle"),
                                    _defineProperty$V(qe, "".concat(
                                            ae.value, "-small"), ne
                                        .value === "small"),
                                    _defineProperty$V(qe, "".concat(
                                            ae.value, "-bordered"),
                                        dt), _defineProperty$V(qe,
                                        "".concat(ae.value,
                                            "-empty"), ce.value.length ===
                                        0), qe)),
                                data: Ge.value,
                                rowKey: he.value,
                                rowClassName: Ze,
                                internalHooks: INTERNAL_HOOKS,
                                internalRefs: pe,
                                onUpdateInternalRefs: me,
                                transformColumns: st,
                                transformCellText: ie.value
                            }), _objectSpread2$1(_objectSpread2$1({}, U), {}, {
                            emptyText: function () {
                                var Nt, Rt;
                                return ((Nt = U.emptyText) === null ||
                                        Nt === void 0 ? void 0 : Nt
                                        .call(U)) || ((Rt = C.locale) ===
                                        null || Rt === void 0 ?
                                        void 0 : Rt.emptyText) ||
                                    te.value("Table")
                            }
                        })), at]
                    }
                })])
            }
        }
    }),
    Table = defineComponent({
        name: "ATable",
        inheritAttrs: !1,
        setup: function (C, H) {
            var W = H.attrs,
                U = H.slots,
                G = H.expose,
                X = ref();
            return G({
                    table: X
                }),
                function () {
                    var Z, Q = W,
                        ee = Q.columns || convertChildrenToColumns((Z = U.default) === null || Z === void 0 ?
                            void 0 : Z.call(U));
                    return createVNode(InteralTable, _objectSpread2$1(_objectSpread2$1({
                        ref: X
                    }, W), {}, {
                        columns: ee || [],
                        expandedRowRender: U.expandedRowRender,
                        contextSlots: _objectSpread2$1({}, U)
                    }), U)
                }
        }
    });
const Table$1 = Table,
    Column = defineComponent({
        name: "ATableColumn",
        slots: ["title", "filterIcon"],
        render: function () {
            return null
        }
    }),
    ColumnGroup = defineComponent({
        name: "ATableColumnGroup",
        slots: ["title"],
        __ANT_TABLE_COLUMN_GROUP: !0,
        render: function () {
            return null
        }
    });
var TableSummaryRow = defineComponent(_objectSpread2$1(_objectSpread2$1({}, SummaryRow), {}, {
        name: "ATableSummaryRow"
    })),
    TableSummaryCell = defineComponent(_objectSpread2$1(_objectSpread2$1({}, SummaryCell), {}, {
        name: "ATableSummaryCell"
    })),
    TableSummary = _extends$1(FooterComponents, {
        Cell: TableSummaryCell,
        Row: TableSummaryRow,
        name: "ATableSummary"
    });
const index$3 = _extends$1(Table$1, {
    SELECTION_ALL,
    SELECTION_INVERT,
    SELECTION_NONE,
    SELECTION_COLUMN,
    EXPAND_COLUMN,
    Column,
    ColumnGroup,
    Summary: TableSummary,
    install: function (C) {
        return C.component(TableSummary.name, TableSummary), C.component(TableSummaryCell.name,
            TableSummaryCell), C.component(TableSummaryRow.name, TableSummaryRow), C.component(Table$1.name,
            Table$1), C.component(Column.name, Column), C.component(ColumnGroup.name, ColumnGroup), C
    }
});
var transferSearchProps = {
    prefixCls: String,
    placeholder: String,
    value: String,
    handleClear: Function,
    disabled: {
        type: Boolean,
        default: void 0
    },
    onChange: Function
};
const Search = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Search",
    inheritAttrs: !1,
    props: initDefaultProps$1(transferSearchProps, {
        placeholder: ""
    }),
    emits: ["change"],
    setup: function (C, H) {
        var W = H.emit,
            U = function (X) {
                if (W("change", X), X.target.value === "") {
                    var Z;
                    (Z = C.handleClear) === null || Z === void 0 || Z.call(C)
                }
            };
        return function () {
            var G = C.placeholder,
                X = C.value,
                Z = C.prefixCls,
                Q = C.disabled;
            return createVNode(Input, {
                placeholder: G,
                class: Z,
                value: X,
                onChange: U,
                disabled: Q,
                allowClear: !0
            }, {
                prefix: function () {
                    return createVNode(SearchOutlined$1, null, null)
                }
            })
        }
    }
});
var DeleteOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z"
            }
        }]
    },
    name: "delete",
    theme: "outlined"
};
const DeleteOutlinedSvg = DeleteOutlined$2;

function _objectSpread$8(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$8(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$8(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var DeleteOutlined = function (C, H) {
    var W = _objectSpread$8({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$8({}, W, {
        icon: DeleteOutlinedSvg
    }), null)
};
DeleteOutlined.displayName = "DeleteOutlined";
DeleteOutlined.inheritAttrs = !1;
const DeleteOutlined$1 = DeleteOutlined;

function noop$2() {}
var transferListItemProps = {
    renderedText: PropTypes$1.any,
    renderedEl: PropTypes$1.any,
    item: PropTypes$1.any,
    checked: {
        type: Boolean,
        default: void 0
    },
    prefixCls: String,
    disabled: {
        type: Boolean,
        default: void 0
    },
    showRemove: {
        type: Boolean,
        default: void 0
    },
    onClick: Function,
    onRemove: Function
};
const ListItem$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ListItem",
    inheritAttrs: !1,
    props: transferListItemProps,
    emits: ["click", "remove"],
    setup: function (C, H) {
        var W = H.emit;
        return function () {
            var U, G = C.renderedText,
                X = C.renderedEl,
                Z = C.item,
                Q = C.checked,
                ee = C.disabled,
                ne = C.prefixCls,
                te = C.showRemove,
                re = classNames((U = {}, _defineProperty$V(U, "".concat(ne, "-content-item"), !0),
                    _defineProperty$V(U, "".concat(ne, "-content-item-disabled"), ee || Z.disabled),
                    U)),
                ae;
            return (typeof G == "string" || typeof G == "number") && (ae = String(G)), createVNode(
                LocaleReceiver, {
                    componentName: "Transfer",
                    defaultLocale: defaultLocale.Transfer
                }, {
                    default: function (ie) {
                        var ue = createVNode("span", {
                            class: "".concat(ne, "-content-item-text")
                        }, [X]);
                        return te ? createVNode("li", {
                            class: re,
                            title: ae
                        }, [ue, createVNode(TransButton$1, {
                            disabled: ee || Z.disabled,
                            class: "".concat(ne, "-content-item-remove"),
                            "aria-label": ie.remove,
                            onClick: function () {
                                W("remove", Z)
                            }
                        }, {
                            default: function () {
                                return [createVNode(DeleteOutlined$1, null,
                                    null)]
                            }
                        })]) : createVNode("li", {
                            class: re,
                            title: ae,
                            onClick: ee || Z.disabled ? noop$2 : function () {
                                W("click", Z)
                            }
                        }, [createVNode(Checkbox, {
                            class: "".concat(ne, "-checkbox"),
                            checked: Q,
                            disabled: ee || Z.disabled
                        }, null), ue])
                    }
                })
        }
    }
});
var transferListBodyProps = {
    prefixCls: String,
    filteredRenderItems: PropTypes$1.array.def([]),
    selectedKeys: PropTypes$1.array,
    disabled: {
        type: Boolean,
        default: void 0
    },
    showRemove: {
        type: Boolean,
        default: void 0
    },
    pagination: PropTypes$1.any,
    onItemSelect: Function,
    onScroll: Function,
    onItemRemove: Function
};

function parsePagination(K) {
    if (!K) return null;
    var C = {
        pageSize: 10
    };
    return _typeof$2(K) === "object" ? _objectSpread2$1(_objectSpread2$1({}, C), K) : C
}
var ListBody = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ListBody",
    inheritAttrs: !1,
    props: transferListBodyProps,
    emits: ["itemSelect", "itemRemove", "scroll"],
    setup: function (C, H) {
        var W = H.emit,
            U = H.expose,
            G = ref(1),
            X = function (ae) {
                var oe = C.selectedKeys,
                    ie = oe.indexOf(ae.key) >= 0;
                W("itemSelect", ae.key, !ie)
            },
            Z = function (ae) {
                W("itemRemove", [ae.key])
            },
            Q = function (ae) {
                W("scroll", ae)
            },
            ee = computed(function () {
                return parsePagination(C.pagination)
            });
        watch([ee, function () {
            return C.filteredRenderItems
        }], function () {
            if (ee.value) {
                var re = Math.ceil(C.filteredRenderItems.length / ee.value.pageSize);
                G.value > re && (G.value = re)
            }
        }, {
            immediate: !0
        });
        var ne = computed(function () {
                var re = C.filteredRenderItems,
                    ae = re;
                return ee.value && (ae = re.slice((G.value - 1) * ee.value.pageSize, G.value * ee.value
                    .pageSize)), ae
            }),
            te = function (ae) {
                G.value = ae
            };
        return U({
                items: ne
            }),
            function () {
                var re = C.prefixCls,
                    ae = C.filteredRenderItems,
                    oe = C.selectedKeys,
                    ie = C.disabled,
                    ue = C.showRemove,
                    le = null;
                ee.value && (le = createVNode(Pagination, {
                    simple: !0,
                    size: "small",
                    disabled: ie,
                    class: "".concat(re, "-pagination"),
                    total: ae.length,
                    pageSize: ee.value.pageSize,
                    current: G.value,
                    onChange: te
                }, null));
                var se = ne.value.map(function (ce) {
                    var de = ce.renderedEl,
                        ve = ce.renderedText,
                        fe = ce.item,
                        pe = fe.disabled,
                        me = oe.indexOf(fe.key) >= 0;
                    return createVNode(ListItem$1, {
                        disabled: ie || pe,
                        key: fe.key,
                        item: fe,
                        renderedText: ve,
                        renderedEl: de,
                        checked: me,
                        prefixCls: re,
                        onClick: X,
                        onRemove: Z,
                        showRemove: ue
                    }, null)
                });
                return createVNode(Fragment, null, [createVNode("ul", {
                    class: classNames("".concat(re, "-content"), _defineProperty$V({}, "".concat(
                        re, "-content-show-remove"), ue)),
                    onScroll: Q
                }, [se]), le])
            }
    }
});
const ListBody$1 = ListBody;
var defaultRender = function () {
    return null
};

function isRenderResultPlainObject(K) {
    return K && !isValidElement(K) && Object.prototype.toString.call(K) === "[object Object]"
}

function getEnabledItemKeys(K) {
    return K.filter(function (C) {
        return !C.disabled
    }).map(function (C) {
        return C.key
    })
}
var transferListProps = {
    prefixCls: String,
    dataSource: {
        type: Array,
        default: []
    },
    filter: String,
    filterOption: Function,
    checkedKeys: PropTypes$1.arrayOf(PropTypes$1.string),
    handleFilter: Function,
    handleClear: Function,
    renderItem: Function,
    showSearch: {
        type: Boolean,
        default: !1
    },
    searchPlaceholder: String,
    notFoundContent: PropTypes$1.any,
    itemUnit: String,
    itemsUnit: String,
    renderList: PropTypes$1.any,
    disabled: {
        type: Boolean,
        default: void 0
    },
    direction: String,
    showSelectAll: {
        type: Boolean,
        default: void 0
    },
    remove: String,
    selectAll: String,
    selectCurrent: String,
    selectInvert: String,
    removeAll: String,
    removeCurrent: String,
    selectAllLabel: PropTypes$1.any,
    showRemove: {
        type: Boolean,
        default: void 0
    },
    pagination: PropTypes$1.any,
    onItemSelect: Function,
    onItemSelectAll: Function,
    onItemRemove: Function,
    onScroll: Function
};
const List = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "TransferList",
    inheritAttrs: !1,
    props: transferListProps,
    slots: ["footer", "titleText"],
    setup: function (C, H) {
        var W = H.attrs,
            U = H.slots,
            G = ref(""),
            X = ref(),
            Z = ref(),
            Q = function (fe, pe) {
                var me = fe ? fe(pe) : null,
                    he = !!me && filterEmpty(me).length > 0;
                return he || (me = createVNode(ListBody$1, _objectSpread2$1(_objectSpread2$1({}, pe), {}, {
                    ref: Z
                }), null)), {
                    customize: he,
                    bodyContent: me
                }
            },
            ee = function (fe) {
                var pe = C.renderItem,
                    me = pe === void 0 ? defaultRender : pe,
                    he = me(fe),
                    Se = isRenderResultPlainObject(he);
                return {
                    renderedText: Se ? he.value : he,
                    renderedEl: Se ? he.label : he,
                    item: fe
                }
            },
            ne = ref([]),
            te = ref([]);
        watchEffect(function () {
            var ve = [],
                fe = [];
            C.dataSource.forEach(function (pe) {
                var me = ee(pe),
                    he = me.renderedText;
                if (G.value && G.value.trim() && !se(he, pe)) return null;
                ve.push(pe), fe.push(me)
            }), ne.value = ve, te.value = fe
        });
        var re = computed(function () {
                var ve = C.checkedKeys;
                return ve.length === 0 ? "none" : ne.value.every(function (fe) {
                    return ve.indexOf(fe.key) >= 0 || !!fe.disabled
                }) ? "all" : "part"
            }),
            ae = computed(function () {
                return getEnabledItemKeys(ne.value)
            }),
            oe = function (fe, pe) {
                return Array.from(new Set([].concat(_toConsumableArray(fe), _toConsumableArray(C.checkedKeys))))
                    .filter(function (me) {
                        return pe.indexOf(me) === -1
                    })
            },
            ie = function (fe) {
                var pe = fe.disabled,
                    me = fe.prefixCls,
                    he = re.value === "all",
                    Se = createVNode(Checkbox, {
                        disabled: pe,
                        checked: he,
                        indeterminate: re.value === "part",
                        class: "".concat(me, "-checkbox"),
                        onChange: function () {
                            var be = ae.value;
                            C.onItemSelectAll(oe(he ? [] : be, he ? C.checkedKeys : []))
                        }
                    }, null);
                return Se
            },
            ue = function (fe) {
                var pe, me = fe.target.value;
                G.value = me, (pe = C.handleFilter) === null || pe === void 0 || pe.call(C, fe)
            },
            le = function (fe) {
                var pe;
                G.value = "", (pe = C.handleClear) === null || pe === void 0 || pe.call(C, fe)
            },
            se = function (fe, pe) {
                var me = C.filterOption;
                return me ? me(G.value, pe) : fe.indexOf(G.value) >= 0
            },
            ce = function (fe, pe) {
                var me = C.itemsUnit,
                    he = C.itemUnit,
                    Se = C.selectAllLabel;
                if (Se) return typeof Se == "function" ? Se({
                    selectedCount: fe,
                    totalCount: pe
                }) : Se;
                var _e = pe > 1 ? me : he;
                return createVNode(Fragment, null, [(fe > 0 ? "".concat(fe, "/") : "") + pe,
                    createTextVNode(" "), _e])
            },
            de = function (fe, pe, me, he, Se, _e) {
                var be = Se ? createVNode("div", {
                        class: "".concat(fe, "-body-search-wrapper")
                    }, [createVNode(Search, {
                        prefixCls: "".concat(fe, "-search"),
                        onChange: ue,
                        handleClear: le,
                        placeholder: pe,
                        value: G.value,
                        disabled: _e
                    }, null)]) : null,
                    ge, xe = splitAttrs(W),
                    Pe = xe.onEvents,
                    $e = Q(he, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                        filteredItems: ne.value,
                        filteredRenderItems: te.value,
                        selectedKeys: me
                    }, Pe)),
                    ye = $e.bodyContent,
                    Ce = $e.customize;
                return Ce ? ge = createVNode("div", {
                    class: "".concat(fe, "-body-customize-wrapper")
                }, [ye]) : ge = ne.value.length ? ye : createVNode("div", {
                    class: "".concat(fe, "-body-not-found")
                }, [C.notFoundContent]), createVNode("div", {
                    class: Se ? "".concat(fe, "-body ").concat(fe, "-body-with-search") : "".concat(
                        fe, "-body"),
                    ref: X
                }, [be, ge])
            };
        return function () {
            var ve, fe, pe, me = C.prefixCls,
                he = C.checkedKeys,
                Se = C.disabled,
                _e = C.showSearch,
                be = C.searchPlaceholder,
                ge = C.selectAll,
                xe = C.selectCurrent,
                Pe = C.selectInvert,
                $e = C.removeAll,
                ye = C.removeCurrent,
                Ce = C.renderList,
                we = C.onItemSelectAll,
                Oe = C.onItemRemove,
                Ne = C.showSelectAll,
                Me = Ne === void 0 ? !0 : Ne,
                Ve = C.showRemove,
                ke = C.pagination,
                Ee = (ve = U.footer) === null || ve === void 0 ? void 0 : ve.call(U, _objectSpread2$1({},
                    C)),
                Ae = classNames(me, (fe = {}, _defineProperty$V(fe, "".concat(me, "-with-pagination"),
                    !!ke), _defineProperty$V(fe, "".concat(me, "-with-footer"), !!Ee), fe)),
                Re = de(me, be, he, Ce, _e, Se),
                He = Ee ? createVNode("div", {
                    class: "".concat(me, "-footer")
                }, [Ee]) : null,
                je = !Ve && !ke && ie({
                    disabled: Se,
                    prefixCls: me
                }),
                Fe = null;
            Ve ? Fe = createVNode(Menu, null, {
                default: function () {
                    return [ke && createVNode(Menu.Item, {
                        key: "removeCurrent",
                        onClick: function () {
                            var De = getEnabledItemKeys((Z.value.items || [])
                                .map(function (Ke) {
                                    return Ke.item
                                }));
                            Oe == null || Oe(De)
                        }
                    }, {
                        default: function () {
                            return [ye]
                        }
                    }), createVNode(Menu.Item, {
                        key: "removeAll",
                        onClick: function () {
                            Oe == null || Oe(ae.value)
                        }
                    }, {
                        default: function () {
                            return [$e]
                        }
                    })]
                }
            }) : Fe = createVNode(Menu, null, {
                default: function () {
                    return [createVNode(Menu.Item, {
                        key: "selectAll",
                        onClick: function () {
                            var De = ae.value;
                            we(oe(De, []))
                        }
                    }, {
                        default: function () {
                            return [ge]
                        }
                    }), ke && createVNode(Menu.Item, {
                        onClick: function () {
                            var De = getEnabledItemKeys((Z.value.items || [])
                                .map(function (Ke) {
                                    return Ke.item
                                }));
                            we(oe(De, []))
                        }
                    }, {
                        default: function () {
                            return [xe]
                        }
                    }), createVNode(Menu.Item, {
                        key: "selectInvert",
                        onClick: function () {
                            var De;
                            ke ? De = getEnabledItemKeys((Z.value.items ||
                                []).map(function (et) {
                                return et.item
                            })) : De = ae.value;
                            var Ke = new Set(he),
                                We = [],
                                Ue = [];
                            De.forEach(function (et) {
                                Ke.has(et) ? Ue.push(et) : We.push(
                                    et)
                            }), we(oe(We, Ue))
                        }
                    }, {
                        default: function () {
                            return [Pe]
                        }
                    })]
                }
            });
            var Le = createVNode(Dropdown$1, {
                class: "".concat(me, "-header-dropdown"),
                overlay: Fe,
                disabled: Se
            }, {
                default: function () {
                    return [createVNode(DownOutlined$1, null, null)]
                }
            });
            return createVNode("div", {
                class: Ae,
                style: W.style
            }, [createVNode("div", {
                class: "".concat(me, "-header")
            }, [Me ? createVNode(Fragment, null, [je, Le]) : null, createVNode("span", {
                class: "".concat(me, "-header-selected")
            }, [createVNode("span", null, [ce(he.length, ne.value.length)]),
                createVNode("span", {
                    class: "".concat(me, "-header-title")
                }, [(pe = U.titleText) === null || pe === void 0 ? void 0 :
                    pe.call(U)])])]), Re, He])
        }
    }
});

function noop$1() {}
var Operation = function (C) {
    var H = C.disabled,
        W = C.moveToLeft,
        U = W === void 0 ? noop$1 : W,
        G = C.moveToRight,
        X = G === void 0 ? noop$1 : G,
        Z = C.leftArrowText,
        Q = Z === void 0 ? "" : Z,
        ee = C.rightArrowText,
        ne = ee === void 0 ? "" : ee,
        te = C.leftActive,
        re = C.rightActive,
        ae = C.class,
        oe = C.style,
        ie = C.direction,
        ue = C.oneWay;
    return createVNode("div", {
        class: ae,
        style: oe
    }, [createVNode(Button$1, {
        type: "primary",
        size: "small",
        disabled: H || !re,
        onClick: X,
        icon: createVNode(ie !== "rtl" ? RightOutlined$1 : LeftOutlined$1, null, null)
    }, {
        default: function () {
            return [ne]
        }
    }), !ue && createVNode(Button$1, {
        type: "primary",
        size: "small",
        disabled: H || !te,
        onClick: U,
        icon: createVNode(ie !== "rtl" ? LeftOutlined$1 : RightOutlined$1, null, null)
    }, {
        default: function () {
            return [Q]
        }
    })])
};
Operation.displayName = "Operation";
Operation.inheritAttrs = !1;
const Operation$1 = Operation;
var transferProps = function () {
        return {
            id: String,
            prefixCls: String,
            dataSource: {
                type: Array,
                default: []
            },
            disabled: {
                type: Boolean,
                default: void 0
            },
            targetKeys: {
                type: Array,
                default: void 0
            },
            selectedKeys: {
                type: Array,
                default: void 0
            },
            render: {
                type: Function
            },
            listStyle: {
                type: [Function, Object],
                default: function () {
                    return {}
                }
            },
            operationStyle: {
                type: Object,
                default: void 0
            },
            titles: {
                type: Array
            },
            operations: {
                type: Array
            },
            showSearch: {
                type: Boolean,
                default: !1
            },
            filterOption: {
                type: Function
            },
            searchPlaceholder: String,
            notFoundContent: PropTypes$1.any,
            locale: {
                type: Object,
                default: function () {
                    return {}
                }
            },
            rowKey: {
                type: Function
            },
            showSelectAll: {
                type: Boolean,
                default: void 0
            },
            selectAllLabels: {
                type: Array
            },
            children: {
                type: Function
            },
            oneWay: {
                type: Boolean,
                default: void 0
            },
            pagination: {
                type: [Object, Boolean],
                default: void 0
            },
            onChange: Function,
            onSelectChange: Function,
            onSearch: Function,
            onScroll: Function,
            "onUpdate:targetKeys": Function,
            "onUpdate:selectedKeys": Function
        }
    },
    Transfer = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ATransfer",
        inheritAttrs: !1,
        props: transferProps(),
        slots: ["leftTitle", "rightTitle", "children", "render", "notFoundContent", "leftSelectAllLabel",
            "rightSelectAllLabel", "footer"],
        setup: function (C, H) {
            var W = H.emit,
                U = H.attrs,
                G = H.slots,
                X = H.expose,
                Z = useConfigInject("transfer", C),
                Q = Z.configProvider,
                ee = Z.prefixCls,
                ne = Z.direction,
                te = ref([]),
                re = ref([]),
                ae = useInjectFormItemContext();
            watch(function () {
                return C.selectedKeys
            }, function () {
                var Ve, ke;
                te.value = ((Ve = C.selectedKeys) === null || Ve === void 0 ? void 0 : Ve.filter(
                    function (Ee) {
                        return C.targetKeys.indexOf(Ee) === -1
                    })) || [], re.value = ((ke = C.selectedKeys) === null || ke === void 0 ? void 0 :
                    ke.filter(function (Ee) {
                        return C.targetKeys.indexOf(Ee) > -1
                    })) || []
            }, {
                immediate: !0
            });
            var oe = function (ke, Ee) {
                    var Ae = {
                            notFoundContent: Ee("Transfer")
                        },
                        Re = getPropsSlot(G, C, "notFoundContent");
                    return Re && (Ae.notFoundContent = Re), C.searchPlaceholder !== void 0 && (Ae.searchPlaceholder =
                        C.searchPlaceholder), _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, ke),
                        Ae), C.locale)
                },
                ie = function (ke) {
                    var Ee = C.targetKeys,
                        Ae = Ee === void 0 ? [] : Ee,
                        Re = C.dataSource,
                        He = Re === void 0 ? [] : Re,
                        je = ke === "right" ? te.value : re.value,
                        Fe = je.filter(function (Te) {
                            return !He.some(function (De) {
                                return !!(Te === De.key && De.disabled)
                            })
                        }),
                        Le = ke === "right" ? Fe.concat(Ae) : Ae.filter(function (Te) {
                            return Fe.indexOf(Te) === -1
                        }),
                        Ie = ke === "right" ? "left" : "right";
                    ke === "right" ? te.value = [] : re.value = [], W("update:targetKeys", Le), ve(Ie, []), W(
                        "change", Le, ke, Fe), ae.onFieldChange()
                },
                ue = function () {
                    ie("left")
                },
                le = function () {
                    ie("right")
                },
                se = function (ke, Ee) {
                    ve(ke, Ee)
                },
                ce = function (ke) {
                    return se("left", ke)
                },
                de = function (ke) {
                    return se("right", ke)
                },
                ve = function (ke, Ee) {
                    ke === "left" ? (C.selectedKeys || (te.value = Ee), W("update:selectedKeys", [].concat(
                        _toConsumableArray(Ee), _toConsumableArray(re.value))), W("selectChange", Ee,
                        toRaw(re.value))) : (C.selectedKeys || (re.value = Ee), W("update:selectedKeys", []
                        .concat(_toConsumableArray(Ee), _toConsumableArray(te.value))), W(
                        "selectChange", toRaw(te.value), Ee))
                },
                fe = function (ke, Ee) {
                    var Ae = Ee.target.value;
                    W("search", ke, Ae)
                },
                pe = function (ke) {
                    fe("left", ke)
                },
                me = function (ke) {
                    fe("right", ke)
                },
                he = function (ke) {
                    W("search", ke, "")
                },
                Se = function () {
                    he("left")
                },
                _e = function () {
                    he("right")
                },
                be = function (ke, Ee, Ae) {
                    var Re = _toConsumableArray(ke === "left" ? te.value : re.value),
                        He = Re.indexOf(Ee);
                    He > -1 && Re.splice(He, 1), Ae && Re.push(Ee), ve(ke, Re)
                },
                ge = function (ke, Ee) {
                    return be("left", ke, Ee)
                },
                xe = function (ke, Ee) {
                    return be("right", ke, Ee)
                },
                Pe = function (ke) {
                    var Ee = C.targetKeys,
                        Ae = Ee === void 0 ? [] : Ee,
                        Re = Ae.filter(function (He) {
                            return !ke.includes(He)
                        });
                    W("update:targetKeys", Re), W("change", Re, "left", _toConsumableArray(ke))
                },
                $e = function (ke, Ee) {
                    W("scroll", ke, Ee)
                },
                ye = function (ke) {
                    $e("left", ke)
                },
                Ce = function (ke) {
                    $e("right", ke)
                },
                we = function (ke, Ee) {
                    return typeof ke == "function" ? ke({
                        direction: Ee
                    }) : ke
                },
                Oe = ref([]),
                Ne = ref([]);
            watchEffect(function () {
                var Ve = C.dataSource,
                    ke = C.rowKey,
                    Ee = C.targetKeys,
                    Ae = Ee === void 0 ? [] : Ee,
                    Re = [],
                    He = new Array(Ae.length);
                Ve.forEach(function (je) {
                    ke && (je.key = ke(je));
                    var Fe = Ae.indexOf(je.key);
                    Fe !== -1 ? He[Fe] = je : Re.push(je)
                }), Oe.value = Re, Ne.value = He
            }), X({
                handleSelectChange: ve
            });
            var Me = function (ke) {
                var Ee, Ae, Re, He, je, Fe, Le, Ie = C.disabled,
                    Te = C.operations,
                    De = Te === void 0 ? [] : Te,
                    Ke = C.showSearch,
                    We = C.listStyle,
                    Ue = C.operationStyle,
                    et = C.filterOption,
                    Ye = C.showSelectAll,
                    ze = C.selectAllLabels,
                    Be = ze === void 0 ? [] : ze,
                    Ge = C.oneWay,
                    Xe = C.pagination,
                    nt = C.id,
                    it = nt === void 0 ? ae.id.value : nt,
                    ft = U.class,
                    pt = U.style,
                    ot = G.children,
                    Ze = !ot && Xe,
                    ut = Q.renderEmpty,
                    st = oe(ke, ut),
                    rt = G.footer,
                    qe = C.render || G.render,
                    Je = re.value.length > 0,
                    Qe = te.value.length > 0,
                    lt = classNames(ee.value, ft, (Ee = {}, _defineProperty$V(Ee, "".concat(ee.value,
                        "-disabled"), Ie), _defineProperty$V(Ee, "".concat(ee.value,
                        "-customize-list"), !!ot), Ee)),
                    ct = C.titles,
                    dt = (Ae = (Re = ct && ct[0]) !== null && Re !== void 0 ? Re : (He = G.leftTitle) ===
                        null || He === void 0 ? void 0 : He.call(G)) !== null && Ae !== void 0 ? Ae : (st.titles ||
                        ["", ""])[0],
                    tt = (je = (Fe = ct && ct[1]) !== null && Fe !== void 0 ? Fe : (Le = G.rightTitle) ===
                        null || Le === void 0 ? void 0 : Le.call(G)) !== null && je !== void 0 ? je : (st.titles ||
                        ["", ""])[1];
                return createVNode("div", {
                    class: lt,
                    style: pt,
                    id: it
                }, [createVNode(List, _objectSpread2$1({
                    key: "leftList",
                    prefixCls: "".concat(ee.value, "-list"),
                    dataSource: Oe.value,
                    filterOption: et,
                    style: we(We, "left"),
                    checkedKeys: te.value,
                    handleFilter: pe,
                    handleClear: Se,
                    onItemSelect: ge,
                    onItemSelectAll: ce,
                    renderItem: qe,
                    showSearch: Ke,
                    renderList: ot,
                    onScroll: ye,
                    disabled: Ie,
                    direction: ne.value === "rtl" ? "right" : "left",
                    showSelectAll: Ye,
                    selectAllLabel: Be[0] || G.leftSelectAllLabel,
                    pagination: Ze
                }, st), {
                    titleText: function () {
                        return dt
                    },
                    footer: rt
                }), createVNode(Operation$1, {
                    key: "operation",
                    class: "".concat(ee.value, "-operation"),
                    rightActive: Qe,
                    rightArrowText: De[0],
                    moveToRight: le,
                    leftActive: Je,
                    leftArrowText: De[1],
                    moveToLeft: ue,
                    style: Ue,
                    disabled: Ie,
                    direction: ne.value,
                    oneWay: Ge
                }, null), createVNode(List, _objectSpread2$1({
                    key: "rightList",
                    prefixCls: "".concat(ee.value, "-list"),
                    dataSource: Ne.value,
                    filterOption: et,
                    style: we(We, "right"),
                    checkedKeys: re.value,
                    handleFilter: me,
                    handleClear: _e,
                    onItemSelect: xe,
                    onItemSelectAll: de,
                    onItemRemove: Pe,
                    renderItem: qe,
                    showSearch: Ke,
                    renderList: ot,
                    onScroll: Ce,
                    disabled: Ie,
                    direction: ne.value === "rtl" ? "left" : "right",
                    showSelectAll: Ye,
                    selectAllLabel: Be[1] || G.rightSelectAllLabel,
                    showRemove: Ge,
                    pagination: Ze
                }, st), {
                    titleText: function () {
                        return tt
                    },
                    footer: rt
                })])
            };
            return function () {
                return createVNode(LocaleReceiver, {
                    componentName: "Transfer",
                    defaultLocale: defaultLocale.Transfer,
                    children: Me
                }, null)
            }
        }
    });
const index$2 = withInstall(Transfer);

function toArray$1(K) {
    return Array.isArray(K) ? K : K !== void 0 ? [K] : []
}

function fillFieldNames(K) {
    var C = K || {},
        H = C.label,
        W = C.value,
        U = C.children,
        G = W || "value";
    return {
        _title: H ? [H] : ["title", "label"],
        value: G,
        key: G,
        children: U || "children"
    }
}

function isCheckDisabled(K) {
    return K.disabled || K.disableCheckbox || K.checkable === !1
}

function getAllKeys(K, C) {
    var H = [];

    function W(U) {
        U.forEach(function (G) {
            H.push(G[C.value]);
            var X = G[C.children];
            X && W(X)
        })
    }
    return W(K), H
}

function isNil(K) {
    return K == null
}
var TreeSelectContextPropsKey = Symbol("TreeSelectContextPropsKey");

function useProvideSelectContext(K) {
    return provide(TreeSelectContextPropsKey, K)
}

function useInjectSelectContext() {
    return inject(TreeSelectContextPropsKey, {})
}
var HIDDEN_STYLE = {
    width: 0,
    height: 0,
    display: "flex",
    overflow: "hidden",
    opacity: 0,
    border: 0,
    padding: 0,
    margin: 0
};
const OptionList = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "OptionList",
    inheritAttrs: !1,
    slots: ["notFoundContent", "menuItemSelectedIcon"],
    setup: function (C, H) {
        var W = H.slots,
            U = H.expose,
            G = useBaseProps(),
            X = useInjectLegacySelectContext(),
            Z = useInjectSelectContext(),
            Q = ref(),
            ee = useMemo(function () {
                return Z.treeData
            }, [function () {
                return G.open
            }, function () {
                return Z.treeData
            }], function (fe) {
                return fe[0]
            }),
            ne = computed(function () {
                var fe = X.checkable,
                    pe = X.halfCheckedKeys,
                    me = X.checkedKeys;
                return fe ? {
                    checked: me,
                    halfChecked: pe
                } : null
            });
        watch(function () {
            return G.open
        }, function () {
            nextTick(function () {
                if (G.open && !G.multiple && X.checkedKeys.length) {
                    var fe;
                    (fe = Q.value) === null || fe === void 0 || fe.scrollTo({
                        key: X.checkedKeys[0]
                    })
                }
            })
        }, {
            immediate: !0,
            flush: "post"
        });
        var te = computed(function () {
                return String(G.searchValue).toLowerCase()
            }),
            re = function (pe) {
                return te.value ? String(pe[X.treeNodeFilterProp]).toLowerCase().includes(te.value) : !1
            },
            ae = shallowRef(X.treeDefaultExpandedKeys),
            oe = shallowRef(null);
        watch(function () {
            return G.searchValue
        }, function () {
            G.searchValue && (oe.value = getAllKeys(toRaw(Z.treeData), toRaw(Z.fieldNames)))
        }, {
            immediate: !0
        });
        var ie = computed(function () {
                return X.treeExpandedKeys ? X.treeExpandedKeys.slice() : G.searchValue ? oe.value : ae.value
            }),
            ue = function (pe) {
                var me;
                ae.value = pe, oe.value = pe, (me = X.onTreeExpand) === null || me === void 0 || me.call(X,
                    pe)
            },
            le = function (pe) {
                pe.preventDefault()
            },
            se = function (pe, me) {
                var he, Se = me.node,
                    _e = X.checkable,
                    be = X.checkedKeys;
                if (!(_e && isCheckDisabled(Se)) && ((he = Z.onSelect) === null || he === void 0 || he.call(
                        Z, Se.key, {
                            selected: !be.includes(Se.key)
                        }), !G.multiple)) {
                    var ge;
                    (ge = G.toggleOpen) === null || ge === void 0 || ge.call(G, !1)
                }
            },
            ce = ref(null),
            de = computed(function () {
                return X.keyEntities[ce.value]
            }),
            ve = function (pe) {
                ce.value = pe
            };
        return U({
                scrollTo: function () {
                    for (var pe, me, he = arguments.length, Se = new Array(he), _e = 0; _e < he; _e++)
                        Se[_e] = arguments[_e];
                    return (pe = Q.value) === null || pe === void 0 || (me = pe.scrollTo) === null ||
                        me === void 0 ? void 0 : me.call.apply(me, [pe].concat(Se))
                },
                onKeydown: function (pe) {
                    var me, he = pe.which;
                    switch (he) {
                        case KeyCode$1.UP:
                        case KeyCode$1.DOWN:
                        case KeyCode$1.LEFT:
                        case KeyCode$1.RIGHT:
                            (me = Q.value) === null || me === void 0 || me.onKeydown(pe);
                            break;
                        case KeyCode$1.ENTER:
                            {
                                if (de.value) {
                                    var Se = de.value.node || {},
                                        _e = Se.selectable,
                                        be = Se.value;
                                    _e !== !1 && se(null, {
                                        node: {
                                            key: ce.value
                                        },
                                        selected: !X.checkedKeys.includes(be)
                                    })
                                }
                                break
                            }
                        case KeyCode$1.ESC:
                            G.toggleOpen(!1)
                    }
                },
                onKeyup: function () {}
            }),
            function () {
                var fe, pe = G.prefixCls,
                    me = G.multiple,
                    he = G.searchValue,
                    Se = G.open,
                    _e = G.notFoundContent,
                    be = _e === void 0 ? (fe = W.notFoundContent) === null || fe === void 0 ? void 0 : fe.call(
                        W) : _e,
                    ge = Z.listHeight,
                    xe = Z.listItemHeight,
                    Pe = Z.virtual,
                    $e = X.checkable,
                    ye = X.treeDefaultExpandAll,
                    Ce = X.treeIcon,
                    we = X.showTreeIcon,
                    Oe = X.switcherIcon,
                    Ne = X.treeLine,
                    Me = X.loadData,
                    Ve = X.treeLoadedKeys,
                    ke = X.treeMotion,
                    Ee = X.onTreeLoad,
                    Ae = X.checkedKeys;
                if (ee.value.length === 0) return createVNode("div", {
                    role: "listbox",
                    class: "".concat(pe, "-empty"),
                    onMousedown: le
                }, [be]);
                var Re = {
                    fieldNames: Z.fieldNames
                };
                return Ve && (Re.loadedKeys = Ve), ie.value && (Re.expandedKeys = ie.value), createVNode(
                    "div", {
                        onMousedown: le
                    }, [de.value && Se && createVNode("span", {
                        style: HIDDEN_STYLE,
                        "aria-live": "assertive"
                    }, [de.value.node.value]), createVNode(Tree$2, _objectSpread2$1(
                        _objectSpread2$1({
                            ref: Q,
                            focusable: !1,
                            prefixCls: "".concat(pe, "-tree"),
                            treeData: ee.value,
                            height: ge,
                            itemHeight: xe,
                            virtual: Pe,
                            multiple: me,
                            icon: Ce,
                            showIcon: we,
                            switcherIcon: Oe,
                            showLine: Ne,
                            loadData: he ? null : Me,
                            motion: ke,
                            activeKey: ce.value,
                            checkable: $e,
                            checkStrictly: !0,
                            checkedKeys: ne.value,
                            selectedKeys: $e ? [] : Ae,
                            defaultExpandAll: ye
                        }, Re), {}, {
                            onActiveChange: ve,
                            onSelect: se,
                            onCheck: se,
                            onExpand: ue,
                            onLoad: Ee,
                            filterTreeNode: re
                        }), _objectSpread2$1(_objectSpread2$1({}, W), {}, {
                        checkable: X.customSlots.treeCheckable
                    }))])
            }
    }
});
var SHOW_ALL = "SHOW_ALL",
    SHOW_PARENT = "SHOW_PARENT",
    SHOW_CHILD = "SHOW_CHILD";

function formatStrategyValues(K, C, H, W) {
    var U = new Set(K);
    return C === SHOW_CHILD ? K.filter(function (G) {
        var X = H[G];
        return !(X && X.children && X.children.some(function (Z) {
            var Q = Z.node;
            return U.has(Q[W.value])
        }) && X.children.every(function (Z) {
            var Q = Z.node;
            return isCheckDisabled(Q) || U.has(Q[W.value])
        }))
    }) : C === SHOW_PARENT ? K.filter(function (G) {
        var X = H[G],
            Z = X ? X.parent : null;
        return !(Z && !isCheckDisabled(Z.node) && U.has(Z.key))
    }) : K
}
var TreeNode = function () {
    return null
};
TreeNode.inheritAttrs = !1;
TreeNode.displayName = "ATreeSelectNode";
TreeNode.isTreeSelectNode = !0;
const TreeNode$1 = TreeNode;
var _excluded$7 = ["title", "switcherIcon"];

function isTreeSelectNode(K) {
    return K && K.type && K.type.isTreeSelectNode
}

function convertChildrenToData(K) {
    function C() {
        var H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        return filterEmpty(H).map(function (W) {
            var U, G, X;
            if (!isTreeSelectNode(W)) return null;
            for (var Z = W.children || {}, Q = W.key, ee = {}, ne = 0, te = Object.entries(W.props); ne < te.length; ne++) {
                var re = _slicedToArray$2(te[ne], 2),
                    ae = re[0],
                    oe = re[1];
                ee[camelize$1(ae)] = oe
            }
            var ie = ee.isLeaf,
                ue = ee.checkable,
                le = ee.selectable,
                se = ee.disabled,
                ce = ee.disableCheckbox,
                de = {
                    isLeaf: ie || ie === "" || void 0,
                    checkable: ue || ue === "" || void 0,
                    selectable: le || le === "" || void 0,
                    disabled: se || se === "" || void 0,
                    disableCheckbox: ce || ce === "" || void 0
                },
                ve = _objectSpread2$1(_objectSpread2$1({}, ee), de),
                fe = ee.title,
                pe = fe === void 0 ? (U = Z.title) === null || U === void 0 ? void 0 : U.call(Z, ve) : fe,
                me = ee.switcherIcon,
                he = me === void 0 ? (G = Z.switcherIcon) === null || G === void 0 ? void 0 : G.call(Z, ve) :
                me,
                Se = _objectWithoutProperties$2(ee, _excluded$7),
                _e = (X = Z.default) === null || X === void 0 ? void 0 : X.call(Z),
                be = _objectSpread2$1(_objectSpread2$1({}, Se), {}, {
                    title: pe,
                    switcherIcon: he,
                    key: Q,
                    isLeaf: ie
                }, de),
                ge = C(_e);
            return ge.length && (be.children = ge), be
        })
    }
    return C(K)
}

function fillLegacyProps(K) {
    if (!K) return K;
    var C = _objectSpread2$1({}, K);
    return "props" in C || Object.defineProperty(C, "props", {
        get: function () {
            return C
        }
    }), C
}

function fillAdditionalInfo(K, C, H, W, U, G) {
    var X = null,
        Z = null;

    function Q() {
        function ee(ne) {
            var te = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "0",
                re = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
            return ne.map(function (ae, oe) {
                var ie = "".concat(te, "-").concat(oe),
                    ue = ae[G.value],
                    le = H.includes(ue),
                    se = ee(ae[G.children] || [], ie, le),
                    ce = createVNode(TreeNode$1, ae, {
                        default: function () {
                            return [se.map(function (fe) {
                                return fe.node
                            })]
                        }
                    });
                if (C === ue && (X = ce), le) {
                    var de = {
                        pos: ie,
                        node: ce,
                        children: se
                    };
                    return re || Z.push(de), de
                }
                return null
            }).filter(function (ae) {
                return ae
            })
        }
        Z || (Z = [], ee(W), Z.sort(function (ne, te) {
            var re = ne.node.props.value,
                ae = te.node.props.value,
                oe = H.indexOf(re),
                ie = H.indexOf(ae);
            return oe - ie
        }))
    }
    Object.defineProperty(K, "triggerNode", {
        get: function () {
            return Q(), X
        }
    }), Object.defineProperty(K, "allCheckedNodes", {
        get: function () {
            return Q(), U ? Z : Z.map(function (ne) {
                var te = ne.node;
                return te
            })
        }
    })
}

function parseSimpleTreeData(K, C) {
    var H = C.id,
        W = C.pId,
        U = C.rootPId,
        G = {},
        X = [],
        Z = K.map(function (Q) {
            var ee = _objectSpread2$1({}, Q),
                ne = ee[H];
            return G[ne] = ee, ee.key = ee.key || ne, ee
        });
    return Z.forEach(function (Q) {
        var ee = Q[W],
            ne = G[ee];
        ne && (ne.children = ne.children || [], ne.children.push(Q)), (ee === U || !ne && U === null) && X.push(
            Q)
    }), X
}

function useTreeData(K, C, H) {
    var W = shallowRef();
    return watch([H, K, C], function () {
        var U = H.value;
        K.value ? W.value = H.value ? parseSimpleTreeData(toRaw(K.value), _objectSpread2$1({
            id: "id",
            pId: "pId",
            rootPId: null
        }, U !== !0 ? U : {})) : toRaw(K.value).slice() : W.value = convertChildrenToData(toRaw(C.value))
    }, {
        immediate: !0,
        deep: !0
    }), W
}
const useCache = function (K) {
        var C = shallowRef({
                valueLabels: new Map
            }),
            H = shallowRef();
        watch(K, function () {
            H.value = toRaw(K.value)
        }, {
            immediate: !0
        });
        var W = computed(function () {
            var U = C.value.valueLabels,
                G = new Map,
                X = H.value.map(function (Z) {
                    var Q, ee = Z.value,
                        ne = (Q = Z.label) !== null && Q !== void 0 ? Q : U.get(ee);
                    return G.set(ee, ne), _objectSpread2$1(_objectSpread2$1({}, Z), {}, {
                        label: ne
                    })
                });
            return C.value.valueLabels = G, X
        });
        return [W]
    },
    useDataEntities = function (K, C) {
        var H = shallowRef(new Map),
            W = shallowRef({});
        return watchEffect(function () {
            var U = C.value,
                G = convertDataToEntities(K.value, {
                    fieldNames: U,
                    initWrapper: function (Z) {
                        return _objectSpread2$1(_objectSpread2$1({}, Z), {}, {
                            valueEntities: new Map
                        })
                    },
                    processEntity: function (Z, Q) {
                        var ee = Z.node[U.value];
                        Q.valueEntities.set(ee, Z)
                    }
                });
            H.value = G.valueEntities, W.value = G.keyEntities
        }), {
            valueEntities: H,
            keyEntities: W
        }
    },
    useCheckedKeys = function (K, C, H, W, U, G) {
        var X = shallowRef([]),
            Z = shallowRef([]);
        return watchEffect(function () {
            var Q = K.value.map(function (re) {
                    var ae = re.value;
                    return ae
                }),
                ee = C.value.map(function (re) {
                    var ae = re.value;
                    return ae
                }),
                ne = Q.filter(function (re) {
                    return !W.value[re]
                });
            if (H.value) {
                var te = conductCheck(Q, !0, W.value, U.value, G.value);
                Q = te.checkedKeys, ee = te.halfCheckedKeys
            }
            X.value = Array.from(new Set([].concat(_toConsumableArray(ne), _toConsumableArray(Q)))), Z.value =
                ee
        }), [X, Z]
    },
    useFilterTreeData = function (K, C, H) {
        var W = H.treeNodeFilterProp,
            U = H.filterTreeNode,
            G = H.fieldNames;
        return computed(function () {
            var X = G.value.children,
                Z = C.value,
                Q = W == null ? void 0 : W.value;
            if (!Z || U.value === !1) return K.value;
            var ee;
            if (typeof U.value == "function") ee = U.value;
            else {
                var ne = Z.toUpperCase();
                ee = function (ae, oe) {
                    var ie = oe[Q];
                    return String(ie).toUpperCase().includes(ne)
                }
            }

            function te(re) {
                for (var ae = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, oe = [], ie =
                        0, ue = re.length; ie < ue; ie++) {
                    var le = re[ie],
                        se = le[X],
                        ce = ae || ee(Z, fillLegacyProps(le)),
                        de = te(se || [], ce);
                    (ce || de.length) && oe.push(_objectSpread2$1(_objectSpread2$1({}, le), {},
                        _defineProperty$V({}, X, de)))
                }
                return oe
            }
            return te(K.value)
        })
    };

function treeSelectProps$1() {
    return _objectSpread2$1(_objectSpread2$1({}, omit$2(baseSelectPropsWithoutPrivate(), ["mode"])), {}, {
        prefixCls: String,
        id: String,
        value: {
            type: [String, Number, Object, Array]
        },
        defaultValue: {
            type: [String, Number, Object, Array]
        },
        onChange: {
            type: Function
        },
        searchValue: String,
        inputValue: String,
        onSearch: {
            type: Function
        },
        autoClearSearchValue: {
            type: Boolean,
            default: void 0
        },
        filterTreeNode: {
            type: [Boolean, Function],
            default: void 0
        },
        treeNodeFilterProp: String,
        onSelect: Function,
        onDeselect: Function,
        showCheckedStrategy: {
            type: String
        },
        treeNodeLabelProp: String,
        fieldNames: {
            type: Object
        },
        multiple: {
            type: Boolean,
            default: void 0
        },
        treeCheckable: {
            type: Boolean,
            default: void 0
        },
        treeCheckStrictly: {
            type: Boolean,
            default: void 0
        },
        labelInValue: {
            type: Boolean,
            default: void 0
        },
        treeData: {
            type: Array
        },
        treeDataSimpleMode: {
            type: [Boolean, Object],
            default: void 0
        },
        loadData: {
            type: Function
        },
        treeLoadedKeys: {
            type: Array
        },
        onTreeLoad: {
            type: Function
        },
        treeDefaultExpandAll: {
            type: Boolean,
            default: void 0
        },
        treeExpandedKeys: {
            type: Array
        },
        treeDefaultExpandedKeys: {
            type: Array
        },
        onTreeExpand: {
            type: Function
        },
        virtual: {
            type: Boolean,
            default: void 0
        },
        listHeight: Number,
        listItemHeight: Number,
        onDropdownVisibleChange: {
            type: Function
        },
        treeLine: {
            type: [Boolean, Object],
            default: void 0
        },
        treeIcon: PropTypes$1.any,
        showTreeIcon: {
            type: Boolean,
            default: void 0
        },
        switcherIcon: PropTypes$1.any,
        treeMotion: PropTypes$1.any,
        children: Array,
        showArrow: {
            type: Boolean,
            default: void 0
        },
        showSearch: {
            type: Boolean,
            default: void 0
        },
        open: {
            type: Boolean,
            default: void 0
        },
        defaultOpen: {
            type: Boolean,
            default: void 0
        },
        disabled: {
            type: Boolean,
            default: void 0
        },
        placeholder: PropTypes$1.any,
        maxTagPlaceholder: {
            type: Function
        },
        dropdownPopupAlign: PropTypes$1.any,
        customSlots: Object
    })
}

function isRawValue(K) {
    return !K || _typeof$2(K) !== "object"
}
const TreeSelect$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "TreeSelect",
    inheritAttrs: !1,
    props: initDefaultProps$1(treeSelectProps$1(), {
        treeNodeFilterProp: "value",
        autoClearSearchValue: !0,
        showCheckedStrategy: SHOW_CHILD,
        listHeight: 200,
        listItemHeight: 20,
        prefixCls: "vc-tree-select"
    }),
    setup: function (C, H) {
        var W = H.attrs,
            U = H.expose,
            G = H.slots,
            X = useId(toRef(C, "id")),
            Z = computed(function () {
                return C.treeCheckable && !C.treeCheckStrictly
            }),
            Q = computed(function () {
                return C.treeCheckable || C.treeCheckStrictly
            }),
            ee = computed(function () {
                return C.treeCheckStrictly || C.labelInValue
            }),
            ne = computed(function () {
                return Q.value || C.multiple
            }),
            te = computed(function () {
                return fillFieldNames(C.fieldNames)
            }),
            re = useMergedState("", {
                value: computed(function () {
                    return C.searchValue !== void 0 ? C.searchValue : C.inputValue
                }),
                postState: function (qe) {
                    return qe || ""
                }
            }),
            ae = _slicedToArray$2(re, 2),
            oe = ae[0],
            ie = ae[1],
            ue = function (qe) {
                var Je;
                ie(qe), (Je = C.onSearch) === null || Je === void 0 || Je.call(C, qe)
            },
            le = useTreeData(toRef(C, "treeData"), toRef(C, "children"), toRef(C, "treeDataSimpleMode")),
            se = useDataEntities(le, te),
            ce = se.keyEntities,
            de = se.valueEntities,
            ve = function (qe) {
                var Je = [],
                    Qe = [];
                return qe.forEach(function (lt) {
                    de.value.has(lt) ? Qe.push(lt) : Je.push(lt)
                }), {
                    missingRawValues: Je,
                    existRawValues: Qe
                }
            },
            fe = useFilterTreeData(le, oe, {
                fieldNames: te,
                treeNodeFilterProp: toRef(C, "treeNodeFilterProp"),
                filterTreeNode: toRef(C, "filterTreeNode")
            }),
            pe = function (qe) {
                if (qe) {
                    if (C.treeNodeLabelProp) return qe[C.treeNodeLabelProp];
                    for (var Je = te.value._title, Qe = 0; Qe < Je.length; Qe += 1) {
                        var lt = qe[Je[Qe]];
                        if (lt !== void 0) return lt
                    }
                }
            },
            me = function (qe) {
                var Je = toArray$1(qe);
                return Je.map(function (Qe) {
                    return isRawValue(Qe) ? {
                        value: Qe
                    } : Qe
                })
            },
            he = function (qe) {
                var Je = me(qe);
                return Je.map(function (Qe) {
                    var lt = Qe.label,
                        ct = Qe.value,
                        dt = Qe.halfChecked,
                        tt, at = de.value.get(ct);
                    if (at) {
                        var vt;
                        lt = (vt = lt) !== null && vt !== void 0 ? vt : pe(at.node), tt = at.node.disabled
                    }
                    return {
                        label: lt,
                        value: ct,
                        halfChecked: dt,
                        disabled: tt
                    }
                })
            },
            Se = useMergedState(C.defaultValue, {
                value: toRef(C, "value")
            }),
            _e = _slicedToArray$2(Se, 2),
            be = _e[0],
            ge = _e[1],
            xe = computed(function () {
                return me(be.value)
            }),
            Pe = shallowRef([]),
            $e = shallowRef([]);
        watchEffect(function () {
            var rt = [],
                qe = [];
            xe.value.forEach(function (Je) {
                Je.halfChecked ? qe.push(Je) : rt.push(Je)
            }), Pe.value = rt, $e.value = qe
        });
        var ye = computed(function () {
                return Pe.value.map(function (rt) {
                    return rt.value
                })
            }),
            Ce = useMaxLevel(ce),
            we = Ce.maxLevel,
            Oe = Ce.levelEntities,
            Ne = useCheckedKeys(Pe, $e, Z, ce, we, Oe),
            Me = _slicedToArray$2(Ne, 2),
            Ve = Me[0],
            ke = Me[1],
            Ee = computed(function () {
                var rt = formatStrategyValues(Ve.value, C.showCheckedStrategy, ce.value, te.value),
                    qe = rt.map(function (ct) {
                        var dt, tt, at;
                        return (dt = (tt = ce.value[ct]) === null || tt === void 0 || (at = tt.node) ===
                                null || at === void 0 ? void 0 : at[te.value.value]) !== null && dt !==
                            void 0 ? dt : ct
                    }),
                    Je = qe.map(function (ct) {
                        var dt = Pe.value.find(function (tt) {
                            return tt.value === ct
                        });
                        return {
                            value: ct,
                            label: dt == null ? void 0 : dt.label
                        }
                    }),
                    Qe = he(Je),
                    lt = Qe[0];
                return !ne.value && lt && isNil(lt.value) && isNil(lt.label) ? [] : Qe.map(function (ct) {
                    var dt;
                    return _objectSpread2$1(_objectSpread2$1({}, ct), {}, {
                        label: (dt = ct.label) !== null && dt !== void 0 ? dt : ct.value
                    })
                })
            }),
            Ae = useCache(Ee),
            Re = _slicedToArray$2(Ae, 1),
            He = Re[0],
            je = function (qe, Je, Qe) {
                var lt = he(qe);
                if (ge(lt), C.autoClearSearchValue && ie(""), C.onChange) {
                    var ct = qe;
                    if (Z.value) {
                        var dt = formatStrategyValues(qe, C.showCheckedStrategy, ce.value, te.value);
                        ct = dt.map(function (_t) {
                            var wt = de.value.get(_t);
                            return wt ? wt.node[te.value.value] : _t
                        })
                    }
                    var tt = Je || {
                            triggerValue: void 0,
                            selected: void 0
                        },
                        at = tt.triggerValue,
                        vt = tt.selected,
                        gt = ct;
                    if (C.treeCheckStrictly) {
                        var mt = $e.value.filter(function (_t) {
                            return !ct.includes(_t.value)
                        });
                        gt = [].concat(_toConsumableArray(gt), _toConsumableArray(mt))
                    }
                    var ht = he(gt),
                        yt = {
                            preValue: Pe.value,
                            triggerValue: at
                        },
                        St = !0;
                    (C.treeCheckStrictly || Qe === "selection" && !vt) && (St = !1), fillAdditionalInfo(yt,
                        at, qe, le.value, St, te.value), Q.value ? yt.checked = vt : yt.selected = vt;
                    var Ct = ee.value ? ht : ht.map(function (_t) {
                        return _t.value
                    });
                    C.onChange(ne.value ? Ct : Ct[0], ee.value ? null : ht.map(function (_t) {
                        return _t.label
                    }), yt)
                }
            },
            Fe = function (qe, Je) {
                var Qe, lt = Je.selected,
                    ct = Je.source,
                    dt = toRaw(ce.value),
                    tt = toRaw(de.value),
                    at = dt[qe],
                    vt = at == null ? void 0 : at.node,
                    gt = (Qe = vt == null ? void 0 : vt[te.value.value]) !== null && Qe !== void 0 ? Qe :
                    qe;
                if (!ne.value) je([gt], {
                    selected: !0,
                    triggerValue: gt
                }, "option");
                else {
                    var mt = lt ? [].concat(_toConsumableArray(ye.value), [gt]) : Ve.value.filter(function (
                        Nt) {
                        return Nt !== gt
                    });
                    if (Z.value) {
                        var ht = ve(mt),
                            yt = ht.missingRawValues,
                            St = ht.existRawValues,
                            Ct = St.map(function (Nt) {
                                return tt.get(Nt).key
                            }),
                            _t;
                        if (lt) {
                            var wt = conductCheck(Ct, !0, dt, we.value, Oe.value);
                            _t = wt.checkedKeys
                        } else {
                            var Et = conductCheck(Ct, {
                                checked: !1,
                                halfCheckedKeys: ke.value
                            }, dt, we.value, Oe.value);
                            _t = Et.checkedKeys
                        }
                        mt = [].concat(_toConsumableArray(yt), _toConsumableArray(_t.map(function (Nt) {
                            return dt[Nt].node[te.value.value]
                        })))
                    }
                    je(mt, {
                        selected: lt,
                        triggerValue: gt
                    }, ct || "option")
                }
                if (lt || !ne.value) {
                    var xt;
                    (xt = C.onSelect) === null || xt === void 0 || xt.call(C, gt, fillLegacyProps(vt))
                } else {
                    var kt;
                    (kt = C.onDeselect) === null || kt === void 0 || kt.call(C, gt, fillLegacyProps(vt))
                }
            },
            Le = function (qe) {
                if (C.onDropdownVisibleChange) {
                    var Je = {};
                    Object.defineProperty(Je, "documentClickClose", {
                        get: function () {
                            return !1
                        }
                    }), C.onDropdownVisibleChange(qe, Je)
                }
            },
            Ie = function (qe, Je) {
                var Qe = qe.map(function (lt) {
                    return lt.value
                });
                if (Je.type === "clear") {
                    je(Qe, {}, "selection");
                    return
                }
                Je.values.length && Fe(Je.values[0].value, {
                    selected: !1,
                    source: "selection"
                })
            },
            Te = toRefs(C),
            De = Te.treeNodeFilterProp,
            Ke = Te.loadData,
            We = Te.treeLoadedKeys,
            Ue = Te.onTreeLoad,
            et = Te.treeDefaultExpandAll,
            Ye = Te.treeExpandedKeys,
            ze = Te.treeDefaultExpandedKeys,
            Be = Te.onTreeExpand,
            Ge = Te.virtual,
            Xe = Te.listHeight,
            nt = Te.listItemHeight,
            it = Te.treeLine,
            ft = Te.treeIcon,
            pt = Te.showTreeIcon,
            ot = Te.switcherIcon,
            Ze = Te.treeMotion,
            ut = Te.customSlots;
        useProvideLegacySelectContext(toReactive({
            checkable: Q,
            loadData: Ke,
            treeLoadedKeys: We,
            onTreeLoad: Ue,
            checkedKeys: Ve,
            halfCheckedKeys: ke,
            treeDefaultExpandAll: et,
            treeExpandedKeys: Ye,
            treeDefaultExpandedKeys: ze,
            onTreeExpand: Be,
            treeIcon: ft,
            treeMotion: Ze,
            showTreeIcon: pt,
            switcherIcon: ot,
            treeLine: it,
            treeNodeFilterProp: De,
            keyEntities: ce,
            customSlots: ut
        })), useProvideSelectContext(toReactive({
            virtual: Ge,
            listHeight: Xe,
            listItemHeight: nt,
            treeData: fe,
            fieldNames: te,
            onSelect: Fe
        }));
        var st = ref();
        return U({
                focus: function () {
                    var qe;
                    (qe = st.value) === null || qe === void 0 || qe.focus()
                },
                blur: function () {
                    var qe;
                    (qe = st.value) === null || qe === void 0 || qe.blur()
                },
                scrollTo: function (qe) {
                    var Je;
                    (Je = st.value) === null || Je === void 0 || Je.scrollTo(qe)
                }
            }),
            function () {
                var rt, qe = omit$2(C, ["id", "prefixCls", "value", "defaultValue", "onChange", "onSelect",
                    "onDeselect", "searchValue", "inputValue", "onSearch", "autoClearSearchValue",
                    "filterTreeNode", "treeNodeFilterProp", "showCheckedStrategy",
                    "treeNodeLabelProp", "multiple", "treeCheckable", "treeCheckStrictly",
                    "labelInValue", "fieldNames", "treeDataSimpleMode", "treeData", "children",
                    "loadData", "treeLoadedKeys", "onTreeLoad", "treeDefaultExpandAll",
                    "treeExpandedKeys", "treeDefaultExpandedKeys", "onTreeExpand", "virtual",
                    "listHeight", "listItemHeight", "onDropdownVisibleChange", "treeLine",
                    "treeIcon", "showTreeIcon", "switcherIcon", "treeMotion"]);
                return createVNode(BaseSelect, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                    ref: st
                }, W), qe), {}, {
                    id: X,
                    prefixCls: C.prefixCls,
                    mode: ne.value ? "multiple" : void 0,
                    displayValues: He.value,
                    onDisplayValuesChange: Ie,
                    searchValue: oe.value,
                    onSearch: ue,
                    OptionList,
                    emptyOptions: !le.value.length,
                    onDropdownVisibleChange: Le,
                    tagRender: C.tagRender || G.tagRender,
                    dropdownMatchSelectWidth: (rt = C.dropdownMatchSelectWidth) !== null && rt !==
                        void 0 ? rt : !0
                }), G)
            }
    }
});
var getTransitionName = function (C, H, W) {
    return W !== void 0 ? W : "".concat(C, "-").concat(H)
};

function treeSelectProps() {
    return _objectSpread2$1(_objectSpread2$1({}, omit$2(treeSelectProps$1(), ["showTreeIcon", "treeMotion", "inputIcon",
        "getInputElement", "treeLine", "customSlots"])), {}, {
        suffixIcon: PropTypes$1.any,
        size: {
            type: String
        },
        bordered: {
            type: Boolean,
            default: void 0
        },
        treeLine: {
            type: [Boolean, Object],
            default: void 0
        },
        replaceFields: {
            type: Object
        },
        "onUpdate:value": {
            type: Function
        },
        "onUpdate:treeExpandedKeys": {
            type: Function
        },
        "onUpdate:searchValue": {
            type: Function
        }
    })
}
var TreeSelect = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "ATreeSelect",
        inheritAttrs: !1,
        props: initDefaultProps$1(treeSelectProps(), {
            choiceTransitionName: "",
            listHeight: 256,
            treeIcon: !1,
            listItemHeight: 26,
            bordered: !0
        }),
        slots: ["title", "titleRender", "placeholder", "maxTagPlaceholder", "treeIcon", "switcherIcon",
            "notFoundContent"],
        setup: function (C, H) {
            var W = H.attrs,
                U = H.slots,
                G = H.expose,
                X = H.emit;
            C.treeData === void 0 && U.default, watchEffect(function () {
                devWarning(C.multiple !== !1 || !C.treeCheckable, "TreeSelect",
                    "`multiple` will always be `true` when `treeCheckable` is true"), devWarning(C.replaceFields ===
                    void 0, "TreeSelect",
                    "`replaceFields` is deprecated, please use fieldNames instead")
            });
            var Z = useInjectFormItemContext(),
                Q = useConfigInject("select", C),
                ee = Q.prefixCls,
                ne = Q.renderEmpty,
                te = Q.direction,
                re = Q.virtual,
                ae = Q.dropdownMatchSelectWidth,
                oe = Q.size,
                ie = Q.getPopupContainer,
                ue = Q.getPrefixCls,
                le = computed(function () {
                    return ue()
                }),
                se = computed(function () {
                    return getTransitionName(le.value, "slide-up", C.transitionName)
                }),
                ce = computed(function () {
                    return getTransitionName(le.value, "", C.choiceTransitionName)
                }),
                de = computed(function () {
                    return ue("select-tree", C.prefixCls)
                }),
                ve = computed(function () {
                    return ue("tree-select", C.prefixCls)
                }),
                fe = computed(function () {
                    return classNames(C.dropdownClassName, "".concat(ve.value, "-dropdown"),
                        _defineProperty$V({}, "".concat(ve.value, "-dropdown-rtl"), te.value === "rtl")
                    )
                }),
                pe = computed(function () {
                    return !!(C.treeCheckable || C.multiple)
                }),
                me = ref();
            G({
                focus: function () {
                    var xe, Pe;
                    (xe = (Pe = me.value).focus) === null || xe === void 0 || xe.call(Pe)
                },
                blur: function () {
                    var xe, Pe;
                    (xe = (Pe = me.value).blur) === null || xe === void 0 || xe.call(Pe)
                }
            });
            var he = function () {
                    for (var xe = arguments.length, Pe = new Array(xe), $e = 0; $e < xe; $e++) Pe[$e] =
                        arguments[$e];
                    X("update:value", Pe[0]), X.apply(void 0, ["change"].concat(Pe)), Z.onFieldChange()
                },
                Se = function (xe) {
                    X("update:treeExpandedKeys", xe), X("treeExpand", xe)
                },
                _e = function (xe) {
                    X("update:searchValue", xe), X("search", xe)
                },
                be = function (xe) {
                    X("blur", xe), Z.onFieldBlur()
                };
            return function () {
                var ge, xe, Pe, $e = C.notFoundContent,
                    ye = $e === void 0 ? (ge = U.notFoundContent) === null || ge === void 0 ? void 0 : ge.call(
                        U) : $e,
                    Ce = C.prefixCls,
                    we = C.bordered,
                    Oe = C.listHeight,
                    Ne = C.listItemHeight,
                    Me = C.multiple,
                    Ve = C.treeIcon,
                    ke = C.treeLine,
                    Ee = C.switcherIcon,
                    Ae = Ee === void 0 ? (xe = U.switcherIcon) === null || xe === void 0 ? void 0 : xe.call(
                        U) : Ee,
                    Re = C.fieldNames,
                    He = Re === void 0 ? C.replaceFields : Re,
                    je = C.id,
                    Fe = je === void 0 ? Z.id.value : je,
                    Le = getIcons(_objectSpread2$1(_objectSpread2$1({}, C), {}, {
                        multiple: pe.value,
                        prefixCls: ee.value
                    }), U),
                    Ie = Le.suffixIcon,
                    Te = Le.removeIcon,
                    De = Le.clearIcon,
                    Ke;
                ye !== void 0 ? Ke = ye : Ke = ne.value("Select");
                var We = omit$2(C, ["suffixIcon", "itemIcon", "removeIcon", "clearIcon", "switcherIcon",
                        "bordered", "onUpdate:value", "onUpdate:treeExpandedKeys",
                        "onUpdate:searchValue"]),
                    Ue = classNames(!Ce && ve.value, (Pe = {}, _defineProperty$V(Pe, "".concat(ee.value,
                        "-lg"), oe.value === "large"), _defineProperty$V(Pe, "".concat(ee.value,
                        "-sm"), oe.value === "small"), _defineProperty$V(Pe, "".concat(ee.value,
                        "-rtl"), te.value === "rtl"), _defineProperty$V(Pe, "".concat(ee.value,
                        "-borderless"), !we), Pe), W.class),
                    et = {};
                return C.treeData === void 0 && U.default && (et.children = flattenChildren(U.default())),
                    createVNode(TreeSelect$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(
                        _objectSpread2$1({}, W), We), {}, {
                        virtual: re.value,
                        dropdownMatchSelectWidth: ae.value,
                        id: Fe,
                        fieldNames: He,
                        ref: me,
                        prefixCls: ee.value,
                        class: Ue,
                        listHeight: Oe,
                        listItemHeight: Ne,
                        treeLine: !!ke,
                        inputIcon: Ie,
                        multiple: Me,
                        removeIcon: Te,
                        clearIcon: De,
                        switcherIcon: function (ze) {
                            return renderSwitcherIcon(de.value, Ae, ke, ze)
                        },
                        showTreeIcon: Ve,
                        notFoundContent: Ke,
                        getPopupContainer: ie.value,
                        treeMotion: null,
                        dropdownClassName: fe.value,
                        choiceTransitionName: ce.value,
                        onChange: he,
                        onBlur: be,
                        onSearch: _e,
                        onTreeExpand: Se
                    }, et), {}, {
                        transitionName: se.value,
                        customSlots: _objectSpread2$1(_objectSpread2$1({}, U), {}, {
                            treeCheckable: function () {
                                return createVNode("span", {
                                    class: "".concat(ee.value,
                                        "-tree-checkbox-inner")
                                }, null)
                            }
                        }),
                        maxTagPlaceholder: C.maxTagPlaceholder || U.maxTagPlaceholder
                    }), _objectSpread2$1(_objectSpread2$1({}, U), {}, {
                        treeCheckable: function () {
                            return createVNode("span", {
                                class: "".concat(ee.value, "-tree-checkbox-inner")
                            }, null)
                        }
                    }))
            }
        }
    }),
    TreeSelectNode = TreeNode$1;
const index$1 = _extends$1(TreeSelect, {
    TreeNode: TreeNode$1,
    SHOW_ALL,
    SHOW_PARENT,
    SHOW_CHILD,
    install: function (C) {
        return C.component(TreeSelect.name, TreeSelect), C.component(TreeSelectNode.displayName,
            TreeSelectNode), C
    }
});
var timePickerProps = function () {
    return {
        format: String,
        showNow: {
            type: Boolean,
            default: void 0
        },
        showHour: {
            type: Boolean,
            default: void 0
        },
        showMinute: {
            type: Boolean,
            default: void 0
        },
        showSecond: {
            type: Boolean,
            default: void 0
        },
        use12Hours: {
            type: Boolean,
            default: void 0
        },
        hourStep: Number,
        minuteStep: Number,
        secondStep: Number,
        hideDisabledOptions: {
            type: Boolean,
            default: void 0
        },
        popupClassName: String
    }
};

function createTimePicker(K) {
    var C = generatePicker(K, _objectSpread2$1(_objectSpread2$1({}, timePickerProps()), {}, {
            order: {
                type: Boolean,
                default: !0
            }
        })),
        H = C.TimePicker,
        W = C.RangePicker,
        U = defineComponent({
            name: "ATimePicker",
            inheritAttrs: !1,
            props: _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, commonProps()),
                datePickerProps()), timePickerProps()), {}, {
                addon: {
                    type: Function
                }
            }),
            slot: ["addon", "renderExtraFooter", "suffixIcon", "clearIcon"],
            setup: function (Z, Q) {
                var ee = Q.slots,
                    ne = Q.expose,
                    te = Q.emit,
                    re = Q.attrs,
                    ae = useInjectFormItemContext();
                devWarning(!(ee.addon || Z.addon), "TimePicker",
                    "`addon` is deprecated. Please use `v-slot:renderExtraFooter` instead.");
                var oe = ref();
                ne({
                    focus: function () {
                        var ve;
                        (ve = oe.value) === null || ve === void 0 || ve.focus()
                    },
                    blur: function () {
                        var ve;
                        (ve = oe.value) === null || ve === void 0 || ve.blur()
                    }
                });
                var ie = function (ve, fe) {
                        te("update:value", ve), te("change", ve, fe), ae.onFieldChange()
                    },
                    ue = function (ve) {
                        te("update:open", ve), te("openChange", ve)
                    },
                    le = function (ve) {
                        te("focus", ve)
                    },
                    se = function (ve) {
                        te("blur", ve), ae.onFieldBlur()
                    },
                    ce = function (ve) {
                        te("ok", ve)
                    };
                return function () {
                    var de = Z.id,
                        ve = de === void 0 ? ae.id.value : de;
                    return createVNode(H, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, re),
                        omit$2(Z, ["onUpdate:value", "onUpdate:open"])), {}, {
                        id: ve,
                        dropdownClassName: Z.popupClassName,
                        mode: void 0,
                        ref: oe,
                        renderExtraFooter: Z.addon || ee.addon || Z.renderExtraFooter || ee.renderExtraFooter,
                        onChange: ie,
                        onOpenChange: ue,
                        onFocus: le,
                        onBlur: se,
                        onOk: ce
                    }), ee)
                }
            }
        }),
        G = defineComponent({
            name: "ATimeRangePicker",
            inheritAttrs: !1,
            props: _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, commonProps()),
                rangePickerProps()), timePickerProps()), {}, {
                order: {
                    type: Boolean,
                    default: !0
                }
            }),
            slot: ["renderExtraFooter", "suffixIcon", "clearIcon"],
            setup: function (Z, Q) {
                var ee = Q.slots,
                    ne = Q.expose,
                    te = Q.emit,
                    re = Q.attrs,
                    ae = ref(),
                    oe = useInjectFormItemContext();
                ne({
                    focus: function () {
                        var pe;
                        (pe = ae.value) === null || pe === void 0 || pe.focus()
                    },
                    blur: function () {
                        var pe;
                        (pe = ae.value) === null || pe === void 0 || pe.blur()
                    }
                });
                var ie = function (pe, me) {
                        te("update:value", pe), te("change", pe, me), oe.onFieldChange()
                    },
                    ue = function (pe) {
                        te("update:open", pe), te("openChange", pe)
                    },
                    le = function (pe) {
                        te("focus", pe)
                    },
                    se = function (pe) {
                        te("blur", pe), oe.onFieldBlur()
                    },
                    ce = function (pe, me) {
                        te("panelChange", pe, me)
                    },
                    de = function (pe) {
                        te("ok", pe)
                    },
                    ve = function (pe, me, he) {
                        te("calendarChange", pe, me, he)
                    };
                return function () {
                    var fe = Z.id,
                        pe = fe === void 0 ? oe.id.value : fe;
                    return createVNode(W, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, re),
                        omit$2(Z, ["onUpdate:open", "onUpdate:value"])), {}, {
                        id: pe,
                        dropdownClassName: Z.popupClassName,
                        picker: "time",
                        mode: void 0,
                        ref: ae,
                        onChange: ie,
                        onOpenChange: ue,
                        onFocus: le,
                        onBlur: se,
                        onPanelChange: ce,
                        onOk: de,
                        onCalendarChange: ve
                    }), ee)
                }
            }
        });
    return {
        TimePicker: U,
        TimeRangePicker: G
    }
}
var _createTimePicker = createTimePicker(dayjsGenerateConfig),
    TimePicker = _createTimePicker.TimePicker,
    TimeRangePicker = _createTimePicker.TimeRangePicker;
const TimePicker$1 = _extends$1(TimePicker, {
    TimePicker,
    TimeRangePicker,
    install: function (C) {
        return C.component(TimePicker.name, TimePicker), C.component(TimeRangePicker.name, TimeRangePicker),
            C
    }
});
var timelineItemProps = function () {
    return {
        prefixCls: String,
        color: String,
        dot: PropTypes$1.any,
        pending: {
            type: Boolean,
            default: void 0
        },
        position: PropTypes$1.oneOf(tuple$1("left", "right", "")).def(""),
        label: PropTypes$1.any
    }
};
const TimelineItem = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ATimelineItem",
    props: initDefaultProps$1(timelineItemProps(), {
        color: "blue",
        pending: !1
    }),
    slots: ["dot", "label"],
    setup: function (C, H) {
        var W = H.slots,
            U = useConfigInject("timeline", C),
            G = U.prefixCls;
        return function () {
            var X, Z, Q, ee, ne, te = C.color,
                re = te === void 0 ? "" : te,
                ae = C.pending,
                oe = C.label,
                ie = oe === void 0 ? (X = W.label) === null || X === void 0 ? void 0 : X.call(W) : oe,
                ue = C.dot,
                le = ue === void 0 ? (Z = W.dot) === null || Z === void 0 ? void 0 : Z.call(W) : ue,
                se = classNames((Q = {}, _defineProperty$V(Q, "".concat(G.value, "-item"), !0),
                    _defineProperty$V(Q, "".concat(G.value, "-item-pending"), ae), Q)),
                ce = classNames((ee = {}, _defineProperty$V(ee, "".concat(G.value, "-item-head"), !0),
                    _defineProperty$V(ee, "".concat(G.value, "-item-head-custom"), le),
                    _defineProperty$V(ee, "".concat(G.value, "-item-head-").concat(re), !0), ee)),
                de = /blue|red|green|gray/.test(re || "") ? void 0 : re;
            return createVNode("li", {
                class: se
            }, [ie && createVNode("div", {
                class: "".concat(G.value, "-item-label")
            }, [ie]), createVNode("div", {
                class: "".concat(G.value, "-item-tail")
            }, null), createVNode("div", {
                class: ce,
                style: {
                    borderColor: de,
                    color: de
                }
            }, [le]), createVNode("div", {
                class: "".concat(G.value, "-item-content")
            }, [(ne = W.default) === null || ne === void 0 ? void 0 : ne.call(W)])])
        }
    }
});
var timelineProps = function () {
    return {
        prefixCls: String,
        pending: PropTypes$1.any,
        pendingDot: PropTypes$1.any,
        reverse: {
            type: Boolean,
            default: void 0
        },
        mode: PropTypes$1.oneOf(tuple$1("left", "alternate", "right", ""))
    }
};
const Timeline = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ATimeline",
    props: initDefaultProps$1(timelineProps(), {
        reverse: !1,
        mode: ""
    }),
    slots: ["pending", "pendingDot"],
    setup: function (C, H) {
        var W = H.slots,
            U = useConfigInject("timeline", C),
            G = U.prefixCls,
            X = U.direction,
            Z = function (ee, ne) {
                var te = ee.props || {};
                return C.mode === "alternate" ? te.position === "right" ? "".concat(G.value, "-item-right") :
                    te.position === "left" || ne % 2 === 0 ? "".concat(G.value, "-item-left") : "".concat(G
                        .value, "-item-right") : C.mode === "left" ? "".concat(G.value, "-item-left") : C.mode ===
                    "right" || te.position === "right" ? "".concat(G.value, "-item-right") : ""
            };
        return function () {
            var Q, ee, ne, te, re = C.pending,
                ae = re === void 0 ? (Q = W.pending) === null || Q === void 0 ? void 0 : Q.call(W) : re,
                oe = C.pendingDot,
                ie = oe === void 0 ? (ee = W.pendingDot) === null || ee === void 0 ? void 0 : ee.call(W) :
                oe,
                ue = C.reverse,
                le = C.mode,
                se = typeof ae == "boolean" ? null : ae,
                ce = filterEmpty((ne = W.default) === null || ne === void 0 ? void 0 : ne.call(W)),
                de = ae ? createVNode(TimelineItem, {
                    pending: !!ae,
                    dot: ie || createVNode(LoadingOutlined$1, null, null)
                }, {
                    default: function () {
                        return [se]
                    }
                }) : null;
            de && ce.push(de);
            var ve = ue ? ce.reverse() : ce,
                fe = ve.length,
                pe = "".concat(G.value, "-item-last"),
                me = ve.map(function (_e, be) {
                    var ge = be === fe - 2 ? pe : "",
                        xe = be === fe - 1 ? pe : "";
                    return cloneVNode(_e, {
                        class: classNames([!ue && ae ? ge : xe, Z(_e, be)])
                    })
                }),
                he = ve.some(function (_e) {
                    var be, ge;
                    return !!((be = _e.props) !== null && be !== void 0 && be.label || (ge = _e.children) !==
                        null && ge !== void 0 && ge.label)
                }),
                Se = classNames(G.value, (te = {}, _defineProperty$V(te, "".concat(G.value, "-pending"),
                        !!ae), _defineProperty$V(te, "".concat(G.value, "-reverse"), !!ue),
                    _defineProperty$V(te, "".concat(G.value, "-").concat(le), !!le && !he),
                    _defineProperty$V(te, "".concat(G.value, "-label"), he), _defineProperty$V(te,
                        "".concat(G.value, "-rtl"), X.value === "rtl"), te));
            return createVNode("ul", {
                class: Se
            }, [me])
        }
    }
});
Timeline.Item = TimelineItem;
Timeline.install = function (K) {
    return K.component(Timeline.name, Timeline), K.component(TimelineItem.name, TimelineItem), K
};
var EnterOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M864 170h-60c-4.4 0-8 3.6-8 8v518H310v-73c0-6.7-7.8-10.5-13-6.3l-141.9 112a8 8 0 000 12.6l141.9 112c5.3 4.2 13 .4 13-6.3v-75h498c35.3 0 64-28.7 64-64V178c0-4.4-3.6-8-8-8z"
            }
        }]
    },
    name: "enter",
    theme: "outlined"
};
const EnterOutlinedSvg = EnterOutlined$2;

function _objectSpread$7(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$7(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$7(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var EnterOutlined = function (C, H) {
    var W = _objectSpread$7({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$7({}, W, {
        icon: EnterOutlinedSvg
    }), null)
};
EnterOutlined.displayName = "EnterOutlined";
EnterOutlined.inheritAttrs = !1;
const EnterOutlined$1 = EnterOutlined;
var editableProps = function () {
        return {
            prefixCls: String,
            value: String,
            maxlength: Number,
            autoSize: {
                type: [Boolean, Object]
            },
            onSave: Function,
            onCancel: Function,
            onEnd: Function,
            onChange: Function,
            originContent: String,
            direction: String
        }
    },
    Editable = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "Editable",
        props: editableProps(),
        setup: function (C, H) {
            var W = H.emit,
                U = H.slots,
                G = reactive({
                    current: C.value || "",
                    lastKeyCode: void 0,
                    inComposition: !1,
                    cancelFlag: !1
                });
            watch(function () {
                return C.value
            }, function (ue) {
                G.current = ue
            });
            var X = ref();
            onMounted(function () {
                if (X.value) {
                    var ue, le = (ue = X.value) === null || ue === void 0 ? void 0 : ue.resizableTextArea,
                        se = le == null ? void 0 : le.textArea;
                    se.focus();
                    var ce = se.value.length;
                    se.setSelectionRange(ce, ce)
                }
            });

            function Z(ue) {
                X.value = ue
            }

            function Q(ue) {
                var le = ue.target.value;
                G.current = le.replace(/[\r\n]/g, ""), W("change", G.current)
            }

            function ee() {
                G.inComposition = !0
            }

            function ne() {
                G.inComposition = !1
            }

            function te(ue) {
                var le = ue.keyCode;
                le === KeyCode$1.ENTER && ue.preventDefault(), !G.inComposition && (G.lastKeyCode = le)
            }

            function re(ue) {
                var le = ue.keyCode,
                    se = ue.ctrlKey,
                    ce = ue.altKey,
                    de = ue.metaKey,
                    ve = ue.shiftKey;
                G.lastKeyCode === le && !G.inComposition && !se && !ce && !de && !ve && (le === KeyCode$1.ENTER ?
                    (oe(), W("end")) : le === KeyCode$1.ESC && (G.current = C.originContent, W("cancel")))
            }

            function ae() {
                oe()
            }

            function oe() {
                W("save", G.current.trim())
            }
            var ie = computed(function () {
                var ue;
                return ue = {}, _defineProperty$V(ue, "".concat(C.prefixCls), !0), _defineProperty$V(ue,
                    "".concat(C.prefixCls, "-edit-content"), !0), _defineProperty$V(ue, "".concat(C
                    .prefixCls, "-rtl"), C.direction === "rtl"), ue
            });
            return function () {
                return createVNode("div", {
                    class: ie.value
                }, [createVNode(TextArea, {
                    ref: Z,
                    maxlength: C.maxlength,
                    value: G.current,
                    onChange: Q,
                    onKeydown: te,
                    onKeyup: re,
                    onCompositionstart: ee,
                    onCompositionend: ne,
                    onBlur: ae,
                    rows: 1,
                    autoSize: C.autoSize === void 0 || C.autoSize
                }, null), U.enterIcon ? U.enterIcon({
                    className: "".concat(C.prefixCls, "-edit-content-confirm")
                }) : createVNode(EnterOutlined$1, {
                    class: "".concat(C.prefixCls, "-edit-content-confirm")
                }, null)])
            }
        }
    });
const Editable$1 = Editable;
var TEXT_NODE = 3,
    COMMENT_NODE = 8,
    ellipsisContainer, wrapperStyle = {
        padding: 0,
        margin: 0,
        display: "inline",
        lineHeight: "inherit"
    };

function styleToString(K) {
    var C = Array.prototype.slice.apply(K);
    return C.map(function (H) {
        return "".concat(H, ": ").concat(K.getPropertyValue(H), ";")
    }).join("")
}

function resetDomStyles(K, C) {
    K.setAttribute("aria-hidden", "true");
    var H = window.getComputedStyle(C),
        W = styleToString(H);
    K.setAttribute("style", W), K.style.position = "fixed", K.style.left = "0", K.style.height = "auto", K.style.minHeight =
        "auto", K.style.maxHeight = "auto", K.style.paddingTop = "0", K.style.paddingBottom = "0", K.style.borderTopWidth =
        "0", K.style.borderBottomWidth = "0", K.style.top = "-999999px", K.style.zIndex = "-1000", K.style.textOverflow =
        "clip", K.style.whiteSpace = "normal", K.style.webkitLineClamp = "none"
}

function getRealLineHeight(K) {
    var C = document.createElement("div");
    resetDomStyles(C, K), C.appendChild(document.createTextNode("text")), document.body.appendChild(C);
    var H = C.getBoundingClientRect().height;
    return document.body.removeChild(C), H
}
const measure = function (K, C, H, W, U) {
    ellipsisContainer || (ellipsisContainer = document.createElement("div"), ellipsisContainer.setAttribute(
        "aria-hidden", "true"), document.body.appendChild(ellipsisContainer));
    var G = C.rows,
        X = C.suffix,
        Z = X === void 0 ? "" : X,
        Q = getRealLineHeight(K),
        ee = Math.round(Q * G * 100) / 100;
    resetDomStyles(ellipsisContainer, K);
    var ne = createApp({
        render: function () {
            return createVNode("div", {
                style: wrapperStyle
            }, [createVNode("span", {
                style: wrapperStyle
            }, [H, Z]), createVNode("span", {
                style: wrapperStyle
            }, [W])])
        }
    });
    ne.mount(ellipsisContainer);

    function te() {
        var de = Math.round(ellipsisContainer.getBoundingClientRect().height * 100) / 100;
        return de - .1 <= ee
    }
    if (te()) return ne.unmount(), {
        content: H,
        text: ellipsisContainer.innerHTML,
        ellipsis: !1
    };
    var re = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].childNodes[0].cloneNode(!0).childNodes).filter(
            function (de) {
                var ve = de.nodeType,
                    fe = de.data;
                return ve !== COMMENT_NODE && fe !== ""
            }),
        ae = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].childNodes[1].cloneNode(!0).childNodes);
    ne.unmount();
    var oe = [];
    ellipsisContainer.innerHTML = "";
    var ie = document.createElement("span");
    ellipsisContainer.appendChild(ie);
    var ue = document.createTextNode(U + Z);
    ie.appendChild(ue), ae.forEach(function (de) {
        ellipsisContainer.appendChild(de)
    });

    function le(de) {
        ie.insertBefore(de, ue)
    }

    function se(de, ve) {
        var fe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
            pe = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ve.length,
            me = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0,
            he = Math.floor((fe + pe) / 2),
            Se = ve.slice(0, he);
        if (de.textContent = Se, fe >= pe - 1)
            for (var _e = pe; _e >= fe; _e -= 1) {
                var be = ve.slice(0, _e);
                if (de.textContent = be, te() || !be) return _e === ve.length ? {
                    finished: !1,
                    vNode: ve
                } : {
                    finished: !0,
                    vNode: be
                }
            }
        return te() ? se(de, ve, he, pe, he) : se(de, ve, fe, he, me)
    }

    function ce(de) {
        var ve = de.nodeType;
        if (ve === TEXT_NODE) {
            var fe = de.textContent || "",
                pe = document.createTextNode(fe);
            return le(pe), se(pe, fe)
        }
        return {
            finished: !1,
            vNode: null
        }
    }
    return re.some(function (de) {
        var ve = ce(de),
            fe = ve.finished,
            pe = ve.vNode;
        return pe && oe.push(pe), fe
    }), {
        content: oe,
        text: ellipsisContainer.innerHTML,
        ellipsis: !0
    }
};
var _excluded$6 = ["prefixCls", "class", "direction", "component"],
    typographyProps = function () {
        return {
            prefixCls: String,
            direction: String,
            component: String
        }
    },
    Typography = defineComponent({
        name: "ATypography",
        inheritAttrs: !1,
        props: typographyProps(),
        setup: function (C, H) {
            var W = H.slots,
                U = H.attrs,
                G = useConfigInject("typography", C),
                X = G.prefixCls,
                Z = G.direction;
            return function () {
                var Q, ee = _objectSpread2$1(_objectSpread2$1({}, C), U);
                ee.prefixCls, ee.class, ee.direction;
                var ne = ee.component,
                    te = ne === void 0 ? "article" : ne,
                    re = _objectWithoutProperties$2(ee, _excluded$6);
                return createVNode(te, _objectSpread2$1({
                    class: classNames(X.value, _defineProperty$V({}, "".concat(X.value, "-rtl"),
                        Z.value === "rtl"), U.class)
                }, re), {
                    default: function () {
                        return [(Q = W.default) === null || Q === void 0 ? void 0 : Q.call(W)]
                    }
                })
            }
        }
    });
const Typography$1 = Typography;
var deselectCurrent = function () {
    var C = document.getSelection();
    if (!C.rangeCount) return function () {};
    for (var H = document.activeElement, W = [], U = 0; U < C.rangeCount; U++) W.push(C.getRangeAt(U));
    switch (H.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
            H.blur();
            break;
        default:
            H = null;
            break
    }
    return C.removeAllRanges(),
        function () {
            C.type === "Caret" && C.removeAllRanges(), C.rangeCount || W.forEach(function (G) {
                C.addRange(G)
            }), H && H.focus()
        }
};
const deselectCurrent$1 = deselectCurrent;
var clipboardToIE11Formatting = {
        "text/plain": "Text",
        "text/html": "Url",
        default: "Text"
    },
    defaultMessage = "Copy to clipboard: #{key}, Enter";

function format$1(K) {
    var C = (/mac os x/i.test(navigator.userAgent) ? "" : "Ctrl") + "+C";
    return K.replace(/#{\s*key\s*}/g, C)
}

function copy(K, C) {
    var H, W, U, G, X, Z = !1;
    C || (C = {});
    var Q = C.debug || !1;
    try {
        W = deselectCurrent$1(), U = document.createRange(), G = document.getSelection(), X = document.createElement(
                "span"), X.textContent = K, X.style.all = "unset", X.style.position = "fixed", X.style.top = 0, X.style
            .clip = "rect(0, 0, 0, 0)", X.style.whiteSpace = "pre", X.style.webkitUserSelect = "text", X.style.MozUserSelect =
            "text", X.style.msUserSelect = "text", X.style.userSelect = "text", X.addEventListener("copy", function (ne) {
                if (ne.stopPropagation(), C.format)
                    if (ne.preventDefault(), typeof ne.clipboardData > "u") {
                        Q && console.warn("unable to use e.clipboardData"), Q && console.warn(
                            "trying IE specific stuff"), window.clipboardData.clearData();
                        var te = clipboardToIE11Formatting[C.format] || clipboardToIE11Formatting.default;
                        window.clipboardData.setData(te, K)
                    } else ne.clipboardData.clearData(), ne.clipboardData.setData(C.format, K);
                C.onCopy && (ne.preventDefault(), C.onCopy(ne.clipboardData))
            }), document.body.appendChild(X), U.selectNodeContents(X), G.addRange(U);
        var ee = document.execCommand("copy");
        if (!ee) throw new Error("copy command was unsuccessful");
        Z = !0
    } catch (ne) {
        Q && console.error("unable to copy using execCommand: ", ne), Q && console.warn("trying IE specific stuff");
        try {
            window.clipboardData.setData(C.format || "text", K), C.onCopy && C.onCopy(window.clipboardData), Z = !0
        } catch (te) {
            Q && console.error("unable to copy using clipboardData: ", te), Q && console.error("falling back to prompt"),
                H = format$1("message" in C ? C.message : defaultMessage), window.prompt(H, K)
        }
    } finally {
        G && (typeof G.removeRange == "function" ? G.removeRange(U) : G.removeAllRanges()), X && document.body.removeChild(
            X), W()
    }
    return Z
}
var CopyOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z"
            }
        }]
    },
    name: "copy",
    theme: "outlined"
};
const CopyOutlinedSvg = CopyOutlined$2;

function _objectSpread$6(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$6(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$6(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var CopyOutlined = function (C, H) {
    var W = _objectSpread$6({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$6({}, W, {
        icon: CopyOutlinedSvg
    }), null)
};
CopyOutlined.displayName = "CopyOutlined";
CopyOutlined.inheritAttrs = !1;
const CopyOutlined$1 = CopyOutlined;
var EditOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z"
            }
        }]
    },
    name: "edit",
    theme: "outlined"
};
const EditOutlinedSvg = EditOutlined$2;

function _objectSpread$5(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$5(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$5(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var EditOutlined = function (C, H) {
    var W = _objectSpread$5({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$5({}, W, {
        icon: EditOutlinedSvg
    }), null)
};
EditOutlined.displayName = "EditOutlined";
EditOutlined.inheritAttrs = !1;
const EditOutlined$1 = EditOutlined;
var _excluded$5 = ["type", "disabled", "content", "class", "style"],
    isLineClampSupport = isStyleSupport("webkitLineClamp"),
    isTextOverflowSupport = isStyleSupport("textOverflow"),
    ELLIPSIS_STR = "...",
    baseProps = function () {
        return {
            editable: {
                type: [Boolean, Object],
                default: void 0
            },
            copyable: {
                type: [Boolean, Object],
                default: void 0
            },
            prefixCls: String,
            component: String,
            type: String,
            disabled: {
                type: Boolean,
                default: void 0
            },
            ellipsis: {
                type: [Boolean, Object],
                default: void 0
            },
            code: {
                type: Boolean,
                default: void 0
            },
            mark: {
                type: Boolean,
                default: void 0
            },
            underline: {
                type: Boolean,
                default: void 0
            },
            delete: {
                type: Boolean,
                default: void 0
            },
            strong: {
                type: Boolean,
                default: void 0
            },
            keyboard: {
                type: Boolean,
                default: void 0
            },
            content: String,
            "onUpdate:content": Function
        }
    },
    Base = defineComponent({
        compatConfig: {
            MODE: 3
        },
        name: "Base",
        inheritAttrs: !1,
        props: baseProps(),
        setup: function (C, H) {
            var W = H.slots,
                U = H.attrs,
                G = H.emit,
                X = useConfigInject("typography", C),
                Z = X.prefixCls,
                Q = X.direction,
                ee = reactive({
                    copied: !1,
                    ellipsisText: "",
                    ellipsisContent: null,
                    isEllipsis: !1,
                    expanded: !1,
                    clientRendered: !1,
                    expandStr: "",
                    copyStr: "",
                    copiedStr: "",
                    editStr: "",
                    copyId: void 0,
                    rafId: void 0,
                    prevProps: void 0,
                    originContent: ""
                }),
                ne = ref(),
                te = ref(),
                re = computed(function () {
                    var we = C.ellipsis;
                    return we ? _objectSpread2$1({
                        rows: 1,
                        expandable: !1
                    }, _typeof$2(we) === "object" ? we : null) : {}
                });
            onMounted(function () {
                ee.clientRendered = !0
            }), onBeforeUnmount(function () {
                clearTimeout(ee.copyId), wrapperRaf.cancel(ee.rafId)
            }), watch([function () {
                return re.value.rows
            }, function () {
                return C.content
            }], function () {
                nextTick(function () {
                    Se()
                })
            }, {
                flush: "post",
                deep: !0,
                immediate: !0
            }), watchEffect(function () {
                C.content === void 0 && (warning$2(!C.editable, "Typography",
                        "When `editable` is enabled, please use `content` instead of children"),
                    warning$2(!C.ellipsis, "Typography",
                        "When `ellipsis` is enabled, please use `content` instead of children"))
            });

            function ae() {
                var we, Oe;
                return C.ellipsis || C.editable ? C.content : (we = ne.value) === null || we === void 0 || (Oe =
                    we.$el) === null || Oe === void 0 ? void 0 : Oe.innerText
            }

            function oe(we) {
                var Oe = re.value.onExpand;
                ee.expanded = !0, Oe == null || Oe(we)
            }

            function ie(we) {
                we.preventDefault(), ee.originContent = C.content, he(!0)
            }

            function ue(we) {
                le(we), he(!1)
            }

            function le(we) {
                var Oe = de.value.onChange;
                we !== C.content && (G("update:content", we), Oe == null || Oe(we))
            }

            function se() {
                var we, Oe;
                (we = (Oe = de.value).onCancel) === null || we === void 0 || we.call(Oe), he(!1)
            }

            function ce(we) {
                we.preventDefault(), we.stopPropagation();
                var Oe = C.copyable,
                    Ne = _objectSpread2$1({}, _typeof$2(Oe) === "object" ? Oe : null);
                Ne.text === void 0 && (Ne.text = ae()), copy(Ne.text || ""), ee.copied = !0, nextTick(function () {
                    Ne.onCopy && Ne.onCopy(), ee.copyId = setTimeout(function () {
                        ee.copied = !1
                    }, 3e3)
                })
            }
            var de = computed(function () {
                    var we = C.editable;
                    return we ? _objectSpread2$1({}, _typeof$2(we) === "object" ? we : null) : {
                        editing: !1
                    }
                }),
                ve = useMergedState(!1, {
                    value: computed(function () {
                        return de.value.editing
                    })
                }),
                fe = _slicedToArray$2(ve, 2),
                pe = fe[0],
                me = fe[1];

            function he(we) {
                var Oe = de.value.onStart;
                we && Oe && Oe(), me(we)
            }
            watch(pe, function (we) {
                if (!we) {
                    var Oe;
                    (Oe = te.value) === null || Oe === void 0 || Oe.focus()
                }
            }, {
                flush: "post"
            });

            function Se() {
                wrapperRaf.cancel(ee.rafId), ee.rafId = wrapperRaf(function () {
                    be()
                })
            }
            var _e = computed(function () {
                    var we = re.value,
                        Oe = we.rows,
                        Ne = we.expandable,
                        Me = we.suffix,
                        Ve = we.onEllipsis,
                        ke = we.tooltip;
                    return Me || ke || C.editable || C.copyable || Ne || Ve ? !1 : Oe === 1 ?
                        isTextOverflowSupport : isLineClampSupport
                }),
                be = function () {
                    var Oe, Ne, Me = ee.ellipsisText,
                        Ve = ee.isEllipsis,
                        ke = re.value,
                        Ee = ke.rows,
                        Ae = ke.suffix,
                        Re = ke.onEllipsis;
                    if (!(!Ee || Ee < 0 || !((Oe = ne.value) !== null && Oe !== void 0 && Oe.$el) || ee.expanded ||
                            C.content === void 0) && !_e.value) {
                        var He = measure((Ne = ne.value) === null || Ne === void 0 ? void 0 : Ne.$el, {
                                rows: Ee,
                                suffix: Ae
                            }, C.content, Ce(!0), ELLIPSIS_STR),
                            je = He.content,
                            Fe = He.text,
                            Le = He.ellipsis;
                        (Me !== Fe || ee.isEllipsis !== Le) && (ee.ellipsisText = Fe, ee.ellipsisContent = je,
                            ee.isEllipsis = Le, Ve !== Le && Re && Re(Le))
                    }
                };

            function ge(we, Oe) {
                var Ne = we.mark,
                    Me = we.code,
                    Ve = we.underline,
                    ke = we.delete,
                    Ee = we.strong,
                    Ae = we.keyboard,
                    Re = Oe;

                function He(je, Fe) {
                    if (je) {
                        var Le = function () {
                            return Re
                        }();
                        Re = createVNode(Fe, null, {
                            default: function () {
                                return [Le]
                            }
                        })
                    }
                }
                return He(Ee, "strong"), He(Ve, "u"), He(ke, "del"), He(Me, "code"), He(Ne, "mark"), He(Ae,
                    "kbd"), Re
            }

            function xe(we) {
                var Oe = re.value,
                    Ne = Oe.expandable,
                    Me = Oe.symbol;
                if (!Ne || !we && (ee.expanded || !ee.isEllipsis)) return null;
                var Ve = (W.ellipsisSymbol ? W.ellipsisSymbol() : Me) || ee.expandStr;
                return createVNode("a", {
                    key: "expand",
                    class: "".concat(Z.value, "-expand"),
                    onClick: oe,
                    "aria-label": ee.expandStr
                }, [Ve])
            }

            function Pe() {
                if (C.editable) {
                    var we = C.editable,
                        Oe = we.tooltip,
                        Ne = we.triggerType,
                        Me = Ne === void 0 ? ["icon"] : Ne,
                        Ve = W.editableIcon ? W.editableIcon() : createVNode(EditOutlined$1, {
                            role: "button"
                        }, null),
                        ke = W.editableTooltip ? W.editableTooltip() : ee.editStr,
                        Ee = typeof ke == "string" ? ke : "";
                    return Me.indexOf("icon") !== -1 ? createVNode(Tooltip, {
                        key: "edit",
                        title: Oe === !1 ? "" : ke
                    }, {
                        default: function () {
                            return [createVNode(TransButton$1, {
                                ref: te,
                                class: "".concat(Z.value, "-edit"),
                                onClick: ie,
                                "aria-label": Ee
                            }, {
                                default: function () {
                                    return [Ve]
                                }
                            })]
                        }
                    }) : null
                }
            }

            function $e() {
                if (C.copyable) {
                    var we = C.copyable.tooltip,
                        Oe = ee.copied ? ee.copiedStr : ee.copyStr,
                        Ne = W.copyableTooltip ? W.copyableTooltip({
                            copied: ee.copied
                        }) : Oe,
                        Me = typeof Ne == "string" ? Ne : "",
                        Ve = ee.copied ? createVNode(CheckOutlined$1, null, null) : createVNode(CopyOutlined$1,
                            null, null),
                        ke = W.copyableIcon ? W.copyableIcon({
                            copied: !!ee.copied
                        }) : Ve;
                    return createVNode(Tooltip, {
                        key: "copy",
                        title: we === !1 ? "" : Ne
                    }, {
                        default: function () {
                            return [createVNode(TransButton$1, {
                                class: ["".concat(Z.value, "-copy"), _defineProperty$V({},
                                    "".concat(Z.value, "-copy-success"), ee.copied
                                )],
                                onClick: ce,
                                "aria-label": Me
                            }, {
                                default: function () {
                                    return [ke]
                                }
                            })]
                        }
                    })
                }
            }

            function ye() {
                var we = U.class,
                    Oe = U.style,
                    Ne = de.value,
                    Me = Ne.maxlength,
                    Ve = Ne.autoSize,
                    ke = Ne.onEnd;
                return createVNode(Editable$1, {
                    class: we,
                    style: Oe,
                    prefixCls: Z.value,
                    value: C.content,
                    originContent: ee.originContent,
                    maxlength: Me,
                    autoSize: Ve,
                    onSave: ue,
                    onChange: le,
                    onCancel: se,
                    onEnd: ke,
                    direction: Q.value
                }, {
                    enterIcon: W.editableEnterIcon
                })
            }

            function Ce(we) {
                return [xe(we), Pe(), $e()].filter(function (Oe) {
                    return Oe
                })
            }
            return function () {
                var we, Oe = de.value.triggerType,
                    Ne = Oe === void 0 ? ["icon"] : Oe,
                    Me = C.ellipsis || C.editable ? C.content !== void 0 ? C.content : (we = W.default) ===
                    null || we === void 0 ? void 0 : we.call(W) : W.default ? W.default() : C.content;
                return pe.value ? ye() : createVNode(LocaleReceiver, {
                    componentName: "Text",
                    children: function (ke) {
                        var Ee, Ae = _objectSpread2$1(_objectSpread2$1({}, C), U),
                            Re = Ae.type,
                            He = Ae.disabled;
                        Ae.content;
                        var je = Ae.class,
                            Fe = Ae.style,
                            Le = _objectWithoutProperties$2(Ae, _excluded$5),
                            Ie = re.value,
                            Te = Ie.rows,
                            De = Ie.suffix,
                            Ke = Ie.tooltip,
                            We = ke.edit,
                            Ue = ke.copy,
                            et = ke.copied,
                            Ye = ke.expand;
                        ee.editStr = We, ee.copyStr = Ue, ee.copiedStr = et, ee.expandStr = Ye;
                        var ze = omit$2(Le, ["prefixCls", "editable", "copyable", "ellipsis",
                                "mark", "code", "delete", "underline", "strong", "keyboard",
                                "onUpdate:content"]),
                            Be = _e.value,
                            Ge = Te === 1 && Be,
                            Xe = Te && Te > 1 && Be,
                            nt = Me,
                            it;
                        if (Te && ee.isEllipsis && !ee.expanded && !Be) {
                            var ft, pt = Le.title,
                                ot = pt || "";
                            !pt && (typeof Me == "string" || typeof Me == "number") && (ot =
                                    String(Me)), ot = (ft = ot) === null || ft === void 0 ?
                                void 0 : ft.slice(String(ee.ellipsisContent || "").length), nt =
                                createVNode(Fragment, null, [toRaw(ee.ellipsisContent),
                                    createVNode("span", {
                                        title: ot,
                                        "aria-hidden": "true"
                                    }, [ELLIPSIS_STR]), De])
                        } else nt = createVNode(Fragment, null, [Me, De]);
                        nt = ge(C, nt);
                        var Ze = Ke && Te && ee.isEllipsis && !ee.expanded && !Be,
                            ut = W.ellipsisTooltip ? W.ellipsisTooltip() : Ke;
                        return createVNode(ResizeObserver$1, {
                            onResize: Se,
                            disabled: !Te
                        }, {
                            default: function () {
                                return [createVNode(Typography$1, _objectSpread2$1({
                                    ref: ne,
                                    class: [(Ee = {},
                                        _defineProperty$V(
                                            Ee, "".concat(Z
                                                .value, "-"
                                            ).concat(Re),
                                            Re),
                                        _defineProperty$V(
                                            Ee, "".concat(Z
                                                .value,
                                                "-disabled"
                                            ), He),
                                        _defineProperty$V(
                                            Ee, "".concat(Z
                                                .value,
                                                "-ellipsis"
                                            ), Te),
                                        _defineProperty$V(
                                            Ee, "".concat(Z
                                                .value,
                                                "-single-line"
                                            ), Te === 1 &&
                                            !ee.isEllipsis),
                                        _defineProperty$V(
                                            Ee, "".concat(Z
                                                .value,
                                                "-ellipsis-single-line"
                                            ), Ge),
                                        _defineProperty$V(
                                            Ee, "".concat(Z
                                                .value,
                                                "-ellipsis-multiple-line"
                                            ), Xe), Ee), je],
                                    style: _objectSpread2$1(
                                        _objectSpread2$1({}, Fe), {}, {
                                            WebkitLineClamp: Xe ?
                                                Te : void 0
                                        }),
                                    "aria-label": it,
                                    direction: Q.value,
                                    onClick: Ne.indexOf("text") !==
                                        -1 ? ie : function () {}
                                }, ze), {
                                    default: function () {
                                        return [Ze ? createVNode(
                                            Tooltip, {
                                                title: Ke ===
                                                    !0 ? Me :
                                                    ut
                                            }, {
                                                default: function () {
                                                    return [
                                                        createVNode(
                                                            "span",
                                                            null,
                                                            [
                                                                nt
                                                                ]
                                                        )
                                                        ]
                                                }
                                            }) : nt, Ce()]
                                    }
                                })]
                            }
                        })
                    }
                }, null)
            }
        }
    });
const Base$1 = Base;
var _excluded$4 = ["ellipsis", "rel"],
    linkProps = function () {
        return omit$2(_objectSpread2$1(_objectSpread2$1({}, baseProps()), {}, {
            ellipsis: {
                type: Boolean,
                default: void 0
            }
        }), ["component"])
    },
    Link = function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = _objectSpread2$1(_objectSpread2$1({}, C), U),
            X = G.ellipsis,
            Z = G.rel,
            Q = _objectWithoutProperties$2(G, _excluded$4);
        warning$2(_typeof$2(X) !== "object", "Typography.Link", "`ellipsis` only supports boolean value.");
        var ee = _objectSpread2$1(_objectSpread2$1({}, Q), {}, {
            rel: Z === void 0 && Q.target === "_blank" ? "noopener noreferrer" : Z,
            ellipsis: !!X,
            component: "a"
        });
        return delete ee.navigate, createVNode(Base$1, ee, W)
    };
Link.displayName = "ATypographyLink";
Link.inheritAttrs = !1;
Link.props = linkProps();
const Link$1 = Link;
var paragraphProps = function () {
        return omit$2(baseProps(), ["component"])
    },
    Paragraph = function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = _objectSpread2$1(_objectSpread2$1({}, C), {}, {
                component: "div"
            }, U);
        return createVNode(Base$1, G, W)
    };
Paragraph.displayName = "ATypographyParagraph";
Paragraph.inheritAttrs = !1;
Paragraph.props = paragraphProps();
const Paragraph$1 = Paragraph;
var textProps = function () {
        return _objectSpread2$1(_objectSpread2$1({}, omit$2(baseProps(), ["component"])), {}, {
            ellipsis: {
                type: [Boolean, Object],
                default: void 0
            }
        })
    },
    Text = function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = C.ellipsis;
        warning$2(_typeof$2(G) !== "object" || !G || !("expandable" in G) && !("rows" in G), "Typography.Text",
            "`ellipsis` do not support `expandable` or `rows` props.");
        var X = _objectSpread2$1(_objectSpread2$1({}, C), {}, {
            ellipsis: G && _typeof$2(G) === "object" ? omit$2(G, ["expandable", "rows"]) : G,
            component: "span"
        }, U);
        return createVNode(Base$1, X, W)
    };
Text.displayName = "ATypographyText";
Text.inheritAttrs = !1;
Text.props = textProps();
const Text$1 = Text;
var _excluded$3 = ["level"],
    TITLE_ELE_LIST = tupleNum(1, 2, 3, 4, 5),
    titleProps = function () {
        return _objectSpread2$1(_objectSpread2$1({}, omit$2(baseProps(), ["component", "strong"])), {}, {
            level: Number
        })
    },
    Title = function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = C.level,
            X = G === void 0 ? 1 : G,
            Z = _objectWithoutProperties$2(C, _excluded$3),
            Q;
        TITLE_ELE_LIST.indexOf(X) !== -1 ? Q = "h".concat(X) : (warning$2(!1, "Typography",
            "Title only accept `1 | 2 | 3 | 4 | 5` as `level` value."), Q = "h1");
        var ee = _objectSpread2$1(_objectSpread2$1({}, Z), {}, {
            component: Q
        }, U);
        return createVNode(Base$1, ee, W)
    };
Title.displayName = "ATypographyTitle";
Title.inheritAttrs = !1;
Title.props = titleProps();
const Title$1 = Title;
Typography$1.Text = Text$1;
Typography$1.Title = Title$1;
Typography$1.Paragraph = Paragraph$1;
Typography$1.Link = Link$1;
Typography$1.Base = Base$1;
Typography$1.install = function (K) {
    return K.component(Typography$1.name, Typography$1), K.component(Typography$1.Text.displayName, Text$1), K.component(
            Typography$1.Title.displayName, Title$1), K.component(Typography$1.Paragraph.displayName, Paragraph$1),
        K.component(Typography$1.Link.displayName, Link$1), K
};

function getError(K, C) {
    var H = "cannot ".concat(K.method, " ").concat(K.action, " ").concat(C.status, "'"),
        W = new Error(H);
    return W.status = C.status, W.method = K.method, W.url = K.action, W
}

function getBody(K) {
    var C = K.responseText || K.response;
    if (!C) return C;
    try {
        return JSON.parse(C)
    } catch {
        return C
    }
}

function upload(K) {
    var C = new XMLHttpRequest;
    K.onProgress && C.upload && (C.upload.onprogress = function (G) {
        G.total > 0 && (G.percent = G.loaded / G.total * 100), K.onProgress(G)
    });
    var H = new FormData;
    K.data && Object.keys(K.data).forEach(function (U) {
            var G = K.data[U];
            if (Array.isArray(G)) {
                G.forEach(function (X) {
                    H.append("".concat(U, "[]"), X)
                });
                return
            }
            H.append(U, G)
        }), K.file instanceof Blob ? H.append(K.filename, K.file, K.file.name) : H.append(K.filename, K.file), C.onerror =
        function (G) {
            K.onError(G)
        }, C.onload = function () {
            return C.status < 200 || C.status >= 300 ? K.onError(getError(K, C), getBody(C)) : K.onSuccess(getBody(C),
                C)
        }, C.open(K.method, K.action, !0), K.withCredentials && "withCredentials" in C && (C.withCredentials = !0);
    var W = K.headers || {};
    return W["X-Requested-With"] !== null && C.setRequestHeader("X-Requested-With", "XMLHttpRequest"), Object.keys(W).forEach(
        function (U) {
            W[U] !== null && C.setRequestHeader(U, W[U])
        }), C.send(H), {
        abort: function () {
            C.abort()
        }
    }
}
var now$1 = +new Date,
    index = 0;

function uid() {
    return "vc-upload-".concat(now$1, "-").concat(++index)
}
const attrAccept = function (K, C) {
    if (K && C) {
        var H = Array.isArray(C) ? C : C.split(","),
            W = K.name || "",
            U = K.type || "",
            G = U.replace(/\/.*$/, "");
        return H.some(function (X) {
            var Z = X.trim();
            if (/^\*(\/\*)?$/.test(X)) return !0;
            if (Z.charAt(0) === ".") {
                var Q = W.toLowerCase(),
                    ee = Z.toLowerCase(),
                    ne = [ee];
                return (ee === ".jpg" || ee === ".jpeg") && (ne = [".jpg", ".jpeg"]), ne.some(function (te) {
                    return Q.endsWith(te)
                })
            }
            return /\/\*$/.test(Z) ? G === Z.replace(/\/.*$/, "") : !!(U === Z || /^\w+$/.test(Z))
        })
    }
    return !0
};

function loopFiles(K, C) {
    var H = K.createReader(),
        W = [];

    function U() {
        H.readEntries(function (G) {
            var X = Array.prototype.slice.apply(G);
            W = W.concat(X);
            var Z = !X.length;
            Z ? C(W) : U()
        })
    }
    U()
}
var traverseFileTree = function (C, H, W) {
    var U = function G(X, Z) {
        X.path = Z || "", X.isFile ? X.file(function (Q) {
            W(Q) && (X.fullPath && !Q.webkitRelativePath && (Object.defineProperties(Q, {
                webkitRelativePath: {
                    writable: !0
                }
            }), Q.webkitRelativePath = X.fullPath.replace(/^\//, ""), Object.defineProperties(
                Q, {
                    webkitRelativePath: {
                        writable: !1
                    }
                })), H([Q]))
        }) : X.isDirectory && loopFiles(X, function (Q) {
            Q.forEach(function (ee) {
                G(ee, "".concat(Z).concat(X.name, "/"))
            })
        })
    };
    C.forEach(function (G) {
        U(G.webkitGetAsEntry())
    })
};
const traverseFileTree$1 = traverseFileTree;
var uploadProps$1 = function () {
    return {
        capture: [Boolean, String],
        multipart: {
            type: Boolean,
            default: void 0
        },
        name: String,
        disabled: {
            type: Boolean,
            default: void 0
        },
        componentTag: String,
        action: [String, Function],
        method: String,
        directory: {
            type: Boolean,
            default: void 0
        },
        data: [Object, Function],
        headers: Object,
        accept: String,
        multiple: {
            type: Boolean,
            default: void 0
        },
        onBatchStart: Function,
        onReject: Function,
        onStart: Function,
        onError: Function,
        onSuccess: Function,
        onProgress: Function,
        beforeUpload: Function,
        customRequest: Function,
        withCredentials: {
            type: Boolean,
            default: void 0
        },
        openFileDialogOnClick: {
            type: Boolean,
            default: void 0
        },
        prefixCls: String,
        id: String,
        onMouseenter: Function,
        onMouseleave: Function,
        onClick: Function
    }
};

function arrayAggregator(K, C, H, W) {
    for (var U = -1, G = K == null ? 0 : K.length; ++U < G;) {
        var X = K[U];
        C(W, X, H(X), K)
    }
    return W
}

function createBaseFor(K) {
    return function (C, H, W) {
        for (var U = -1, G = Object(C), X = W(C), Z = X.length; Z--;) {
            var Q = X[K ? Z : ++U];
            if (H(G[Q], Q, G) === !1) break
        }
        return C
    }
}
var baseFor = createBaseFor();
const baseFor$1 = baseFor;

function baseForOwn(K, C) {
    return K && baseFor$1(K, C, keys$1)
}

function createBaseEach(K, C) {
    return function (H, W) {
        if (H == null) return H;
        if (!isArrayLike(H)) return K(H, W);
        for (var U = H.length, G = C ? U : -1, X = Object(H);
            (C ? G-- : ++G < U) && W(X[G], G, X) !== !1;);
        return H
    }
}
var baseEach = createBaseEach(baseForOwn);
const baseEach$1 = baseEach;

function baseAggregator(K, C, H, W) {
    return baseEach$1(K, function (U, G, X) {
        C(W, U, H(U), X)
    }), W
}

function createAggregator(K, C) {
    return function (H, W) {
        var U = isArray$2(H) ? arrayAggregator : baseAggregator,
            G = C ? C() : {};
        return U(H, K, baseIteratee(W), G)
    }
}
var partition = createAggregator(function (K, C, H) {
    K[H ? 0 : 1].push(C)
}, function () {
    return [[], []]
});
const partition$1 = partition;
var _excluded$2 = ["componentTag", "prefixCls", "disabled", "id", "multiple", "accept", "capture", "directory",
    "openFileDialogOnClick", "onMouseenter", "onMouseleave"];
const AjaxUpload = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AjaxUploader",
    inheritAttrs: !1,
    props: uploadProps$1(),
    setup: function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = H.expose,
            X = ref(uid()),
            Z = {},
            Q = ref(),
            ee = !1,
            ne = function () {
                var ce = _asyncToGenerator(regenerator.mark(function de(ve, fe) {
                    var pe, me, he, Se, _e, be, ge, xe, Pe;
                    return regenerator.wrap(function (ye) {
                        for (;;) switch (ye.prev = ye.next) {
                            case 0:
                                if (pe = C.beforeUpload, me = ve, !pe) {
                                    ye.next = 14;
                                    break
                                }
                                return ye.prev = 3, ye.next = 6, pe(ve, fe);
                            case 6:
                                me = ye.sent, ye.next = 12;
                                break;
                            case 9:
                                ye.prev = 9, ye.t0 = ye.catch(3), me = !1;
                            case 12:
                                if (me !== !1) {
                                    ye.next = 14;
                                    break
                                }
                                return ye.abrupt("return", {
                                    origin: ve,
                                    parsedFile: null,
                                    action: null,
                                    data: null
                                });
                            case 14:
                                if (he = C.action, typeof he != "function") {
                                    ye.next = 21;
                                    break
                                }
                                return ye.next = 18, he(ve);
                            case 18:
                                Se = ye.sent, ye.next = 22;
                                break;
                            case 21:
                                Se = he;
                            case 22:
                                if (_e = C.data, typeof _e != "function") {
                                    ye.next = 29;
                                    break
                                }
                                return ye.next = 26, _e(ve);
                            case 26:
                                be = ye.sent, ye.next = 30;
                                break;
                            case 29:
                                be = _e;
                            case 30:
                                return ge = (_typeof$2(me) === "object" || typeof me ==
                                        "string") && me ? me : ve, ge instanceof File ?
                                    xe = ge : xe = new File([ge], ve.name, {
                                        type: ve.type
                                    }), Pe = xe, Pe.uid = ve.uid, ye.abrupt(
                                        "return", {
                                            origin: ve,
                                            data: be,
                                            parsedFile: Pe,
                                            action: Se
                                        });
                            case 35:
                            case "end":
                                return ye.stop()
                        }
                    }, de, null, [[3, 9]])
                }));
                return function (ve, fe) {
                    return ce.apply(this, arguments)
                }
            }(),
            te = function (de) {
                var ve = de.data,
                    fe = de.origin,
                    pe = de.action,
                    me = de.parsedFile;
                if (ee) {
                    var he = C.onStart,
                        Se = C.customRequest,
                        _e = C.name,
                        be = C.headers,
                        ge = C.withCredentials,
                        xe = C.method,
                        Pe = fe.uid,
                        $e = Se || upload,
                        ye = {
                            action: pe,
                            filename: _e,
                            data: ve,
                            file: me,
                            headers: be,
                            withCredentials: ge,
                            method: xe || "post",
                            onProgress: function (we) {
                                var Oe = C.onProgress;
                                Oe == null || Oe(we, me)
                            },
                            onSuccess: function (we, Oe) {
                                var Ne = C.onSuccess;
                                Ne == null || Ne(we, me, Oe), delete Z[Pe]
                            },
                            onError: function (we, Oe) {
                                var Ne = C.onError;
                                Ne == null || Ne(we, Oe, me), delete Z[Pe]
                            }
                        };
                    he(fe), Z[Pe] = $e(ye)
                }
            },
            re = function () {
                X.value = uid()
            },
            ae = function (de) {
                if (de) {
                    var ve = de.uid ? de.uid : de;
                    Z[ve] && Z[ve].abort && Z[ve].abort(), delete Z[ve]
                } else Object.keys(Z).forEach(function (fe) {
                    Z[fe] && Z[fe].abort && Z[fe].abort(), delete Z[fe]
                })
            };
        onMounted(function () {
            ee = !0
        }), onBeforeUnmount(function () {
            ee = !1, ae()
        });
        var oe = function (de) {
                var ve = _toConsumableArray(de),
                    fe = ve.map(function (pe) {
                        return pe.uid = uid(), ne(pe, ve)
                    });
                Promise.all(fe).then(function (pe) {
                    var me = C.onBatchStart;
                    me == null || me(pe.map(function (he) {
                        var Se = he.origin,
                            _e = he.parsedFile;
                        return {
                            file: Se,
                            parsedFile: _e
                        }
                    })), pe.filter(function (he) {
                        return he.parsedFile !== null
                    }).forEach(function (he) {
                        te(he)
                    })
                })
            },
            ie = function (de) {
                var ve = C.accept,
                    fe = C.directory,
                    pe = de.target.files,
                    me = _toConsumableArray(pe).filter(function (he) {
                        return !fe || attrAccept(he, ve)
                    });
                oe(me), re()
            },
            ue = function (de) {
                var ve = Q.value;
                if (ve) {
                    var fe = C.onClick;
                    ve.click(), fe && fe(de)
                }
            },
            le = function (de) {
                de.key === "Enter" && ue(de)
            },
            se = function (de) {
                var ve = C.multiple;
                if (de.preventDefault(), de.type !== "dragover")
                    if (C.directory) traverseFileTree$1(Array.prototype.slice.call(de.dataTransfer.items),
                        oe,
                        function (he) {
                            return attrAccept(he, C.accept)
                        });
                    else {
                        var fe = partition$1(Array.prototype.slice.call(de.dataTransfer.files), function (
                                he) {
                                return attrAccept(he, C.accept)
                            }),
                            pe = fe[0],
                            me = fe[1];
                        ve === !1 && (pe = pe.slice(0, 1)), oe(pe), me.length && C.onReject && C.onReject(
                            me)
                    }
            };
        return G({
                abort: ae
            }),
            function () {
                var ce, de, ve = C.componentTag,
                    fe = C.prefixCls,
                    pe = C.disabled,
                    me = C.id,
                    he = C.multiple,
                    Se = C.accept,
                    _e = C.capture,
                    be = C.directory,
                    ge = C.openFileDialogOnClick,
                    xe = C.onMouseenter,
                    Pe = C.onMouseleave,
                    $e = _objectWithoutProperties$2(C, _excluded$2),
                    ye = (ce = {}, _defineProperty$V(ce, fe, !0), _defineProperty$V(ce, "".concat(fe,
                        "-disabled"), pe), _defineProperty$V(ce, U.class, !!U.class), ce),
                    Ce = be ? {
                        directory: "directory",
                        webkitdirectory: "webkitdirectory"
                    } : {},
                    we = pe ? {} : {
                        onClick: ge ? ue : function () {},
                        onKeydown: ge ? le : function () {},
                        onMouseenter: xe,
                        onMouseleave: Pe,
                        onDrop: se,
                        onDragover: se,
                        tabindex: "0"
                    };
                return createVNode(ve, _objectSpread2$1(_objectSpread2$1({}, we), {}, {
                    class: ye,
                    role: "button",
                    style: U.style
                }), {
                    default: function () {
                        return [createVNode("input", _objectSpread2$1(_objectSpread2$1(
                                _objectSpread2$1({}, pickAttrs($e, {
                                    aria: !0,
                                    data: !0
                                })), {}, {
                                    id: me,
                                    type: "file",
                                    ref: Q,
                                    onClick: function (Me) {
                                        return Me.stopPropagation()
                                    },
                                    key: X.value,
                                    style: {
                                        display: "none"
                                    },
                                    accept: Se
                                }, Ce), {}, {
                                multiple: he,
                                onChange: ie
                            }, _e != null ? {
                                capture: _e
                            } : {}), null), (de = W.default) === null || de === void 0 ?
                            void 0 : de.call(W)]
                    }
                })
            }
    }
});

function empty() {}
const Upload$2 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "Upload",
    inheritAttrs: !1,
    props: initDefaultProps$1(uploadProps$1(), {
        componentTag: "span",
        prefixCls: "rc-upload",
        data: {},
        headers: {},
        name: "file",
        multipart: !1,
        onStart: empty,
        onError: empty,
        onSuccess: empty,
        multiple: !1,
        beforeUpload: null,
        customRequest: null,
        withCredentials: !1,
        openFileDialogOnClick: !0
    }),
    setup: function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = H.expose,
            X = ref(),
            Z = function (ee) {
                var ne;
                (ne = X.value) === null || ne === void 0 || ne.abort(ee)
            };
        return G({
                abort: Z
            }),
            function () {
                return createVNode(AjaxUpload, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, C), U), {}, {
                    ref: X
                }), W)
            }
    }
});
var PaperClipOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M779.3 196.6c-94.2-94.2-247.6-94.2-341.7 0l-261 260.8c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l261-260.8c32.4-32.4 75.5-50.2 121.3-50.2s88.9 17.8 121.2 50.2c32.4 32.4 50.2 75.5 50.2 121.2 0 45.8-17.8 88.8-50.2 121.2l-266 265.9-43.1 43.1c-40.3 40.3-105.8 40.3-146.1 0-19.5-19.5-30.2-45.4-30.2-73s10.7-53.5 30.2-73l263.9-263.8c6.7-6.6 15.5-10.3 24.9-10.3h.1c9.4 0 18.1 3.7 24.7 10.3 6.7 6.7 10.3 15.5 10.3 24.9 0 9.3-3.7 18.1-10.3 24.7L372.4 653c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l215.6-215.6c19.9-19.9 30.8-46.3 30.8-74.4s-11-54.6-30.8-74.4c-41.1-41.1-107.9-41-149 0L463 364 224.8 602.1A172.22 172.22 0 00174 724.8c0 46.3 18.1 89.8 50.8 122.5 33.9 33.8 78.3 50.7 122.7 50.7 44.4 0 88.8-16.9 122.6-50.7l309.2-309C824.8 492.7 850 432 850 367.5c.1-64.6-25.1-125.3-70.7-170.9z"
            }
        }]
    },
    name: "paper-clip",
    theme: "outlined"
};
const PaperClipOutlinedSvg = PaperClipOutlined$2;

function _objectSpread$4(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$4(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$4(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var PaperClipOutlined = function (C, H) {
    var W = _objectSpread$4({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$4({}, W, {
        icon: PaperClipOutlinedSvg
    }), null)
};
PaperClipOutlined.displayName = "PaperClipOutlined";
PaperClipOutlined.inheritAttrs = !1;
const PaperClipOutlined$1 = PaperClipOutlined;
var PictureTwoTone$2 = {
    icon: function (C, H) {
        return {
            tag: "svg",
            attrs: {
                viewBox: "64 64 896 896",
                focusable: "false"
            },
            children: [{
                tag: "path",
                attrs: {
                    d: "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 632H136v-39.9l138.5-164.3 150.1 178L658.1 489 888 761.6V792zm0-129.8L664.2 396.8c-3.2-3.8-9-3.8-12.2 0L424.6 666.4l-144-170.7c-3.2-3.8-9-3.8-12.2 0L136 652.7V232h752v430.2z",
                    fill: C
                }
            }, {
                tag: "path",
                attrs: {
                    d: "M424.6 765.8l-150.1-178L136 752.1V792h752v-30.4L658.1 489z",
                    fill: H
                }
            }, {
                tag: "path",
                attrs: {
                    d: "M136 652.7l132.4-157c3.2-3.8 9-3.8 12.2 0l144 170.7L652 396.8c3.2-3.8 9-3.8 12.2 0L888 662.2V232H136v420.7zM304 280a88 88 0 110 176 88 88 0 010-176z",
                    fill: H
                }
            }, {
                tag: "path",
                attrs: {
                    d: "M276 368a28 28 0 1056 0 28 28 0 10-56 0z",
                    fill: H
                }
            }, {
                tag: "path",
                attrs: {
                    d: "M304 456a88 88 0 100-176 88 88 0 000 176zm0-116c15.5 0 28 12.5 28 28s-12.5 28-28 28-28-12.5-28-28 12.5-28 28-28z",
                    fill: C
                }
            }]
        }
    },
    name: "picture",
    theme: "twotone"
};
const PictureTwoToneSvg = PictureTwoTone$2;

function _objectSpread$3(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$3(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$3(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var PictureTwoTone = function (C, H) {
    var W = _objectSpread$3({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$3({}, W, {
        icon: PictureTwoToneSvg
    }), null)
};
PictureTwoTone.displayName = "PictureTwoTone";
PictureTwoTone.inheritAttrs = !1;
const PictureTwoTone$1 = PictureTwoTone;
var FileTwoTone$2 = {
    icon: function (C, H) {
        return {
            tag: "svg",
            attrs: {
                viewBox: "64 64 896 896",
                focusable: "false"
            },
            children: [{
                tag: "path",
                attrs: {
                    d: "M534 352V136H232v752h560V394H576a42 42 0 01-42-42z",
                    fill: H
                }
            }, {
                tag: "path",
                attrs: {
                    d: "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM602 137.8L790.2 326H602V137.8zM792 888H232V136h302v216a42 42 0 0042 42h216v494z",
                    fill: C
                }
            }]
        }
    },
    name: "file",
    theme: "twotone"
};
const FileTwoToneSvg = FileTwoTone$2;

function _objectSpread$2(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$2(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$2(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var FileTwoTone = function (C, H) {
    var W = _objectSpread$2({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$2({}, W, {
        icon: FileTwoToneSvg
    }), null)
};
FileTwoTone.displayName = "FileTwoTone";
FileTwoTone.inheritAttrs = !1;
const FileTwoTone$1 = FileTwoTone;

function uploadProps() {
    return {
        capture: [Boolean, String],
        type: String,
        name: String,
        defaultFileList: Array,
        fileList: Array,
        action: [String, Function],
        directory: {
            type: Boolean,
            default: void 0
        },
        data: [Object, Function],
        method: String,
        headers: Object,
        showUploadList: {
            type: [Boolean, Object],
            default: void 0
        },
        multiple: {
            type: Boolean,
            default: void 0
        },
        accept: String,
        beforeUpload: Function,
        onChange: Function,
        "onUpdate:fileList": Function,
        onDrop: Function,
        listType: String,
        onPreview: Function,
        onDownload: Function,
        onReject: Function,
        onRemove: Function,
        remove: Function,
        supportServerRender: {
            type: Boolean,
            default: void 0
        },
        disabled: {
            type: Boolean,
            default: void 0
        },
        prefixCls: String,
        customRequest: Function,
        withCredentials: {
            type: Boolean,
            default: void 0
        },
        openFileDialogOnClick: {
            type: Boolean,
            default: void 0
        },
        locale: {
            type: Object,
            default: void 0
        },
        id: String,
        previewFile: Function,
        transformFile: Function,
        iconRender: Function,
        isImageUrl: Function,
        progress: Object,
        itemRender: Function,
        maxCount: Number,
        height: [Number, String],
        removeIcon: Function,
        downloadIcon: Function,
        previewIcon: Function
    }
}

function uploadListProps() {
    return {
        listType: String,
        onPreview: Function,
        onDownload: Function,
        onRemove: Function,
        items: Array,
        progress: Object,
        prefixCls: String,
        showRemoveIcon: {
            type: Boolean,
            default: void 0
        },
        showDownloadIcon: {
            type: Boolean,
            default: void 0
        },
        showPreviewIcon: {
            type: Boolean,
            default: void 0
        },
        removeIcon: Function,
        downloadIcon: Function,
        previewIcon: Function,
        locale: {
            type: Object,
            default: void 0
        },
        previewFile: Function,
        iconRender: Function,
        isImageUrl: Function,
        appendAction: Function,
        appendActionVisible: {
            type: Boolean,
            default: void 0
        },
        itemRender: Function
    }
}

function file2Obj(K) {
    return _objectSpread2$1(_objectSpread2$1({}, K), {}, {
        lastModified: K.lastModified,
        lastModifiedDate: K.lastModifiedDate,
        name: K.name,
        size: K.size,
        type: K.type,
        uid: K.uid,
        percent: 0,
        originFileObj: K
    })
}

function updateFileList(K, C) {
    var H = _toConsumableArray(C),
        W = H.findIndex(function (U) {
            var G = U.uid;
            return G === K.uid
        });
    return W === -1 ? H.push(K) : H[W] = K, H
}

function getFileItem(K, C) {
    var H = K.uid !== void 0 ? "uid" : "name";
    return C.filter(function (W) {
        return W[H] === K[H]
    })[0]
}

function removeFileItem(K, C) {
    var H = K.uid !== void 0 ? "uid" : "name",
        W = C.filter(function (U) {
            return U[H] !== K[H]
        });
    return W.length === C.length ? null : W
}
var extname = function () {
        var C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "",
            H = C.split("/"),
            W = H[H.length - 1],
            U = W.split(/#|\?/)[0];
        return (/\.[^./\\]*$/.exec(U) || [""])[0]
    },
    isImageFileType = function (C) {
        return C.indexOf("image/") === 0
    },
    isImageUrl = function (C) {
        if (C.type && !C.thumbUrl) return isImageFileType(C.type);
        var H = C.thumbUrl || C.url || "",
            W = extname(H);
        return /^data:image\//.test(H) || /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i.test(W) ? !0 : !(/^data:/.test(
            H) || W)
    },
    MEASURE_SIZE = 200;

function previewImage(K) {
    return new Promise(function (C) {
        if (!K.type || !isImageFileType(K.type)) {
            C("");
            return
        }
        var H = document.createElement("canvas");
        H.width = MEASURE_SIZE, H.height = MEASURE_SIZE, H.style.cssText =
            "position: fixed; left: 0; top: 0; width: ".concat(MEASURE_SIZE, "px; height: ").concat(
                MEASURE_SIZE, "px; z-index: 9999; display: none;"), document.body.appendChild(H);
        var W = H.getContext("2d"),
            U = new Image;
        U.onload = function () {
            var G = U.width,
                X = U.height,
                Z = MEASURE_SIZE,
                Q = MEASURE_SIZE,
                ee = 0,
                ne = 0;
            G > X ? (Q = X * (MEASURE_SIZE / G), ne = -(Q - Z) / 2) : (Z = G * (MEASURE_SIZE / X), ee = -(Z -
                Q) / 2), W.drawImage(U, ee, ne, Z, Q);
            var te = H.toDataURL();
            document.body.removeChild(H), C(te)
        }, U.src = window.URL.createObjectURL(K)
    })
}
var DownloadOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M505.7 661a8 8 0 0012.6 0l112-141.7c4.1-5.2.4-12.9-6.3-12.9h-74.1V168c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v338.3H400c-6.7 0-10.4 7.7-6.3 12.9l112 141.8zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z"
            }
        }]
    },
    name: "download",
    theme: "outlined"
};
const DownloadOutlinedSvg = DownloadOutlined$2;

function _objectSpread$1(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty$1(K, U, H[U])
        })
    }
    return K
}

function _defineProperty$1(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var DownloadOutlined = function (C, H) {
    var W = _objectSpread$1({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread$1({}, W, {
        icon: DownloadOutlinedSvg
    }), null)
};
DownloadOutlined.displayName = "DownloadOutlined";
DownloadOutlined.inheritAttrs = !1;
const DownloadOutlined$1 = DownloadOutlined;
var listItemProps = function () {
    return {
        prefixCls: String,
        locale: {
            type: Object,
            default: void 0
        },
        file: Object,
        items: Array,
        listType: String,
        isImgUrl: Function,
        showRemoveIcon: {
            type: Boolean,
            default: void 0
        },
        showDownloadIcon: {
            type: Boolean,
            default: void 0
        },
        showPreviewIcon: {
            type: Boolean,
            default: void 0
        },
        removeIcon: Function,
        downloadIcon: Function,
        previewIcon: Function,
        iconRender: Function,
        actionIconRender: Function,
        itemRender: Function,
        onPreview: Function,
        onClose: Function,
        onDownload: Function,
        progress: Object
    }
};
const ListItem = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "ListItem",
    inheritAttrs: !1,
    props: listItemProps(),
    setup: function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = ref(!1),
            X = ref();
        onMounted(function () {
            X.value = setTimeout(function () {
                G.value = !0
            }, 300)
        }), onBeforeUnmount(function () {
            clearTimeout(X.value)
        });
        var Z = useConfigInject("upload", C),
            Q = Z.rootPrefixCls,
            ee = computed(function () {
                return getTransitionProps("".concat(Q.value, "-fade"))
            });
        return function () {
            var ne, te, re = C.prefixCls,
                ae = C.locale,
                oe = C.listType,
                ie = C.file,
                ue = C.items,
                le = C.progress,
                se = C.iconRender,
                ce = se === void 0 ? W.iconRender : se,
                de = C.actionIconRender,
                ve = de === void 0 ? W.actionIconRender : de,
                fe = C.itemRender,
                pe = fe === void 0 ? W.itemRender : fe,
                me = C.isImgUrl,
                he = C.showPreviewIcon,
                Se = C.showRemoveIcon,
                _e = C.showDownloadIcon,
                be = C.previewIcon,
                ge = be === void 0 ? W.previewIcon : be,
                xe = C.removeIcon,
                Pe = xe === void 0 ? W.removeIcon : xe,
                $e = C.downloadIcon,
                ye = $e === void 0 ? W.downloadIcon : $e,
                Ce = C.onPreview,
                we = C.onDownload,
                Oe = C.onClose,
                Ne = U.class,
                Me = U.style,
                Ve = "".concat(re, "-span"),
                ke = ce({
                    file: ie
                }),
                Ee = createVNode("div", {
                    class: "".concat(re, "-text-icon")
                }, [ke]);
            if (oe === "picture" || oe === "picture-card")
                if (ie.status === "uploading" || !ie.thumbUrl && !ie.url) {
                    var Ae, Re = (Ae = {}, _defineProperty$V(Ae, "".concat(re, "-list-item-thumbnail"),
                        !0), _defineProperty$V(Ae, "".concat(re, "-list-item-file"), ie.status !==
                        "uploading"), Ae);
                    Ee = createVNode("div", {
                        class: Re
                    }, [ke])
                } else {
                    var He, je = me != null && me(ie) ? createVNode("img", {
                            src: ie.thumbUrl || ie.url,
                            alt: ie.name,
                            class: "".concat(re, "-list-item-image")
                        }, null) : ke,
                        Fe = (He = {}, _defineProperty$V(He, "".concat(re, "-list-item-thumbnail"), !0),
                            _defineProperty$V(He, "".concat(re, "-list-item-file"), me && !me(ie)), He);
                    Ee = createVNode("a", {
                        class: Fe,
                        onClick: function (Ze) {
                            return Ce(ie, Ze)
                        },
                        href: ie.url || ie.thumbUrl,
                        target: "_blank",
                        rel: "noopener noreferrer"
                    }, [je])
                } var Le = (ne = {}, _defineProperty$V(ne, "".concat(re, "-list-item"), !0),
                    _defineProperty$V(ne, "".concat(re, "-list-item-").concat(ie.status), !0),
                    _defineProperty$V(ne, "".concat(re, "-list-item-list-type-").concat(oe), !0), ne),
                Ie = typeof ie.linkProps == "string" ? JSON.parse(ie.linkProps) : ie.linkProps,
                Te = Se ? ve({
                    customIcon: Pe ? Pe({
                        file: ie
                    }) : createVNode(DeleteOutlined$1, null, null),
                    callback: function () {
                        return Oe(ie)
                    },
                    prefixCls: re,
                    title: ae.removeFile
                }) : null,
                De = _e && ie.status === "done" ? ve({
                    customIcon: ye ? ye({
                        file: ie
                    }) : createVNode(DownloadOutlined$1, null, null),
                    callback: function () {
                        return we(ie)
                    },
                    prefixCls: re,
                    title: ae.downloadFile
                }) : null,
                Ke = oe !== "picture-card" && createVNode("span", {
                    key: "download-delete",
                    class: ["".concat(re, "-list-item-card-actions"), {
                        picture: oe === "picture"
                    }]
                }, [De, Te]),
                We = "".concat(re, "-list-item-name"),
                Ue = ie.url ? [createVNode("a", _objectSpread2$1(_objectSpread2$1({
                    key: "view",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    class: We,
                    title: ie.name
                }, Ie), {}, {
                    href: ie.url,
                    onClick: function (Ze) {
                        return Ce(ie, Ze)
                    }
                }), [ie.name]), Ke] : [createVNode("span", {
                    key: "view",
                    class: We,
                    onClick: function (Ze) {
                        return Ce(ie, Ze)
                    },
                    title: ie.name
                }, [ie.name]), Ke],
                et = {
                    pointerEvents: "none",
                    opacity: .5
                },
                Ye = he ? createVNode("a", {
                    href: ie.url || ie.thumbUrl,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    style: ie.url || ie.thumbUrl ? void 0 : et,
                    onClick: function (Ze) {
                        return Ce(ie, Ze)
                    },
                    title: ae.previewFile
                }, [ge ? ge({
                    file: ie
                }) : createVNode(EyeOutlined$1, null, null)]) : null,
                ze = oe === "picture-card" && ie.status !== "uploading" && createVNode("span", {
                    class: "".concat(re, "-list-item-actions")
                }, [Ye, ie.status === "done" && De, Te]),
                Be;
            if (ie.response && typeof ie.response == "string") Be = ie.response;
            else {
                var Ge, Xe;
                Be = ((Ge = ie.error) === null || Ge === void 0 ? void 0 : Ge.statusText) || ((Xe = ie.error) ===
                    null || Xe === void 0 ? void 0 : Xe.message) || ae.uploadError
            }
            var nt = createVNode("span", {
                    class: Ve
                }, [Ee, Ue]),
                it = createVNode("div", {
                    class: Le
                }, [createVNode("div", {
                    class: "".concat(re, "-list-item-info")
                }, [nt]), ze, G.value && createVNode(Transition, ee.value, {
                    default: function () {
                        return [withDirectives(createVNode("div", {
                            class: "".concat(re, "-list-item-progress")
                        }, ["percent" in ie ? createVNode(Progress,
                            _objectSpread2$1(_objectSpread2$1({},
                                le), {}, {
                                type: "line",
                                percent: ie.percent
                            }), null) : null]), [[vShow, ie.status ===
                            "uploading"]])]
                    }
                })]),
                ft = (te = {}, _defineProperty$V(te, "".concat(re, "-list-").concat(oe, "-container"),
                    !0), _defineProperty$V(te, "".concat(Ne), !!Ne), te),
                pt = ie.status === "error" ? createVNode(Tooltip, {
                    title: Be,
                    getPopupContainer: function (Ze) {
                        return Ze.parentNode
                    }
                }, {
                    default: function () {
                        return [it]
                    }
                }) : it;
            return createVNode("div", {
                class: ft,
                style: Me,
                ref
            }, [pe ? pe({
                originNode: pt,
                file: ie,
                fileList: ue,
                actions: {
                    download: we.bind(null, ie),
                    preview: Ce.bind(null, ie),
                    remove: Oe.bind(null, ie)
                }
            }) : pt])
        }
    }
});
var HackSlot = function (C, H) {
    var W, U = H.slots;
    return filterEmpty((W = U.default) === null || W === void 0 ? void 0 : W.call(U))[0]
};
const UploadList = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AUploadList",
    props: initDefaultProps$1(uploadListProps(), {
        listType: "text",
        progress: {
            strokeWidth: 2,
            showInfo: !1
        },
        showRemoveIcon: !0,
        showDownloadIcon: !1,
        showPreviewIcon: !0,
        previewFile: previewImage,
        isImageUrl,
        items: [],
        appendActionVisible: !0
    }),
    setup: function (C, H) {
        var W = H.slots,
            U = H.expose,
            G = ref(!1),
            X = getCurrentInstance();
        onMounted(function () {
            G.value == !0
        }), watchEffect(function () {
            C.listType !== "picture" && C.listType !== "picture-card" || (C.items || []).forEach(
                function (le) {
                    typeof document > "u" || typeof window > "u" || !window.FileReader || !
                        window.File || !(le.originFileObj instanceof File || le.originFileObj instanceof Blob) ||
                        le.thumbUrl !== void 0 || (le.thumbUrl = "", C.previewFile && C.previewFile(
                            le.originFileObj).then(function (se) {
                            le.thumbUrl = se || "", X.update()
                        }))
                })
        });
        var Z = function (se, ce) {
                if (C.onPreview) return ce == null || ce.preventDefault(), C.onPreview(se)
            },
            Q = function (se) {
                typeof C.onDownload == "function" ? C.onDownload(se) : se.url && window.open(se.url)
            },
            ee = function (se) {
                var ce;
                (ce = C.onRemove) === null || ce === void 0 || ce.call(C, se)
            },
            ne = function (se) {
                var ce = se.file,
                    de = C.iconRender || W.iconRender;
                if (de) return de({
                    file: ce,
                    listType: C.listType
                });
                var ve = ce.status === "uploading",
                    fe = C.isImageUrl && C.isImageUrl(ce) ? createVNode(PictureTwoTone$1, null, null) :
                    createVNode(FileTwoTone$1, null, null),
                    pe = createVNode(ve ? LoadingOutlined$1 : PaperClipOutlined$1, null, null);
                return C.listType === "picture" ? pe = ve ? createVNode(LoadingOutlined$1, null, null) : fe :
                    C.listType === "picture-card" && (pe = ve ? C.locale.uploading : fe), pe
            },
            te = function (se) {
                var ce = se.customIcon,
                    de = se.callback,
                    ve = se.prefixCls,
                    fe = se.title,
                    pe = {
                        type: "text",
                        size: "small",
                        title: fe,
                        onClick: function () {
                            de()
                        },
                        class: "".concat(ve, "-list-item-card-actions-btn")
                    };
                return isValidElement(ce) ? createVNode(Button$1, pe, {
                    icon: function () {
                        return ce
                    }
                }) : createVNode(Button$1, pe, {
                    default: function () {
                        return [createVNode("span", null, [ce])]
                    }
                })
            };
        U({
            handlePreview: Z,
            handleDownload: Q
        });
        var re = useConfigInject("upload", C),
            ae = re.prefixCls,
            oe = re.direction,
            ie = computed(function () {
                var le;
                return le = {}, _defineProperty$V(le, "".concat(ae.value, "-list"), !0),
                    _defineProperty$V(le, "".concat(ae.value, "-list-").concat(C.listType), !0),
                    _defineProperty$V(le, "".concat(ae.value, "-list-rtl"), oe.value === "rtl"), le
            }),
            ue = computed(function () {
                return _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, collapseMotion$1("".concat(
                    ae.value, "-").concat(C.listType === "picture-card" ?
                    "animate-inline" : "animate"))), getTransitionGroupProps("".concat(ae.value,
                    "-").concat(C.listType === "picture-card" ? "animate-inline" :
                    "animate"))), {}, {
                    class: ie.value,
                    appear: G.value
                })
            });
        return function () {
            var le = C.listType,
                se = C.locale,
                ce = C.isImageUrl,
                de = C.items,
                ve = de === void 0 ? [] : de,
                fe = C.showPreviewIcon,
                pe = C.showRemoveIcon,
                me = C.showDownloadIcon,
                he = C.removeIcon,
                Se = C.previewIcon,
                _e = C.downloadIcon,
                be = C.progress,
                ge = C.appendAction,
                xe = C.itemRender,
                Pe = C.appendActionVisible,
                $e = ge == null ? void 0 : ge();
            return createVNode(TransitionGroup, _objectSpread2$1(_objectSpread2$1({}, ue.value), {}, {
                tag: "div"
            }), {
                default: function () {
                    return [ve.map(function (Ce) {
                        var we = Ce.uid;
                        return createVNode(ListItem, {
                            key: we,
                            locale: se,
                            prefixCls: ae.value,
                            file: Ce,
                            items: ve,
                            progress: be,
                            listType: le,
                            isImgUrl: ce,
                            showPreviewIcon: fe,
                            showRemoveIcon: pe,
                            showDownloadIcon: me,
                            onPreview: Z,
                            onDownload: Q,
                            onClose: ee,
                            removeIcon: he,
                            previewIcon: Se,
                            downloadIcon: _e,
                            itemRender: xe
                        }, _objectSpread2$1(_objectSpread2$1({}, W), {}, {
                            iconRender: ne,
                            actionIconRender: te
                        }))
                    }), ge ? withDirectives(createVNode(HackSlot, {
                        key: "__ant_upload_appendAction"
                    }, {
                        default: function () {
                            return $e
                        }
                    }), [[vShow, !!Pe]]) : null]
                }
            })
        }
    }
});
var _excluded$1 = ["class", "style"],
    LIST_IGNORE = "__LIST_IGNORE_".concat(Date.now(), "__");
const Upload$1 = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AUpload",
    inheritAttrs: !1,
    props: initDefaultProps$1(uploadProps(), {
        type: "select",
        multiple: !1,
        action: "",
        data: {},
        accept: "",
        showUploadList: !0,
        listType: "text",
        disabled: !1,
        supportServerRender: !0
    }),
    setup: function (C, H) {
        var W = H.slots,
            U = H.attrs,
            G = H.expose,
            X = useInjectFormItemContext(),
            Z = useMergedState(C.defaultFileList || [], {
                value: toRef(C, "fileList"),
                postState: function (ge) {
                    var xe = Date.now();
                    return (ge || []).map(function (Pe, $e) {
                        return !Pe.uid && !Object.isFrozen(Pe) && (Pe.uid = "__AUTO__".concat(
                            xe, "_").concat($e, "__")), Pe
                    })
                }
            }),
            Q = _slicedToArray$2(Z, 2),
            ee = Q[0],
            ne = Q[1],
            te = ref("drop"),
            re = ref();
        onMounted(function () {
            devWarning(C.fileList !== void 0 || U.value === void 0, "Upload",
                    "`value` is not a valid prop, do you mean `fileList`?"), devWarning(C.transformFile ===
                    void 0, "Upload",
                    "`transformFile` is deprecated. Please use `beforeUpload` directly."),
                devWarning(C.remove === void 0, "Upload",
                    "`remove` props is deprecated. Please use `remove` event.")
        });
        var ae = function (ge, xe, Pe) {
                var $e, ye, Ce = _toConsumableArray(xe);
                C.maxCount === 1 ? Ce = Ce.slice(-1) : C.maxCount && (Ce = Ce.slice(0, C.maxCount)), ne(Ce);
                var we = {
                    file: ge,
                    fileList: Ce
                };
                Pe && (we.event = Pe), ($e = C["onUpdate:fileList"]) === null || $e === void 0 || $e.call(C,
                    we.fileList), (ye = C.onChange) === null || ye === void 0 || ye.call(C, we), X.onFieldChange()
            },
            oe = function () {
                var be = _asyncToGenerator(regenerator.mark(function ge(xe, Pe) {
                    var $e, ye, Ce, we;
                    return regenerator.wrap(function (Ne) {
                        for (;;) switch (Ne.prev = Ne.next) {
                            case 0:
                                if ($e = C.beforeUpload, ye = C.transformFile, Ce =
                                    xe, !$e) {
                                    Ne.next = 13;
                                    break
                                }
                                return Ne.next = 5, $e(xe, Pe);
                            case 5:
                                if (we = Ne.sent, we !== !1) {
                                    Ne.next = 8;
                                    break
                                }
                                return Ne.abrupt("return", !1);
                            case 8:
                                if (delete xe[LIST_IGNORE], we !== LIST_IGNORE) {
                                    Ne.next = 12;
                                    break
                                }
                                return Object.defineProperty(xe, LIST_IGNORE, {
                                    value: !0,
                                    configurable: !0
                                }), Ne.abrupt("return", !1);
                            case 12:
                                _typeof$2(we) === "object" && we && (Ce = we);
                            case 13:
                                if (!ye) {
                                    Ne.next = 17;
                                    break
                                }
                                return Ne.next = 16, ye(Ce);
                            case 16:
                                Ce = Ne.sent;
                            case 17:
                                return Ne.abrupt("return", Ce);
                            case 18:
                            case "end":
                                return Ne.stop()
                        }
                    }, ge)
                }));
                return function (xe, Pe) {
                    return be.apply(this, arguments)
                }
            }(),
            ie = function (ge) {
                var xe = ge.filter(function (ye) {
                    return !ye.file[LIST_IGNORE]
                });
                if (xe.length) {
                    var Pe = xe.map(function (ye) {
                            return file2Obj(ye.file)
                        }),
                        $e = _toConsumableArray(ee.value);
                    Pe.forEach(function (ye) {
                        $e = updateFileList(ye, $e)
                    }), Pe.forEach(function (ye, Ce) {
                        var we = ye;
                        if (xe[Ce].parsedFile) ye.status = "uploading";
                        else {
                            var Oe = ye.originFileObj,
                                Ne;
                            try {
                                Ne = new File([Oe], Oe.name, {
                                    type: Oe.type
                                })
                            } catch {
                                Ne = new Blob([Oe], {
                                        type: Oe.type
                                    }), Ne.name = Oe.name, Ne.lastModifiedDate = new Date, Ne.lastModified =
                                    new Date().getTime()
                            }
                            Ne.uid = ye.uid, we = Ne
                        }
                        ae(we, $e)
                    })
                }
            },
            ue = function (ge, xe, Pe) {
                try {
                    typeof ge == "string" && (ge = JSON.parse(ge))
                } catch {}
                if (getFileItem(xe, ee.value)) {
                    var $e = file2Obj(xe);
                    $e.status = "done", $e.percent = 100, $e.response = ge, $e.xhr = Pe;
                    var ye = updateFileList($e, ee.value);
                    ae($e, ye)
                }
            },
            le = function (ge, xe) {
                if (getFileItem(xe, ee.value)) {
                    var Pe = file2Obj(xe);
                    Pe.status = "uploading", Pe.percent = ge.percent;
                    var $e = updateFileList(Pe, ee.value);
                    ae(Pe, $e, ge)
                }
            },
            se = function (ge, xe, Pe) {
                if (getFileItem(Pe, ee.value)) {
                    var $e = file2Obj(Pe);
                    $e.error = ge, $e.response = xe, $e.status = "error";
                    var ye = updateFileList($e, ee.value);
                    ae($e, ye)
                }
            },
            ce = function (ge) {
                var xe, Pe = C.onRemove || C.remove;
                Promise.resolve(typeof Pe == "function" ? Pe(ge) : Pe).then(function ($e) {
                    if ($e !== !1) {
                        var ye = removeFileItem(ge, ee.value);
                        if (ye) {
                            var Ce, we;
                            xe = _objectSpread2$1(_objectSpread2$1({}, ge), {}, {
                                    status: "removed"
                                }), (Ce = ee.value) === null || Ce === void 0 || Ce.forEach(
                                    function (Oe) {
                                        var Ne = xe.uid !== void 0 ? "uid" : "name";
                                        Oe[Ne] === xe[Ne] && !Object.isFrozen(Oe) && (Oe.status =
                                            "removed")
                                    }), (we = re.value) === null || we === void 0 || we.abort(xe),
                                ae(xe, ye)
                        }
                    }
                })
            },
            de = function (ge) {
                if (te.value = ge.type, ge.type === "drop") {
                    var xe;
                    (xe = C.onDrop) === null || xe === void 0 || xe.call(C, ge)
                }
            };
        G({
            onBatchStart: ie,
            onSuccess: ue,
            onProgress: le,
            onError: se,
            fileList: ee,
            upload: re
        });
        var ve = useConfigInject("upload", C),
            fe = ve.prefixCls,
            pe = ve.direction,
            me = useLocaleReceiver("Upload", defaultLocale.Upload, computed(function () {
                return C.locale
            })),
            he = _slicedToArray$2(me, 1),
            Se = he[0],
            _e = function (ge, xe) {
                var Pe = C.removeIcon,
                    $e = C.previewIcon,
                    ye = C.downloadIcon,
                    Ce = C.previewFile,
                    we = C.onPreview,
                    Oe = C.onDownload,
                    Ne = C.disabled,
                    Me = C.isImageUrl,
                    Ve = C.progress,
                    ke = C.itemRender,
                    Ee = C.iconRender,
                    Ae = C.showUploadList,
                    Re = typeof Ae == "boolean" ? {} : Ae,
                    He = Re.showDownloadIcon,
                    je = Re.showPreviewIcon,
                    Fe = Re.showRemoveIcon;
                return Ae ? createVNode(UploadList, {
                    listType: C.listType,
                    items: ee.value,
                    previewFile: Ce,
                    onPreview: we,
                    onDownload: Oe,
                    onRemove: ce,
                    showRemoveIcon: !Ne && Fe,
                    showPreviewIcon: je,
                    showDownloadIcon: He,
                    removeIcon: Pe,
                    previewIcon: $e,
                    downloadIcon: ye,
                    iconRender: Ee,
                    locale: Se.value,
                    isImageUrl: Me,
                    progress: Ve,
                    itemRender: ke,
                    appendActionVisible: xe,
                    appendAction: ge
                }, _objectSpread2$1({}, W)) : ge == null ? void 0 : ge()
            };
        return function () {
            var be, ge, xe, Pe = C.listType,
                $e = C.disabled,
                ye = C.type;
            U.class, U.style;
            var Ce = _objectWithoutProperties$2(U, _excluded$1),
                we = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                    onBatchStart: ie,
                    onError: se,
                    onProgress: le,
                    onSuccess: ue
                }, Ce), C), {}, {
                    id: (be = C.id) !== null && be !== void 0 ? be : X.id.value,
                    prefixCls: fe.value,
                    beforeUpload: oe,
                    onChange: void 0
                });
            if (delete we.remove, (!W.default || $e) && delete we.id, ye === "drag") {
                var Oe, Ne, Me = classNames(fe.value, (Oe = {}, _defineProperty$V(Oe, "".concat(fe.value,
                            "-drag"), !0), _defineProperty$V(Oe, "".concat(fe.value,
                            "-drag-uploading"), ee.value.some(function (Ae) {
                            return Ae.status === "uploading"
                        })), _defineProperty$V(Oe, "".concat(fe.value, "-drag-hover"), te.value ===
                            "dragover"), _defineProperty$V(Oe, "".concat(fe.value, "-disabled"), $e),
                        _defineProperty$V(Oe, "".concat(fe.value, "-rtl"), pe.value === "rtl"), Oe),
                    U.class);
                return createVNode("span", null, [createVNode("div", {
                    class: Me,
                    onDrop: de,
                    onDragover: de,
                    onDragleave: de,
                    style: U.style
                }, [createVNode(Upload$2, _objectSpread2$1(_objectSpread2$1({}, we), {}, {
                    ref: re,
                    class: "".concat(fe.value, "-btn")
                }), _objectSpread2$1({
                    default: function () {
                        return [createVNode("div", {
                            class: "".concat(fe,
                                "-drag-container")
                        }, [(Ne = W.default) === null || Ne ===
                            void 0 ? void 0 : Ne.call(W)])]
                    }
                }, W))]), _e()])
            }
            var Ve = classNames(fe.value, (ge = {}, _defineProperty$V(ge, "".concat(fe.value, "-select"),
                        !0), _defineProperty$V(ge, "".concat(fe.value, "-select-").concat(Pe), !0),
                    _defineProperty$V(ge, "".concat(fe.value, "-disabled"), $e), _defineProperty$V(
                        ge, "".concat(fe.value, "-rtl"), pe.value === "rtl"), ge)),
                ke = flattenChildren((xe = W.default) === null || xe === void 0 ? void 0 : xe.call(W)),
                Ee = function (Re) {
                    return createVNode("div", {
                        class: Ve,
                        style: Re
                    }, [createVNode(Upload$2, _objectSpread2$1(_objectSpread2$1({}, we), {}, {
                        ref: re
                    }), W)])
                };
            return Pe === "picture-card" ? createVNode("span", {
                class: classNames("".concat(fe.value, "-picture-card-wrapper"), U.class)
            }, [_e(Ee, !!(ke && ke.length))]) : createVNode("span", {
                class: U.class
            }, [Ee(ke && ke.length ? void 0 : {
                display: "none"
            }), _e()])
        }
    }
});
var _excluded = ["height"],
    _excluded2 = ["style"];
const Dragger = defineComponent({
    compatConfig: {
        MODE: 3
    },
    name: "AUploadDragger",
    inheritAttrs: !1,
    props: uploadProps(),
    setup: function (C, H) {
        var W = H.slots,
            U = H.attrs;
        return function () {
            var G = C.height,
                X = _objectWithoutProperties$2(C, _excluded),
                Z = U.style,
                Q = _objectWithoutProperties$2(U, _excluded2),
                ee = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, X), Q), {}, {
                    type: "drag",
                    style: _objectSpread2$1(_objectSpread2$1({}, Z), {}, {
                        height: typeof G == "number" ? "".concat(G, "px") : G
                    })
                });
            return createVNode(Upload$1, ee, W)
        }
    }
});
var UploadDragger = Dragger;
const Upload = _extends$1(Upload$1, {
        Dragger,
        LIST_IGNORE,
        install: function (C) {
            return C.component(Upload$1.name, Upload$1), C.component(Dragger.name, Dragger), C
        }
    }),
    components = Object.freeze(Object.defineProperty({
        __proto__: null,
        Affix: Affix$1,
        Alert: index$l,
        Anchor,
        AnchorLink,
        AutoComplete: index$m,
        AutoCompleteOptGroup,
        AutoCompleteOption,
        Avatar: Avatar$1,
        AvatarGroup: Group$4,
        BackTop: index$k,
        Badge,
        BadgeRibbon: Ribbon,
        Breadcrumb,
        BreadcrumbItem,
        BreadcrumbSeparator,
        Button: Button$1,
        ButtonGroup: ButtonGroup$1,
        Calendar: Calendar$1,
        Card: Card$1,
        CardGrid: Grid,
        CardMeta: Meta,
        Carousel: index$i,
        Cascader: index$h,
        CheckableTag: CheckableTag$1,
        Checkbox,
        CheckboxGroup,
        Col,
        Collapse,
        CollapsePanel,
        Comment: index$g,
        ConfigProvider: ConfigProvider$1,
        DatePicker: DatePicker$1,
        Descriptions: Descriptions$1,
        DescriptionsItem,
        DirectoryTree,
        Divider: index$f,
        Drawer: index$e,
        Dropdown: Dropdown$1,
        DropdownButton,
        Empty: Empty$1,
        Form: Form$1,
        FormItem,
        FormItemRest,
        Grid: index$j,
        Image: Image$2,
        ImagePreviewGroup: PreviewGroup,
        Input,
        InputGroup: Group$1,
        InputNumber: index$d,
        InputPassword: Password,
        InputSearch: Search$1,
        Layout: index$c,
        LayoutContent,
        LayoutFooter,
        LayoutHeader,
        LayoutSider,
        List: List$2,
        ListItem: Item,
        ListItemMeta: ItemMeta,
        LocaleProvider: LocaleProvider$1,
        Mentions: index$b,
        MentionsOption,
        Menu,
        MenuDivider: Divider$1,
        MenuItem: MenuItem$1,
        MenuItemGroup: ItemGroup,
        Modal,
        MonthPicker,
        PageHeader: index$a,
        Pagination,
        Popconfirm: index$9,
        Popover: Popover$1,
        Progress,
        QuarterPicker,
        Radio,
        RadioButton: Button,
        RadioGroup: Group$2,
        RangePicker,
        Rate: index$8,
        Result: Result$1,
        Row: Row$2,
        Select: VcSelect,
        SelectOptGroup,
        SelectOption,
        Skeleton: Skeleton$1,
        SkeletonAvatar: SkeletonAvatar$1,
        SkeletonButton: SkeletonButton$1,
        SkeletonImage: SkeletonImage$1,
        SkeletonInput: SkeletonInput$1,
        SkeletonTitle: SkeletonTitle$1,
        Slider: index$7,
        Space: index$6,
        Spin,
        Statistic,
        StatisticCountdown,
        Step,
        Steps: index$5,
        SubMenu: SubMenu$1,
        Switch: index$4,
        TabPane: TabPane$1,
        Table: index$3,
        TableColumn: Column,
        TableColumnGroup: ColumnGroup,
        TableSummary,
        TableSummaryCell,
        TableSummaryRow,
        Tabs,
        Tag: Tag$1,
        Textarea: TextArea,
        TimePicker: TimePicker$1,
        TimeRangePicker,
        Timeline,
        TimelineItem,
        Tooltip,
        Transfer: index$2,
        Tree,
        TreeNode: TreeNode$2,
        TreeSelect: index$1,
        TreeSelectNode,
        Typography: Typography$1,
        TypographyLink: Link$1,
        TypographyParagraph: Paragraph$1,
        TypographyText: Text$1,
        TypographyTitle: Title$1,
        Upload,
        UploadDragger,
        WeekPicker,
        message: message$1,
        notification
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    version = "3.2.17";
var install = function (C) {
    return Object.keys(components).forEach(function (H) {
            var W = components[H];
            W.install && C.use(W)
        }), C.config.globalProperties.$message = message$1, C.config.globalProperties.$notification = notification,
        C.config.globalProperties.$info = Modal.info, C.config.globalProperties.$success = Modal.success, C.config.globalProperties
        .$error = Modal.error, C.config.globalProperties.$warning = Modal.warning, C.config.globalProperties.$confirm =
        Modal.confirm, C.config.globalProperties.$destroyAll = Modal.destroyAll, C
};
const Antd = {
    version,
    install
};
/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var wasm = null;
try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0,
        1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0,
        11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95,
        117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116,
        95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1,
        173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167,
        36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,
        3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126,
        32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4,
        66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134,
        132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167,
        11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32,
        134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports
} catch {}

function Long(K, C, H) {
    this.low = K | 0, this.high = C | 0, this.unsigned = !!H
}
Long.prototype.__isLong__;
Object.defineProperty(Long.prototype, "__isLong__", {
    value: !0
});

function isLong(K) {
    return (K && K.__isLong__) === !0
}

function ctz32(K) {
    var C = Math.clz32(K & -K);
    return K ? 31 - C : C
}
Long.isLong = isLong;
var INT_CACHE = {},
    UINT_CACHE = {};

function fromInt(K, C) {
    var H, W, U;
    return C ? (K >>>= 0, (U = 0 <= K && K < 256) && (W = UINT_CACHE[K], W) ? W : (H = fromBits(K, 0, !0), U && (
        UINT_CACHE[K] = H), H)) : (K |= 0, (U = -128 <= K && K < 128) && (W = INT_CACHE[K], W) ? W : (H = fromBits(
        K, K < 0 ? -1 : 0, !1), U && (INT_CACHE[K] = H), H))
}
Long.fromInt = fromInt;

function fromNumber(K, C) {
    if (isNaN(K)) return C ? UZERO : ZERO;
    if (C) {
        if (K < 0) return UZERO;
        if (K >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE
    } else {
        if (K <= -TWO_PWR_63_DBL) return MIN_VALUE;
        if (K + 1 >= TWO_PWR_63_DBL) return MAX_VALUE
    }
    return K < 0 ? fromNumber(-K, C).neg() : fromBits(K % TWO_PWR_32_DBL | 0, K / TWO_PWR_32_DBL | 0, C)
}
Long.fromNumber = fromNumber;

function fromBits(K, C, H) {
    return new Long(K, C, H)
}
Long.fromBits = fromBits;
var pow_dbl = Math.pow;

function fromString(K, C, H) {
    if (K.length === 0) throw Error("empty string");
    if (typeof C == "number" ? (H = C, C = !1) : C = !!C, K === "NaN" || K === "Infinity" || K === "+Infinity" || K ===
        "-Infinity") return C ? UZERO : ZERO;
    if (H = H || 10, H < 2 || 36 < H) throw RangeError("radix");
    var W;
    if ((W = K.indexOf("-")) > 0) throw Error("interior hyphen");
    if (W === 0) return fromString(K.substring(1), C, H).neg();
    for (var U = fromNumber(pow_dbl(H, 8)), G = ZERO, X = 0; X < K.length; X += 8) {
        var Z = Math.min(8, K.length - X),
            Q = parseInt(K.substring(X, X + Z), H);
        if (Z < 8) {
            var ee = fromNumber(pow_dbl(H, Z));
            G = G.mul(ee).add(fromNumber(Q))
        } else G = G.mul(U), G = G.add(fromNumber(Q))
    }
    return G.unsigned = C, G
}
Long.fromString = fromString;

function fromValue(K, C) {
    return typeof K == "number" ? fromNumber(K, C) : typeof K == "string" ? fromString(K, C) : fromBits(K.low, K.high,
        typeof C == "boolean" ? C : K.unsigned)
}
Long.fromValue = fromValue;
var TWO_PWR_16_DBL = 1 << 16,
    TWO_PWR_24_DBL = 1 << 24,
    TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL,
    TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL,
    TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2,
    TWO_PWR_24 = fromInt(TWO_PWR_24_DBL),
    ZERO = fromInt(0);
Long.ZERO = ZERO;
var UZERO = fromInt(0, !0);
Long.UZERO = UZERO;
var ONE = fromInt(1);
Long.ONE = ONE;
var UONE = fromInt(1, !0);
Long.UONE = UONE;
var NEG_ONE = fromInt(-1);
Long.NEG_ONE = NEG_ONE;
var MAX_VALUE = fromBits(-1, 2147483647, !1);
Long.MAX_VALUE = MAX_VALUE;
var MAX_UNSIGNED_VALUE = fromBits(-1, -1, !0);
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
var MIN_VALUE = fromBits(0, -2147483648, !1);
Long.MIN_VALUE = MIN_VALUE;
var LongPrototype = Long.prototype;
LongPrototype.toInt = function () {
    return this.unsigned ? this.low >>> 0 : this.low
};
LongPrototype.toNumber = function () {
    return this.unsigned ? (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0) : this.high * TWO_PWR_32_DBL + (
        this.low >>> 0)
};
LongPrototype.toString = function (C) {
    if (C = C || 10, C < 2 || 36 < C) throw RangeError("radix");
    if (this.isZero()) return "0";
    if (this.isNegative())
        if (this.eq(MIN_VALUE)) {
            var H = fromNumber(C),
                W = this.div(H),
                U = W.mul(H).sub(this);
            return W.toString(C) + U.toInt().toString(C)
        } else return "-" + this.neg().toString(C);
    for (var G = fromNumber(pow_dbl(C, 6), this.unsigned), X = this, Z = "";;) {
        var Q = X.div(G),
            ee = X.sub(Q.mul(G)).toInt() >>> 0,
            ne = ee.toString(C);
        if (X = Q, X.isZero()) return ne + Z;
        for (; ne.length < 6;) ne = "0" + ne;
        Z = "" + ne + Z
    }
};
LongPrototype.getHighBits = function () {
    return this.high
};
LongPrototype.getHighBitsUnsigned = function () {
    return this.high >>> 0
};
LongPrototype.getLowBits = function () {
    return this.low
};
LongPrototype.getLowBitsUnsigned = function () {
    return this.low >>> 0
};
LongPrototype.getNumBitsAbs = function () {
    if (this.isNegative()) return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    for (var C = this.high != 0 ? this.high : this.low, H = 31; H > 0 && !(C & 1 << H); H--);
    return this.high != 0 ? H + 33 : H + 1
};
LongPrototype.isZero = function () {
    return this.high === 0 && this.low === 0
};
LongPrototype.eqz = LongPrototype.isZero;
LongPrototype.isNegative = function () {
    return !this.unsigned && this.high < 0
};
LongPrototype.isPositive = function () {
    return this.unsigned || this.high >= 0
};
LongPrototype.isOdd = function () {
    return (this.low & 1) === 1
};
LongPrototype.isEven = function () {
    return (this.low & 1) === 0
};
LongPrototype.equals = function (C) {
    return isLong(C) || (C = fromValue(C)), this.unsigned !== C.unsigned && this.high >>> 31 === 1 && C.high >>> 31 ===
        1 ? !1 : this.high === C.high && this.low === C.low
};
LongPrototype.eq = LongPrototype.equals;
LongPrototype.notEquals = function (C) {
    return !this.eq(C)
};
LongPrototype.neq = LongPrototype.notEquals;
LongPrototype.ne = LongPrototype.notEquals;
LongPrototype.lessThan = function (C) {
    return this.comp(C) < 0
};
LongPrototype.lt = LongPrototype.lessThan;
LongPrototype.lessThanOrEqual = function (C) {
    return this.comp(C) <= 0
};
LongPrototype.lte = LongPrototype.lessThanOrEqual;
LongPrototype.le = LongPrototype.lessThanOrEqual;
LongPrototype.greaterThan = function (C) {
    return this.comp(C) > 0
};
LongPrototype.gt = LongPrototype.greaterThan;
LongPrototype.greaterThanOrEqual = function (C) {
    return this.comp(C) >= 0
};
LongPrototype.gte = LongPrototype.greaterThanOrEqual;
LongPrototype.ge = LongPrototype.greaterThanOrEqual;
LongPrototype.compare = function (C) {
    if (isLong(C) || (C = fromValue(C)), this.eq(C)) return 0;
    var H = this.isNegative(),
        W = C.isNegative();
    return H && !W ? -1 : !H && W ? 1 : this.unsigned ? C.high >>> 0 > this.high >>> 0 || C.high === this.high && C
        .low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(C).isNegative() ? -1 : 1
};
LongPrototype.comp = LongPrototype.compare;
LongPrototype.negate = function () {
    return !this.unsigned && this.eq(MIN_VALUE) ? MIN_VALUE : this.not().add(ONE)
};
LongPrototype.neg = LongPrototype.negate;
LongPrototype.add = function (C) {
    isLong(C) || (C = fromValue(C));
    var H = this.high >>> 16,
        W = this.high & 65535,
        U = this.low >>> 16,
        G = this.low & 65535,
        X = C.high >>> 16,
        Z = C.high & 65535,
        Q = C.low >>> 16,
        ee = C.low & 65535,
        ne = 0,
        te = 0,
        re = 0,
        ae = 0;
    return ae += G + ee, re += ae >>> 16, ae &= 65535, re += U + Q, te += re >>> 16, re &= 65535, te += W + Z, ne +=
        te >>> 16, te &= 65535, ne += H + X, ne &= 65535, fromBits(re << 16 | ae, ne << 16 | te, this.unsigned)
};
LongPrototype.subtract = function (C) {
    return isLong(C) || (C = fromValue(C)), this.add(C.neg())
};
LongPrototype.sub = LongPrototype.subtract;
LongPrototype.multiply = function (C) {
    if (this.isZero()) return this;
    if (isLong(C) || (C = fromValue(C)), wasm) {
        var H = wasm.mul(this.low, this.high, C.low, C.high);
        return fromBits(H, wasm.get_high(), this.unsigned)
    }
    if (C.isZero()) return this.unsigned ? UZERO : ZERO;
    if (this.eq(MIN_VALUE)) return C.isOdd() ? MIN_VALUE : ZERO;
    if (C.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
    if (this.isNegative()) return C.isNegative() ? this.neg().mul(C.neg()) : this.neg().mul(C).neg();
    if (C.isNegative()) return this.mul(C.neg()).neg();
    if (this.lt(TWO_PWR_24) && C.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * C.toNumber(), this.unsigned);
    var W = this.high >>> 16,
        U = this.high & 65535,
        G = this.low >>> 16,
        X = this.low & 65535,
        Z = C.high >>> 16,
        Q = C.high & 65535,
        ee = C.low >>> 16,
        ne = C.low & 65535,
        te = 0,
        re = 0,
        ae = 0,
        oe = 0;
    return oe += X * ne, ae += oe >>> 16, oe &= 65535, ae += G * ne, re += ae >>> 16, ae &= 65535, ae += X * ee, re +=
        ae >>> 16, ae &= 65535, re += U * ne, te += re >>> 16, re &= 65535, re += G * ee, te += re >>> 16, re &=
        65535, re += X * Q, te += re >>> 16, re &= 65535, te += W * ne + U * ee + G * Q + X * Z, te &= 65535,
        fromBits(ae << 16 | oe, te << 16 | re, this.unsigned)
};
LongPrototype.mul = LongPrototype.multiply;
LongPrototype.divide = function (C) {
    if (isLong(C) || (C = fromValue(C)), C.isZero()) throw Error("division by zero");
    if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && C.low === -1 && C.high === -1) return this;
        var H = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, C.low, C.high);
        return fromBits(H, wasm.get_high(), this.unsigned)
    }
    if (this.isZero()) return this.unsigned ? UZERO : ZERO;
    var W, U, G;
    if (this.unsigned) {
        if (C.unsigned || (C = C.toUnsigned()), C.gt(this)) return UZERO;
        if (C.gt(this.shru(1))) return UONE;
        G = UZERO
    } else {
        if (this.eq(MIN_VALUE)) {
            if (C.eq(ONE) || C.eq(NEG_ONE)) return MIN_VALUE;
            if (C.eq(MIN_VALUE)) return ONE;
            var X = this.shr(1);
            return W = X.div(C).shl(1), W.eq(ZERO) ? C.isNegative() ? ONE : NEG_ONE : (U = this.sub(C.mul(W)), G =
                W.add(U.div(C)), G)
        } else if (C.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) return C.isNegative() ? this.neg().div(C.neg()) : this.neg().div(C).neg();
        if (C.isNegative()) return this.div(C.neg()).neg();
        G = ZERO
    }
    for (U = this; U.gte(C);) {
        W = Math.max(1, Math.floor(U.toNumber() / C.toNumber()));
        for (var Z = Math.ceil(Math.log(W) / Math.LN2), Q = Z <= 48 ? 1 : pow_dbl(2, Z - 48), ee = fromNumber(W),
                ne = ee.mul(C); ne.isNegative() || ne.gt(U);) W -= Q, ee = fromNumber(W, this.unsigned), ne = ee.mul(
            C);
        ee.isZero() && (ee = ONE), G = G.add(ee), U = U.sub(ne)
    }
    return G
};
LongPrototype.div = LongPrototype.divide;
LongPrototype.modulo = function (C) {
    if (isLong(C) || (C = fromValue(C)), wasm) {
        var H = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, C.low, C.high);
        return fromBits(H, wasm.get_high(), this.unsigned)
    }
    return this.sub(this.div(C).mul(C))
};
LongPrototype.mod = LongPrototype.modulo;
LongPrototype.rem = LongPrototype.modulo;
LongPrototype.not = function () {
    return fromBits(~this.low, ~this.high, this.unsigned)
};
LongPrototype.countLeadingZeros = function () {
    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32
};
LongPrototype.clz = LongPrototype.countLeadingZeros;
LongPrototype.countTrailingZeros = function () {
    return this.low ? ctz32(this.low) : ctz32(this.high) + 32
};
LongPrototype.ctz = LongPrototype.countTrailingZeros;
LongPrototype.and = function (C) {
    return isLong(C) || (C = fromValue(C)), fromBits(this.low & C.low, this.high & C.high, this.unsigned)
};
LongPrototype.or = function (C) {
    return isLong(C) || (C = fromValue(C)), fromBits(this.low | C.low, this.high | C.high, this.unsigned)
};
LongPrototype.xor = function (C) {
    return isLong(C) || (C = fromValue(C)), fromBits(this.low ^ C.low, this.high ^ C.high, this.unsigned)
};
LongPrototype.shiftLeft = function (C) {
    return isLong(C) && (C = C.toInt()), (C &= 63) === 0 ? this : C < 32 ? fromBits(this.low << C, this.high << C |
        this.low >>> 32 - C, this.unsigned) : fromBits(0, this.low << C - 32, this.unsigned)
};
LongPrototype.shl = LongPrototype.shiftLeft;
LongPrototype.shiftRight = function (C) {
    return isLong(C) && (C = C.toInt()), (C &= 63) === 0 ? this : C < 32 ? fromBits(this.low >>> C | this.high <<
        32 - C, this.high >> C, this.unsigned) : fromBits(this.high >> C - 32, this.high >= 0 ? 0 : -1, this.unsigned)
};
LongPrototype.shr = LongPrototype.shiftRight;
LongPrototype.shiftRightUnsigned = function (C) {
    return isLong(C) && (C = C.toInt()), (C &= 63) === 0 ? this : C < 32 ? fromBits(this.low >>> C | this.high <<
        32 - C, this.high >>> C, this.unsigned) : C === 32 ? fromBits(this.high, 0, this.unsigned) : fromBits(
        this.high >>> C - 32, 0, this.unsigned)
};
LongPrototype.shru = LongPrototype.shiftRightUnsigned;
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
LongPrototype.rotateLeft = function (C) {
    var H;
    return isLong(C) && (C = C.toInt()), (C &= 63) === 0 ? this : C === 32 ? fromBits(this.high, this.low, this.unsigned) :
        C < 32 ? (H = 32 - C, fromBits(this.low << C | this.high >>> H, this.high << C | this.low >>> H, this.unsigned)) :
        (C -= 32, H = 32 - C, fromBits(this.high << C | this.low >>> H, this.low << C | this.high >>> H, this.unsigned))
};
LongPrototype.rotl = LongPrototype.rotateLeft;
LongPrototype.rotateRight = function (C) {
    var H;
    return isLong(C) && (C = C.toInt()), (C &= 63) === 0 ? this : C === 32 ? fromBits(this.high, this.low, this.unsigned) :
        C < 32 ? (H = 32 - C, fromBits(this.high << H | this.low >>> C, this.low << H | this.high >>> C, this.unsigned)) :
        (C -= 32, H = 32 - C, fromBits(this.low << H | this.high >>> C, this.high << H | this.low >>> C, this.unsigned))
};
LongPrototype.rotr = LongPrototype.rotateRight;
LongPrototype.toSigned = function () {
    return this.unsigned ? fromBits(this.low, this.high, !1) : this
};
LongPrototype.toUnsigned = function () {
    return this.unsigned ? this : fromBits(this.low, this.high, !0)
};
LongPrototype.toBytes = function (C) {
    return C ? this.toBytesLE() : this.toBytesBE()
};
LongPrototype.toBytesLE = function () {
    var C = this.high,
        H = this.low;
    return [H & 255, H >>> 8 & 255, H >>> 16 & 255, H >>> 24, C & 255, C >>> 8 & 255, C >>> 16 & 255, C >>> 24]
};
LongPrototype.toBytesBE = function () {
    var C = this.high,
        H = this.low;
    return [C >>> 24, C >>> 16 & 255, C >>> 8 & 255, C & 255, H >>> 24, H >>> 16 & 255, H >>> 8 & 255, H & 255]
};
Long.fromBytes = function (C, H, W) {
    return W ? Long.fromBytesLE(C, H) : Long.fromBytesBE(C, H)
};
Long.fromBytesLE = function (C, H) {
    return new Long(C[0] | C[1] << 8 | C[2] << 16 | C[3] << 24, C[4] | C[5] << 8 | C[6] << 16 | C[7] << 24, H)
};
Long.fromBytesBE = function (C, H) {
    return new Long(C[4] << 24 | C[5] << 16 | C[6] << 8 | C[7], C[0] << 24 | C[1] << 16 | C[2] << 8 | C[3], H)
};
var QuestionCircleOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
            }
        }, {
            tag: "path",
            attrs: {
                d: "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z"
            }
        }]
    },
    name: "question-circle",
    theme: "outlined"
};
const QuestionCircleOutlinedSvg = QuestionCircleOutlined$2;

function _objectSpread(K) {
    for (var C = 1; C < arguments.length; C++) {
        var H = arguments[C] != null ? Object(arguments[C]) : {},
            W = Object.keys(H);
        typeof Object.getOwnPropertySymbols == "function" && (W = W.concat(Object.getOwnPropertySymbols(H).filter(
            function (U) {
                return Object.getOwnPropertyDescriptor(H, U).enumerable
            }))), W.forEach(function (U) {
            _defineProperty(K, U, H[U])
        })
    }
    return K
}

function _defineProperty(K, C, H) {
    return C in K ? Object.defineProperty(K, C, {
        value: H,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : K[C] = H, K
}
var QuestionCircleOutlined = function (C, H) {
    var W = _objectSpread({}, C, H.attrs);
    return createVNode(AntdIcon, _objectSpread({}, W, {
        icon: QuestionCircleOutlinedSvg
    }), null)
};
QuestionCircleOutlined.displayName = "QuestionCircleOutlined";
QuestionCircleOutlined.inheritAttrs = !1;
const QuestionCircleOutlined$1 = QuestionCircleOutlined;
let getRandomValues;
const rnds8 = new Uint8Array(16);

function rng() {
    if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(
            crypto), !getRandomValues)) throw new Error(
        "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"
    );
    return getRandomValues(rnds8)
}
const byteToHex = [];
for (let K = 0; K < 256; ++K) byteToHex.push((K + 256).toString(16).slice(1));

function unsafeStringify(K, C = 0) {
    return (byteToHex[K[C + 0]] + byteToHex[K[C + 1]] + byteToHex[K[C + 2]] + byteToHex[K[C + 3]] + "-" + byteToHex[K[C +
            4]] + byteToHex[K[C + 5]] + "-" + byteToHex[K[C + 6]] + byteToHex[K[C + 7]] + "-" + byteToHex[K[C + 8]] +
        byteToHex[K[C + 9]] + "-" + byteToHex[K[C + 10]] + byteToHex[K[C + 11]] + byteToHex[K[C + 12]] + byteToHex[
            K[C + 13]] + byteToHex[K[C + 14]] + byteToHex[K[C + 15]]).toLowerCase()
}
const randomUUID = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto),
    native = {
        randomUUID
    };

function v4(K, C, H) {
    if (native.randomUUID && !C && !K) return native.randomUUID();
    K = K || {};
    const W = K.random || (K.rng || rng)();
    if (W[6] = W[6] & 15 | 64, W[8] = W[8] & 63 | 128, C) {
        H = H || 0;
        for (let U = 0; U < 16; ++U) C[H + U] = W[U];
        return C
    }
    return unsafeStringify(W)
} //! moment.js
//! version : 2.29.4
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var hookCallback;

function hooks() {
    return hookCallback.apply(null, arguments)
}

function setHookCallback(K) {
    hookCallback = K
}

function isArray(K) {
    return K instanceof Array || Object.prototype.toString.call(K) === "[object Array]"
}

function isObject(K) {
    return K != null && Object.prototype.toString.call(K) === "[object Object]"
}

function hasOwnProp(K, C) {
    return Object.prototype.hasOwnProperty.call(K, C)
}

function isObjectEmpty(K) {
    if (Object.getOwnPropertyNames) return Object.getOwnPropertyNames(K).length === 0;
    var C;
    for (C in K)
        if (hasOwnProp(K, C)) return !1;
    return !0
}

function isUndefined(K) {
    return K === void 0
}

function isNumber(K) {
    return typeof K == "number" || Object.prototype.toString.call(K) === "[object Number]"
}

function isDate(K) {
    return K instanceof Date || Object.prototype.toString.call(K) === "[object Date]"
}

function map(K, C) {
    var H = [],
        W, U = K.length;
    for (W = 0; W < U; ++W) H.push(C(K[W], W));
    return H
}

function extend(K, C) {
    for (var H in C) hasOwnProp(C, H) && (K[H] = C[H]);
    return hasOwnProp(C, "toString") && (K.toString = C.toString), hasOwnProp(C, "valueOf") && (K.valueOf = C.valueOf),
        K
}

function createUTC(K, C, H, W) {
    return createLocalOrUTC(K, C, H, W, !0).utc()
}

function defaultParsingFlags() {
    return {
        empty: !1,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: !1,
        invalidEra: null,
        invalidMonth: null,
        invalidFormat: !1,
        userInvalidated: !1,
        iso: !1,
        parsedDateParts: [],
        era: null,
        meridiem: null,
        rfc2822: !1,
        weekdayMismatch: !1
    }
}

function getParsingFlags(K) {
    return K._pf == null && (K._pf = defaultParsingFlags()), K._pf
}
var some;
Array.prototype.some ? some = Array.prototype.some : some = function (K) {
    var C = Object(this),
        H = C.length >>> 0,
        W;
    for (W = 0; W < H; W++)
        if (W in C && K.call(this, C[W], W, C)) return !0;
    return !1
};

function isValid(K) {
    if (K._isValid == null) {
        var C = getParsingFlags(K),
            H = some.call(C.parsedDateParts, function (U) {
                return U != null
            }),
            W = !isNaN(K._d.getTime()) && C.overflow < 0 && !C.empty && !C.invalidEra && !C.invalidMonth && !C.invalidWeekday &&
            !C.weekdayMismatch && !C.nullInput && !C.invalidFormat && !C.userInvalidated && (!C.meridiem || C.meridiem &&
                H);
        if (K._strict && (W = W && C.charsLeftOver === 0 && C.unusedTokens.length === 0 && C.bigHour === void 0),
            Object.isFrozen == null || !Object.isFrozen(K)) K._isValid = W;
        else return W
    }
    return K._isValid
}

function createInvalid(K) {
    var C = createUTC(NaN);
    return K != null ? extend(getParsingFlags(C), K) : getParsingFlags(C).userInvalidated = !0, C
}
var momentProperties = hooks.momentProperties = [],
    updateInProgress = !1;

function copyConfig(K, C) {
    var H, W, U, G = momentProperties.length;
    if (isUndefined(C._isAMomentObject) || (K._isAMomentObject = C._isAMomentObject), isUndefined(C._i) || (K._i = C._i),
        isUndefined(C._f) || (K._f = C._f), isUndefined(C._l) || (K._l = C._l), isUndefined(C._strict) || (K._strict =
            C._strict), isUndefined(C._tzm) || (K._tzm = C._tzm), isUndefined(C._isUTC) || (K._isUTC = C._isUTC),
        isUndefined(C._offset) || (K._offset = C._offset), isUndefined(C._pf) || (K._pf = getParsingFlags(C)),
        isUndefined(C._locale) || (K._locale = C._locale), G > 0)
        for (H = 0; H < G; H++) W = momentProperties[H], U = C[W], isUndefined(U) || (K[W] = U);
    return K
}

function Moment(K) {
    copyConfig(this, K), this._d = new Date(K._d != null ? K._d.getTime() : NaN), this.isValid() || (this._d = new Date(
        NaN)), updateInProgress === !1 && (updateInProgress = !0, hooks.updateOffset(this), updateInProgress = !1)
}

function isMoment(K) {
    return K instanceof Moment || K != null && K._isAMomentObject != null
}

function warn(K) {
    hooks.suppressDeprecationWarnings === !1 && typeof console < "u" && console.warn && console.warn(
        "Deprecation warning: " + K)
}

function deprecate(K, C) {
    var H = !0;
    return extend(function () {
        if (hooks.deprecationHandler != null && hooks.deprecationHandler(null, K), H) {
            var W = [],
                U, G, X, Z = arguments.length;
            for (G = 0; G < Z; G++) {
                if (U = "", typeof arguments[G] == "object") {
                    U += `
[` + G + "] ";
                    for (X in arguments[0]) hasOwnProp(arguments[0], X) && (U += X + ": " + arguments[0][X] +
                        ", ");
                    U = U.slice(0, -2)
                } else U = arguments[G];
                W.push(U)
            }
            warn(K + `
Arguments: ` + Array.prototype.slice.call(W).join("") + `
` + new Error().stack), H = !1
        }
        return C.apply(this, arguments)
    }, C)
}
var deprecations = {};

function deprecateSimple(K, C) {
    hooks.deprecationHandler != null && hooks.deprecationHandler(K, C), deprecations[K] || (warn(C), deprecations[K] = !
        0)
}
hooks.suppressDeprecationWarnings = !1;
hooks.deprecationHandler = null;

function isFunction(K) {
    return typeof Function < "u" && K instanceof Function || Object.prototype.toString.call(K) === "[object Function]"
}

function set(K) {
    var C, H;
    for (H in K) hasOwnProp(K, H) && (C = K[H], isFunction(C) ? this[H] = C : this["_" + H] = C);
    this._config = K, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse
        .source) + "|" + /\d{1,2}/.source)
}

function mergeConfigs(K, C) {
    var H = extend({}, K),
        W;
    for (W in C) hasOwnProp(C, W) && (isObject(K[W]) && isObject(C[W]) ? (H[W] = {}, extend(H[W], K[W]), extend(H[W], C[
        W])) : C[W] != null ? H[W] = C[W] : delete H[W]);
    for (W in K) hasOwnProp(K, W) && !hasOwnProp(C, W) && isObject(K[W]) && (H[W] = extend({}, H[W]));
    return H
}

function Locale(K) {
    K != null && this.set(K)
}
var keys;
Object.keys ? keys = Object.keys : keys = function (K) {
    var C, H = [];
    for (C in K) hasOwnProp(K, C) && H.push(C);
    return H
};
var defaultCalendar = {
    sameDay: "[Today at] LT",
    nextDay: "[Tomorrow at] LT",
    nextWeek: "dddd [at] LT",
    lastDay: "[Yesterday at] LT",
    lastWeek: "[Last] dddd [at] LT",
    sameElse: "L"
};

function calendar(K, C, H) {
    var W = this._calendar[K] || this._calendar.sameElse;
    return isFunction(W) ? W.call(C, H) : W
}

function zeroFill(K, C, H) {
    var W = "" + Math.abs(K),
        U = C - W.length,
        G = K >= 0;
    return (G ? H ? "+" : "" : "-") + Math.pow(10, Math.max(0, U)).toString().substr(1) + W
}
var formattingTokens =
    /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
    localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
    formatFunctions = {},
    formatTokenFunctions = {};

function addFormatToken(K, C, H, W) {
    var U = W;
    typeof W == "string" && (U = function () {
        return this[W]()
    }), K && (formatTokenFunctions[K] = U), C && (formatTokenFunctions[C[0]] = function () {
        return zeroFill(U.apply(this, arguments), C[1], C[2])
    }), H && (formatTokenFunctions[H] = function () {
        return this.localeData().ordinal(U.apply(this, arguments), K)
    })
}

function removeFormattingTokens(K) {
    return K.match(/\[[\s\S]/) ? K.replace(/^\[|\]$/g, "") : K.replace(/\\/g, "")
}

function makeFormatFunction(K) {
    var C = K.match(formattingTokens),
        H, W;
    for (H = 0, W = C.length; H < W; H++) formatTokenFunctions[C[H]] ? C[H] = formatTokenFunctions[C[H]] : C[H] =
        removeFormattingTokens(C[H]);
    return function (U) {
        var G = "",
            X;
        for (X = 0; X < W; X++) G += isFunction(C[X]) ? C[X].call(U, K) : C[X];
        return G
    }
}

function formatMoment(K, C) {
    return K.isValid() ? (C = expandFormat(C, K.localeData()), formatFunctions[C] = formatFunctions[C] ||
        makeFormatFunction(C), formatFunctions[C](K)) : K.localeData().invalidDate()
}

function expandFormat(K, C) {
    var H = 5;

    function W(U) {
        return C.longDateFormat(U) || U
    }
    for (localFormattingTokens.lastIndex = 0; H >= 0 && localFormattingTokens.test(K);) K = K.replace(
        localFormattingTokens, W), localFormattingTokens.lastIndex = 0, H -= 1;
    return K
}
var defaultLongDateFormat = {
    LTS: "h:mm:ss A",
    LT: "h:mm A",
    L: "MM/DD/YYYY",
    LL: "MMMM D, YYYY",
    LLL: "MMMM D, YYYY h:mm A",
    LLLL: "dddd, MMMM D, YYYY h:mm A"
};

function longDateFormat(K) {
    var C = this._longDateFormat[K],
        H = this._longDateFormat[K.toUpperCase()];
    return C || !H ? C : (this._longDateFormat[K] = H.match(formattingTokens).map(function (W) {
        return W === "MMMM" || W === "MM" || W === "DD" || W === "dddd" ? W.slice(1) : W
    }).join(""), this._longDateFormat[K])
}
var defaultInvalidDate = "Invalid date";

function invalidDate() {
    return this._invalidDate
}
var defaultOrdinal = "%d",
    defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal(K) {
    return this._ordinal.replace("%d", K)
}
var defaultRelativeTime = {
    future: "in %s",
    past: "%s ago",
    s: "a few seconds",
    ss: "%d seconds",
    m: "a minute",
    mm: "%d minutes",
    h: "an hour",
    hh: "%d hours",
    d: "a day",
    dd: "%d days",
    w: "a week",
    ww: "%d weeks",
    M: "a month",
    MM: "%d months",
    y: "a year",
    yy: "%d years"
};

function relativeTime(K, C, H, W) {
    var U = this._relativeTime[H];
    return isFunction(U) ? U(K, C, H, W) : U.replace(/%d/i, K)
}

function pastFuture(K, C) {
    var H = this._relativeTime[K > 0 ? "future" : "past"];
    return isFunction(H) ? H(C) : H.replace(/%s/i, C)
}
var aliases = {};

function addUnitAlias(K, C) {
    var H = K.toLowerCase();
    aliases[H] = aliases[H + "s"] = aliases[C] = K
}

function normalizeUnits(K) {
    return typeof K == "string" ? aliases[K] || aliases[K.toLowerCase()] : void 0
}

function normalizeObjectUnits(K) {
    var C = {},
        H, W;
    for (W in K) hasOwnProp(K, W) && (H = normalizeUnits(W), H && (C[H] = K[W]));
    return C
}
var priorities = {};

function addUnitPriority(K, C) {
    priorities[K] = C
}

function getPrioritizedUnits(K) {
    var C = [],
        H;
    for (H in K) hasOwnProp(K, H) && C.push({
        unit: H,
        priority: priorities[H]
    });
    return C.sort(function (W, U) {
        return W.priority - U.priority
    }), C
}

function isLeapYear(K) {
    return K % 4 === 0 && K % 100 !== 0 || K % 400 === 0
}

function absFloor(K) {
    return K < 0 ? Math.ceil(K) || 0 : Math.floor(K)
}

function toInt(K) {
    var C = +K,
        H = 0;
    return C !== 0 && isFinite(C) && (H = absFloor(C)), H
}

function makeGetSet(K, C) {
    return function (H) {
        return H != null ? (set$1(this, K, H), hooks.updateOffset(this, C), this) : get(this, K)
    }
}

function get(K, C) {
    return K.isValid() ? K._d["get" + (K._isUTC ? "UTC" : "") + C]() : NaN
}

function set$1(K, C, H) {
    K.isValid() && !isNaN(H) && (C === "FullYear" && isLeapYear(K.year()) && K.month() === 1 && K.date() === 29 ? (H =
        toInt(H), K._d["set" + (K._isUTC ? "UTC" : "") + C](H, K.month(), daysInMonth(H, K.month()))) : K._d[
        "set" + (K._isUTC ? "UTC" : "") + C](H))
}

function stringGet(K) {
    return K = normalizeUnits(K), isFunction(this[K]) ? this[K]() : this
}

function stringSet(K, C) {
    if (typeof K == "object") {
        K = normalizeObjectUnits(K);
        var H = getPrioritizedUnits(K),
            W, U = H.length;
        for (W = 0; W < U; W++) this[H[W].unit](K[H[W].unit])
    } else if (K = normalizeUnits(K), isFunction(this[K])) return this[K](C);
    return this
}
var match1 = /\d/,
    match2 = /\d\d/,
    match3 = /\d{3}/,
    match4 = /\d{4}/,
    match6 = /[+-]?\d{6}/,
    match1to2 = /\d\d?/,
    match3to4 = /\d\d\d\d?/,
    match5to6 = /\d\d\d\d\d\d?/,
    match1to3 = /\d{1,3}/,
    match1to4 = /\d{1,4}/,
    match1to6 = /[+-]?\d{1,6}/,
    matchUnsigned = /\d+/,
    matchSigned = /[+-]?\d+/,
    matchOffset = /Z|[+-]\d\d:?\d\d/gi,
    matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi,
    matchTimestamp = /[+-]?\d+(\.\d{1,3})?/,
    matchWord =
    /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
    regexes;
regexes = {};

function addRegexToken(K, C, H) {
    regexes[K] = isFunction(C) ? C : function (W, U) {
        return W && H ? H : C
    }
}

function getParseRegexForToken(K, C) {
    return hasOwnProp(regexes, K) ? regexes[K](C._strict, C._locale) : new RegExp(unescapeFormat(K))
}

function unescapeFormat(K) {
    return regexEscape(K.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (C, H, W, U, G) {
        return H || W || U || G
    }))
}

function regexEscape(K) {
    return K.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
}
var tokens = {};

function addParseToken(K, C) {
    var H, W = C,
        U;
    for (typeof K == "string" && (K = [K]), isNumber(C) && (W = function (G, X) {
            X[C] = toInt(G)
        }), U = K.length, H = 0; H < U; H++) tokens[K[H]] = W
}

function addWeekParseToken(K, C) {
    addParseToken(K, function (H, W, U, G) {
        U._w = U._w || {}, C(H, U._w, U, G)
    })
}

function addTimeToArrayFromToken(K, C, H) {
    C != null && hasOwnProp(tokens, K) && tokens[K](C, H._a, H, K)
}
var YEAR = 0,
    MONTH = 1,
    DATE = 2,
    HOUR = 3,
    MINUTE = 4,
    SECOND = 5,
    MILLISECOND = 6,
    WEEK = 7,
    WEEKDAY = 8;

function mod(K, C) {
    return (K % C + C) % C
}
var indexOf;
Array.prototype.indexOf ? indexOf = Array.prototype.indexOf : indexOf = function (K) {
    var C;
    for (C = 0; C < this.length; ++C)
        if (this[C] === K) return C;
    return -1
};

function daysInMonth(K, C) {
    if (isNaN(K) || isNaN(C)) return NaN;
    var H = mod(C, 12);
    return K += (C - H) / 12, H === 1 ? isLeapYear(K) ? 29 : 28 : 31 - H % 7 % 2
}
addFormatToken("M", ["MM", 2], "Mo", function () {
    return this.month() + 1
});
addFormatToken("MMM", 0, 0, function (K) {
    return this.localeData().monthsShort(this, K)
});
addFormatToken("MMMM", 0, 0, function (K) {
    return this.localeData().months(this, K)
});
addUnitAlias("month", "M");
addUnitPriority("month", 8);
addRegexToken("M", match1to2);
addRegexToken("MM", match1to2, match2);
addRegexToken("MMM", function (K, C) {
    return C.monthsShortRegex(K)
});
addRegexToken("MMMM", function (K, C) {
    return C.monthsRegex(K)
});
addParseToken(["M", "MM"], function (K, C) {
    C[MONTH] = toInt(K) - 1
});
addParseToken(["MMM", "MMMM"], function (K, C, H, W) {
    var U = H._locale.monthsParse(K, W, H._strict);
    U != null ? C[MONTH] = U : getParsingFlags(H).invalidMonth = K
});
var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"),
    defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
    MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
    defaultMonthsShortRegex = matchWord,
    defaultMonthsRegex = matchWord;

function localeMonths(K, C) {
    return K ? isArray(this._months) ? this._months[K.month()] : this._months[(this._months.isFormat ||
            MONTHS_IN_FORMAT).test(C) ? "format" : "standalone"][K.month()] : isArray(this._months) ? this._months :
        this._months.standalone
}

function localeMonthsShort(K, C) {
    return K ? isArray(this._monthsShort) ? this._monthsShort[K.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(C) ?
        "format" : "standalone"][K.month()] : isArray(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone
}

function handleStrictParse(K, C, H) {
    var W, U, G, X = K.toLocaleLowerCase();
    if (!this._monthsParse)
        for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], W = 0; W < 12; ++W) G =
            createUTC([2e3, W]), this._shortMonthsParse[W] = this.monthsShort(G, "").toLocaleLowerCase(), this._longMonthsParse[
                W] = this.months(G, "").toLocaleLowerCase();
    return H ? C === "MMM" ? (U = indexOf.call(this._shortMonthsParse, X), U !== -1 ? U : null) : (U = indexOf.call(
        this._longMonthsParse, X), U !== -1 ? U : null) : C === "MMM" ? (U = indexOf.call(this._shortMonthsParse, X),
        U !== -1 ? U : (U = indexOf.call(this._longMonthsParse, X), U !== -1 ? U : null)) : (U = indexOf.call(this._longMonthsParse,
        X), U !== -1 ? U : (U = indexOf.call(this._shortMonthsParse, X), U !== -1 ? U : null))
}

function localeMonthsParse(K, C, H) {
    var W, U, G;
    if (this._monthsParseExact) return handleStrictParse.call(this, K, C, H);
    for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), W = 0; W <
        12; W++) {
        if (U = createUTC([2e3, W]), H && !this._longMonthsParse[W] && (this._longMonthsParse[W] = new RegExp("^" +
                this.months(U, "").replace(".", "") + "$", "i"), this._shortMonthsParse[W] = new RegExp("^" + this.monthsShort(
                U, "").replace(".", "") + "$", "i")), !H && !this._monthsParse[W] && (G = "^" + this.months(U, "") +
                "|^" + this.monthsShort(U, ""), this._monthsParse[W] = new RegExp(G.replace(".", ""), "i")), H && C ===
            "MMMM" && this._longMonthsParse[W].test(K)) return W;
        if (H && C === "MMM" && this._shortMonthsParse[W].test(K)) return W;
        if (!H && this._monthsParse[W].test(K)) return W
    }
}

function setMonth(K, C) {
    var H;
    if (!K.isValid()) return K;
    if (typeof C == "string") {
        if (/^\d+$/.test(C)) C = toInt(C);
        else if (C = K.localeData().monthsParse(C), !isNumber(C)) return K
    }
    return H = Math.min(K.date(), daysInMonth(K.year(), C)), K._d["set" + (K._isUTC ? "UTC" : "") + "Month"](C, H), K
}

function getSetMonth(K) {
    return K != null ? (setMonth(this, K), hooks.updateOffset(this, !0), this) : get(this, "Month")
}

function getDaysInMonth() {
    return daysInMonth(this.year(), this.month())
}

function monthsShortRegex(K) {
    return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this), K ? this._monthsShortStrictRegex :
        this._monthsShortRegex) : (hasOwnProp(this, "_monthsShortRegex") || (this._monthsShortRegex =
        defaultMonthsShortRegex), this._monthsShortStrictRegex && K ? this._monthsShortStrictRegex : this._monthsShortRegex)
}

function monthsRegex(K) {
    return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this), K ? this._monthsStrictRegex :
        this._monthsRegex) : (hasOwnProp(this, "_monthsRegex") || (this._monthsRegex = defaultMonthsRegex), this._monthsStrictRegex &&
        K ? this._monthsStrictRegex : this._monthsRegex)
}

function computeMonthsParse() {
    function K(X, Z) {
        return Z.length - X.length
    }
    var C = [],
        H = [],
        W = [],
        U, G;
    for (U = 0; U < 12; U++) G = createUTC([2e3, U]), C.push(this.monthsShort(G, "")), H.push(this.months(G, "")), W.push(
        this.months(G, "")), W.push(this.monthsShort(G, ""));
    for (C.sort(K), H.sort(K), W.sort(K), U = 0; U < 12; U++) C[U] = regexEscape(C[U]), H[U] = regexEscape(H[U]);
    for (U = 0; U < 24; U++) W[U] = regexEscape(W[U]);
    this._monthsRegex = new RegExp("^(" + W.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex =
        new RegExp("^(" + H.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + C.join("|") + ")",
            "i")
}
addFormatToken("Y", 0, 0, function () {
    var K = this.year();
    return K <= 9999 ? zeroFill(K, 4) : "+" + K
});
addFormatToken(0, ["YY", 2], 0, function () {
    return this.year() % 100
});
addFormatToken(0, ["YYYY", 4], 0, "year");
addFormatToken(0, ["YYYYY", 5], 0, "year");
addFormatToken(0, ["YYYYYY", 6, !0], 0, "year");
addUnitAlias("year", "y");
addUnitPriority("year", 1);
addRegexToken("Y", matchSigned);
addRegexToken("YY", match1to2, match2);
addRegexToken("YYYY", match1to4, match4);
addRegexToken("YYYYY", match1to6, match6);
addRegexToken("YYYYYY", match1to6, match6);
addParseToken(["YYYYY", "YYYYYY"], YEAR);
addParseToken("YYYY", function (K, C) {
    C[YEAR] = K.length === 2 ? hooks.parseTwoDigitYear(K) : toInt(K)
});
addParseToken("YY", function (K, C) {
    C[YEAR] = hooks.parseTwoDigitYear(K)
});
addParseToken("Y", function (K, C) {
    C[YEAR] = parseInt(K, 10)
});

function daysInYear(K) {
    return isLeapYear(K) ? 366 : 365
}
hooks.parseTwoDigitYear = function (K) {
    return toInt(K) + (toInt(K) > 68 ? 1900 : 2e3)
};
var getSetYear = makeGetSet("FullYear", !0);

function getIsLeapYear() {
    return isLeapYear(this.year())
}

function createDate(K, C, H, W, U, G, X) {
    var Z;
    return K < 100 && K >= 0 ? (Z = new Date(K + 400, C, H, W, U, G, X), isFinite(Z.getFullYear()) && Z.setFullYear(K)) :
        Z = new Date(K, C, H, W, U, G, X), Z
}

function createUTCDate(K) {
    var C, H;
    return K < 100 && K >= 0 ? (H = Array.prototype.slice.call(arguments), H[0] = K + 400, C = new Date(Date.UTC.apply(
        null, H)), isFinite(C.getUTCFullYear()) && C.setUTCFullYear(K)) : C = new Date(Date.UTC.apply(null,
        arguments)), C
}

function firstWeekOffset(K, C, H) {
    var W = 7 + C - H,
        U = (7 + createUTCDate(K, 0, W).getUTCDay() - C) % 7;
    return -U + W - 1
}

function dayOfYearFromWeeks(K, C, H, W, U) {
    var G = (7 + H - W) % 7,
        X = firstWeekOffset(K, W, U),
        Z = 1 + 7 * (C - 1) + G + X,
        Q, ee;
    return Z <= 0 ? (Q = K - 1, ee = daysInYear(Q) + Z) : Z > daysInYear(K) ? (Q = K + 1, ee = Z - daysInYear(K)) : (Q =
        K, ee = Z), {
        year: Q,
        dayOfYear: ee
    }
}

function weekOfYear(K, C, H) {
    var W = firstWeekOffset(K.year(), C, H),
        U = Math.floor((K.dayOfYear() - W - 1) / 7) + 1,
        G, X;
    return U < 1 ? (X = K.year() - 1, G = U + weeksInYear(X, C, H)) : U > weeksInYear(K.year(), C, H) ? (G = U -
        weeksInYear(K.year(), C, H), X = K.year() + 1) : (X = K.year(), G = U), {
        week: G,
        year: X
    }
}

function weeksInYear(K, C, H) {
    var W = firstWeekOffset(K, C, H),
        U = firstWeekOffset(K + 1, C, H);
    return (daysInYear(K) - W + U) / 7
}
addFormatToken("w", ["ww", 2], "wo", "week");
addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
addUnitAlias("week", "w");
addUnitAlias("isoWeek", "W");
addUnitPriority("week", 5);
addUnitPriority("isoWeek", 5);
addRegexToken("w", match1to2);
addRegexToken("ww", match1to2, match2);
addRegexToken("W", match1to2);
addRegexToken("WW", match1to2, match2);
addWeekParseToken(["w", "ww", "W", "WW"], function (K, C, H, W) {
    C[W.substr(0, 1)] = toInt(K)
});

function localeWeek(K) {
    return weekOfYear(K, this._week.dow, this._week.doy).week
}
var defaultLocaleWeek = {
    dow: 0,
    doy: 6
};

function localeFirstDayOfWeek() {
    return this._week.dow
}

function localeFirstDayOfYear() {
    return this._week.doy
}

function getSetWeek(K) {
    var C = this.localeData().week(this);
    return K == null ? C : this.add((K - C) * 7, "d")
}

function getSetISOWeek(K) {
    var C = weekOfYear(this, 1, 4).week;
    return K == null ? C : this.add((K - C) * 7, "d")
}
addFormatToken("d", 0, "do", "day");
addFormatToken("dd", 0, 0, function (K) {
    return this.localeData().weekdaysMin(this, K)
});
addFormatToken("ddd", 0, 0, function (K) {
    return this.localeData().weekdaysShort(this, K)
});
addFormatToken("dddd", 0, 0, function (K) {
    return this.localeData().weekdays(this, K)
});
addFormatToken("e", 0, 0, "weekday");
addFormatToken("E", 0, 0, "isoWeekday");
addUnitAlias("day", "d");
addUnitAlias("weekday", "e");
addUnitAlias("isoWeekday", "E");
addUnitPriority("day", 11);
addUnitPriority("weekday", 11);
addUnitPriority("isoWeekday", 11);
addRegexToken("d", match1to2);
addRegexToken("e", match1to2);
addRegexToken("E", match1to2);
addRegexToken("dd", function (K, C) {
    return C.weekdaysMinRegex(K)
});
addRegexToken("ddd", function (K, C) {
    return C.weekdaysShortRegex(K)
});
addRegexToken("dddd", function (K, C) {
    return C.weekdaysRegex(K)
});
addWeekParseToken(["dd", "ddd", "dddd"], function (K, C, H, W) {
    var U = H._locale.weekdaysParse(K, W, H._strict);
    U != null ? C.d = U : getParsingFlags(H).invalidWeekday = K
});
addWeekParseToken(["d", "e", "E"], function (K, C, H, W) {
    C[W] = toInt(K)
});

function parseWeekday(K, C) {
    return typeof K != "string" ? K : isNaN(K) ? (K = C.weekdaysParse(K), typeof K == "number" ? K : null) : parseInt(K,
        10)
}

function parseIsoWeekday(K, C) {
    return typeof K == "string" ? C.weekdaysParse(K) % 7 || 7 : isNaN(K) ? null : K
}

function shiftWeekdays(K, C) {
    return K.slice(C, 7).concat(K.slice(0, C))
}
var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
    defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
    defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
    defaultWeekdaysRegex = matchWord,
    defaultWeekdaysShortRegex = matchWord,
    defaultWeekdaysMinRegex = matchWord;

function localeWeekdays(K, C) {
    var H = isArray(this._weekdays) ? this._weekdays : this._weekdays[K && K !== !0 && this._weekdays.isFormat.test(C) ?
        "format" : "standalone"];
    return K === !0 ? shiftWeekdays(H, this._week.dow) : K ? H[K.day()] : H
}

function localeWeekdaysShort(K) {
    return K === !0 ? shiftWeekdays(this._weekdaysShort, this._week.dow) : K ? this._weekdaysShort[K.day()] : this._weekdaysShort
}

function localeWeekdaysMin(K) {
    return K === !0 ? shiftWeekdays(this._weekdaysMin, this._week.dow) : K ? this._weekdaysMin[K.day()] : this._weekdaysMin
}

function handleStrictParse$1(K, C, H) {
    var W, U, G, X = K.toLocaleLowerCase();
    if (!this._weekdaysParse)
        for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], W = 0; W < 7; ++W) G =
            createUTC([2e3, 1]).day(W), this._minWeekdaysParse[W] = this.weekdaysMin(G, "").toLocaleLowerCase(), this._shortWeekdaysParse[
                W] = this.weekdaysShort(G, "").toLocaleLowerCase(), this._weekdaysParse[W] = this.weekdays(G, "").toLocaleLowerCase();
    return H ? C === "dddd" ? (U = indexOf.call(this._weekdaysParse, X), U !== -1 ? U : null) : C === "ddd" ? (U =
        indexOf.call(this._shortWeekdaysParse, X), U !== -1 ? U : null) : (U = indexOf.call(this._minWeekdaysParse,
        X), U !== -1 ? U : null) : C === "dddd" ? (U = indexOf.call(this._weekdaysParse, X), U !== -1 || (U =
        indexOf.call(this._shortWeekdaysParse, X), U !== -1) ? U : (U = indexOf.call(this._minWeekdaysParse, X),
        U !== -1 ? U : null)) : C === "ddd" ? (U = indexOf.call(this._shortWeekdaysParse, X), U !== -1 || (U =
        indexOf.call(this._weekdaysParse, X), U !== -1) ? U : (U = indexOf.call(this._minWeekdaysParse, X), U !==
        -1 ? U : null)) : (U = indexOf.call(this._minWeekdaysParse, X), U !== -1 || (U = indexOf.call(this._weekdaysParse,
        X), U !== -1) ? U : (U = indexOf.call(this._shortWeekdaysParse, X), U !== -1 ? U : null))
}

function localeWeekdaysParse(K, C, H) {
    var W, U, G;
    if (this._weekdaysParseExact) return handleStrictParse$1.call(this, K, C, H);
    for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [],
            this._fullWeekdaysParse = []), W = 0; W < 7; W++) {
        if (U = createUTC([2e3, 1]).day(W), H && !this._fullWeekdaysParse[W] && (this._fullWeekdaysParse[W] = new RegExp(
                "^" + this.weekdays(U, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[W] = new RegExp(
                "^" + this.weekdaysShort(U, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[W] = new RegExp(
                "^" + this.weekdaysMin(U, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[W] || (G = "^" +
                this.weekdays(U, "") + "|^" + this.weekdaysShort(U, "") + "|^" + this.weekdaysMin(U, ""), this._weekdaysParse[
                    W] = new RegExp(G.replace(".", ""), "i")), H && C === "dddd" && this._fullWeekdaysParse[W].test(K))
            return W;
        if (H && C === "ddd" && this._shortWeekdaysParse[W].test(K)) return W;
        if (H && C === "dd" && this._minWeekdaysParse[W].test(K)) return W;
        if (!H && this._weekdaysParse[W].test(K)) return W
    }
}

function getSetDayOfWeek(K) {
    if (!this.isValid()) return K != null ? this : NaN;
    var C = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    return K != null ? (K = parseWeekday(K, this.localeData()), this.add(K - C, "d")) : C
}

function getSetLocaleDayOfWeek(K) {
    if (!this.isValid()) return K != null ? this : NaN;
    var C = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return K == null ? C : this.add(K - C, "d")
}

function getSetISODayOfWeek(K) {
    if (!this.isValid()) return K != null ? this : NaN;
    if (K != null) {
        var C = parseIsoWeekday(K, this.localeData());
        return this.day(this.day() % 7 ? C : C - 7)
    } else return this.day() || 7
}

function weekdaysRegex(K) {
    return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), K ? this._weekdaysStrictRegex :
        this._weekdaysRegex) : (hasOwnProp(this, "_weekdaysRegex") || (this._weekdaysRegex = defaultWeekdaysRegex),
        this._weekdaysStrictRegex && K ? this._weekdaysStrictRegex : this._weekdaysRegex)
}

function weekdaysShortRegex(K) {
    return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), K ? this._weekdaysShortStrictRegex :
        this._weekdaysShortRegex) : (hasOwnProp(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex =
            defaultWeekdaysShortRegex), this._weekdaysShortStrictRegex && K ? this._weekdaysShortStrictRegex : this
        ._weekdaysShortRegex)
}

function weekdaysMinRegex(K) {
    return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), K ? this._weekdaysMinStrictRegex :
        this._weekdaysMinRegex) : (hasOwnProp(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex =
        defaultWeekdaysMinRegex), this._weekdaysMinStrictRegex && K ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
}

function computeWeekdaysParse() {
    function K(ne, te) {
        return te.length - ne.length
    }
    var C = [],
        H = [],
        W = [],
        U = [],
        G, X, Z, Q, ee;
    for (G = 0; G < 7; G++) X = createUTC([2e3, 1]).day(G), Z = regexEscape(this.weekdaysMin(X, "")), Q = regexEscape(
        this.weekdaysShort(X, "")), ee = regexEscape(this.weekdays(X, "")), C.push(Z), H.push(Q), W.push(ee), U.push(
        Z), U.push(Q), U.push(ee);
    C.sort(K), H.sort(K), W.sort(K), U.sort(K), this._weekdaysRegex = new RegExp("^(" + U.join("|") + ")", "i"), this._weekdaysShortRegex =
        this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" +
            W.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + H.join("|") + ")", "i"), this._weekdaysMinStrictRegex =
        new RegExp("^(" + C.join("|") + ")", "i")
}

function hFormat() {
    return this.hours() % 12 || 12
}

function kFormat() {
    return this.hours() || 24
}
addFormatToken("H", ["HH", 2], 0, "hour");
addFormatToken("h", ["hh", 2], 0, hFormat);
addFormatToken("k", ["kk", 2], 0, kFormat);
addFormatToken("hmm", 0, 0, function () {
    return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2)
});
addFormatToken("hmmss", 0, 0, function () {
    return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2)
});
addFormatToken("Hmm", 0, 0, function () {
    return "" + this.hours() + zeroFill(this.minutes(), 2)
});
addFormatToken("Hmmss", 0, 0, function () {
    return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2)
});

function meridiem(K, C) {
    addFormatToken(K, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), C)
    })
}
meridiem("a", !0);
meridiem("A", !1);
addUnitAlias("hour", "h");
addUnitPriority("hour", 13);

function matchMeridiem(K, C) {
    return C._meridiemParse
}
addRegexToken("a", matchMeridiem);
addRegexToken("A", matchMeridiem);
addRegexToken("H", match1to2);
addRegexToken("h", match1to2);
addRegexToken("k", match1to2);
addRegexToken("HH", match1to2, match2);
addRegexToken("hh", match1to2, match2);
addRegexToken("kk", match1to2, match2);
addRegexToken("hmm", match3to4);
addRegexToken("hmmss", match5to6);
addRegexToken("Hmm", match3to4);
addRegexToken("Hmmss", match5to6);
addParseToken(["H", "HH"], HOUR);
addParseToken(["k", "kk"], function (K, C, H) {
    var W = toInt(K);
    C[HOUR] = W === 24 ? 0 : W
});
addParseToken(["a", "A"], function (K, C, H) {
    H._isPm = H._locale.isPM(K), H._meridiem = K
});
addParseToken(["h", "hh"], function (K, C, H) {
    C[HOUR] = toInt(K), getParsingFlags(H).bigHour = !0
});
addParseToken("hmm", function (K, C, H) {
    var W = K.length - 2;
    C[HOUR] = toInt(K.substr(0, W)), C[MINUTE] = toInt(K.substr(W)), getParsingFlags(H).bigHour = !0
});
addParseToken("hmmss", function (K, C, H) {
    var W = K.length - 4,
        U = K.length - 2;
    C[HOUR] = toInt(K.substr(0, W)), C[MINUTE] = toInt(K.substr(W, 2)), C[SECOND] = toInt(K.substr(U)),
        getParsingFlags(H).bigHour = !0
});
addParseToken("Hmm", function (K, C, H) {
    var W = K.length - 2;
    C[HOUR] = toInt(K.substr(0, W)), C[MINUTE] = toInt(K.substr(W))
});
addParseToken("Hmmss", function (K, C, H) {
    var W = K.length - 4,
        U = K.length - 2;
    C[HOUR] = toInt(K.substr(0, W)), C[MINUTE] = toInt(K.substr(W, 2)), C[SECOND] = toInt(K.substr(U))
});

function localeIsPM(K) {
    return (K + "").toLowerCase().charAt(0) === "p"
}
var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
    getSetHour = makeGetSet("Hours", !0);

function localeMeridiem(K, C, H) {
    return K > 11 ? H ? "pm" : "PM" : H ? "am" : "AM"
}
var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
    },
    locales = {},
    localeFamilies = {},
    globalLocale;

function commonPrefix(K, C) {
    var H, W = Math.min(K.length, C.length);
    for (H = 0; H < W; H += 1)
        if (K[H] !== C[H]) return H;
    return W
}

function normalizeLocale(K) {
    return K && K.toLowerCase().replace("_", "-")
}

function chooseLocale(K) {
    for (var C = 0, H, W, U, G; C < K.length;) {
        for (G = normalizeLocale(K[C]).split("-"), H = G.length, W = normalizeLocale(K[C + 1]), W = W ? W.split("-") :
            null; H > 0;) {
            if (U = loadLocale(G.slice(0, H).join("-")), U) return U;
            if (W && W.length >= H && commonPrefix(G, W) >= H - 1) break;
            H--
        }
        C++
    }
    return globalLocale
}

function isLocaleNameSane(K) {
    return K.match("^[^/\\\\]*$") != null
}

function loadLocale(K) {
    var C = null,
        H;
    if (locales[K] === void 0 && typeof module < "u" && module && module.exports && isLocaleNameSane(K)) try {
        C = globalLocale._abbr, H = require, H("./locale/" + K), getSetGlobalLocale(C)
    } catch {
        locales[K] = null
    }
    return locales[K]
}

function getSetGlobalLocale(K, C) {
    var H;
    return K && (isUndefined(C) ? H = getLocale(K) : H = defineLocale(K, C), H ? globalLocale = H : typeof console <
            "u" && console.warn && console.warn("Locale " + K + " not found. Did you forget to load it?")),
        globalLocale._abbr
}

function defineLocale(K, C) {
    if (C !== null) {
        var H, W = baseConfig;
        if (C.abbr = K, locales[K] != null) deprecateSimple("defineLocaleOverride",
            "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
        ), W = locales[K]._config;
        else if (C.parentLocale != null)
            if (locales[C.parentLocale] != null) W = locales[C.parentLocale]._config;
            else if (H = loadLocale(C.parentLocale), H != null) W = H._config;
        else return localeFamilies[C.parentLocale] || (localeFamilies[C.parentLocale] = []), localeFamilies[C.parentLocale]
            .push({
                name: K,
                config: C
            }), null;
        return locales[K] = new Locale(mergeConfigs(W, C)), localeFamilies[K] && localeFamilies[K].forEach(function (U) {
            defineLocale(U.name, U.config)
        }), getSetGlobalLocale(K), locales[K]
    } else return delete locales[K], null
}

function updateLocale(K, C) {
    if (C != null) {
        var H, W, U = baseConfig;
        locales[K] != null && locales[K].parentLocale != null ? locales[K].set(mergeConfigs(locales[K]._config, C)) : (
            W = loadLocale(K), W != null && (U = W._config), C = mergeConfigs(U, C), W == null && (C.abbr = K), H =
            new Locale(C), H.parentLocale = locales[K], locales[K] = H), getSetGlobalLocale(K)
    } else locales[K] != null && (locales[K].parentLocale != null ? (locales[K] = locales[K].parentLocale, K ===
        getSetGlobalLocale() && getSetGlobalLocale(K)) : locales[K] != null && delete locales[K]);
    return locales[K]
}

function getLocale(K) {
    var C;
    if (K && K._locale && K._locale._abbr && (K = K._locale._abbr), !K) return globalLocale;
    if (!isArray(K)) {
        if (C = loadLocale(K), C) return C;
        K = [K]
    }
    return chooseLocale(K)
}

function listLocales() {
    return keys(locales)
}

function checkOverflow(K) {
    var C, H = K._a;
    return H && getParsingFlags(K).overflow === -2 && (C = H[MONTH] < 0 || H[MONTH] > 11 ? MONTH : H[DATE] < 1 || H[
            DATE] > daysInMonth(H[YEAR], H[MONTH]) ? DATE : H[HOUR] < 0 || H[HOUR] > 24 || H[HOUR] === 24 && (H[
            MINUTE] !== 0 || H[SECOND] !== 0 || H[MILLISECOND] !== 0) ? HOUR : H[MINUTE] < 0 || H[MINUTE] > 59 ?
        MINUTE : H[SECOND] < 0 || H[SECOND] > 59 ? SECOND : H[MILLISECOND] < 0 || H[MILLISECOND] > 999 ?
        MILLISECOND : -1, getParsingFlags(K)._overflowDayOfYear && (C < YEAR || C > DATE) && (C = DATE),
        getParsingFlags(K)._overflowWeeks && C === -1 && (C = WEEK), getParsingFlags(K)._overflowWeekday && C ===
        -1 && (C = WEEKDAY), getParsingFlags(K).overflow = C), K
}
var extendedIsoRegex =
    /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
    basicIsoRegex =
    /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
    tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
    isoDates = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E",
        /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, !1], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/,
        !1], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW",
        /\d{4}W\d{2}/, !1], ["YYYYDDD", /\d{7}/], ["YYYYMM", /\d{6}/, !1], ["YYYY", /\d{4}/, !1]],
    isoTimes = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss",
        /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS",
        /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]],
    aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
    rfc2822 =
    /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
    obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

function configFromISO(K) {
    var C, H, W = K._i,
        U = extendedIsoRegex.exec(W) || basicIsoRegex.exec(W),
        G, X, Z, Q, ee = isoDates.length,
        ne = isoTimes.length;
    if (U) {
        for (getParsingFlags(K).iso = !0, C = 0, H = ee; C < H; C++)
            if (isoDates[C][1].exec(U[1])) {
                X = isoDates[C][0], G = isoDates[C][2] !== !1;
                break
            } if (X == null) {
            K._isValid = !1;
            return
        }
        if (U[3]) {
            for (C = 0, H = ne; C < H; C++)
                if (isoTimes[C][1].exec(U[3])) {
                    Z = (U[2] || " ") + isoTimes[C][0];
                    break
                } if (Z == null) {
                K._isValid = !1;
                return
            }
        }
        if (!G && Z != null) {
            K._isValid = !1;
            return
        }
        if (U[4])
            if (tzRegex.exec(U[4])) Q = "Z";
            else {
                K._isValid = !1;
                return
            } K._f = X + (Z || "") + (Q || ""), configFromStringAndFormat(K)
    } else K._isValid = !1
}

function extractFromRFC2822Strings(K, C, H, W, U, G) {
    var X = [untruncateYear(K), defaultLocaleMonthsShort.indexOf(C), parseInt(H, 10), parseInt(W, 10), parseInt(U, 10)];
    return G && X.push(parseInt(G, 10)), X
}

function untruncateYear(K) {
    var C = parseInt(K, 10);
    return C <= 49 ? 2e3 + C : C <= 999 ? 1900 + C : C
}

function preprocessRFC2822(K) {
    return K.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "")
}

function checkWeekday(K, C, H) {
    if (K) {
        var W = defaultLocaleWeekdaysShort.indexOf(K),
            U = new Date(C[0], C[1], C[2]).getDay();
        if (W !== U) return getParsingFlags(H).weekdayMismatch = !0, H._isValid = !1, !1
    }
    return !0
}

function calculateOffset(K, C, H) {
    if (K) return obsOffsets[K];
    if (C) return 0;
    var W = parseInt(H, 10),
        U = W % 100,
        G = (W - U) / 100;
    return G * 60 + U
}

function configFromRFC2822(K) {
    var C = rfc2822.exec(preprocessRFC2822(K._i)),
        H;
    if (C) {
        if (H = extractFromRFC2822Strings(C[4], C[3], C[2], C[5], C[6], C[7]), !checkWeekday(C[1], H, K)) return;
        K._a = H, K._tzm = calculateOffset(C[8], C[9], C[10]), K._d = createUTCDate.apply(null, K._a), K._d.setUTCMinutes(
            K._d.getUTCMinutes() - K._tzm), getParsingFlags(K).rfc2822 = !0
    } else K._isValid = !1
}

function configFromString(K) {
    var C = aspNetJsonRegex.exec(K._i);
    if (C !== null) {
        K._d = new Date(+C[1]);
        return
    }
    if (configFromISO(K), K._isValid === !1) delete K._isValid;
    else return;
    if (configFromRFC2822(K), K._isValid === !1) delete K._isValid;
    else return;
    K._strict ? K._isValid = !1 : hooks.createFromInputFallback(K)
}
hooks.createFromInputFallback = deprecate(
    "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
    function (K) {
        K._d = new Date(K._i + (K._useUTC ? " UTC" : ""))
    });

function defaults(K, C, H) {
    return K || C || H
}

function currentDateArray(K) {
    var C = new Date(hooks.now());
    return K._useUTC ? [C.getUTCFullYear(), C.getUTCMonth(), C.getUTCDate()] : [C.getFullYear(), C.getMonth(), C.getDate()]
}

function configFromArray(K) {
    var C, H, W = [],
        U, G, X;
    if (!K._d) {
        for (U = currentDateArray(K), K._w && K._a[DATE] == null && K._a[MONTH] == null && dayOfYearFromWeekInfo(K), K._dayOfYear !=
            null && (X = defaults(K._a[YEAR], U[YEAR]), (K._dayOfYear > daysInYear(X) || K._dayOfYear === 0) && (
                    getParsingFlags(K)._overflowDayOfYear = !0), H = createUTCDate(X, 0, K._dayOfYear), K._a[MONTH] = H
                .getUTCMonth(), K._a[DATE] = H.getUTCDate()), C = 0; C < 3 && K._a[C] == null; ++C) K._a[C] = W[C] = U[
            C];
        for (; C < 7; C++) K._a[C] = W[C] = K._a[C] == null ? C === 2 ? 1 : 0 : K._a[C];
        K._a[HOUR] === 24 && K._a[MINUTE] === 0 && K._a[SECOND] === 0 && K._a[MILLISECOND] === 0 && (K._nextDay = !0, K
                ._a[HOUR] = 0), K._d = (K._useUTC ? createUTCDate : createDate).apply(null, W), G = K._useUTC ? K._d.getUTCDay() :
            K._d.getDay(), K._tzm != null && K._d.setUTCMinutes(K._d.getUTCMinutes() - K._tzm), K._nextDay && (K._a[
                HOUR] = 24), K._w && typeof K._w.d < "u" && K._w.d !== G && (getParsingFlags(K).weekdayMismatch = !0)
    }
}

function dayOfYearFromWeekInfo(K) {
    var C, H, W, U, G, X, Z, Q, ee;
    C = K._w, C.GG != null || C.W != null || C.E != null ? (G = 1, X = 4, H = defaults(C.GG, K._a[YEAR], weekOfYear(
            createLocal(), 1, 4).year), W = defaults(C.W, 1), U = defaults(C.E, 1), (U < 1 || U > 7) && (Q = !0)) : (G =
            K._locale._week.dow, X = K._locale._week.doy, ee = weekOfYear(createLocal(), G, X), H = defaults(C.gg, K._a[
                YEAR], ee.year), W = defaults(C.w, ee.week), C.d != null ? (U = C.d, (U < 0 || U > 6) && (Q = !0)) : C.e !=
            null ? (U = C.e + G, (C.e < 0 || C.e > 6) && (Q = !0)) : U = G), W < 1 || W > weeksInYear(H, G, X) ?
        getParsingFlags(K)._overflowWeeks = !0 : Q != null ? getParsingFlags(K)._overflowWeekday = !0 : (Z =
            dayOfYearFromWeeks(H, W, U, G, X), K._a[YEAR] = Z.year, K._dayOfYear = Z.dayOfYear)
}
hooks.ISO_8601 = function () {};
hooks.RFC_2822 = function () {};

function configFromStringAndFormat(K) {
    if (K._f === hooks.ISO_8601) {
        configFromISO(K);
        return
    }
    if (K._f === hooks.RFC_2822) {
        configFromRFC2822(K);
        return
    }
    K._a = [], getParsingFlags(K).empty = !0;
    var C = "" + K._i,
        H, W, U, G, X, Z = C.length,
        Q = 0,
        ee, ne;
    for (U = expandFormat(K._f, K._locale).match(formattingTokens) || [], ne = U.length, H = 0; H < ne; H++) G = U[H],
        W = (C.match(getParseRegexForToken(G, K)) || [])[0], W && (X = C.substr(0, C.indexOf(W)), X.length > 0 &&
            getParsingFlags(K).unusedInput.push(X), C = C.slice(C.indexOf(W) + W.length), Q += W.length),
        formatTokenFunctions[G] ? (W ? getParsingFlags(K).empty = !1 : getParsingFlags(K).unusedTokens.push(G),
            addTimeToArrayFromToken(G, W, K)) : K._strict && !W && getParsingFlags(K).unusedTokens.push(G);
    getParsingFlags(K).charsLeftOver = Z - Q, C.length > 0 && getParsingFlags(K).unusedInput.push(C), K._a[HOUR] <= 12 &&
        getParsingFlags(K).bigHour === !0 && K._a[HOUR] > 0 && (getParsingFlags(K).bigHour = void 0), getParsingFlags(K)
        .parsedDateParts = K._a.slice(0), getParsingFlags(K).meridiem = K._meridiem, K._a[HOUR] = meridiemFixWrap(K._locale,
            K._a[HOUR], K._meridiem), ee = getParsingFlags(K).era, ee !== null && (K._a[YEAR] = K._locale.erasConvertYear(
            ee, K._a[YEAR])), configFromArray(K), checkOverflow(K)
}

function meridiemFixWrap(K, C, H) {
    var W;
    return H == null ? C : K.meridiemHour != null ? K.meridiemHour(C, H) : (K.isPM != null && (W = K.isPM(H), W && C <
        12 && (C += 12), !W && C === 12 && (C = 0)), C)
}

function configFromStringAndArray(K) {
    var C, H, W, U, G, X, Z = !1,
        Q = K._f.length;
    if (Q === 0) {
        getParsingFlags(K).invalidFormat = !0, K._d = new Date(NaN);
        return
    }
    for (U = 0; U < Q; U++) G = 0, X = !1, C = copyConfig({}, K), K._useUTC != null && (C._useUTC = K._useUTC), C._f =
        K._f[U], configFromStringAndFormat(C), isValid(C) && (X = !0), G += getParsingFlags(C).charsLeftOver, G +=
        getParsingFlags(C).unusedTokens.length * 10, getParsingFlags(C).score = G, Z ? G < W && (W = G, H = C) : (W ==
            null || G < W || X) && (W = G, H = C, X && (Z = !0));
    extend(K, H || C)
}

function configFromObject(K) {
    if (!K._d) {
        var C = normalizeObjectUnits(K._i),
            H = C.day === void 0 ? C.date : C.day;
        K._a = map([C.year, C.month, H, C.hour, C.minute, C.second, C.millisecond], function (W) {
            return W && parseInt(W, 10)
        }), configFromArray(K)
    }
}

function createFromConfig(K) {
    var C = new Moment(checkOverflow(prepareConfig(K)));
    return C._nextDay && (C.add(1, "d"), C._nextDay = void 0), C
}

function prepareConfig(K) {
    var C = K._i,
        H = K._f;
    return K._locale = K._locale || getLocale(K._l), C === null || H === void 0 && C === "" ? createInvalid({
        nullInput: !0
    }) : (typeof C == "string" && (K._i = C = K._locale.preparse(C)), isMoment(C) ? new Moment(checkOverflow(C)) :
        (isDate(C) ? K._d = C : isArray(H) ? configFromStringAndArray(K) : H ? configFromStringAndFormat(K) :
            configFromInput(K), isValid(K) || (K._d = null), K))
}

function configFromInput(K) {
    var C = K._i;
    isUndefined(C) ? K._d = new Date(hooks.now()) : isDate(C) ? K._d = new Date(C.valueOf()) : typeof C == "string" ?
        configFromString(K) : isArray(C) ? (K._a = map(C.slice(0), function (H) {
            return parseInt(H, 10)
        }), configFromArray(K)) : isObject(C) ? configFromObject(K) : isNumber(C) ? K._d = new Date(C) : hooks.createFromInputFallback(
            K)
}

function createLocalOrUTC(K, C, H, W, U) {
    var G = {};
    return (C === !0 || C === !1) && (W = C, C = void 0), (H === !0 || H === !1) && (W = H, H = void 0), (isObject(K) &&
            isObjectEmpty(K) || isArray(K) && K.length === 0) && (K = void 0), G._isAMomentObject = !0, G._useUTC = G._isUTC =
        U, G._l = H, G._i = K, G._f = C, G._strict = W, createFromConfig(G)
}

function createLocal(K, C, H, W) {
    return createLocalOrUTC(K, C, H, W, !1)
}
var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function () {
            var K = createLocal.apply(null, arguments);
            return this.isValid() && K.isValid() ? K < this ? this : K : createInvalid()
        }),
    prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function () {
            var K = createLocal.apply(null, arguments);
            return this.isValid() && K.isValid() ? K > this ? this : K : createInvalid()
        });

function pickBy(K, C) {
    var H, W;
    if (C.length === 1 && isArray(C[0]) && (C = C[0]), !C.length) return createLocal();
    for (H = C[0], W = 1; W < C.length; ++W)(!C[W].isValid() || C[W][K](H)) && (H = C[W]);
    return H
}

function min() {
    var K = [].slice.call(arguments, 0);
    return pickBy("isBefore", K)
}

function max() {
    var K = [].slice.call(arguments, 0);
    return pickBy("isAfter", K)
}
var now = function () {
        return Date.now ? Date.now() : +new Date
    },
    ordering = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];

function isDurationValid(K) {
    var C, H = !1,
        W, U = ordering.length;
    for (C in K)
        if (hasOwnProp(K, C) && !(indexOf.call(ordering, C) !== -1 && (K[C] == null || !isNaN(K[C])))) return !1;
    for (W = 0; W < U; ++W)
        if (K[ordering[W]]) {
            if (H) return !1;
            parseFloat(K[ordering[W]]) !== toInt(K[ordering[W]]) && (H = !0)
        } return !0
}

function isValid$1() {
    return this._isValid
}

function createInvalid$1() {
    return createDuration(NaN)
}

function Duration(K) {
    var C = normalizeObjectUnits(K),
        H = C.year || 0,
        W = C.quarter || 0,
        U = C.month || 0,
        G = C.week || C.isoWeek || 0,
        X = C.day || 0,
        Z = C.hour || 0,
        Q = C.minute || 0,
        ee = C.second || 0,
        ne = C.millisecond || 0;
    this._isValid = isDurationValid(C), this._milliseconds = +ne + ee * 1e3 + Q * 6e4 + Z * 1e3 * 60 * 60, this._days = +
        X + G * 7, this._months = +U + W * 3 + H * 12, this._data = {}, this._locale = getLocale(), this._bubble()
}

function isDuration(K) {
    return K instanceof Duration
}

function absRound(K) {
    return K < 0 ? Math.round(-1 * K) * -1 : Math.round(K)
}

function compareArrays(K, C, H) {
    var W = Math.min(K.length, C.length),
        U = Math.abs(K.length - C.length),
        G = 0,
        X;
    for (X = 0; X < W; X++)(H && K[X] !== C[X] || !H && toInt(K[X]) !== toInt(C[X])) && G++;
    return G + U
}

function offset(K, C) {
    addFormatToken(K, 0, 0, function () {
        var H = this.utcOffset(),
            W = "+";
        return H < 0 && (H = -H, W = "-"), W + zeroFill(~~(H / 60), 2) + C + zeroFill(~~H % 60, 2)
    })
}
offset("Z", ":");
offset("ZZ", "");
addRegexToken("Z", matchShortOffset);
addRegexToken("ZZ", matchShortOffset);
addParseToken(["Z", "ZZ"], function (K, C, H) {
    H._useUTC = !0, H._tzm = offsetFromString(matchShortOffset, K)
});
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(K, C) {
    var H = (C || "").match(K),
        W, U, G;
    return H === null ? null : (W = H[H.length - 1] || [], U = (W + "").match(chunkOffset) || ["-", 0, 0], G = +(U[1] *
        60) + toInt(U[2]), G === 0 ? 0 : U[0] === "+" ? G : -G)
}

function cloneWithOffset(K, C) {
    var H, W;
    return C._isUTC ? (H = C.clone(), W = (isMoment(K) || isDate(K) ? K.valueOf() : createLocal(K).valueOf()) - H.valueOf(),
        H._d.setTime(H._d.valueOf() + W), hooks.updateOffset(H, !1), H) : createLocal(K).local()
}

function getDateOffset(K) {
    return -Math.round(K._d.getTimezoneOffset())
}
hooks.updateOffset = function () {};

function getSetOffset(K, C, H) {
    var W = this._offset || 0,
        U;
    if (!this.isValid()) return K != null ? this : NaN;
    if (K != null) {
        if (typeof K == "string") {
            if (K = offsetFromString(matchShortOffset, K), K === null) return this
        } else Math.abs(K) < 16 && !H && (K = K * 60);
        return !this._isUTC && C && (U = getDateOffset(this)), this._offset = K, this._isUTC = !0, U != null && this.add(
            U, "m"), W !== K && (!C || this._changeInProgress ? addSubtract(this, createDuration(K - W, "m"), 1, !1) :
            this._changeInProgress || (this._changeInProgress = !0, hooks.updateOffset(this, !0), this._changeInProgress =
                null)), this
    } else return this._isUTC ? W : getDateOffset(this)
}

function getSetZone(K, C) {
    return K != null ? (typeof K != "string" && (K = -K), this.utcOffset(K, C), this) : -this.utcOffset()
}

function setOffsetToUTC(K) {
    return this.utcOffset(0, K)
}

function setOffsetToLocal(K) {
    return this._isUTC && (this.utcOffset(0, K), this._isUTC = !1, K && this.subtract(getDateOffset(this), "m")), this
}

function setOffsetToParsedOffset() {
    if (this._tzm != null) this.utcOffset(this._tzm, !1, !0);
    else if (typeof this._i == "string") {
        var K = offsetFromString(matchOffset, this._i);
        K != null ? this.utcOffset(K) : this.utcOffset(0, !0)
    }
    return this
}

function hasAlignedHourOffset(K) {
    return this.isValid() ? (K = K ? createLocal(K).utcOffset() : 0, (this.utcOffset() - K) % 60 === 0) : !1
}

function isDaylightSavingTime() {
    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
}

function isDaylightSavingTimeShifted() {
    if (!isUndefined(this._isDSTShifted)) return this._isDSTShifted;
    var K = {},
        C;
    return copyConfig(K, this), K = prepareConfig(K), K._a ? (C = K._isUTC ? createUTC(K._a) : createLocal(K._a), this._isDSTShifted =
        this.isValid() && compareArrays(K._a, C.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted
}

function isLocal() {
    return this.isValid() ? !this._isUTC : !1
}

function isUtcOffset() {
    return this.isValid() ? this._isUTC : !1
}

function isUtc() {
    return this.isValid() ? this._isUTC && this._offset === 0 : !1
}
var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
    isoRegex =
    /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

function createDuration(K, C) {
    var H = K,
        W = null,
        U, G, X;
    return isDuration(K) ? H = {
            ms: K._milliseconds,
            d: K._days,
            M: K._months
        } : isNumber(K) || !isNaN(+K) ? (H = {}, C ? H[C] = +K : H.milliseconds = +K) : (W = aspNetRegex.exec(K)) ? (U =
            W[1] === "-" ? -1 : 1, H = {
                y: 0,
                d: toInt(W[DATE]) * U,
                h: toInt(W[HOUR]) * U,
                m: toInt(W[MINUTE]) * U,
                s: toInt(W[SECOND]) * U,
                ms: toInt(absRound(W[MILLISECOND] * 1e3)) * U
            }) : (W = isoRegex.exec(K)) ? (U = W[1] === "-" ? -1 : 1, H = {
            y: parseIso(W[2], U),
            M: parseIso(W[3], U),
            w: parseIso(W[4], U),
            d: parseIso(W[5], U),
            h: parseIso(W[6], U),
            m: parseIso(W[7], U),
            s: parseIso(W[8], U)
        }) : H == null ? H = {} : typeof H == "object" && ("from" in H || "to" in H) && (X = momentsDifference(
            createLocal(H.from), createLocal(H.to)), H = {}, H.ms = X.milliseconds, H.M = X.months), G = new Duration(H),
        isDuration(K) && hasOwnProp(K, "_locale") && (G._locale = K._locale), isDuration(K) && hasOwnProp(K, "_isValid") &&
        (G._isValid = K._isValid), G
}
createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso(K, C) {
    var H = K && parseFloat(K.replace(",", "."));
    return (isNaN(H) ? 0 : H) * C
}

function positiveMomentsDifference(K, C) {
    var H = {};
    return H.months = C.month() - K.month() + (C.year() - K.year()) * 12, K.clone().add(H.months, "M").isAfter(C) && --
        H.months, H.milliseconds = +C - +K.clone().add(H.months, "M"), H
}

function momentsDifference(K, C) {
    var H;
    return K.isValid() && C.isValid() ? (C = cloneWithOffset(C, K), K.isBefore(C) ? H = positiveMomentsDifference(K, C) :
        (H = positiveMomentsDifference(C, K), H.milliseconds = -H.milliseconds, H.months = -H.months), H) : {
        milliseconds: 0,
        months: 0
    }
}

function createAdder(K, C) {
    return function (H, W) {
        var U, G;
        return W !== null && !isNaN(+W) && (deprecateSimple(C, "moment()." + C +
            "(period, number) is deprecated. Please use moment()." + C +
            "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
        ), G = H, H = W, W = G), U = createDuration(H, W), addSubtract(this, U, K), this
    }
}

function addSubtract(K, C, H, W) {
    var U = C._milliseconds,
        G = absRound(C._days),
        X = absRound(C._months);
    K.isValid() && (W = W || !0, X && setMonth(K, get(K, "Month") + X * H), G && set$1(K, "Date", get(K, "Date") + G *
        H), U && K._d.setTime(K._d.valueOf() + U * H), W && hooks.updateOffset(K, G || X))
}
var add = createAdder(1, "add"),
    subtract = createAdder(-1, "subtract");

function isString(K) {
    return typeof K == "string" || K instanceof String
}

function isMomentInput(K) {
    return isMoment(K) || isDate(K) || isString(K) || isNumber(K) || isNumberOrStringArray(K) || isMomentInputObject(K) ||
        K === null || K === void 0
}

function isMomentInputObject(K) {
    var C = isObject(K) && !isObjectEmpty(K),
        H = !1,
        W = ["years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour",
            "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms"],
        U, G, X = W.length;
    for (U = 0; U < X; U += 1) G = W[U], H = H || hasOwnProp(K, G);
    return C && H
}

function isNumberOrStringArray(K) {
    var C = isArray(K),
        H = !1;
    return C && (H = K.filter(function (W) {
        return !isNumber(W) && isString(K)
    }).length === 0), C && H
}

function isCalendarSpec(K) {
    var C = isObject(K) && !isObjectEmpty(K),
        H = !1,
        W = ["sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse"],
        U, G;
    for (U = 0; U < W.length; U += 1) G = W[U], H = H || hasOwnProp(K, G);
    return C && H
}

function getCalendarFormat(K, C) {
    var H = K.diff(C, "days", !0);
    return H < -6 ? "sameElse" : H < -1 ? "lastWeek" : H < 0 ? "lastDay" : H < 1 ? "sameDay" : H < 2 ? "nextDay" : H <
        7 ? "nextWeek" : "sameElse"
}

function calendar$1(K, C) {
    arguments.length === 1 && (arguments[0] ? isMomentInput(arguments[0]) ? (K = arguments[0], C = void 0) :
        isCalendarSpec(arguments[0]) && (C = arguments[0], K = void 0) : (K = void 0, C = void 0));
    var H = K || createLocal(),
        W = cloneWithOffset(H, this).startOf("day"),
        U = hooks.calendarFormat(this, W) || "sameElse",
        G = C && (isFunction(C[U]) ? C[U].call(this, H) : C[U]);
    return this.format(G || this.localeData().calendar(U, this, createLocal(H)))
}

function clone() {
    return new Moment(this)
}

function isAfter(K, C) {
    var H = isMoment(K) ? K : createLocal(K);
    return this.isValid() && H.isValid() ? (C = normalizeUnits(C) || "millisecond", C === "millisecond" ? this.valueOf() >
        H.valueOf() : H.valueOf() < this.clone().startOf(C).valueOf()) : !1
}

function isBefore(K, C) {
    var H = isMoment(K) ? K : createLocal(K);
    return this.isValid() && H.isValid() ? (C = normalizeUnits(C) || "millisecond", C === "millisecond" ? this.valueOf() <
        H.valueOf() : this.clone().endOf(C).valueOf() < H.valueOf()) : !1
}

function isBetween(K, C, H, W) {
    var U = isMoment(K) ? K : createLocal(K),
        G = isMoment(C) ? C : createLocal(C);
    return this.isValid() && U.isValid() && G.isValid() ? (W = W || "()", (W[0] === "(" ? this.isAfter(U, H) : !this.isBefore(
        U, H)) && (W[1] === ")" ? this.isBefore(G, H) : !this.isAfter(G, H))) : !1
}

function isSame(K, C) {
    var H = isMoment(K) ? K : createLocal(K),
        W;
    return this.isValid() && H.isValid() ? (C = normalizeUnits(C) || "millisecond", C === "millisecond" ? this.valueOf() ===
        H.valueOf() : (W = H.valueOf(), this.clone().startOf(C).valueOf() <= W && W <= this.clone().endOf(C).valueOf())
    ) : !1
}

function isSameOrAfter(K, C) {
    return this.isSame(K, C) || this.isAfter(K, C)
}

function isSameOrBefore(K, C) {
    return this.isSame(K, C) || this.isBefore(K, C)
}

function diff(K, C, H) {
    var W, U, G;
    if (!this.isValid()) return NaN;
    if (W = cloneWithOffset(K, this), !W.isValid()) return NaN;
    switch (U = (W.utcOffset() - this.utcOffset()) * 6e4, C = normalizeUnits(C), C) {
        case "year":
            G = monthDiff(this, W) / 12;
            break;
        case "month":
            G = monthDiff(this, W);
            break;
        case "quarter":
            G = monthDiff(this, W) / 3;
            break;
        case "second":
            G = (this - W) / 1e3;
            break;
        case "minute":
            G = (this - W) / 6e4;
            break;
        case "hour":
            G = (this - W) / 36e5;
            break;
        case "day":
            G = (this - W - U) / 864e5;
            break;
        case "week":
            G = (this - W - U) / 6048e5;
            break;
        default:
            G = this - W
    }
    return H ? G : absFloor(G)
}

function monthDiff(K, C) {
    if (K.date() < C.date()) return -monthDiff(C, K);
    var H = (C.year() - K.year()) * 12 + (C.month() - K.month()),
        W = K.clone().add(H, "months"),
        U, G;
    return C - W < 0 ? (U = K.clone().add(H - 1, "months"), G = (C - W) / (W - U)) : (U = K.clone().add(H + 1, "months"),
        G = (C - W) / (U - W)), -(H + G) || 0
}
hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";

function toString() {
    return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
}

function toISOString(K) {
    if (!this.isValid()) return null;
    var C = K !== !0,
        H = C ? this.clone().utc() : this;
    return H.year() < 0 || H.year() > 9999 ? formatMoment(H, C ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" :
            "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : isFunction(Date.prototype.toISOString) ? C ? this.toDate().toISOString() :
        new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(H, "Z")) :
        formatMoment(H, C ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ")
}

function inspect() {
    if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
    var K = "moment",
        C = "",
        H, W, U, G;
    return this.isLocal() || (K = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone", C = "Z"), H = "[" + K +
        '("]', W = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", U = "-MM-DD[T]HH:mm:ss.SSS", G = C +
        '[")]', this.format(H + W + U + G)
}

function format(K) {
    K || (K = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat);
    var C = formatMoment(this, K);
    return this.localeData().postformat(C)
}

function from(K, C) {
    return this.isValid() && (isMoment(K) && K.isValid() || createLocal(K).isValid()) ? createDuration({
        to: this,
        from: K
    }).locale(this.locale()).humanize(!C) : this.localeData().invalidDate()
}

function fromNow(K) {
    return this.from(createLocal(), K)
}

function to(K, C) {
    return this.isValid() && (isMoment(K) && K.isValid() || createLocal(K).isValid()) ? createDuration({
        from: this,
        to: K
    }).locale(this.locale()).humanize(!C) : this.localeData().invalidDate()
}

function toNow(K) {
    return this.to(createLocal(), K)
}

function locale(K) {
    var C;
    return K === void 0 ? this._locale._abbr : (C = getLocale(K), C != null && (this._locale = C), this)
}
var lang = deprecate(
    "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
    function (K) {
        return K === void 0 ? this.localeData() : this.locale(K)
    });

function localeData() {
    return this._locale
}
var MS_PER_SECOND = 1e3,
    MS_PER_MINUTE = 60 * MS_PER_SECOND,
    MS_PER_HOUR = 60 * MS_PER_MINUTE,
    MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

function mod$1(K, C) {
    return (K % C + C) % C
}

function localStartOfDate(K, C, H) {
    return K < 100 && K >= 0 ? new Date(K + 400, C, H) - MS_PER_400_YEARS : new Date(K, C, H).valueOf()
}

function utcStartOfDate(K, C, H) {
    return K < 100 && K >= 0 ? Date.UTC(K + 400, C, H) - MS_PER_400_YEARS : Date.UTC(K, C, H)
}

function startOf(K) {
    var C, H;
    if (K = normalizeUnits(K), K === void 0 || K === "millisecond" || !this.isValid()) return this;
    switch (H = this._isUTC ? utcStartOfDate : localStartOfDate, K) {
        case "year":
            C = H(this.year(), 0, 1);
            break;
        case "quarter":
            C = H(this.year(), this.month() - this.month() % 3, 1);
            break;
        case "month":
            C = H(this.year(), this.month(), 1);
            break;
        case "week":
            C = H(this.year(), this.month(), this.date() - this.weekday());
            break;
        case "isoWeek":
            C = H(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
            break;
        case "day":
        case "date":
            C = H(this.year(), this.month(), this.date());
            break;
        case "hour":
            C = this._d.valueOf(), C -= mod$1(C + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
            break;
        case "minute":
            C = this._d.valueOf(), C -= mod$1(C, MS_PER_MINUTE);
            break;
        case "second":
            C = this._d.valueOf(), C -= mod$1(C, MS_PER_SECOND);
            break
    }
    return this._d.setTime(C), hooks.updateOffset(this, !0), this
}

function endOf(K) {
    var C, H;
    if (K = normalizeUnits(K), K === void 0 || K === "millisecond" || !this.isValid()) return this;
    switch (H = this._isUTC ? utcStartOfDate : localStartOfDate, K) {
        case "year":
            C = H(this.year() + 1, 0, 1) - 1;
            break;
        case "quarter":
            C = H(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
            break;
        case "month":
            C = H(this.year(), this.month() + 1, 1) - 1;
            break;
        case "week":
            C = H(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
            break;
        case "isoWeek":
            C = H(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
            break;
        case "day":
        case "date":
            C = H(this.year(), this.month(), this.date() + 1) - 1;
            break;
        case "hour":
            C = this._d.valueOf(), C += MS_PER_HOUR - mod$1(C + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                MS_PER_HOUR) - 1;
            break;
        case "minute":
            C = this._d.valueOf(), C += MS_PER_MINUTE - mod$1(C, MS_PER_MINUTE) - 1;
            break;
        case "second":
            C = this._d.valueOf(), C += MS_PER_SECOND - mod$1(C, MS_PER_SECOND) - 1;
            break
    }
    return this._d.setTime(C), hooks.updateOffset(this, !0), this
}

function valueOf() {
    return this._d.valueOf() - (this._offset || 0) * 6e4
}

function unix() {
    return Math.floor(this.valueOf() / 1e3)
}

function toDate() {
    return new Date(this.valueOf())
}

function toArray() {
    var K = this;
    return [K.year(), K.month(), K.date(), K.hour(), K.minute(), K.second(), K.millisecond()]
}

function toObject() {
    var K = this;
    return {
        years: K.year(),
        months: K.month(),
        date: K.date(),
        hours: K.hours(),
        minutes: K.minutes(),
        seconds: K.seconds(),
        milliseconds: K.milliseconds()
    }
}

function toJSON() {
    return this.isValid() ? this.toISOString() : null
}

function isValid$2() {
    return isValid(this)
}

function parsingFlags() {
    return extend({}, getParsingFlags(this))
}

function invalidAt() {
    return getParsingFlags(this).overflow
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    }
}
addFormatToken("N", 0, 0, "eraAbbr");
addFormatToken("NN", 0, 0, "eraAbbr");
addFormatToken("NNN", 0, 0, "eraAbbr");
addFormatToken("NNNN", 0, 0, "eraName");
addFormatToken("NNNNN", 0, 0, "eraNarrow");
addFormatToken("y", ["y", 1], "yo", "eraYear");
addFormatToken("y", ["yy", 2], 0, "eraYear");
addFormatToken("y", ["yyy", 3], 0, "eraYear");
addFormatToken("y", ["yyyy", 4], 0, "eraYear");
addRegexToken("N", matchEraAbbr);
addRegexToken("NN", matchEraAbbr);
addRegexToken("NNN", matchEraAbbr);
addRegexToken("NNNN", matchEraName);
addRegexToken("NNNNN", matchEraNarrow);
addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function (K, C, H, W) {
    var U = H._locale.erasParse(K, W, H._strict);
    U ? getParsingFlags(H).era = U : getParsingFlags(H).invalidEra = K
});
addRegexToken("y", matchUnsigned);
addRegexToken("yy", matchUnsigned);
addRegexToken("yyy", matchUnsigned);
addRegexToken("yyyy", matchUnsigned);
addRegexToken("yo", matchEraYearOrdinal);
addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
addParseToken(["yo"], function (K, C, H, W) {
    var U;
    H._locale._eraYearOrdinalRegex && (U = K.match(H._locale._eraYearOrdinalRegex)), H._locale.eraYearOrdinalParse ?
        C[YEAR] = H._locale.eraYearOrdinalParse(K, U) : C[YEAR] = parseInt(K, 10)
});

function localeEras(K, C) {
    var H, W, U, G = this._eras || getLocale("en")._eras;
    for (H = 0, W = G.length; H < W; ++H) {
        switch (typeof G[H].since) {
            case "string":
                U = hooks(G[H].since).startOf("day"), G[H].since = U.valueOf();
                break
        }
        switch (typeof G[H].until) {
            case "undefined":
                G[H].until = 1 / 0;
                break;
            case "string":
                U = hooks(G[H].until).startOf("day").valueOf(), G[H].until = U.valueOf();
                break
        }
    }
    return G
}

function localeErasParse(K, C, H) {
    var W, U, G = this.eras(),
        X, Z, Q;
    for (K = K.toUpperCase(), W = 0, U = G.length; W < U; ++W)
        if (X = G[W].name.toUpperCase(), Z = G[W].abbr.toUpperCase(), Q = G[W].narrow.toUpperCase(), H) switch (C) {
            case "N":
            case "NN":
            case "NNN":
                if (Z === K) return G[W];
                break;
            case "NNNN":
                if (X === K) return G[W];
                break;
            case "NNNNN":
                if (Q === K) return G[W];
                break
        } else if ([X, Z, Q].indexOf(K) >= 0) return G[W]
}

function localeErasConvertYear(K, C) {
    var H = K.since <= K.until ? 1 : -1;
    return C === void 0 ? hooks(K.since).year() : hooks(K.since).year() + (C - K.offset) * H
}

function getEraName() {
    var K, C, H, W = this.localeData().eras();
    for (K = 0, C = W.length; K < C; ++K)
        if (H = this.clone().startOf("day").valueOf(), W[K].since <= H && H <= W[K].until || W[K].until <= H && H <= W[
                K].since) return W[K].name;
    return ""
}

function getEraNarrow() {
    var K, C, H, W = this.localeData().eras();
    for (K = 0, C = W.length; K < C; ++K)
        if (H = this.clone().startOf("day").valueOf(), W[K].since <= H && H <= W[K].until || W[K].until <= H && H <= W[
                K].since) return W[K].narrow;
    return ""
}

function getEraAbbr() {
    var K, C, H, W = this.localeData().eras();
    for (K = 0, C = W.length; K < C; ++K)
        if (H = this.clone().startOf("day").valueOf(), W[K].since <= H && H <= W[K].until || W[K].until <= H && H <= W[
                K].since) return W[K].abbr;
    return ""
}

function getEraYear() {
    var K, C, H, W, U = this.localeData().eras();
    for (K = 0, C = U.length; K < C; ++K)
        if (H = U[K].since <= U[K].until ? 1 : -1, W = this.clone().startOf("day").valueOf(), U[K].since <= W && W <= U[
                K].until || U[K].until <= W && W <= U[K].since) return (this.year() - hooks(U[K].since).year()) * H + U[
            K].offset;
    return this.year()
}

function erasNameRegex(K) {
    return hasOwnProp(this, "_erasNameRegex") || computeErasParse.call(this), K ? this._erasNameRegex : this._erasRegex
}

function erasAbbrRegex(K) {
    return hasOwnProp(this, "_erasAbbrRegex") || computeErasParse.call(this), K ? this._erasAbbrRegex : this._erasRegex
}

function erasNarrowRegex(K) {
    return hasOwnProp(this, "_erasNarrowRegex") || computeErasParse.call(this), K ? this._erasNarrowRegex : this._erasRegex
}

function matchEraAbbr(K, C) {
    return C.erasAbbrRegex(K)
}

function matchEraName(K, C) {
    return C.erasNameRegex(K)
}

function matchEraNarrow(K, C) {
    return C.erasNarrowRegex(K)
}

function matchEraYearOrdinal(K, C) {
    return C._eraYearOrdinalRegex || matchUnsigned
}

function computeErasParse() {
    var K = [],
        C = [],
        H = [],
        W = [],
        U, G, X = this.eras();
    for (U = 0, G = X.length; U < G; ++U) C.push(regexEscape(X[U].name)), K.push(regexEscape(X[U].abbr)), H.push(
        regexEscape(X[U].narrow)), W.push(regexEscape(X[U].name)), W.push(regexEscape(X[U].abbr)), W.push(
        regexEscape(X[U].narrow));
    this._erasRegex = new RegExp("^(" + W.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + C.join("|") +
        ")", "i"), this._erasAbbrRegex = new RegExp("^(" + K.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp(
        "^(" + H.join("|") + ")", "i")
}
addFormatToken(0, ["gg", 2], 0, function () {
    return this.weekYear() % 100
});
addFormatToken(0, ["GG", 2], 0, function () {
    return this.isoWeekYear() % 100
});

function addWeekYearFormatToken(K, C) {
    addFormatToken(0, [K, K.length], 0, C)
}
addWeekYearFormatToken("gggg", "weekYear");
addWeekYearFormatToken("ggggg", "weekYear");
addWeekYearFormatToken("GGGG", "isoWeekYear");
addWeekYearFormatToken("GGGGG", "isoWeekYear");
addUnitAlias("weekYear", "gg");
addUnitAlias("isoWeekYear", "GG");
addUnitPriority("weekYear", 1);
addUnitPriority("isoWeekYear", 1);
addRegexToken("G", matchSigned);
addRegexToken("g", matchSigned);
addRegexToken("GG", match1to2, match2);
addRegexToken("gg", match1to2, match2);
addRegexToken("GGGG", match1to4, match4);
addRegexToken("gggg", match1to4, match4);
addRegexToken("GGGGG", match1to6, match6);
addRegexToken("ggggg", match1to6, match6);
addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function (K, C, H, W) {
    C[W.substr(0, 2)] = toInt(K)
});
addWeekParseToken(["gg", "GG"], function (K, C, H, W) {
    C[W] = hooks.parseTwoDigitYear(K)
});

function getSetWeekYear(K) {
    return getSetWeekYearHelper.call(this, K, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()
        ._week.doy)
}

function getSetISOWeekYear(K) {
    return getSetWeekYearHelper.call(this, K, this.isoWeek(), this.isoWeekday(), 1, 4)
}

function getISOWeeksInYear() {
    return weeksInYear(this.year(), 1, 4)
}

function getISOWeeksInISOWeekYear() {
    return weeksInYear(this.isoWeekYear(), 1, 4)
}

function getWeeksInYear() {
    var K = this.localeData()._week;
    return weeksInYear(this.year(), K.dow, K.doy)
}

function getWeeksInWeekYear() {
    var K = this.localeData()._week;
    return weeksInYear(this.weekYear(), K.dow, K.doy)
}

function getSetWeekYearHelper(K, C, H, W, U) {
    var G;
    return K == null ? weekOfYear(this, W, U).year : (G = weeksInYear(K, W, U), C > G && (C = G), setWeekAll.call(this,
        K, C, H, W, U))
}

function setWeekAll(K, C, H, W, U) {
    var G = dayOfYearFromWeeks(K, C, H, W, U),
        X = createUTCDate(G.year, 0, G.dayOfYear);
    return this.year(X.getUTCFullYear()), this.month(X.getUTCMonth()), this.date(X.getUTCDate()), this
}
addFormatToken("Q", 0, "Qo", "quarter");
addUnitAlias("quarter", "Q");
addUnitPriority("quarter", 7);
addRegexToken("Q", match1);
addParseToken("Q", function (K, C) {
    C[MONTH] = (toInt(K) - 1) * 3
});

function getSetQuarter(K) {
    return K == null ? Math.ceil((this.month() + 1) / 3) : this.month((K - 1) * 3 + this.month() % 3)
}
addFormatToken("D", ["DD", 2], "Do", "date");
addUnitAlias("date", "D");
addUnitPriority("date", 9);
addRegexToken("D", match1to2);
addRegexToken("DD", match1to2, match2);
addRegexToken("Do", function (K, C) {
    return K ? C._dayOfMonthOrdinalParse || C._ordinalParse : C._dayOfMonthOrdinalParseLenient
});
addParseToken(["D", "DD"], DATE);
addParseToken("Do", function (K, C) {
    C[DATE] = toInt(K.match(match1to2)[0])
});
var getSetDayOfMonth = makeGetSet("Date", !0);
addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
addUnitAlias("dayOfYear", "DDD");
addUnitPriority("dayOfYear", 4);
addRegexToken("DDD", match1to3);
addRegexToken("DDDD", match3);
addParseToken(["DDD", "DDDD"], function (K, C, H) {
    H._dayOfYear = toInt(K)
});

function getSetDayOfYear(K) {
    var C = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
    return K == null ? C : this.add(K - C, "d")
}
addFormatToken("m", ["mm", 2], 0, "minute");
addUnitAlias("minute", "m");
addUnitPriority("minute", 14);
addRegexToken("m", match1to2);
addRegexToken("mm", match1to2, match2);
addParseToken(["m", "mm"], MINUTE);
var getSetMinute = makeGetSet("Minutes", !1);
addFormatToken("s", ["ss", 2], 0, "second");
addUnitAlias("second", "s");
addUnitPriority("second", 15);
addRegexToken("s", match1to2);
addRegexToken("ss", match1to2, match2);
addParseToken(["s", "ss"], SECOND);
var getSetSecond = makeGetSet("Seconds", !1);
addFormatToken("S", 0, 0, function () {
    return ~~(this.millisecond() / 100)
});
addFormatToken(0, ["SS", 2], 0, function () {
    return ~~(this.millisecond() / 10)
});
addFormatToken(0, ["SSS", 3], 0, "millisecond");
addFormatToken(0, ["SSSS", 4], 0, function () {
    return this.millisecond() * 10
});
addFormatToken(0, ["SSSSS", 5], 0, function () {
    return this.millisecond() * 100
});
addFormatToken(0, ["SSSSSS", 6], 0, function () {
    return this.millisecond() * 1e3
});
addFormatToken(0, ["SSSSSSS", 7], 0, function () {
    return this.millisecond() * 1e4
});
addFormatToken(0, ["SSSSSSSS", 8], 0, function () {
    return this.millisecond() * 1e5
});
addFormatToken(0, ["SSSSSSSSS", 9], 0, function () {
    return this.millisecond() * 1e6
});
addUnitAlias("millisecond", "ms");
addUnitPriority("millisecond", 16);
addRegexToken("S", match1to3, match1);
addRegexToken("SS", match1to3, match2);
addRegexToken("SSS", match1to3, match3);
var token, getSetMillisecond;
for (token = "SSSS"; token.length <= 9; token += "S") addRegexToken(token, matchUnsigned);

function parseMs(K, C) {
    C[MILLISECOND] = toInt(("0." + K) * 1e3)
}
for (token = "S"; token.length <= 9; token += "S") addParseToken(token, parseMs);
getSetMillisecond = makeGetSet("Milliseconds", !1);
addFormatToken("z", 0, 0, "zoneAbbr");
addFormatToken("zz", 0, 0, "zoneName");

function getZoneAbbr() {
    return this._isUTC ? "UTC" : ""
}

function getZoneName() {
    return this._isUTC ? "Coordinated Universal Time" : ""
}
var proto = Moment.prototype;
proto.add = add;
proto.calendar = calendar$1;
proto.clone = clone;
proto.diff = diff;
proto.endOf = endOf;
proto.format = format;
proto.from = from;
proto.fromNow = fromNow;
proto.to = to;
proto.toNow = toNow;
proto.get = stringGet;
proto.invalidAt = invalidAt;
proto.isAfter = isAfter;
proto.isBefore = isBefore;
proto.isBetween = isBetween;
proto.isSame = isSame;
proto.isSameOrAfter = isSameOrAfter;
proto.isSameOrBefore = isSameOrBefore;
proto.isValid = isValid$2;
proto.lang = lang;
proto.locale = locale;
proto.localeData = localeData;
proto.max = prototypeMax;
proto.min = prototypeMin;
proto.parsingFlags = parsingFlags;
proto.set = stringSet;
proto.startOf = startOf;
proto.subtract = subtract;
proto.toArray = toArray;
proto.toObject = toObject;
proto.toDate = toDate;
proto.toISOString = toISOString;
proto.inspect = inspect;
typeof Symbol < "u" && Symbol.for != null && (proto[Symbol.for("nodejs.util.inspect.custom")] = function () {
    return "Moment<" + this.format() + ">"
});
proto.toJSON = toJSON;
proto.toString = toString;
proto.unix = unix;
proto.valueOf = valueOf;
proto.creationData = creationData;
proto.eraName = getEraName;
proto.eraNarrow = getEraNarrow;
proto.eraAbbr = getEraAbbr;
proto.eraYear = getEraYear;
proto.year = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month = getSetMonth;
proto.daysInMonth = getDaysInMonth;
proto.week = proto.weeks = getSetWeek;
proto.isoWeek = proto.isoWeeks = getSetISOWeek;
proto.weeksInYear = getWeeksInYear;
proto.weeksInWeekYear = getWeeksInWeekYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
proto.date = getSetDayOfMonth;
proto.day = proto.days = getSetDayOfWeek;
proto.weekday = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset = getSetOffset;
proto.utc = setOffsetToUTC;
proto.local = setOffsetToLocal;
proto.parseZone = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST = isDaylightSavingTime;
proto.isLocal = isLocal;
proto.isUtcOffset = isUtcOffset;
proto.isUtc = isUtc;
proto.isUTC = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
proto.zone = deprecate(
    "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
    getSetZone);
proto.isDSTShifted = deprecate(
    "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
    isDaylightSavingTimeShifted);

function createUnix(K) {
    return createLocal(K * 1e3)
}

function createInZone() {
    return createLocal.apply(null, arguments).parseZone()
}

function preParsePostFormat(K) {
    return K
}
var proto$1 = Locale.prototype;
proto$1.calendar = calendar;
proto$1.longDateFormat = longDateFormat;
proto$1.invalidDate = invalidDate;
proto$1.ordinal = ordinal;
proto$1.preparse = preParsePostFormat;
proto$1.postformat = preParsePostFormat;
proto$1.relativeTime = relativeTime;
proto$1.pastFuture = pastFuture;
proto$1.set = set;
proto$1.eras = localeEras;
proto$1.erasParse = localeErasParse;
proto$1.erasConvertYear = localeErasConvertYear;
proto$1.erasAbbrRegex = erasAbbrRegex;
proto$1.erasNameRegex = erasNameRegex;
proto$1.erasNarrowRegex = erasNarrowRegex;
proto$1.months = localeMonths;
proto$1.monthsShort = localeMonthsShort;
proto$1.monthsParse = localeMonthsParse;
proto$1.monthsRegex = monthsRegex;
proto$1.monthsShortRegex = monthsShortRegex;
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;
proto$1.weekdays = localeWeekdays;
proto$1.weekdaysMin = localeWeekdaysMin;
proto$1.weekdaysShort = localeWeekdaysShort;
proto$1.weekdaysParse = localeWeekdaysParse;
proto$1.weekdaysRegex = weekdaysRegex;
proto$1.weekdaysShortRegex = weekdaysShortRegex;
proto$1.weekdaysMinRegex = weekdaysMinRegex;
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1(K, C, H, W) {
    var U = getLocale(),
        G = createUTC().set(W, C);
    return U[H](G, K)
}

function listMonthsImpl(K, C, H) {
    if (isNumber(K) && (C = K, K = void 0), K = K || "", C != null) return get$1(K, C, H, "month");
    var W, U = [];
    for (W = 0; W < 12; W++) U[W] = get$1(K, W, H, "month");
    return U
}

function listWeekdaysImpl(K, C, H, W) {
    typeof K == "boolean" ? (isNumber(C) && (H = C, C = void 0), C = C || "") : (C = K, H = C, K = !1, isNumber(C) && (
        H = C, C = void 0), C = C || "");
    var U = getLocale(),
        G = K ? U._week.dow : 0,
        X, Z = [];
    if (H != null) return get$1(C, (H + G) % 7, W, "day");
    for (X = 0; X < 7; X++) Z[X] = get$1(C, (X + G) % 7, W, "day");
    return Z
}

function listMonths(K, C) {
    return listMonthsImpl(K, C, "months")
}

function listMonthsShort(K, C) {
    return listMonthsImpl(K, C, "monthsShort")
}

function listWeekdays(K, C, H) {
    return listWeekdaysImpl(K, C, H, "weekdays")
}

function listWeekdaysShort(K, C, H) {
    return listWeekdaysImpl(K, C, H, "weekdaysShort")
}

function listWeekdaysMin(K, C, H) {
    return listWeekdaysImpl(K, C, H, "weekdaysMin")
}
getSetGlobalLocale("en", {
    eras: [{
        since: "0001-01-01",
        until: 1 / 0,
        offset: 1,
        name: "Anno Domini",
        narrow: "AD",
        abbr: "AD"
    }, {
        since: "0000-12-31",
        until: -1 / 0,
        offset: 1,
        name: "Before Christ",
        narrow: "BC",
        abbr: "BC"
    }],
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function (K) {
        var C = K % 10,
            H = toInt(K % 100 / 10) === 1 ? "th" : C === 1 ? "st" : C === 2 ? "nd" : C === 3 ? "rd" : "th";
        return K + H
    }
});
hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
var mathAbs = Math.abs;

function abs() {
    var K = this._data;
    return this._milliseconds = mathAbs(this._milliseconds), this._days = mathAbs(this._days), this._months = mathAbs(
            this._months), K.milliseconds = mathAbs(K.milliseconds), K.seconds = mathAbs(K.seconds), K.minutes =
        mathAbs(K.minutes), K.hours = mathAbs(K.hours), K.months = mathAbs(K.months), K.years = mathAbs(K.years), this
}

function addSubtract$1(K, C, H, W) {
    var U = createDuration(C, H);
    return K._milliseconds += W * U._milliseconds, K._days += W * U._days, K._months += W * U._months, K._bubble()
}

function add$1(K, C) {
    return addSubtract$1(this, K, C, 1)
}

function subtract$1(K, C) {
    return addSubtract$1(this, K, C, -1)
}

function absCeil(K) {
    return K < 0 ? Math.floor(K) : Math.ceil(K)
}

function bubble() {
    var K = this._milliseconds,
        C = this._days,
        H = this._months,
        W = this._data,
        U, G, X, Z, Q;
    return K >= 0 && C >= 0 && H >= 0 || K <= 0 && C <= 0 && H <= 0 || (K += absCeil(monthsToDays(H) + C) * 864e5, C =
            0, H = 0), W.milliseconds = K % 1e3, U = absFloor(K / 1e3), W.seconds = U % 60, G = absFloor(U / 60), W.minutes =
        G % 60, X = absFloor(G / 60), W.hours = X % 24, C += absFloor(X / 24), Q = absFloor(daysToMonths(C)), H += Q, C -=
        absCeil(monthsToDays(Q)), Z = absFloor(H / 12), H %= 12, W.days = C, W.months = H, W.years = Z, this
}

function daysToMonths(K) {
    return K * 4800 / 146097
}

function monthsToDays(K) {
    return K * 146097 / 4800
}

function as(K) {
    if (!this.isValid()) return NaN;
    var C, H, W = this._milliseconds;
    if (K = normalizeUnits(K), K === "month" || K === "quarter" || K === "year") switch (C = this._days + W / 864e5, H =
        this._months + daysToMonths(C), K) {
        case "month":
            return H;
        case "quarter":
            return H / 3;
        case "year":
            return H / 12
    } else switch (C = this._days + Math.round(monthsToDays(this._months)), K) {
        case "week":
            return C / 7 + W / 6048e5;
        case "day":
            return C + W / 864e5;
        case "hour":
            return C * 24 + W / 36e5;
        case "minute":
            return C * 1440 + W / 6e4;
        case "second":
            return C * 86400 + W / 1e3;
        case "millisecond":
            return Math.floor(C * 864e5) + W;
        default:
            throw new Error("Unknown unit " + K)
    }
}

function valueOf$1() {
    return this.isValid() ? this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months /
        12) * 31536e6 : NaN
}

function makeAs(K) {
    return function () {
        return this.as(K)
    }
}
var asMilliseconds = makeAs("ms"),
    asSeconds = makeAs("s"),
    asMinutes = makeAs("m"),
    asHours = makeAs("h"),
    asDays = makeAs("d"),
    asWeeks = makeAs("w"),
    asMonths = makeAs("M"),
    asQuarters = makeAs("Q"),
    asYears = makeAs("y");

function clone$1() {
    return createDuration(this)
}

function get$2(K) {
    return K = normalizeUnits(K), this.isValid() ? this[K + "s"]() : NaN
}

function makeGetter(K) {
    return function () {
        return this.isValid() ? this._data[K] : NaN
    }
}
var milliseconds = makeGetter("milliseconds"),
    seconds = makeGetter("seconds"),
    minutes = makeGetter("minutes"),
    hours = makeGetter("hours"),
    days = makeGetter("days"),
    months = makeGetter("months"),
    years = makeGetter("years");

function weeks() {
    return absFloor(this.days() / 7)
}
var round = Math.round,
    thresholds = {
        ss: 44,
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        w: null,
        M: 11
    };

function substituteTimeAgo(K, C, H, W, U) {
    return U.relativeTime(C || 1, !!H, K, W)
}

function relativeTime$1(K, C, H, W) {
    var U = createDuration(K).abs(),
        G = round(U.as("s")),
        X = round(U.as("m")),
        Z = round(U.as("h")),
        Q = round(U.as("d")),
        ee = round(U.as("M")),
        ne = round(U.as("w")),
        te = round(U.as("y")),
        re = G <= H.ss && ["s", G] || G < H.s && ["ss", G] || X <= 1 && ["m"] || X < H.m && ["mm", X] || Z <= 1 && ["h"] ||
        Z < H.h && ["hh", Z] || Q <= 1 && ["d"] || Q < H.d && ["dd", Q];
    return H.w != null && (re = re || ne <= 1 && ["w"] || ne < H.w && ["ww", ne]), re = re || ee <= 1 && ["M"] || ee <
        H.M && ["MM", ee] || te <= 1 && ["y"] || ["yy", te], re[2] = C, re[3] = +K > 0, re[4] = W, substituteTimeAgo.apply(
            null, re)
}

function getSetRelativeTimeRounding(K) {
    return K === void 0 ? round : typeof K == "function" ? (round = K, !0) : !1
}

function getSetRelativeTimeThreshold(K, C) {
    return thresholds[K] === void 0 ? !1 : C === void 0 ? thresholds[K] : (thresholds[K] = C, K === "s" && (thresholds.ss =
        C - 1), !0)
}

function humanize(K, C) {
    if (!this.isValid()) return this.localeData().invalidDate();
    var H = !1,
        W = thresholds,
        U, G;
    return typeof K == "object" && (C = K, K = !1), typeof K == "boolean" && (H = K), typeof C == "object" && (W =
            Object.assign({}, thresholds, C), C.s != null && C.ss == null && (W.ss = C.s - 1)), U = this.localeData(),
        G = relativeTime$1(this, !H, W, U), H && (G = U.pastFuture(+this, G)), U.postformat(G)
}
var abs$1 = Math.abs;

function sign(K) {
    return (K > 0) - (K < 0) || +K
}

function toISOString$1() {
    if (!this.isValid()) return this.localeData().invalidDate();
    var K = abs$1(this._milliseconds) / 1e3,
        C = abs$1(this._days),
        H = abs$1(this._months),
        W, U, G, X, Z = this.asSeconds(),
        Q, ee, ne, te;
    return Z ? (W = absFloor(K / 60), U = absFloor(W / 60), K %= 60, W %= 60, G = absFloor(H / 12), H %= 12, X = K ? K.toFixed(
            3).replace(/\.?0+$/, "") : "", Q = Z < 0 ? "-" : "", ee = sign(this._months) !== sign(Z) ? "-" : "", ne =
        sign(this._days) !== sign(Z) ? "-" : "", te = sign(this._milliseconds) !== sign(Z) ? "-" : "", Q + "P" + (G ?
            ee + G + "Y" : "") + (H ? ee + H + "M" : "") + (C ? ne + C + "D" : "") + (U || W || K ? "T" : "") + (U ?
            te + U + "H" : "") + (W ? te + W + "M" : "") + (K ? te + X + "S" : "")) : "P0D"
}
var proto$2 = Duration.prototype;
proto$2.isValid = isValid$1;
proto$2.abs = abs;
proto$2.add = add$1;
proto$2.subtract = subtract$1;
proto$2.as = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds = asSeconds;
proto$2.asMinutes = asMinutes;
proto$2.asHours = asHours;
proto$2.asDays = asDays;
proto$2.asWeeks = asWeeks;
proto$2.asMonths = asMonths;
proto$2.asQuarters = asQuarters;
proto$2.asYears = asYears;
proto$2.valueOf = valueOf$1;
proto$2._bubble = bubble;
proto$2.clone = clone$1;
proto$2.get = get$2;
proto$2.milliseconds = milliseconds;
proto$2.seconds = seconds;
proto$2.minutes = minutes;
proto$2.hours = hours;
proto$2.days = days;
proto$2.weeks = weeks;
proto$2.months = months;
proto$2.years = years;
proto$2.humanize = humanize;
proto$2.toISOString = toISOString$1;
proto$2.toString = toISOString$1;
proto$2.toJSON = toISOString$1;
proto$2.locale = locale;
proto$2.localeData = localeData;
proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
    toISOString$1);
proto$2.lang = lang;
addFormatToken("X", 0, 0, "unix");
addFormatToken("x", 0, 0, "valueOf");
addRegexToken("x", matchSigned);
addRegexToken("X", matchTimestamp);
addParseToken("X", function (K, C, H) {
    H._d = new Date(parseFloat(K) * 1e3)
});
addParseToken("x", function (K, C, H) {
    H._d = new Date(toInt(K))
}); //! moment.js
hooks.version = "2.29.4";
setHookCallback(createLocal);
hooks.fn = proto;
hooks.min = min;
hooks.max = max;
hooks.now = now;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = proto;
hooks.HTML5_FMT = {
    DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
    DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
    DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
    DATE: "YYYY-MM-DD",
    TIME: "HH:mm",
    TIME_SECONDS: "HH:mm:ss",
    TIME_MS: "HH:mm:ss.SSS",
    WEEK: "GGGG-[W]WW",
    MONTH: "YYYY-MM"
};
var minimalExports = {},
    minimal$1 = {
        get exports() {
            return minimalExports
        },
        set exports(K) {
            minimalExports = K
        }
    },
    indexMinimal = {},
    minimal = {},
    aspromise = asPromise$1;

function asPromise$1(K, C) {
    for (var H = new Array(arguments.length - 1), W = 0, U = 2, G = !0; U < arguments.length;) H[W++] = arguments[U++];
    return new Promise(function (Z, Q) {
        H[W] = function (ne) {
            if (G)
                if (G = !1, ne) Q(ne);
                else {
                    for (var te = new Array(arguments.length - 1), re = 0; re < te.length;) te[re++] =
                        arguments[re];
                    Z.apply(null, te)
                }
        };
        try {
            K.apply(C || null, H)
        } catch (ee) {
            G && (G = !1, Q(ee))
        }
    })
}
var base64$1 = {};
(function (K) {
    var C = K;
    C.length = function (Z) {
        var Q = Z.length;
        if (!Q) return 0;
        for (var ee = 0; --Q % 4 > 1 && Z.charAt(Q) === "=";) ++ee;
        return Math.ceil(Z.length * 3) / 4 - ee
    };
    for (var H = new Array(64), W = new Array(123), U = 0; U < 64;) W[H[U] = U < 26 ? U + 65 : U < 52 ? U + 71 : U <
        62 ? U - 4 : U - 59 | 43] = U++;
    C.encode = function (Z, Q, ee) {
        for (var ne = null, te = [], re = 0, ae = 0, oe; Q < ee;) {
            var ie = Z[Q++];
            switch (ae) {
                case 0:
                    te[re++] = H[ie >> 2], oe = (ie & 3) << 4, ae = 1;
                    break;
                case 1:
                    te[re++] = H[oe | ie >> 4], oe = (ie & 15) << 2, ae = 2;
                    break;
                case 2:
                    te[re++] = H[oe | ie >> 6], te[re++] = H[ie & 63], ae = 0;
                    break
            }
            re > 8191 && ((ne || (ne = [])).push(String.fromCharCode.apply(String, te)), re = 0)
        }
        return ae && (te[re++] = H[oe], te[re++] = 61, ae === 1 && (te[re++] = 61)), ne ? (re && ne.push(String
            .fromCharCode.apply(String, te.slice(0, re))), ne.join("")) : String.fromCharCode.apply(String,
            te.slice(0, re))
    };
    var G = "invalid encoding";
    C.decode = function (Z, Q, ee) {
        for (var ne = ee, te = 0, re, ae = 0; ae < Z.length;) {
            var oe = Z.charCodeAt(ae++);
            if (oe === 61 && te > 1) break;
            if ((oe = W[oe]) === void 0) throw Error(G);
            switch (te) {
                case 0:
                    re = oe, te = 1;
                    break;
                case 1:
                    Q[ee++] = re << 2 | (oe & 48) >> 4, re = oe, te = 2;
                    break;
                case 2:
                    Q[ee++] = (re & 15) << 4 | (oe & 60) >> 2, re = oe, te = 3;
                    break;
                case 3:
                    Q[ee++] = (re & 3) << 6 | oe, te = 0;
                    break
            }
        }
        if (te === 1) throw Error(G);
        return ee - ne
    }, C.test = function (Z) {
        return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(Z)
    }
})(base64$1);
var eventemitter = EventEmitter;

function EventEmitter() {
    this._listeners = {}
}
EventEmitter.prototype.on = function (C, H, W) {
    return (this._listeners[C] || (this._listeners[C] = [])).push({
        fn: H,
        ctx: W || this
    }), this
};
EventEmitter.prototype.off = function (C, H) {
    if (C === void 0) this._listeners = {};
    else if (H === void 0) this._listeners[C] = [];
    else
        for (var W = this._listeners[C], U = 0; U < W.length;) W[U].fn === H ? W.splice(U, 1) : ++U;
    return this
};
EventEmitter.prototype.emit = function (C) {
    var H = this._listeners[C];
    if (H) {
        for (var W = [], U = 1; U < arguments.length;) W.push(arguments[U++]);
        for (U = 0; U < H.length;) H[U].fn.apply(H[U++].ctx, W)
    }
    return this
};
var float = factory(factory);

function factory(K) {
    return typeof Float32Array < "u" ? function () {
        var C = new Float32Array([-0]),
            H = new Uint8Array(C.buffer),
            W = H[3] === 128;

        function U(Q, ee, ne) {
            C[0] = Q, ee[ne] = H[0], ee[ne + 1] = H[1], ee[ne + 2] = H[2], ee[ne + 3] = H[3]
        }

        function G(Q, ee, ne) {
            C[0] = Q, ee[ne] = H[3], ee[ne + 1] = H[2], ee[ne + 2] = H[1], ee[ne + 3] = H[0]
        }
        K.writeFloatLE = W ? U : G, K.writeFloatBE = W ? G : U;

        function X(Q, ee) {
            return H[0] = Q[ee], H[1] = Q[ee + 1], H[2] = Q[ee + 2], H[3] = Q[ee + 3], C[0]
        }

        function Z(Q, ee) {
            return H[3] = Q[ee], H[2] = Q[ee + 1], H[1] = Q[ee + 2], H[0] = Q[ee + 3], C[0]
        }
        K.readFloatLE = W ? X : Z, K.readFloatBE = W ? Z : X
    }() : function () {
        function C(W, U, G, X) {
            var Z = U < 0 ? 1 : 0;
            if (Z && (U = -U), U === 0) W(1 / U > 0 ? 0 : 2147483648, G, X);
            else if (isNaN(U)) W(2143289344, G, X);
            else if (U > 34028234663852886e22) W((Z << 31 | 2139095040) >>> 0, G, X);
            else if (U < 11754943508222875e-54) W((Z << 31 | Math.round(U / 1401298464324817e-60)) >>> 0, G, X);
            else {
                var Q = Math.floor(Math.log(U) / Math.LN2),
                    ee = Math.round(U * Math.pow(2, -Q) * 8388608) & 8388607;
                W((Z << 31 | Q + 127 << 23 | ee) >>> 0, G, X)
            }
        }
        K.writeFloatLE = C.bind(null, writeUintLE), K.writeFloatBE = C.bind(null, writeUintBE);

        function H(W, U, G) {
            var X = W(U, G),
                Z = (X >> 31) * 2 + 1,
                Q = X >>> 23 & 255,
                ee = X & 8388607;
            return Q === 255 ? ee ? NaN : Z * (1 / 0) : Q === 0 ? Z * 1401298464324817e-60 * ee : Z * Math.pow(2, Q -
                150) * (ee + 8388608)
        }
        K.readFloatLE = H.bind(null, readUintLE), K.readFloatBE = H.bind(null, readUintBE)
    }(), typeof Float64Array < "u" ? function () {
        var C = new Float64Array([-0]),
            H = new Uint8Array(C.buffer),
            W = H[7] === 128;

        function U(Q, ee, ne) {
            C[0] = Q, ee[ne] = H[0], ee[ne + 1] = H[1], ee[ne + 2] = H[2], ee[ne + 3] = H[3], ee[ne + 4] = H[4], ee[
                ne + 5] = H[5], ee[ne + 6] = H[6], ee[ne + 7] = H[7]
        }

        function G(Q, ee, ne) {
            C[0] = Q, ee[ne] = H[7], ee[ne + 1] = H[6], ee[ne + 2] = H[5], ee[ne + 3] = H[4], ee[ne + 4] = H[3], ee[
                ne + 5] = H[2], ee[ne + 6] = H[1], ee[ne + 7] = H[0]
        }
        K.writeDoubleLE = W ? U : G, K.writeDoubleBE = W ? G : U;

        function X(Q, ee) {
            return H[0] = Q[ee], H[1] = Q[ee + 1], H[2] = Q[ee + 2], H[3] = Q[ee + 3], H[4] = Q[ee + 4], H[5] = Q[
                ee + 5], H[6] = Q[ee + 6], H[7] = Q[ee + 7], C[0]
        }

        function Z(Q, ee) {
            return H[7] = Q[ee], H[6] = Q[ee + 1], H[5] = Q[ee + 2], H[4] = Q[ee + 3], H[3] = Q[ee + 4], H[2] = Q[
                ee + 5], H[1] = Q[ee + 6], H[0] = Q[ee + 7], C[0]
        }
        K.readDoubleLE = W ? X : Z, K.readDoubleBE = W ? Z : X
    }() : function () {
        function C(W, U, G, X, Z, Q) {
            var ee = X < 0 ? 1 : 0;
            if (ee && (X = -X), X === 0) W(0, Z, Q + U), W(1 / X > 0 ? 0 : 2147483648, Z, Q + G);
            else if (isNaN(X)) W(0, Z, Q + U), W(2146959360, Z, Q + G);
            else if (X > 17976931348623157e292) W(0, Z, Q + U), W((ee << 31 | 2146435072) >>> 0, Z, Q + G);
            else {
                var ne;
                if (X < 22250738585072014e-324) ne = X / 5e-324, W(ne >>> 0, Z, Q + U), W((ee << 31 | ne /
                    4294967296) >>> 0, Z, Q + G);
                else {
                    var te = Math.floor(Math.log(X) / Math.LN2);
                    te === 1024 && (te = 1023), ne = X * Math.pow(2, -te), W(ne * 4503599627370496 >>> 0, Z, Q + U),
                        W((ee << 31 | te + 1023 << 20 | ne * 1048576 & 1048575) >>> 0, Z, Q + G)
                }
            }
        }
        K.writeDoubleLE = C.bind(null, writeUintLE, 0, 4), K.writeDoubleBE = C.bind(null, writeUintBE, 4, 0);

        function H(W, U, G, X, Z) {
            var Q = W(X, Z + U),
                ee = W(X, Z + G),
                ne = (ee >> 31) * 2 + 1,
                te = ee >>> 20 & 2047,
                re = 4294967296 * (ee & 1048575) + Q;
            return te === 2047 ? re ? NaN : ne * (1 / 0) : te === 0 ? ne * 5e-324 * re : ne * Math.pow(2, te - 1075) *
                (re + 4503599627370496)
        }
        K.readDoubleLE = H.bind(null, readUintLE, 0, 4), K.readDoubleBE = H.bind(null, readUintBE, 4, 0)
    }(), K
}

function writeUintLE(K, C, H) {
    C[H] = K & 255, C[H + 1] = K >>> 8 & 255, C[H + 2] = K >>> 16 & 255, C[H + 3] = K >>> 24
}

function writeUintBE(K, C, H) {
    C[H] = K >>> 24, C[H + 1] = K >>> 16 & 255, C[H + 2] = K >>> 8 & 255, C[H + 3] = K & 255
}

function readUintLE(K, C) {
    return (K[C] | K[C + 1] << 8 | K[C + 2] << 16 | K[C + 3] << 24) >>> 0
}

function readUintBE(K, C) {
    return (K[C] << 24 | K[C + 1] << 16 | K[C + 2] << 8 | K[C + 3]) >>> 0
}
var inquire_1 = inquire$1;

function inquire$1(moduleName) {
    try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length)) return mod
    } catch (K) {}
    return null
}
var utf8$2 = {};
(function (K) {
    var C = K;
    C.length = function (W) {
        for (var U = 0, G = 0, X = 0; X < W.length; ++X) G = W.charCodeAt(X), G < 128 ? U += 1 : G < 2048 ? U +=
            2 : (G & 64512) === 55296 && (W.charCodeAt(X + 1) & 64512) === 56320 ? (++X, U += 4) : U += 3;
        return U
    }, C.read = function (W, U, G) {
        var X = G - U;
        if (X < 1) return "";
        for (var Z = null, Q = [], ee = 0, ne; U < G;) ne = W[U++], ne < 128 ? Q[ee++] = ne : ne > 191 && ne <
            224 ? Q[ee++] = (ne & 31) << 6 | W[U++] & 63 : ne > 239 && ne < 365 ? (ne = ((ne & 7) << 18 | (W[U++] &
                    63) << 12 | (W[U++] & 63) << 6 | W[U++] & 63) - 65536, Q[ee++] = 55296 + (ne >> 10), Q[ee++] =
                56320 + (ne & 1023)) : Q[ee++] = (ne & 15) << 12 | (W[U++] & 63) << 6 | W[U++] & 63, ee > 8191 &&
            ((Z || (Z = [])).push(String.fromCharCode.apply(String, Q)), ee = 0);
        return Z ? (ee && Z.push(String.fromCharCode.apply(String, Q.slice(0, ee))), Z.join("")) : String.fromCharCode
            .apply(String, Q.slice(0, ee))
    }, C.write = function (W, U, G) {
        for (var X = G, Z, Q, ee = 0; ee < W.length; ++ee) Z = W.charCodeAt(ee), Z < 128 ? U[G++] = Z : Z <
            2048 ? (U[G++] = Z >> 6 | 192, U[G++] = Z & 63 | 128) : (Z & 64512) === 55296 && ((Q = W.charCodeAt(
                ee + 1)) & 64512) === 56320 ? (Z = 65536 + ((Z & 1023) << 10) + (Q & 1023), ++ee, U[G++] = Z >>
                18 | 240, U[G++] = Z >> 12 & 63 | 128, U[G++] = Z >> 6 & 63 | 128, U[G++] = Z & 63 | 128) : (U[
                G++] = Z >> 12 | 224, U[G++] = Z >> 6 & 63 | 128, U[G++] = Z & 63 | 128);
        return G - X
    }
})(utf8$2);
var pool_1 = pool;

function pool(K, C, H) {
    var W = H || 8192,
        U = W >>> 1,
        G = null,
        X = W;
    return function (Q) {
        if (Q < 1 || Q > U) return K(Q);
        X + Q > W && (G = K(W), X = 0);
        var ee = C.call(G, X, X += Q);
        return X & 7 && (X = (X | 7) + 1), ee
    }
}
var longbits, hasRequiredLongbits;

function requireLongbits() {
    if (hasRequiredLongbits) return longbits;
    hasRequiredLongbits = 1, longbits = C;
    var K = requireMinimal();

    function C(G, X) {
        this.lo = G >>> 0, this.hi = X >>> 0
    }
    var H = C.zero = new C(0, 0);
    H.toNumber = function () {
        return 0
    }, H.zzEncode = H.zzDecode = function () {
        return this
    }, H.length = function () {
        return 1
    };
    var W = C.zeroHash = "\0\0\0\0\0\0\0\0";
    C.fromNumber = function (X) {
        if (X === 0) return H;
        var Z = X < 0;
        Z && (X = -X);
        var Q = X >>> 0,
            ee = (X - Q) / 4294967296 >>> 0;
        return Z && (ee = ~ee >>> 0, Q = ~Q >>> 0, ++Q > 4294967295 && (Q = 0, ++ee > 4294967295 && (ee = 0))), new C(
            Q, ee)
    }, C.from = function (X) {
        if (typeof X == "number") return C.fromNumber(X);
        if (K.isString(X))
            if (K.Long) X = K.Long.fromString(X);
            else return C.fromNumber(parseInt(X, 10));
        return X.low || X.high ? new C(X.low >>> 0, X.high >>> 0) : H
    }, C.prototype.toNumber = function (X) {
        if (!X && this.hi >>> 31) {
            var Z = ~this.lo + 1 >>> 0,
                Q = ~this.hi >>> 0;
            return Z || (Q = Q + 1 >>> 0), -(Z + Q * 4294967296)
        }
        return this.lo + this.hi * 4294967296
    }, C.prototype.toLong = function (X) {
        return K.Long ? new K.Long(this.lo | 0, this.hi | 0, !!X) : {
            low: this.lo | 0,
            high: this.hi | 0,
            unsigned: !!X
        }
    };
    var U = String.prototype.charCodeAt;
    return C.fromHash = function (X) {
        return X === W ? H : new C((U.call(X, 0) | U.call(X, 1) << 8 | U.call(X, 2) << 16 | U.call(X, 3) << 24) >>>
            0, (U.call(X, 4) | U.call(X, 5) << 8 | U.call(X, 6) << 16 | U.call(X, 7) << 24) >>> 0)
    }, C.prototype.toHash = function () {
        return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi &
            255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24)
    }, C.prototype.zzEncode = function () {
        var X = this.hi >> 31;
        return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ X) >>> 0, this.lo = (this.lo << 1 ^ X) >>> 0, this
    }, C.prototype.zzDecode = function () {
        var X = -(this.lo & 1);
        return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ X) >>> 0, this.hi = (this.hi >>> 1 ^ X) >>> 0, this
    }, C.prototype.length = function () {
        var X = this.lo,
            Z = (this.lo >>> 28 | this.hi << 4) >>> 0,
            Q = this.hi >>> 24;
        return Q === 0 ? Z === 0 ? X < 16384 ? X < 128 ? 1 : 2 : X < 2097152 ? 3 : 4 : Z < 16384 ? Z < 128 ? 5 : 6 :
            Z < 2097152 ? 7 : 8 : Q < 128 ? 9 : 10
    }, longbits
}
var hasRequiredMinimal;

function requireMinimal() {
    return hasRequiredMinimal || (hasRequiredMinimal = 1, function (K) {
        var C = K;
        C.asPromise = aspromise, C.base64 = base64$1, C.EventEmitter = eventemitter, C.float = float, C.inquire =
            inquire_1, C.utf8 = utf8$2, C.pool = pool_1, C.LongBits = requireLongbits(), C.isNode = !!(typeof commonjsGlobal <
                "u" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions &&
                commonjsGlobal.process.versions.node), C.global = C.isNode && commonjsGlobal || typeof window <
            "u" && window || typeof self < "u" && self || commonjsGlobal, C.emptyArray = Object.freeze ? Object
            .freeze([]) : [], C.emptyObject = Object.freeze ? Object.freeze({}) : {}, C.isInteger = Number.isInteger ||
            function (G) {
                return typeof G == "number" && isFinite(G) && Math.floor(G) === G
            }, C.isString = function (G) {
                return typeof G == "string" || G instanceof String
            }, C.isObject = function (G) {
                return G && typeof G == "object"
            }, C.isset = C.isSet = function (G, X) {
                var Z = G[X];
                return Z != null && G.hasOwnProperty(X) ? typeof Z != "object" || (Array.isArray(Z) ? Z.length :
                    Object.keys(Z).length) > 0 : !1
            }, C.Buffer = function () {
                try {
                    var U = C.inquire("buffer").Buffer;
                    return U.prototype.utf8Write ? U : null
                } catch {
                    return null
                }
            }(), C._Buffer_from = null, C._Buffer_allocUnsafe = null, C.newBuffer = function (G) {
                return typeof G == "number" ? C.Buffer ? C._Buffer_allocUnsafe(G) : new C.Array(G) : C.Buffer ?
                    C._Buffer_from(G) : typeof Uint8Array > "u" ? G : new Uint8Array(G)
            }, C.Array = typeof Uint8Array < "u" ? Uint8Array : Array, C.Long = C.global.dcodeIO && C.global.dcodeIO
            .Long || C.global.Long || C.inquire("long"), C.key2Re = /^true|false|0|1$/, C.key32Re =
            /^-?(?:0|[1-9][0-9]*)$/, C.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, C.longToHash =
            function (G) {
                return G ? C.LongBits.from(G).toHash() : C.LongBits.zeroHash
            }, C.longFromHash = function (G, X) {
                var Z = C.LongBits.fromHash(G);
                return C.Long ? C.Long.fromBits(Z.lo, Z.hi, X) : Z.toNumber(!!X)
            };

        function H(U, G, X) {
            for (var Z = Object.keys(G), Q = 0; Q < Z.length; ++Q)(U[Z[Q]] === void 0 || !X) && (U[Z[Q]] = G[Z[
                Q]]);
            return U
        }
        C.merge = H, C.lcFirst = function (G) {
            return G.charAt(0).toLowerCase() + G.substring(1)
        };

        function W(U) {
            function G(X, Z) {
                if (!(this instanceof G)) return new G(X, Z);
                Object.defineProperty(this, "message", {
                    get: function () {
                        return X
                    }
                }), Error.captureStackTrace ? Error.captureStackTrace(this, G) : Object.defineProperty(this,
                    "stack", {
                        value: new Error().stack || ""
                    }), Z && H(this, Z)
            }
            return G.prototype = Object.create(Error.prototype, {
                constructor: {
                    value: G,
                    writable: !0,
                    enumerable: !1,
                    configurable: !0
                },
                name: {
                    get: function () {
                        return U
                    },
                    set: void 0,
                    enumerable: !1,
                    configurable: !0
                },
                toString: {
                    value: function () {
                        return this.name + ": " + this.message
                    },
                    writable: !0,
                    enumerable: !1,
                    configurable: !0
                }
            }), G
        }
        C.newError = W, C.ProtocolError = W("ProtocolError"), C.oneOfGetter = function (G) {
            for (var X = {}, Z = 0; Z < G.length; ++Z) X[G[Z]] = 1;
            return function () {
                for (var Q = Object.keys(this), ee = Q.length - 1; ee > -1; --ee)
                    if (X[Q[ee]] === 1 && this[Q[ee]] !== void 0 && this[Q[ee]] !== null) return Q[ee]
            }
        }, C.oneOfSetter = function (G) {
            return function (X) {
                for (var Z = 0; Z < G.length; ++Z) G[Z] !== X && delete this[G[Z]]
            }
        }, C.toJSONOptions = {
            longs: String,
            enums: String,
            bytes: String,
            json: !0
        }, C._configure = function () {
            var U = C.Buffer;
            if (!U) {
                C._Buffer_from = C._Buffer_allocUnsafe = null;
                return
            }
            C._Buffer_from = U.from !== Uint8Array.from && U.from || function (X, Z) {
                return new U(X, Z)
            }, C._Buffer_allocUnsafe = U.allocUnsafe || function (X) {
                return new U(X)
            }
        }
    }(minimal)), minimal
}
var writer = Writer$1,
    util$7 = requireMinimal(),
    BufferWriter$1, LongBits$1 = util$7.LongBits,
    base64 = util$7.base64,
    utf8$1 = util$7.utf8;

function Op(K, C, H) {
    this.fn = K, this.len = C, this.next = void 0, this.val = H
}

function noop() {}

function State(K) {
    this.head = K.head, this.tail = K.tail, this.len = K.len, this.next = K.states
}

function Writer$1() {
    this.len = 0, this.head = new Op(noop, 0, 0), this.tail = this.head, this.states = null
}
var create$1 = function K() {
    return util$7.Buffer ? function () {
        return (Writer$1.create = function () {
            return new BufferWriter$1
        })()
    } : function () {
        return new Writer$1
    }
};
Writer$1.create = create$1();
Writer$1.alloc = function K(C) {
    return new util$7.Array(C)
};
util$7.Array !== Array && (Writer$1.alloc = util$7.pool(Writer$1.alloc, util$7.Array.prototype.subarray));
Writer$1.prototype._push = function K(C, H, W) {
    return this.tail = this.tail.next = new Op(C, H, W), this.len += H, this
};

function writeByte(K, C, H) {
    C[H] = K & 255
}

function writeVarint32(K, C, H) {
    for (; K > 127;) C[H++] = K & 127 | 128, K >>>= 7;
    C[H] = K
}

function VarintOp(K, C) {
    this.len = K, this.next = void 0, this.val = C
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function K(C) {
    return this.len += (this.tail = this.tail.next = new VarintOp((C = C >>> 0) < 128 ? 1 : C < 16384 ? 2 : C <
        2097152 ? 3 : C < 268435456 ? 4 : 5, C)).len, this
};
Writer$1.prototype.int32 = function K(C) {
    return C < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(C)) : this.uint32(C)
};
Writer$1.prototype.sint32 = function K(C) {
    return this.uint32((C << 1 ^ C >> 31) >>> 0)
};

function writeVarint64(K, C, H) {
    for (; K.hi;) C[H++] = K.lo & 127 | 128, K.lo = (K.lo >>> 7 | K.hi << 25) >>> 0, K.hi >>>= 7;
    for (; K.lo > 127;) C[H++] = K.lo & 127 | 128, K.lo = K.lo >>> 7;
    C[H++] = K.lo
}
Writer$1.prototype.uint64 = function K(C) {
    var H = LongBits$1.from(C);
    return this._push(writeVarint64, H.length(), H)
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function K(C) {
    var H = LongBits$1.from(C).zzEncode();
    return this._push(writeVarint64, H.length(), H)
};
Writer$1.prototype.bool = function K(C) {
    return this._push(writeByte, 1, C ? 1 : 0)
};

function writeFixed32(K, C, H) {
    C[H] = K & 255, C[H + 1] = K >>> 8 & 255, C[H + 2] = K >>> 16 & 255, C[H + 3] = K >>> 24
}
Writer$1.prototype.fixed32 = function K(C) {
    return this._push(writeFixed32, 4, C >>> 0)
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function K(C) {
    var H = LongBits$1.from(C);
    return this._push(writeFixed32, 4, H.lo)._push(writeFixed32, 4, H.hi)
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function K(C) {
    return this._push(util$7.float.writeFloatLE, 4, C)
};
Writer$1.prototype.double = function K(C) {
    return this._push(util$7.float.writeDoubleLE, 8, C)
};
var writeBytes = util$7.Array.prototype.set ? function K(C, H, W) {
    H.set(C, W)
} : function K(C, H, W) {
    for (var U = 0; U < C.length; ++U) H[W + U] = C[U]
};
Writer$1.prototype.bytes = function K(C) {
    var H = C.length >>> 0;
    if (!H) return this._push(writeByte, 1, 0);
    if (util$7.isString(C)) {
        var W = Writer$1.alloc(H = base64.length(C));
        base64.decode(C, W, 0), C = W
    }
    return this.uint32(H)._push(writeBytes, H, C)
};
Writer$1.prototype.string = function K(C) {
    var H = utf8$1.length(C);
    return H ? this.uint32(H)._push(utf8$1.write, H, C) : this._push(writeByte, 1, 0)
};
Writer$1.prototype.fork = function K() {
    return this.states = new State(this), this.head = this.tail = new Op(noop, 0, 0), this.len = 0, this
};
Writer$1.prototype.reset = function K() {
    return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len,
        this.states = this.states.next) : (this.head = this.tail = new Op(noop, 0, 0), this.len = 0), this
};
Writer$1.prototype.ldelim = function K() {
    var C = this.head,
        H = this.tail,
        W = this.len;
    return this.reset().uint32(W), W && (this.tail.next = C.next, this.tail = H, this.len += W), this
};
Writer$1.prototype.finish = function K() {
    for (var C = this.head.next, H = this.constructor.alloc(this.len), W = 0; C;) C.fn(C.val, H, W), W += C.len, C =
        C.next;
    return H
};
Writer$1._configure = function (K) {
    BufferWriter$1 = K, Writer$1.create = create$1(), BufferWriter$1._configure()
};
var writer_buffer = BufferWriter,
    Writer = writer;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$6 = requireMinimal();

function BufferWriter() {
    Writer.call(this)
}
BufferWriter._configure = function () {
    BufferWriter.alloc = util$6._Buffer_allocUnsafe, BufferWriter.writeBytesBuffer = util$6.Buffer && util$6.Buffer
        .prototype instanceof Uint8Array && util$6.Buffer.prototype.set.name === "set" ? function (C, H, W) {
            H.set(C, W)
        } : function (C, H, W) {
            if (C.copy) C.copy(H, W, 0, C.length);
            else
                for (var U = 0; U < C.length;) H[W++] = C[U++]
        }
};
BufferWriter.prototype.bytes = function K(C) {
    util$6.isString(C) && (C = util$6._Buffer_from(C, "base64"));
    var H = C.length >>> 0;
    return this.uint32(H), H && this._push(BufferWriter.writeBytesBuffer, H, C), this
};

function writeStringBuffer(K, C, H) {
    K.length < 40 ? util$6.utf8.write(K, C, H) : C.utf8Write ? C.utf8Write(K, H) : C.write(K, H)
}
BufferWriter.prototype.string = function K(C) {
    var H = util$6.Buffer.byteLength(C);
    return this.uint32(H), H && this._push(writeStringBuffer, H, C), this
};
BufferWriter._configure();
var reader = Reader$1,
    util$5 = requireMinimal(),
    BufferReader$1, LongBits = util$5.LongBits,
    utf8 = util$5.utf8;

function indexOutOfRange(K, C) {
    return RangeError("index out of range: " + K.pos + " + " + (C || 1) + " > " + K.len)
}

function Reader$1(K) {
    this.buf = K, this.pos = 0, this.len = K.length
}
var create_array = typeof Uint8Array < "u" ? function K(C) {
        if (C instanceof Uint8Array || Array.isArray(C)) return new Reader$1(C);
        throw Error("illegal buffer")
    } : function K(C) {
        if (Array.isArray(C)) return new Reader$1(C);
        throw Error("illegal buffer")
    },
    create = function K() {
        return util$5.Buffer ? function (H) {
            return (Reader$1.create = function (U) {
                return util$5.Buffer.isBuffer(U) ? new BufferReader$1(U) : create_array(U)
            })(H)
        } : create_array
    };
Reader$1.create = create();
Reader$1.prototype._slice = util$5.Array.prototype.subarray || util$5.Array.prototype.slice;
Reader$1.prototype.uint32 = function K() {
    var C = 4294967295;
    return function () {
        if (C = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (C = (C | (this.buf[this.pos] &
                127) << 7) >>> 0, this.buf[this.pos++] < 128) || (C = (C | (this.buf[this.pos] & 127) << 14) >>>
                0, this.buf[this.pos++] < 128) || (C = (C | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[
                this.pos++] < 128) || (C = (C | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] <
                128)) return C;
        if ((this.pos += 5) > this.len) throw this.pos = this.len, indexOutOfRange(this, 10);
        return C
    }
}();
Reader$1.prototype.int32 = function K() {
    return this.uint32() | 0
};
Reader$1.prototype.sint32 = function K() {
    var C = this.uint32();
    return C >>> 1 ^ -(C & 1) | 0
};

function readLongVarint() {
    var K = new LongBits(0, 0),
        C = 0;
    if (this.len - this.pos > 4) {
        for (; C < 4; ++C)
            if (K.lo = (K.lo | (this.buf[this.pos] & 127) << C * 7) >>> 0, this.buf[this.pos++] < 128) return K;
        if (K.lo = (K.lo | (this.buf[this.pos] & 127) << 28) >>> 0, K.hi = (K.hi | (this.buf[this.pos] & 127) >> 4) >>>
            0, this.buf[this.pos++] < 128) return K;
        C = 0
    } else {
        for (; C < 3; ++C) {
            if (this.pos >= this.len) throw indexOutOfRange(this);
            if (K.lo = (K.lo | (this.buf[this.pos] & 127) << C * 7) >>> 0, this.buf[this.pos++] < 128) return K
        }
        return K.lo = (K.lo | (this.buf[this.pos++] & 127) << C * 7) >>> 0, K
    }
    if (this.len - this.pos > 4) {
        for (; C < 5; ++C)
            if (K.hi = (K.hi | (this.buf[this.pos] & 127) << C * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return K
    } else
        for (; C < 5; ++C) {
            if (this.pos >= this.len) throw indexOutOfRange(this);
            if (K.hi = (K.hi | (this.buf[this.pos] & 127) << C * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return K
        }
    throw Error("invalid varint encoding")
}
Reader$1.prototype.bool = function K() {
    return this.uint32() !== 0
};

function readFixed32_end(K, C) {
    return (K[C - 4] | K[C - 3] << 8 | K[C - 2] << 16 | K[C - 1] << 24) >>> 0
}
Reader$1.prototype.fixed32 = function K() {
    if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4)
};
Reader$1.prototype.sfixed32 = function K() {
    if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4) | 0
};

function readFixed64() {
    if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);
    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4))
}
Reader$1.prototype.float = function K() {
    if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    var C = util$5.float.readFloatLE(this.buf, this.pos);
    return this.pos += 4, C
};
Reader$1.prototype.double = function K() {
    if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);
    var C = util$5.float.readDoubleLE(this.buf, this.pos);
    return this.pos += 8, C
};
Reader$1.prototype.bytes = function K() {
    var C = this.uint32(),
        H = this.pos,
        W = this.pos + C;
    if (W > this.len) throw indexOutOfRange(this, C);
    return this.pos += C, Array.isArray(this.buf) ? this.buf.slice(H, W) : H === W ? new this.buf.constructor(0) :
        this._slice.call(this.buf, H, W)
};
Reader$1.prototype.string = function K() {
    var C = this.bytes();
    return utf8.read(C, 0, C.length)
};
Reader$1.prototype.skip = function K(C) {
    if (typeof C == "number") {
        if (this.pos + C > this.len) throw indexOutOfRange(this, C);
        this.pos += C
    } else
        do
            if (this.pos >= this.len) throw indexOutOfRange(this); while (this.buf[this.pos++] & 128);
    return this
};
Reader$1.prototype.skipType = function (K) {
    switch (K) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            for (;
                (K = this.uint32() & 7) !== 4;) this.skipType(K);
            break;
        case 5:
            this.skip(4);
            break;
        default:
            throw Error("invalid wire type " + K + " at offset " + this.pos)
    }
    return this
};
Reader$1._configure = function (K) {
    BufferReader$1 = K, Reader$1.create = create(), BufferReader$1._configure();
    var C = util$5.Long ? "toLong" : "toNumber";
    util$5.merge(Reader$1.prototype, {
        int64: function () {
            return readLongVarint.call(this)[C](!1)
        },
        uint64: function () {
            return readLongVarint.call(this)[C](!0)
        },
        sint64: function () {
            return readLongVarint.call(this).zzDecode()[C](!1)
        },
        fixed64: function () {
            return readFixed64.call(this)[C](!0)
        },
        sfixed64: function () {
            return readFixed64.call(this)[C](!1)
        }
    })
};
var reader_buffer = BufferReader,
    Reader = reader;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$4 = requireMinimal();

function BufferReader(K) {
    Reader.call(this, K)
}
BufferReader._configure = function () {
    util$4.Buffer && (BufferReader.prototype._slice = util$4.Buffer.prototype.slice)
};
BufferReader.prototype.string = function K() {
    var C = this.uint32();
    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + C, this.len)) : this.buf
        .toString("utf-8", this.pos, this.pos = Math.min(this.pos + C, this.len))
};
BufferReader._configure();
var rpc = {},
    service$1 = Service$1,
    util$3 = requireMinimal();
(Service$1.prototype = Object.create(util$3.EventEmitter.prototype)).constructor = Service$1;

function Service$1(K, C, H) {
    if (typeof K != "function") throw TypeError("rpcImpl must be a function");
    util$3.EventEmitter.call(this), this.rpcImpl = K, this.requestDelimited = !!C, this.responseDelimited = !!H
}
Service$1.prototype.rpcCall = function K(C, H, W, U, G) {
    if (!U) throw TypeError("request must be specified");
    var X = this;
    if (!G) return util$3.asPromise(K, X, C, H, W, U);
    if (!X.rpcImpl) {
        setTimeout(function () {
            G(Error("already ended"))
        }, 0);
        return
    }
    try {
        return X.rpcImpl(C, H[X.requestDelimited ? "encodeDelimited" : "encode"](U).finish(), function (Q, ee) {
            if (Q) return X.emit("error", Q, C), G(Q);
            if (ee === null) {
                X.end(!0);
                return
            }
            if (!(ee instanceof W)) try {
                ee = W[X.responseDelimited ? "decodeDelimited" : "decode"](ee)
            } catch (ne) {
                return X.emit("error", ne, C), G(ne)
            }
            return X.emit("data", ee, C), G(null, ee)
        })
    } catch (Z) {
        X.emit("error", Z, C), setTimeout(function () {
            G(Z)
        }, 0);
        return
    }
};
Service$1.prototype.end = function K(C) {
    return this.rpcImpl && (C || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this
};
(function (K) {
    var C = K;
    C.Service = service$1
})(rpc);
var roots = {};
(function (K) {
    var C = K;
    C.build = "minimal", C.Writer = writer, C.BufferWriter = writer_buffer, C.Reader = reader, C.BufferReader =
        reader_buffer, C.util = requireMinimal(), C.rpc = rpc, C.roots = roots, C.configure = H;

    function H() {
        C.util._configure(), C.Writer._configure(C.BufferWriter), C.Reader._configure(C.BufferReader)
    }
    H()
})(indexMinimal);
(function (K) {
    K.exports = indexMinimal
})(minimal$1);
var protobufjsExports = {},
    protobufjs = {
        get exports() {
            return protobufjsExports
        },
        set exports(K) {
            protobufjsExports = K
        }
    },
    srcExports = {},
    src = {
        get exports() {
            return srcExports
        },
        set exports(K) {
            srcExports = K
        }
    },
    indexLightExports = {},
    indexLight = {
        get exports() {
            return indexLightExports
        },
        set exports(K) {
            indexLightExports = K
        }
    },
    utilExports = {},
    util$2 = {
        get exports() {
            return utilExports
        },
        set exports(K) {
            utilExports = K
        }
    },
    codegen_1 = codegen;

function codegen(K, C) {
    typeof K == "string" && (C = K, K = void 0);
    var H = [];

    function W(G) {
        if (typeof G != "string") {
            var X = U();
            if (codegen.verbose && console.log("codegen: " + X), X = "return " + X, G) {
                for (var Z = Object.keys(G), Q = new Array(Z.length + 1), ee = new Array(Z.length), ne = 0; ne < Z.length;)
                    Q[ne] = Z[ne], ee[ne] = G[Z[ne++]];
                return Q[ne] = X, Function.apply(null, Q).apply(null, ee)
            }
            return Function(X)()
        }
        for (var te = new Array(arguments.length - 1), re = 0; re < te.length;) te[re] = arguments[++re];
        if (re = 0, G = G.replace(/%([%dfijs])/g, function (oe, ie) {
                var ue = te[re++];
                switch (ie) {
                    case "d":
                    case "f":
                        return String(Number(ue));
                    case "i":
                        return String(Math.floor(ue));
                    case "j":
                        return JSON.stringify(ue);
                    case "s":
                        return String(ue)
                }
                return "%"
            }), re !== te.length) throw Error("parameter count mismatch");
        return H.push(G), W
    }

    function U(G) {
        return "function " + (G || C || "") + "(" + (K && K.join(",") || "") + `){
  ` + H.join(`
  `) + `
}`
    }
    return W.toString = U, W
}
codegen.verbose = !1;
var fetch_1 = fetch,
    asPromise = aspromise,
    inquire = inquire_1,
    fs = inquire("fs");

function fetch(K, C, H) {
    return typeof C == "function" ? (H = C, C = {}) : C || (C = {}), H ? !C.xhr && fs && fs.readFile ? fs.readFile(K,
        function (U, G) {
            return U && typeof XMLHttpRequest < "u" ? fetch.xhr(K, C, H) : U ? H(U) : H(null, C.binary ? G : G.toString(
                "utf8"))
        }) : fetch.xhr(K, C, H) : asPromise(fetch, this, K, C)
}
fetch.xhr = function K(C, H, W) {
    var U = new XMLHttpRequest;
    U.onreadystatechange = function () {
        if (U.readyState === 4) {
            if (U.status !== 0 && U.status !== 200) return W(Error("status " + U.status));
            if (H.binary) {
                var X = U.response;
                if (!X) {
                    X = [];
                    for (var Z = 0; Z < U.responseText.length; ++Z) X.push(U.responseText.charCodeAt(Z) & 255)
                }
                return W(null, typeof Uint8Array < "u" ? new Uint8Array(X) : X)
            }
            return W(null, U.responseText)
        }
    }, H.binary && ("overrideMimeType" in U && U.overrideMimeType("text/plain; charset=x-user-defined"), U.responseType =
        "arraybuffer"), U.open("GET", C), U.send()
};
var path = {};
(function (K) {
    var C = K,
        H = C.isAbsolute = function (G) {
            return /^(?:\/|\w+:)/.test(G)
        },
        W = C.normalize = function (G) {
            G = G.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
            var X = G.split("/"),
                Z = H(G),
                Q = "";
            Z && (Q = X.shift() + "/");
            for (var ee = 0; ee < X.length;) X[ee] === ".." ? ee > 0 && X[ee - 1] !== ".." ? X.splice(--ee, 2) : Z ?
                X.splice(ee, 1) : ++ee : X[ee] === "." ? X.splice(ee, 1) : ++ee;
            return Q + X.join("/")
        };
    C.resolve = function (G, X, Z) {
        return Z || (X = W(X)), H(X) ? X : (Z || (G = W(G)), (G = G.replace(/(?:\/|^)[^/]+$/, "")).length ? W(G +
            "/" + X) : X)
    }
})(path);
var types$1 = {},
    hasRequiredTypes;

function requireTypes() {
    return hasRequiredTypes || (hasRequiredTypes = 1, function (K) {
        var C = K,
            H = requireUtil(),
            W = ["double", "float", "int32", "uint32", "sint32", "fixed32", "sfixed32", "int64", "uint64",
                "sint64", "fixed64", "sfixed64", "bool", "string", "bytes"];

        function U(G, X) {
            var Z = 0,
                Q = {};
            for (X |= 0; Z < G.length;) Q[W[Z + X]] = G[Z++];
            return Q
        }
        C.basic = U([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2, 2]), C.defaults = U([0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, !1, "", H.emptyArray, null]), C.long = U([0, 0, 0, 1, 1], 7), C.mapKey = U([0, 0, 0, 5,
            5, 0, 0, 0, 1, 1, 0, 2], 2), C.packed = U([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0])
    }(types$1)), types$1
}
var field, hasRequiredField;

function requireField() {
    if (hasRequiredField) return field;
    hasRequiredField = 1, field = X;
    var K = requireObject();
    ((X.prototype = Object.create(K.prototype)).constructor = X).className = "Field";
    var C = require_enum(),
        H = requireTypes(),
        W = requireUtil(),
        U, G = /^required|optional|repeated$/;
    X.fromJSON = function (Q, ee) {
        return new X(Q, ee.id, ee.type, ee.rule, ee.extend, ee.options, ee.comment)
    };

    function X(Z, Q, ee, ne, te, re, ae) {
        if (W.isObject(ne) ? (ae = te, re = ne, ne = te = void 0) : W.isObject(te) && (ae = re, re = te, te = void 0),
            K.call(this, Z, re), !W.isInteger(Q) || Q < 0) throw TypeError("id must be a non-negative integer");
        if (!W.isString(ee)) throw TypeError("type must be a string");
        if (ne !== void 0 && !G.test(ne = ne.toString().toLowerCase())) throw TypeError("rule must be a string rule");
        if (te !== void 0 && !W.isString(te)) throw TypeError("extend must be a string");
        ne === "proto3_optional" && (ne = "optional"), this.rule = ne && ne !== "optional" ? ne : void 0, this.type =
            ee, this.id = Q, this.extend = te || void 0, this.required = ne === "required", this.optional = !this.required,
            this.repeated = ne === "repeated", this.map = !1, this.message = null, this.partOf = null, this.typeDefault =
            null, this.defaultValue = null, this.long = W.Long ? H.long[ee] !== void 0 : !1, this.bytes = ee ===
            "bytes", this.resolvedType = null, this.extensionField = null, this.declaringField = null, this._packed =
            null, this.comment = ae
    }
    return Object.defineProperty(X.prototype, "packed", {
        get: function () {
            return this._packed === null && (this._packed = this.getOption("packed") !== !1), this._packed
        }
    }), X.prototype.setOption = function (Q, ee, ne) {
        return Q === "packed" && (this._packed = null), K.prototype.setOption.call(this, Q, ee, ne)
    }, X.prototype.toJSON = function (Q) {
        var ee = Q ? !!Q.keepComments : !1;
        return W.toObject(["rule", this.rule !== "optional" && this.rule || void 0, "type", this.type, "id", this.id,
            "extend", this.extend, "options", this.options, "comment", ee ? this.comment : void 0])
    }, X.prototype.resolve = function () {
        if (this.resolved) return this;
        if ((this.typeDefault = H.defaults[this.type]) === void 0 ? (this.resolvedType = (this.declaringField ?
                    this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type), this.resolvedType instanceof U ?
                this.typeDefault = null : this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType
                    .values)[0]]) : this.options && this.options.proto3_optional && (this.typeDefault = null), this
            .options && this.options.default != null && (this.typeDefault = this.options.default, this.resolvedType instanceof C &&
                typeof this.typeDefault == "string" && (this.typeDefault = this.resolvedType.values[this.typeDefault])
            ), this.options && ((this.options.packed === !0 || this.options.packed !== void 0 && this.resolvedType &&
                    !(this.resolvedType instanceof C)) && delete this.options.packed, Object.keys(this.options).length ||
                (this.options = void 0)), this.long) this.typeDefault = W.Long.fromNumber(this.typeDefault, this.type
            .charAt(0) === "u"), Object.freeze && Object.freeze(this.typeDefault);
        else if (this.bytes && typeof this.typeDefault == "string") {
            var Q;
            W.base64.test(this.typeDefault) ? W.base64.decode(this.typeDefault, Q = W.newBuffer(W.base64.length(
                this.typeDefault)), 0) : W.utf8.write(this.typeDefault, Q = W.newBuffer(W.utf8.length(this.typeDefault)),
                0), this.typeDefault = Q
        }
        return this.map ? this.defaultValue = W.emptyObject : this.repeated ? this.defaultValue = W.emptyArray :
            this.defaultValue = this.typeDefault, this.parent instanceof U && (this.parent.ctor.prototype[this.name] =
                this.defaultValue), K.prototype.resolve.call(this)
    }, X.d = function (Q, ee, ne, te) {
        return typeof ee == "function" ? ee = W.decorateType(ee).name : ee && typeof ee == "object" && (ee = W.decorateEnum(
                ee).name),
            function (ae, oe) {
                W.decorateType(ae.constructor).add(new X(oe, Q, ee, ne, {
                    default: te
                }))
            }
    }, X._configure = function (Q) {
        U = Q
    }, field
}
var oneof, hasRequiredOneof;

function requireOneof() {
    if (hasRequiredOneof) return oneof;
    hasRequiredOneof = 1, oneof = W;
    var K = requireObject();
    ((W.prototype = Object.create(K.prototype)).constructor = W).className = "OneOf";
    var C = requireField(),
        H = requireUtil();

    function W(G, X, Z, Q) {
        if (Array.isArray(X) || (Z = X, X = void 0), K.call(this, G, Z), !(X === void 0 || Array.isArray(X))) throw TypeError(
            "fieldNames must be an Array");
        this.oneof = X || [], this.fieldsArray = [], this.comment = Q
    }
    W.fromJSON = function (X, Z) {
        return new W(X, Z.oneof, Z.options, Z.comment)
    }, W.prototype.toJSON = function (X) {
        var Z = X ? !!X.keepComments : !1;
        return H.toObject(["options", this.options, "oneof", this.oneof, "comment", Z ? this.comment : void 0])
    };

    function U(G) {
        if (G.parent)
            for (var X = 0; X < G.fieldsArray.length; ++X) G.fieldsArray[X].parent || G.parent.add(G.fieldsArray[X])
    }
    return W.prototype.add = function (X) {
        if (!(X instanceof C)) throw TypeError("field must be a Field");
        return X.parent && X.parent !== this.parent && X.parent.remove(X), this.oneof.push(X.name), this.fieldsArray
            .push(X), X.partOf = this, U(this), this
    }, W.prototype.remove = function (X) {
        if (!(X instanceof C)) throw TypeError("field must be a Field");
        var Z = this.fieldsArray.indexOf(X);
        if (Z < 0) throw Error(X + " is not a member of " + this);
        return this.fieldsArray.splice(Z, 1), Z = this.oneof.indexOf(X.name), Z > -1 && this.oneof.splice(Z, 1), X.partOf =
            null, this
    }, W.prototype.onAdd = function (X) {
        K.prototype.onAdd.call(this, X);
        for (var Z = this, Q = 0; Q < this.oneof.length; ++Q) {
            var ee = X.get(this.oneof[Q]);
            ee && !ee.partOf && (ee.partOf = Z, Z.fieldsArray.push(ee))
        }
        U(this)
    }, W.prototype.onRemove = function (X) {
        for (var Z = 0, Q; Z < this.fieldsArray.length; ++Z)(Q = this.fieldsArray[Z]).parent && Q.parent.remove(Q);
        K.prototype.onRemove.call(this, X)
    }, W.d = function () {
        for (var X = new Array(arguments.length), Z = 0; Z < arguments.length;) X[Z] = arguments[Z++];
        return function (ee, ne) {
            H.decorateType(ee.constructor).add(new W(ne, X)), Object.defineProperty(ee, ne, {
                get: H.oneOfGetter(X),
                set: H.oneOfSetter(X)
            })
        }
    }, oneof
}
var namespace, hasRequiredNamespace;

function requireNamespace() {
    if (hasRequiredNamespace) return namespace;
    hasRequiredNamespace = 1, namespace = Q;
    var K = requireObject();
    ((Q.prototype = Object.create(K.prototype)).constructor = Q).className = "Namespace";
    var C = requireField(),
        H = requireUtil(),
        W = requireOneof(),
        U, G, X;
    Q.fromJSON = function (te, re) {
        return new Q(te, re.options).addJSON(re.nested)
    };

    function Z(ne, te) {
        if (ne && ne.length) {
            for (var re = {}, ae = 0; ae < ne.length; ++ae) re[ne[ae].name] = ne[ae].toJSON(te);
            return re
        }
    }
    Q.arrayToJSON = Z, Q.isReservedId = function (te, re) {
        if (te) {
            for (var ae = 0; ae < te.length; ++ae)
                if (typeof te[ae] != "string" && te[ae][0] <= re && te[ae][1] > re) return !0
        }
        return !1
    }, Q.isReservedName = function (te, re) {
        if (te) {
            for (var ae = 0; ae < te.length; ++ae)
                if (te[ae] === re) return !0
        }
        return !1
    };

    function Q(ne, te) {
        K.call(this, ne, te), this.nested = void 0, this._nestedArray = null
    }

    function ee(ne) {
        return ne._nestedArray = null, ne
    }
    return Object.defineProperty(Q.prototype, "nestedArray", {
        get: function () {
            return this._nestedArray || (this._nestedArray = H.toArray(this.nested))
        }
    }), Q.prototype.toJSON = function (te) {
        return H.toObject(["options", this.options, "nested", Z(this.nestedArray, te)])
    }, Q.prototype.addJSON = function (te) {
        var re = this;
        if (te)
            for (var ae = Object.keys(te), oe = 0, ie; oe < ae.length; ++oe) ie = te[ae[oe]], re.add((ie.fields !==
                void 0 ? U.fromJSON : ie.values !== void 0 ? X.fromJSON : ie.methods !== void 0 ? G.fromJSON :
                ie.id !== void 0 ? C.fromJSON : Q.fromJSON)(ae[oe], ie));
        return this
    }, Q.prototype.get = function (te) {
        return this.nested && this.nested[te] || null
    }, Q.prototype.getEnum = function (te) {
        if (this.nested && this.nested[te] instanceof X) return this.nested[te].values;
        throw Error("no such enum: " + te)
    }, Q.prototype.add = function (te) {
        if (!(te instanceof C && te.extend !== void 0 || te instanceof U || te instanceof W || te instanceof X ||
                te instanceof G || te instanceof Q)) throw TypeError("object must be a valid nested object");
        if (!this.nested) this.nested = {};
        else {
            var re = this.get(te.name);
            if (re)
                if (re instanceof Q && te instanceof Q && !(re instanceof U || re instanceof G)) {
                    for (var ae = re.nestedArray, oe = 0; oe < ae.length; ++oe) te.add(ae[oe]);
                    this.remove(re), this.nested || (this.nested = {}), te.setOptions(re.options, !0)
                } else throw Error("duplicate name '" + te.name + "' in " + this)
        }
        return this.nested[te.name] = te, te.onAdd(this), ee(this)
    }, Q.prototype.remove = function (te) {
        if (!(te instanceof K)) throw TypeError("object must be a ReflectionObject");
        if (te.parent !== this) throw Error(te + " is not a member of " + this);
        return delete this.nested[te.name], Object.keys(this.nested).length || (this.nested = void 0), te.onRemove(
            this), ee(this)
    }, Q.prototype.define = function (te, re) {
        if (H.isString(te)) te = te.split(".");
        else if (!Array.isArray(te)) throw TypeError("illegal path");
        if (te && te.length && te[0] === "") throw Error("path must be relative");
        for (var ae = this; te.length > 0;) {
            var oe = te.shift();
            if (ae.nested && ae.nested[oe]) {
                if (ae = ae.nested[oe], !(ae instanceof Q)) throw Error("path conflicts with non-namespace objects")
            } else ae.add(ae = new Q(oe))
        }
        return re && ae.addJSON(re), ae
    }, Q.prototype.resolveAll = function () {
        for (var te = this.nestedArray, re = 0; re < te.length;) te[re] instanceof Q ? te[re++].resolveAll() : te[
            re++].resolve();
        return this.resolve()
    }, Q.prototype.lookup = function (te, re, ae) {
        if (typeof re == "boolean" ? (ae = re, re = void 0) : re && !Array.isArray(re) && (re = [re]), H.isString(
                te) && te.length) {
            if (te === ".") return this.root;
            te = te.split(".")
        } else if (!te.length) return this;
        if (te[0] === "") return this.root.lookup(te.slice(1), re);
        var oe = this.get(te[0]);
        if (oe) {
            if (te.length === 1) {
                if (!re || re.indexOf(oe.constructor) > -1) return oe
            } else if (oe instanceof Q && (oe = oe.lookup(te.slice(1), re, !0))) return oe
        } else
            for (var ie = 0; ie < this.nestedArray.length; ++ie)
                if (this._nestedArray[ie] instanceof Q && (oe = this._nestedArray[ie].lookup(te, re, !0))) return oe;
        return this.parent === null || ae ? null : this.parent.lookup(te, re)
    }, Q.prototype.lookupType = function (te) {
        var re = this.lookup(te, [U]);
        if (!re) throw Error("no such type: " + te);
        return re
    }, Q.prototype.lookupEnum = function (te) {
        var re = this.lookup(te, [X]);
        if (!re) throw Error("no such Enum '" + te + "' in " + this);
        return re
    }, Q.prototype.lookupTypeOrEnum = function (te) {
        var re = this.lookup(te, [U, X]);
        if (!re) throw Error("no such Type or Enum '" + te + "' in " + this);
        return re
    }, Q.prototype.lookupService = function (te) {
        var re = this.lookup(te, [G]);
        if (!re) throw Error("no such Service '" + te + "' in " + this);
        return re
    }, Q._configure = function (ne, te, re) {
        U = ne, G = te, X = re
    }, namespace
}
var mapfield, hasRequiredMapfield;

function requireMapfield() {
    if (hasRequiredMapfield) return mapfield;
    hasRequiredMapfield = 1, mapfield = W;
    var K = requireField();
    ((W.prototype = Object.create(K.prototype)).constructor = W).className = "MapField";
    var C = requireTypes(),
        H = requireUtil();

    function W(U, G, X, Z, Q, ee) {
        if (K.call(this, U, G, Z, void 0, void 0, Q, ee), !H.isString(X)) throw TypeError("keyType must be a string");
        this.keyType = X, this.resolvedKeyType = null, this.map = !0
    }
    return W.fromJSON = function (G, X) {
        return new W(G, X.id, X.keyType, X.type, X.options, X.comment)
    }, W.prototype.toJSON = function (G) {
        var X = G ? !!G.keepComments : !1;
        return H.toObject(["keyType", this.keyType, "type", this.type, "id", this.id, "extend", this.extend,
            "options", this.options, "comment", X ? this.comment : void 0])
    }, W.prototype.resolve = function () {
        if (this.resolved) return this;
        if (C.mapKey[this.keyType] === void 0) throw Error("invalid key type: " + this.keyType);
        return K.prototype.resolve.call(this)
    }, W.d = function (G, X, Z) {
        return typeof Z == "function" ? Z = H.decorateType(Z).name : Z && typeof Z == "object" && (Z = H.decorateEnum(
                Z).name),
            function (ee, ne) {
                H.decorateType(ee.constructor).add(new W(ne, G, X, Z))
            }
    }, mapfield
}
var method, hasRequiredMethod;

function requireMethod() {
    if (hasRequiredMethod) return method;
    hasRequiredMethod = 1, method = H;
    var K = requireObject();
    ((H.prototype = Object.create(K.prototype)).constructor = H).className = "Method";
    var C = requireUtil();

    function H(W, U, G, X, Z, Q, ee, ne, te) {
        if (C.isObject(Z) ? (ee = Z, Z = Q = void 0) : C.isObject(Q) && (ee = Q, Q = void 0), !(U === void 0 || C.isString(
                U))) throw TypeError("type must be a string");
        if (!C.isString(G)) throw TypeError("requestType must be a string");
        if (!C.isString(X)) throw TypeError("responseType must be a string");
        K.call(this, W, ee), this.type = U || "rpc", this.requestType = G, this.requestStream = Z ? !0 : void 0, this.responseType =
            X, this.responseStream = Q ? !0 : void 0, this.resolvedRequestType = null, this.resolvedResponseType = null,
            this.comment = ne, this.parsedOptions = te
    }
    return H.fromJSON = function (U, G) {
        return new H(U, G.type, G.requestType, G.responseType, G.requestStream, G.responseStream, G.options, G.comment,
            G.parsedOptions)
    }, H.prototype.toJSON = function (U) {
        var G = U ? !!U.keepComments : !1;
        return C.toObject(["type", this.type !== "rpc" && this.type || void 0, "requestType", this.requestType,
            "requestStream", this.requestStream, "responseType", this.responseType, "responseStream", this.responseStream,
            "options", this.options, "comment", G ? this.comment : void 0, "parsedOptions", this.parsedOptions
            ])
    }, H.prototype.resolve = function () {
        return this.resolved ? this : (this.resolvedRequestType = this.parent.lookupType(this.requestType), this.resolvedResponseType =
            this.parent.lookupType(this.responseType), K.prototype.resolve.call(this))
    }, method
}
var service, hasRequiredService;

function requireService() {
    if (hasRequiredService) return service;
    hasRequiredService = 1, service = U;
    var K = requireNamespace();
    ((U.prototype = Object.create(K.prototype)).constructor = U).className = "Service";
    var C = requireMethod(),
        H = requireUtil(),
        W = rpc;

    function U(X, Z) {
        K.call(this, X, Z), this.methods = {}, this._methodsArray = null
    }
    U.fromJSON = function (Z, Q) {
        var ee = new U(Z, Q.options);
        if (Q.methods)
            for (var ne = Object.keys(Q.methods), te = 0; te < ne.length; ++te) ee.add(C.fromJSON(ne[te], Q.methods[
                ne[te]]));
        return Q.nested && ee.addJSON(Q.nested), ee.comment = Q.comment, ee
    }, U.prototype.toJSON = function (Z) {
        var Q = K.prototype.toJSON.call(this, Z),
            ee = Z ? !!Z.keepComments : !1;
        return H.toObject(["options", Q && Q.options || void 0, "methods", K.arrayToJSON(this.methodsArray, Z) || {},
            "nested", Q && Q.nested || void 0, "comment", ee ? this.comment : void 0])
    }, Object.defineProperty(U.prototype, "methodsArray", {
        get: function () {
            return this._methodsArray || (this._methodsArray = H.toArray(this.methods))
        }
    });

    function G(X) {
        return X._methodsArray = null, X
    }
    return U.prototype.get = function (Z) {
        return this.methods[Z] || K.prototype.get.call(this, Z)
    }, U.prototype.resolveAll = function () {
        for (var Z = this.methodsArray, Q = 0; Q < Z.length; ++Q) Z[Q].resolve();
        return K.prototype.resolve.call(this)
    }, U.prototype.add = function (Z) {
        if (this.get(Z.name)) throw Error("duplicate name '" + Z.name + "' in " + this);
        return Z instanceof C ? (this.methods[Z.name] = Z, Z.parent = this, G(this)) : K.prototype.add.call(this, Z)
    }, U.prototype.remove = function (Z) {
        if (Z instanceof C) {
            if (this.methods[Z.name] !== Z) throw Error(Z + " is not a member of " + this);
            return delete this.methods[Z.name], Z.parent = null, G(this)
        }
        return K.prototype.remove.call(this, Z)
    }, U.prototype.create = function (Z, Q, ee) {
        for (var ne = new W.Service(Z, Q, ee), te = 0, re; te < this.methodsArray.length; ++te) {
            var ae = H.lcFirst((re = this._methodsArray[te]).resolve().name).replace(/[^$\w_]/g, "");
            ne[ae] = H.codegen(["r", "c"], H.isReserved(ae) ? ae + "_" : ae)("return this.rpcCall(m,q,s,r,c)")({
                m: re,
                q: re.resolvedRequestType.ctor,
                s: re.resolvedResponseType.ctor
            })
        }
        return ne
    }, service
}
var message = Message,
    util$1 = requireMinimal();

function Message(K) {
    if (K)
        for (var C = Object.keys(K), H = 0; H < C.length; ++H) this[C[H]] = K[C[H]]
}
Message.create = function K(C) {
    return this.$type.create(C)
};
Message.encode = function K(C, H) {
    return this.$type.encode(C, H)
};
Message.encodeDelimited = function K(C, H) {
    return this.$type.encodeDelimited(C, H)
};
Message.decode = function K(C) {
    return this.$type.decode(C)
};
Message.decodeDelimited = function K(C) {
    return this.$type.decodeDelimited(C)
};
Message.verify = function K(C) {
    return this.$type.verify(C)
};
Message.fromObject = function K(C) {
    return this.$type.fromObject(C)
};
Message.toObject = function K(C, H) {
    return this.$type.toObject(C, H)
};
Message.prototype.toJSON = function K() {
    return this.$type.toObject(this, util$1.toJSONOptions)
};
var decoder_1, hasRequiredDecoder;

function requireDecoder() {
    if (hasRequiredDecoder) return decoder_1;
    hasRequiredDecoder = 1, decoder_1 = U;
    var K = require_enum(),
        C = requireTypes(),
        H = requireUtil();

    function W(G) {
        return "missing required '" + G.name + "'"
    }

    function U(G) {
        var X = H.codegen(["r", "l"], G.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")(
            "var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (G.fieldsArray.filter(function (re) {
                return re.map
            }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()");
        G.group && X("if((t&7)===4)")("break"), X("switch(t>>>3){");
        for (var Z = 0; Z < G.fieldsArray.length; ++Z) {
            var Q = G._fieldsArray[Z].resolve(),
                ee = Q.resolvedType instanceof K ? "int32" : Q.type,
                ne = "m" + H.safeProp(Q.name);
            X("case %i: {", Q.id), Q.map ? (X("if(%s===util.emptyObject)", ne)("%s={}", ne)("var c2 = r.uint32()+r.pos"),
                    C.defaults[Q.keyType] !== void 0 ? X("k=%j", C.defaults[Q.keyType]) : X("k=null"), C.defaults[ee] !==
                    void 0 ? X("value=%j", C.defaults[ee]) : X("value=null"), X("while(r.pos<c2){")(
                        "var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", Q.keyType)("case 2:"), C
                    .basic[ee] === void 0 ? X("value=types[%i].decode(r,r.uint32())", Z) : X("value=r.%s()", ee), X(
                        "break")("default:")("r.skipType(tag2&7)")("break")("}")("}"), C.long[Q.keyType] !== void 0 ? X(
                        '%s[typeof k==="object"?util.longToHash(k):k]=value', ne) : X("%s[k]=value", ne)) : Q.repeated ?
                (X("if(!(%s&&%s.length))", ne, ne)("%s=[]", ne), C.packed[ee] !== void 0 && X("if((t&7)===2){")(
                        "var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ne, ee)("}else"), C.basic[ee] ===
                    void 0 ? X(Q.resolvedType.group ? "%s.push(types[%i].decode(r))" :
                        "%s.push(types[%i].decode(r,r.uint32()))", ne, Z) : X("%s.push(r.%s())", ne, ee)) : C.basic[ee] ===
                void 0 ? X(Q.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", ne, Z) :
                X("%s=r.%s()", ne, ee), X("break")("}")
        }
        for (X("default:")("r.skipType(t&7)")("break")("}")("}"), Z = 0; Z < G._fieldsArray.length; ++Z) {
            var te = G._fieldsArray[Z];
            te.required && X("if(!m.hasOwnProperty(%j))", te.name)("throw util.ProtocolError(%j,{instance:m})", W(te))
        }
        return X("return m")
    }
    return decoder_1
}
var verifier_1, hasRequiredVerifier;

function requireVerifier() {
    if (hasRequiredVerifier) return verifier_1;
    hasRequiredVerifier = 1, verifier_1 = G;
    var K = require_enum(),
        C = requireUtil();

    function H(X, Z) {
        return X.name + ": " + Z + (X.repeated && Z !== "array" ? "[]" : X.map && Z !== "object" ? "{k:" + X.keyType +
            "}" : "") + " expected"
    }

    function W(X, Z, Q, ee) {
        if (Z.resolvedType)
            if (Z.resolvedType instanceof K) {
                X("switch(%s){", ee)("default:")("return%j", H(Z, "enum value"));
                for (var ne = Object.keys(Z.resolvedType.values), te = 0; te < ne.length; ++te) X("case %i:", Z.resolvedType
                    .values[ne[te]]);
                X("break")("}")
            } else X("{")("var e=types[%i].verify(%s);", Q, ee)("if(e)")("return%j+e", Z.name + ".")("}");
        else switch (Z.type) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32":
                X("if(!util.isInteger(%s))", ee)("return%j", H(Z, "integer"));
                break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64":
                X("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ee, ee, ee, ee)
                    ("return%j", H(Z, "integer|Long"));
                break;
            case "float":
            case "double":
                X('if(typeof %s!=="number")', ee)("return%j", H(Z, "number"));
                break;
            case "bool":
                X('if(typeof %s!=="boolean")', ee)("return%j", H(Z, "boolean"));
                break;
            case "string":
                X("if(!util.isString(%s))", ee)("return%j", H(Z, "string"));
                break;
            case "bytes":
                X('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', ee, ee, ee)("return%j", H(Z,
                    "buffer"));
                break
        }
        return X
    }

    function U(X, Z, Q) {
        switch (Z.keyType) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32":
                X("if(!util.key32Re.test(%s))", Q)("return%j", H(Z, "integer key"));
                break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64":
                X("if(!util.key64Re.test(%s))", Q)("return%j", H(Z, "integer|Long key"));
                break;
            case "bool":
                X("if(!util.key2Re.test(%s))", Q)("return%j", H(Z, "boolean key"));
                break
        }
        return X
    }

    function G(X) {
        var Z = C.codegen(["m"], X.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected"),
            Q = X.oneofsArray,
            ee = {};
        Q.length && Z("var p={}");
        for (var ne = 0; ne < X.fieldsArray.length; ++ne) {
            var te = X._fieldsArray[ne].resolve(),
                re = "m" + C.safeProp(te.name);
            if (te.optional && Z("if(%s!=null&&m.hasOwnProperty(%j)){", re, te.name), te.map) Z(
                "if(!util.isObject(%s))", re)("return%j", H(te, "object"))("var k=Object.keys(%s)", re)(
                "for(var i=0;i<k.length;++i){"), U(Z, te, "k[i]"), W(Z, te, ne, re + "[k[i]]")("}");
            else if (te.repeated) Z("if(!Array.isArray(%s))", re)("return%j", H(te, "array"))(
                "for(var i=0;i<%s.length;++i){", re), W(Z, te, ne, re + "[i]")("}");
            else {
                if (te.partOf) {
                    var ae = C.safeProp(te.partOf.name);
                    ee[te.partOf.name] === 1 && Z("if(p%s===1)", ae)("return%j", te.partOf.name + ": multiple values"),
                        ee[te.partOf.name] = 1, Z("p%s=1", ae)
                }
                W(Z, te, ne, re)
            }
            te.optional && Z("}")
        }
        return Z("return null")
    }
    return verifier_1
}
var converter = {},
    hasRequiredConverter;

function requireConverter() {
    return hasRequiredConverter || (hasRequiredConverter = 1, function (K) {
        var C = K,
            H = require_enum(),
            W = requireUtil();

        function U(X, Z, Q, ee) {
            var ne = !1;
            if (Z.resolvedType)
                if (Z.resolvedType instanceof H) {
                    X("switch(d%s){", ee);
                    for (var te = Z.resolvedType.values, re = Object.keys(te), ae = 0; ae < re.length; ++ae) te[
                        re[ae]] === Z.typeDefault && !ne && (X("default:")(
                        'if(typeof(d%s)==="number"){m%s=d%s;break}', ee, ee, ee), Z.repeated || X(
                        "break"), ne = !0), X("case%j:", re[ae])("case %i:", te[re[ae]])("m%s=%j", ee, te[
                        re[ae]])("break");
                    X("}")
                } else X('if(typeof d%s!=="object")', ee)("throw TypeError(%j)", Z.fullName +
                    ": object expected")("m%s=types[%i].fromObject(d%s)", ee, Q, ee);
            else {
                var oe = !1;
                switch (Z.type) {
                    case "double":
                    case "float":
                        X("m%s=Number(d%s)", ee, ee);
                        break;
                    case "uint32":
                    case "fixed32":
                        X("m%s=d%s>>>0", ee, ee);
                        break;
                    case "int32":
                    case "sint32":
                    case "sfixed32":
                        X("m%s=d%s|0", ee, ee);
                        break;
                    case "uint64":
                        oe = !0;
                    case "int64":
                    case "sint64":
                    case "fixed64":
                    case "sfixed64":
                        X("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", ee, ee, oe)(
                            'else if(typeof d%s==="string")', ee)("m%s=parseInt(d%s,10)", ee, ee)(
                            'else if(typeof d%s==="number")', ee)("m%s=d%s", ee, ee)(
                            'else if(typeof d%s==="object")', ee)(
                            "m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", ee, ee, ee, oe ?
                            "true" : "");
                        break;
                    case "bytes":
                        X('if(typeof d%s==="string")', ee)(
                            "util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", ee, ee,
                            ee)("else if(d%s.length >= 0)", ee)("m%s=d%s", ee, ee);
                        break;
                    case "string":
                        X("m%s=String(d%s)", ee, ee);
                        break;
                    case "bool":
                        X("m%s=Boolean(d%s)", ee, ee);
                        break
                }
            }
            return X
        }
        C.fromObject = function (Z) {
            var Q = Z.fieldsArray,
                ee = W.codegen(["d"], Z.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
            if (!Q.length) return ee("return new this.ctor");
            ee("var m=new this.ctor");
            for (var ne = 0; ne < Q.length; ++ne) {
                var te = Q[ne].resolve(),
                    re = W.safeProp(te.name);
                te.map ? (ee("if(d%s){", re)('if(typeof d%s!=="object")', re)("throw TypeError(%j)", te.fullName +
                    ": object expected")("m%s={}", re)(
                    "for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", re), U(ee, te, ne, re +
                    "[ks[i]]")("}")("}")) : te.repeated ? (ee("if(d%s){", re)("if(!Array.isArray(d%s))",
                    re)("throw TypeError(%j)", te.fullName + ": array expected")("m%s=[]", re)(
                    "for(var i=0;i<d%s.length;++i){", re), U(ee, te, ne, re + "[i]")("}")("}")) : (te.resolvedType instanceof H ||
                    ee("if(d%s!=null){", re), U(ee, te, ne, re), te.resolvedType instanceof H || ee("}")
                )
            }
            return ee("return m")
        };

        function G(X, Z, Q, ee) {
            if (Z.resolvedType) Z.resolvedType instanceof H ? X(
                "d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s",
                ee, Q, ee, ee, Q, ee, ee) : X("d%s=types[%i].toObject(m%s,o)", ee, Q, ee);
            else {
                var ne = !1;
                switch (Z.type) {
                    case "double":
                    case "float":
                        X("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", ee, ee, ee, ee);
                        break;
                    case "uint64":
                        ne = !0;
                    case "int64":
                    case "sint64":
                    case "fixed64":
                    case "sfixed64":
                        X('if(typeof m%s==="number")', ee)("d%s=o.longs===String?String(m%s):m%s", ee, ee, ee)(
                            "else")(
                            "d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s",
                            ee, ee, ee, ee, ne ? "true" : "", ee);
                        break;
                    case "bytes":
                        X(
                            "d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s",
                            ee, ee, ee, ee, ee);
                        break;
                    default:
                        X("d%s=m%s", ee, ee);
                        break
                }
            }
            return X
        }
        C.toObject = function (Z) {
            var Q = Z.fieldsArray.slice().sort(W.compareFieldsById);
            if (!Q.length) return W.codegen()("return {}");
            for (var ee = W.codegen(["m", "o"], Z.name + "$toObject")("if(!o)")("o={}")("var d={}"), ne = [],
                    te = [], re = [], ae = 0; ae < Q.length; ++ae) Q[ae].partOf || (Q[ae].resolve().repeated ?
                ne : Q[ae].map ? te : re).push(Q[ae]);
            if (ne.length) {
                for (ee("if(o.arrays||o.defaults){"), ae = 0; ae < ne.length; ++ae) ee("d%s=[]", W.safeProp(
                    ne[ae].name));
                ee("}")
            }
            if (te.length) {
                for (ee("if(o.objects||o.defaults){"), ae = 0; ae < te.length; ++ae) ee("d%s={}", W.safeProp(
                    te[ae].name));
                ee("}")
            }
            if (re.length) {
                for (ee("if(o.defaults){"), ae = 0; ae < re.length; ++ae) {
                    var oe = re[ae],
                        ie = W.safeProp(oe.name);
                    if (oe.resolvedType instanceof H) ee("d%s=o.enums===String?%j:%j", ie, oe.resolvedType.valuesById[
                        oe.typeDefault], oe.typeDefault);
                    else if (oe.long) ee("if(util.Long){")("var n=new util.Long(%i,%i,%j)", oe.typeDefault.low,
                        oe.typeDefault.high, oe.typeDefault.unsigned)(
                        "d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", ie)(
                        "}else")("d%s=o.longs===String?%j:%i", ie, oe.typeDefault.toString(), oe.typeDefault
                        .toNumber());
                    else if (oe.bytes) {
                        var ue = "[" + Array.prototype.slice.call(oe.typeDefault).join(",") + "]";
                        ee("if(o.bytes===String)d%s=%j", ie, String.fromCharCode.apply(String, oe.typeDefault))
                            ("else{")("d%s=%s", ie, ue)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", ie,
                                ie)("}")
                    } else ee("d%s=%j", ie, oe.typeDefault)
                }
                ee("}")
            }
            var le = !1;
            for (ae = 0; ae < Q.length; ++ae) {
                var oe = Q[ae],
                    se = Z._fieldsArray.indexOf(oe),
                    ie = W.safeProp(oe.name);
                oe.map ? (le || (le = !0, ee("var ks2")), ee("if(m%s&&(ks2=Object.keys(m%s)).length){", ie,
                    ie)("d%s={}", ie)("for(var j=0;j<ks2.length;++j){"), G(ee, oe, se, ie +
                    "[ks2[j]]")("}")) : oe.repeated ? (ee("if(m%s&&m%s.length){", ie, ie)("d%s=[]", ie)
                    ("for(var j=0;j<m%s.length;++j){", ie), G(ee, oe, se, ie + "[j]")("}")) : (ee(
                        "if(m%s!=null&&m.hasOwnProperty(%j)){", ie, oe.name), G(ee, oe, se, ie), oe.partOf &&
                    ee("if(o.oneofs)")("d%s=%j", W.safeProp(oe.partOf.name), oe.name)), ee("}")
            }
            return ee("return d")
        }
    }(converter)), converter
}
var wrappers = {};
(function (K) {
    var C = K,
        H = message;
    C[".google.protobuf.Any"] = {
        fromObject: function (W) {
            if (W && W["@type"]) {
                var U = W["@type"].substring(W["@type"].lastIndexOf("/") + 1),
                    G = this.lookup(U);
                if (G) {
                    var X = W["@type"].charAt(0) === "." ? W["@type"].slice(1) : W["@type"];
                    return X.indexOf("/") === -1 && (X = "/" + X), this.create({
                        type_url: X,
                        value: G.encode(G.fromObject(W)).finish()
                    })
                }
            }
            return this.fromObject(W)
        },
        toObject: function (W, U) {
            var G = "type.googleapis.com/",
                X = "",
                Z = "";
            if (U && U.json && W.type_url && W.value) {
                Z = W.type_url.substring(W.type_url.lastIndexOf("/") + 1), X = W.type_url.substring(0, W.type_url
                    .lastIndexOf("/") + 1);
                var Q = this.lookup(Z);
                Q && (W = Q.decode(W.value))
            }
            if (!(W instanceof this.ctor) && W instanceof H) {
                var ee = W.$type.toObject(W, U),
                    ne = W.$type.fullName[0] === "." ? W.$type.fullName.slice(1) : W.$type.fullName;
                return X === "" && (X = G), Z = X + ne, ee["@type"] = Z, ee
            }
            return this.toObject(W, U)
        }
    }
})(wrappers);
var type, hasRequiredType;

function requireType() {
    if (hasRequiredType) return type;
    hasRequiredType = 1, type = ie;
    var K = requireNamespace();
    ((ie.prototype = Object.create(K.prototype)).constructor = ie).className = "Type";
    var C = require_enum(),
        H = requireOneof(),
        W = requireField(),
        U = requireMapfield(),
        G = requireService(),
        X = message,
        Z = reader,
        Q = writer,
        ee = requireUtil(),
        ne = requireEncoder(),
        te = requireDecoder(),
        re = requireVerifier(),
        ae = requireConverter(),
        oe = wrappers;

    function ie(le, se) {
        K.call(this, le, se), this.fields = {}, this.oneofs = void 0, this.extensions = void 0, this.reserved = void 0,
            this.group = void 0, this._fieldsById = null, this._fieldsArray = null, this._oneofsArray = null, this._ctor =
            null
    }
    Object.defineProperties(ie.prototype, {
        fieldsById: {
            get: function () {
                if (this._fieldsById) return this._fieldsById;
                this._fieldsById = {};
                for (var le = Object.keys(this.fields), se = 0; se < le.length; ++se) {
                    var ce = this.fields[le[se]],
                        de = ce.id;
                    if (this._fieldsById[de]) throw Error("duplicate id " + de + " in " + this);
                    this._fieldsById[de] = ce
                }
                return this._fieldsById
            }
        },
        fieldsArray: {
            get: function () {
                return this._fieldsArray || (this._fieldsArray = ee.toArray(this.fields))
            }
        },
        oneofsArray: {
            get: function () {
                return this._oneofsArray || (this._oneofsArray = ee.toArray(this.oneofs))
            }
        },
        ctor: {
            get: function () {
                return this._ctor || (this.ctor = ie.generateConstructor(this)())
            },
            set: function (le) {
                var se = le.prototype;
                se instanceof X || ((le.prototype = new X).constructor = le, ee.merge(le.prototype, se)),
                    le.$type = le.prototype.$type = this, ee.merge(le, X, !0), this._ctor = le;
                for (var ce = 0; ce < this.fieldsArray.length; ++ce) this._fieldsArray[ce].resolve();
                var de = {};
                for (ce = 0; ce < this.oneofsArray.length; ++ce) de[this._oneofsArray[ce].resolve().name] = {
                    get: ee.oneOfGetter(this._oneofsArray[ce].oneof),
                    set: ee.oneOfSetter(this._oneofsArray[ce].oneof)
                };
                ce && Object.defineProperties(le.prototype, de)
            }
        }
    }), ie.generateConstructor = function (se) {
        for (var ce = ee.codegen(["p"], se.name), de = 0, ve; de < se.fieldsArray.length; ++de)(ve = se._fieldsArray[
            de]).map ? ce("this%s={}", ee.safeProp(ve.name)) : ve.repeated && ce("this%s=[]", ee.safeProp(ve.name));
        return ce("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]")
    };

    function ue(le) {
        return le._fieldsById = le._fieldsArray = le._oneofsArray = null, delete le.encode, delete le.decode, delete le
            .verify, le
    }
    return ie.fromJSON = function (se, ce) {
        var de = new ie(se, ce.options);
        de.extensions = ce.extensions, de.reserved = ce.reserved;
        for (var ve = Object.keys(ce.fields), fe = 0; fe < ve.length; ++fe) de.add((typeof ce.fields[ve[fe]].keyType <
            "u" ? U.fromJSON : W.fromJSON)(ve[fe], ce.fields[ve[fe]]));
        if (ce.oneofs)
            for (ve = Object.keys(ce.oneofs), fe = 0; fe < ve.length; ++fe) de.add(H.fromJSON(ve[fe], ce.oneofs[ve[
                fe]]));
        if (ce.nested)
            for (ve = Object.keys(ce.nested), fe = 0; fe < ve.length; ++fe) {
                var pe = ce.nested[ve[fe]];
                de.add((pe.id !== void 0 ? W.fromJSON : pe.fields !== void 0 ? ie.fromJSON : pe.values !== void 0 ?
                    C.fromJSON : pe.methods !== void 0 ? G.fromJSON : K.fromJSON)(ve[fe], pe))
            }
        return ce.extensions && ce.extensions.length && (de.extensions = ce.extensions), ce.reserved && ce.reserved
            .length && (de.reserved = ce.reserved), ce.group && (de.group = !0), ce.comment && (de.comment = ce.comment),
            de
    }, ie.prototype.toJSON = function (se) {
        var ce = K.prototype.toJSON.call(this, se),
            de = se ? !!se.keepComments : !1;
        return ee.toObject(["options", ce && ce.options || void 0, "oneofs", K.arrayToJSON(this.oneofsArray, se),
            "fields", K.arrayToJSON(this.fieldsArray.filter(function (ve) {
                return !ve.declaringField
            }), se) || {}, "extensions", this.extensions && this.extensions.length ? this.extensions : void 0,
            "reserved", this.reserved && this.reserved.length ? this.reserved : void 0, "group", this.group ||
            void 0, "nested", ce && ce.nested || void 0, "comment", de ? this.comment : void 0])
    }, ie.prototype.resolveAll = function () {
        for (var se = this.fieldsArray, ce = 0; ce < se.length;) se[ce++].resolve();
        var de = this.oneofsArray;
        for (ce = 0; ce < de.length;) de[ce++].resolve();
        return K.prototype.resolveAll.call(this)
    }, ie.prototype.get = function (se) {
        return this.fields[se] || this.oneofs && this.oneofs[se] || this.nested && this.nested[se] || null
    }, ie.prototype.add = function (se) {
        if (this.get(se.name)) throw Error("duplicate name '" + se.name + "' in " + this);
        if (se instanceof W && se.extend === void 0) {
            if (this._fieldsById ? this._fieldsById[se.id] : this.fieldsById[se.id]) throw Error("duplicate id " +
                se.id + " in " + this);
            if (this.isReservedId(se.id)) throw Error("id " + se.id + " is reserved in " + this);
            if (this.isReservedName(se.name)) throw Error("name '" + se.name + "' is reserved in " + this);
            return se.parent && se.parent.remove(se), this.fields[se.name] = se, se.message = this, se.onAdd(this),
                ue(this)
        }
        return se instanceof H ? (this.oneofs || (this.oneofs = {}), this.oneofs[se.name] = se, se.onAdd(this), ue(
            this)) : K.prototype.add.call(this, se)
    }, ie.prototype.remove = function (se) {
        if (se instanceof W && se.extend === void 0) {
            if (!this.fields || this.fields[se.name] !== se) throw Error(se + " is not a member of " + this);
            return delete this.fields[se.name], se.parent = null, se.onRemove(this), ue(this)
        }
        if (se instanceof H) {
            if (!this.oneofs || this.oneofs[se.name] !== se) throw Error(se + " is not a member of " + this);
            return delete this.oneofs[se.name], se.parent = null, se.onRemove(this), ue(this)
        }
        return K.prototype.remove.call(this, se)
    }, ie.prototype.isReservedId = function (se) {
        return K.isReservedId(this.reserved, se)
    }, ie.prototype.isReservedName = function (se) {
        return K.isReservedName(this.reserved, se)
    }, ie.prototype.create = function (se) {
        return new this.ctor(se)
    }, ie.prototype.setup = function () {
        for (var se = this.fullName, ce = [], de = 0; de < this.fieldsArray.length; ++de) ce.push(this._fieldsArray[
            de].resolve().resolvedType);
        this.encode = ne(this)({
            Writer: Q,
            types: ce,
            util: ee
        }), this.decode = te(this)({
            Reader: Z,
            types: ce,
            util: ee
        }), this.verify = re(this)({
            types: ce,
            util: ee
        }), this.fromObject = ae.fromObject(this)({
            types: ce,
            util: ee
        }), this.toObject = ae.toObject(this)({
            types: ce,
            util: ee
        });
        var ve = oe[se];
        if (ve) {
            var fe = Object.create(this);
            fe.fromObject = this.fromObject, this.fromObject = ve.fromObject.bind(fe), fe.toObject = this.toObject,
                this.toObject = ve.toObject.bind(fe)
        }
        return this
    }, ie.prototype.encode = function (se, ce) {
        return this.setup().encode(se, ce)
    }, ie.prototype.encodeDelimited = function (se, ce) {
        return this.encode(se, ce && ce.len ? ce.fork() : ce).ldelim()
    }, ie.prototype.decode = function (se, ce) {
        return this.setup().decode(se, ce)
    }, ie.prototype.decodeDelimited = function (se) {
        return se instanceof Z || (se = Z.create(se)), this.decode(se, se.uint32())
    }, ie.prototype.verify = function (se) {
        return this.setup().verify(se)
    }, ie.prototype.fromObject = function (se) {
        return this.setup().fromObject(se)
    }, ie.prototype.toObject = function (se, ce) {
        return this.setup().toObject(se, ce)
    }, ie.d = function (se) {
        return function (de) {
            ee.decorateType(de, se)
        }
    }, type
}
var root, hasRequiredRoot;

function requireRoot() {
    if (hasRequiredRoot) return root;
    hasRequiredRoot = 1, root = Q;
    var K = requireNamespace();
    ((Q.prototype = Object.create(K.prototype)).constructor = Q).className = "Root";
    var C = requireField(),
        H = require_enum(),
        W = requireOneof(),
        U = requireUtil(),
        G, X, Z;

    function Q(re) {
        K.call(this, "", re), this.deferred = [], this.files = []
    }
    Q.fromJSON = function (ae, oe) {
        return oe || (oe = new Q), ae.options && oe.setOptions(ae.options), oe.addJSON(ae.nested)
    }, Q.prototype.resolvePath = U.path.resolve, Q.prototype.fetch = U.fetch;

    function ee() {}
    Q.prototype.load = function re(ae, oe, ie) {
        typeof oe == "function" && (ie = oe, oe = void 0);
        var ue = this;
        if (!ie) return U.asPromise(re, ue, ae, oe);
        var le = ie === ee;

        function se(he, Se) {
            if (ie) {
                var _e = ie;
                if (ie = null, le) throw he;
                _e(he, Se)
            }
        }

        function ce(he) {
            var Se = he.lastIndexOf("google/protobuf/");
            if (Se > -1) {
                var _e = he.substring(Se);
                if (_e in Z) return _e
            }
            return null
        }

        function de(he, Se) {
            try {
                if (U.isString(Se) && Se.charAt(0) === "{" && (Se = JSON.parse(Se)), !U.isString(Se)) ue.setOptions(
                    Se.options).addJSON(Se.nested);
                else {
                    X.filename = he;
                    var _e = X(Se, ue, oe),
                        be, ge = 0;
                    if (_e.imports)
                        for (; ge < _e.imports.length; ++ge)(be = ce(_e.imports[ge]) || ue.resolvePath(he, _e.imports[
                            ge])) && ve(be);
                    if (_e.weakImports)
                        for (ge = 0; ge < _e.weakImports.length; ++ge)(be = ce(_e.weakImports[ge]) || ue.resolvePath(
                            he, _e.weakImports[ge])) && ve(be, !0)
                }
            } catch (xe) {
                se(xe)
            }!le && !fe && se(null, ue)
        }

        function ve(he, Se) {
            if (he = ce(he) || he, !(ue.files.indexOf(he) > -1)) {
                if (ue.files.push(he), he in Z) {
                    le ? de(he, Z[he]) : (++fe, setTimeout(function () {
                        --fe, de(he, Z[he])
                    }));
                    return
                }
                if (le) {
                    var _e;
                    try {
                        _e = U.fs.readFileSync(he).toString("utf8")
                    } catch (be) {
                        Se || se(be);
                        return
                    }
                    de(he, _e)
                } else ++fe, ue.fetch(he, function (be, ge) {
                    if (--fe, !!ie) {
                        if (be) {
                            Se ? fe || se(null, ue) : se(be);
                            return
                        }
                        de(he, ge)
                    }
                })
            }
        }
        var fe = 0;
        U.isString(ae) && (ae = [ae]);
        for (var pe = 0, me; pe < ae.length; ++pe)(me = ue.resolvePath("", ae[pe])) && ve(me);
        if (le) return ue;
        fe || se(null, ue)
    }, Q.prototype.loadSync = function (ae, oe) {
        if (!U.isNode) throw Error("not supported");
        return this.load(ae, oe, ee)
    }, Q.prototype.resolveAll = function () {
        if (this.deferred.length) throw Error("unresolvable extensions: " + this.deferred.map(function (ae) {
            return "'extend " + ae.extend + "' in " + ae.parent.fullName
        }).join(", "));
        return K.prototype.resolveAll.call(this)
    };
    var ne = /^[A-Z]/;

    function te(re, ae) {
        var oe = ae.parent.lookup(ae.extend);
        if (oe) {
            var ie = new C(ae.fullName, ae.id, ae.type, ae.rule, void 0, ae.options);
            return oe.get(ie.name) || (ie.declaringField = ae, ae.extensionField = ie, oe.add(ie)), !0
        }
        return !1
    }
    return Q.prototype._handleAdd = function (ae) {
        if (ae instanceof C) ae.extend !== void 0 && !ae.extensionField && (te(this, ae) || this.deferred.push(ae));
        else if (ae instanceof H) ne.test(ae.name) && (ae.parent[ae.name] = ae.values);
        else if (!(ae instanceof W)) {
            if (ae instanceof G)
                for (var oe = 0; oe < this.deferred.length;) te(this, this.deferred[oe]) ? this.deferred.splice(oe,
                    1) : ++oe;
            for (var ie = 0; ie < ae.nestedArray.length; ++ie) this._handleAdd(ae._nestedArray[ie]);
            ne.test(ae.name) && (ae.parent[ae.name] = ae)
        }
    }, Q.prototype._handleRemove = function (ae) {
        if (ae instanceof C) {
            if (ae.extend !== void 0)
                if (ae.extensionField) ae.extensionField.parent.remove(ae.extensionField), ae.extensionField = null;
                else {
                    var oe = this.deferred.indexOf(ae);
                    oe > -1 && this.deferred.splice(oe, 1)
                }
        } else if (ae instanceof H) ne.test(ae.name) && delete ae.parent[ae.name];
        else if (ae instanceof K) {
            for (var ie = 0; ie < ae.nestedArray.length; ++ie) this._handleRemove(ae._nestedArray[ie]);
            ne.test(ae.name) && delete ae.parent[ae.name]
        }
    }, Q._configure = function (re, ae, oe) {
        G = re, X = ae, Z = oe
    }, root
}
var hasRequiredUtil;

function requireUtil() {
    return hasRequiredUtil || (hasRequiredUtil = 1, function (K) {
        var C = K.exports = requireMinimal(),
            H = roots,
            W, U;
        C.codegen = codegen_1, C.fetch = fetch_1, C.path = path, C.fs = C.inquire("fs"), C.toArray = function (
            ne) {
            if (ne) {
                for (var te = Object.keys(ne), re = new Array(te.length), ae = 0; ae < te.length;) re[ae] =
                    ne[te[ae++]];
                return re
            }
            return []
        }, C.toObject = function (ne) {
            for (var te = {}, re = 0; re < ne.length;) {
                var ae = ne[re++],
                    oe = ne[re++];
                oe !== void 0 && (te[ae] = oe)
            }
            return te
        };
        var G = /\\/g,
            X = /"/g;
        C.isReserved = function (ne) {
            return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/
                .test(ne)
        }, C.safeProp = function (ne) {
            return !/^[$\w_]+$/.test(ne) || C.isReserved(ne) ? '["' + ne.replace(G, "\\\\").replace(X,
                '\\"') + '"]' : "." + ne
        }, C.ucFirst = function (ne) {
            return ne.charAt(0).toUpperCase() + ne.substring(1)
        };
        var Z = /_([a-z])/g;
        C.camelCase = function (ne) {
            return ne.substring(0, 1) + ne.substring(1).replace(Z, function (te, re) {
                return re.toUpperCase()
            })
        }, C.compareFieldsById = function (ne, te) {
            return ne.id - te.id
        }, C.decorateType = function (ne, te) {
            if (ne.$type) return te && ne.$type.name !== te && (C.decorateRoot.remove(ne.$type), ne.$type.name =
                te, C.decorateRoot.add(ne.$type)), ne.$type;
            W || (W = requireType());
            var re = new W(te || ne.name);
            return C.decorateRoot.add(re), re.ctor = ne, Object.defineProperty(ne, "$type", {
                value: re,
                enumerable: !1
            }), Object.defineProperty(ne.prototype, "$type", {
                value: re,
                enumerable: !1
            }), re
        };
        var Q = 0;
        C.decorateEnum = function (ne) {
            if (ne.$type) return ne.$type;
            U || (U = require_enum());
            var te = new U("Enum" + Q++, ne);
            return C.decorateRoot.add(te), Object.defineProperty(ne, "$type", {
                value: te,
                enumerable: !1
            }), te
        }, C.setProperty = function (ne, te, re) {
            function ae(oe, ie, ue) {
                var le = ie.shift();
                if (le === "__proto__") return oe;
                if (ie.length > 0) oe[le] = ae(oe[le] || {}, ie, ue);
                else {
                    var se = oe[le];
                    se && (ue = [].concat(se).concat(ue)), oe[le] = ue
                }
                return oe
            }
            if (typeof ne != "object") throw TypeError("dst must be an object");
            if (!te) throw TypeError("path must be specified");
            return te = te.split("."), ae(ne, te, re)
        }, Object.defineProperty(C, "decorateRoot", {
            get: function () {
                return H.decorated || (H.decorated = new(requireRoot()))
            }
        })
    }(util$2)), utilExports
}
var object, hasRequiredObject;

function requireObject() {
    if (hasRequiredObject) return object;
    hasRequiredObject = 1, object = H, H.className = "ReflectionObject";
    var K = requireUtil(),
        C;

    function H(W, U) {
        if (!K.isString(W)) throw TypeError("name must be a string");
        if (U && !K.isObject(U)) throw TypeError("options must be an object");
        this.options = U, this.parsedOptions = null, this.name = W, this.parent = null, this.resolved = !1, this.comment =
            null, this.filename = null
    }
    return Object.defineProperties(H.prototype, {
        root: {
            get: function () {
                for (var W = this; W.parent !== null;) W = W.parent;
                return W
            }
        },
        fullName: {
            get: function () {
                for (var W = [this.name], U = this.parent; U;) W.unshift(U.name), U = U.parent;
                return W.join(".")
            }
        }
    }), H.prototype.toJSON = function () {
        throw Error()
    }, H.prototype.onAdd = function (U) {
        this.parent && this.parent !== U && this.parent.remove(this), this.parent = U, this.resolved = !1;
        var G = U.root;
        G instanceof C && G._handleAdd(this)
    }, H.prototype.onRemove = function (U) {
        var G = U.root;
        G instanceof C && G._handleRemove(this), this.parent = null, this.resolved = !1
    }, H.prototype.resolve = function () {
        return this.resolved ? this : (this.root instanceof C && (this.resolved = !0), this)
    }, H.prototype.getOption = function (U) {
        if (this.options) return this.options[U]
    }, H.prototype.setOption = function (U, G, X) {
        return (!X || !this.options || this.options[U] === void 0) && ((this.options || (this.options = {}))[U] = G),
            this
    }, H.prototype.setParsedOption = function (U, G, X) {
        this.parsedOptions || (this.parsedOptions = []);
        var Z = this.parsedOptions;
        if (X) {
            var Q = Z.find(function (te) {
                return Object.prototype.hasOwnProperty.call(te, U)
            });
            if (Q) {
                var ee = Q[U];
                K.setProperty(ee, X, G)
            } else Q = {}, Q[U] = K.setProperty({}, X, G), Z.push(Q)
        } else {
            var ne = {};
            ne[U] = G, Z.push(ne)
        }
        return this
    }, H.prototype.setOptions = function (U, G) {
        if (U)
            for (var X = Object.keys(U), Z = 0; Z < X.length; ++Z) this.setOption(X[Z], U[X[Z]], G);
        return this
    }, H.prototype.toString = function () {
        var U = this.constructor.className,
            G = this.fullName;
        return G.length ? U + " " + G : U
    }, H._configure = function (W) {
        C = W
    }, object
}
var _enum, hasRequired_enum;

function require_enum() {
    if (hasRequired_enum) return _enum;
    hasRequired_enum = 1, _enum = W;
    var K = requireObject();
    ((W.prototype = Object.create(K.prototype)).constructor = W).className = "Enum";
    var C = requireNamespace(),
        H = requireUtil();

    function W(U, G, X, Z, Q, ee) {
        if (K.call(this, U, X), G && typeof G != "object") throw TypeError("values must be an object");
        if (this.valuesById = {}, this.values = Object.create(this.valuesById), this.comment = Z, this.comments = Q ||
            {}, this.valuesOptions = ee, this.reserved = void 0, G)
            for (var ne = Object.keys(G), te = 0; te < ne.length; ++te) typeof G[ne[te]] == "number" && (this.valuesById[
                this.values[ne[te]] = G[ne[te]]] = ne[te])
    }
    return W.fromJSON = function (G, X) {
        var Z = new W(G, X.values, X.options, X.comment, X.comments);
        return Z.reserved = X.reserved, Z
    }, W.prototype.toJSON = function (G) {
        var X = G ? !!G.keepComments : !1;
        return H.toObject(["options", this.options, "valuesOptions", this.valuesOptions, "values", this.values,
            "reserved", this.reserved && this.reserved.length ? this.reserved : void 0, "comment", X ? this
            .comment : void 0, "comments", X ? this.comments : void 0])
    }, W.prototype.add = function (G, X, Z, Q) {
        if (!H.isString(G)) throw TypeError("name must be a string");
        if (!H.isInteger(X)) throw TypeError("id must be an integer");
        if (this.values[G] !== void 0) throw Error("duplicate name '" + G + "' in " + this);
        if (this.isReservedId(X)) throw Error("id " + X + " is reserved in " + this);
        if (this.isReservedName(G)) throw Error("name '" + G + "' is reserved in " + this);
        if (this.valuesById[X] !== void 0) {
            if (!(this.options && this.options.allow_alias)) throw Error("duplicate id " + X + " in " + this);
            this.values[G] = X
        } else this.valuesById[this.values[G] = X] = G;
        return Q && (this.valuesOptions === void 0 && (this.valuesOptions = {}), this.valuesOptions[G] = Q || null),
            this.comments[G] = Z || null, this
    }, W.prototype.remove = function (G) {
        if (!H.isString(G)) throw TypeError("name must be a string");
        var X = this.values[G];
        if (X == null) throw Error("name '" + G + "' does not exist in " + this);
        return delete this.valuesById[X], delete this.values[G], delete this.comments[G], this.valuesOptions &&
            delete this.valuesOptions[G], this
    }, W.prototype.isReservedId = function (G) {
        return C.isReservedId(this.reserved, G)
    }, W.prototype.isReservedName = function (G) {
        return C.isReservedName(this.reserved, G)
    }, _enum
}
var encoder_1, hasRequiredEncoder;

function requireEncoder() {
    if (hasRequiredEncoder) return encoder_1;
    hasRequiredEncoder = 1, encoder_1 = U;
    var K = require_enum(),
        C = requireTypes(),
        H = requireUtil();

    function W(G, X, Z, Q) {
        return X.resolvedType.group ? G("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", Z, Q, (X.id << 3 | 3) >>> 0, (X
            .id << 3 | 4) >>> 0) : G("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", Z, Q, (X.id << 3 | 2) >>>
            0)
    }

    function U(G) {
        for (var X = H.codegen(["m", "w"], G.name + "$encode")("if(!w)")("w=Writer.create()"), Z, Q, ee = G.fieldsArray
                .slice().sort(H.compareFieldsById), Z = 0; Z < ee.length; ++Z) {
            var ne = ee[Z].resolve(),
                te = G._fieldsArray.indexOf(ne),
                re = ne.resolvedType instanceof K ? "int32" : ne.type,
                ae = C.basic[re];
            Q = "m" + H.safeProp(ne.name), ne.map ? (X("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", Q, ne.name)(
                "for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", Q)(
                "w.uint32(%i).fork().uint32(%i).%s(ks[i])", (ne.id << 3 | 2) >>> 0, 8 | C.mapKey[ne.keyType],
                ne.keyType), ae === void 0 ? X(
                "types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", te, Q) : X(
                ".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | ae, re, Q), X("}")("}")) : ne.repeated ? (X(
                "if(%s!=null&&%s.length){", Q, Q), ne.packed && C.packed[re] !== void 0 ? X(
                "w.uint32(%i).fork()", (ne.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", Q)("w.%s(%s[i])",
                re, Q)("w.ldelim()") : (X("for(var i=0;i<%s.length;++i)", Q), ae === void 0 ? W(X, ne, te, Q +
                "[i]") : X("w.uint32(%i).%s(%s[i])", (ne.id << 3 | ae) >>> 0, re, Q)), X("}")) : (ne.optional && X(
                    "if(%s!=null&&Object.hasOwnProperty.call(m,%j))", Q, ne.name), ae === void 0 ? W(X, ne, te, Q) :
                X("w.uint32(%i).%s(%s)", (ne.id << 3 | ae) >>> 0, re, Q))
        }
        return X("return w")
    }
    return encoder_1
}(function (K) {
    var C = K.exports = indexMinimal;
    C.build = "light";

    function H(U, G, X) {
        return typeof G == "function" ? (X = G, G = new C.Root) : G || (G = new C.Root), G.load(U, X)
    }
    C.load = H;

    function W(U, G) {
        return G || (G = new C.Root), G.loadSync(U)
    }
    C.loadSync = W, C.encoder = requireEncoder(), C.decoder = requireDecoder(), C.verifier = requireVerifier(), C.converter =
        requireConverter(), C.ReflectionObject = requireObject(), C.Namespace = requireNamespace(), C.Root =
        requireRoot(), C.Enum = require_enum(), C.Type = requireType(), C.Field = requireField(), C.OneOf =
        requireOneof(), C.MapField = requireMapfield(), C.Service = requireService(), C.Method = requireMethod(), C
        .Message = message, C.wrappers = wrappers, C.types = requireTypes(), C.util = requireUtil(), C.ReflectionObject
        ._configure(C.Root), C.Namespace._configure(C.Type, C.Service, C.Enum), C.Root._configure(C.Type), C.Field._configure(
            C.Type)
})(indexLight);
var tokenize_1 = tokenize$1,
    delimRe = /[\s{}=;:[\],'"()<>]/g,
    stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
    stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g,
    setCommentRe = /^ *[*/]+ */,
    setCommentAltRe = /^\s*\*?\/*/,
    setCommentSplitRe = /\n/g,
    whitespaceRe = /\s/,
    unescapeRe = /\\(.?)/g,
    unescapeMap = {
        0: "\0",
        r: "\r",
        n: `
`,
        t: "	"
    };

function unescape(K) {
    return K.replace(unescapeRe, function (C, H) {
        switch (H) {
            case "\\":
            case "":
                return H;
            default:
                return unescapeMap[H] || ""
        }
    })
}
tokenize$1.unescape = unescape;

function tokenize$1(K, C) {
    K = K.toString();
    var H = 0,
        W = K.length,
        U = 1,
        G = 0,
        X = {},
        Z = [],
        Q = null;

    function ee(de) {
        return Error("illegal " + de + " (line " + U + ")")
    }

    function ne() {
        var de = Q === "'" ? stringSingleRe : stringDoubleRe;
        de.lastIndex = H - 1;
        var ve = de.exec(K);
        if (!ve) throw ee("string");
        return H = de.lastIndex, ue(Q), Q = null, unescape(ve[1])
    }

    function te(de) {
        return K.charAt(de)
    }

    function re(de, ve, fe) {
        var pe = {
                type: K.charAt(de++),
                lineEmpty: !1,
                leading: fe
            },
            me;
        C ? me = 2 : me = 3;
        var he = de - me,
            Se;
        do
            if (--he < 0 || (Se = K.charAt(he)) === `
`) {
                pe.lineEmpty = !0;
                break
            } while (Se === " " || Se === "	");
        for (var _e = K.substring(de, ve).split(setCommentSplitRe), be = 0; be < _e.length; ++be) _e[be] = _e[be].replace(
            C ? setCommentAltRe : setCommentRe, "").trim();
        pe.text = _e.join(`
`).trim(), X[U] = pe, G = U
    }

    function ae(de) {
        var ve = oe(de),
            fe = K.substring(de, ve),
            pe = /^\s*\/{1,2}/.test(fe);
        return pe
    }

    function oe(de) {
        for (var ve = de; ve < W && te(ve) !== `
`;) ve++;
        return ve
    }

    function ie() {
        if (Z.length > 0) return Z.shift();
        if (Q) return ne();
        var de, ve, fe, pe, me, he = H === 0;
        do {
            if (H === W) return null;
            for (de = !1; whitespaceRe.test(fe = te(H));)
                if (fe === `
` && (he = !0, ++U), ++H === W) return null;
            if (te(H) === "/") {
                if (++H === W) throw ee("comment");
                if (te(H) === "/")
                    if (C) {
                        if (pe = H, me = !1, ae(H)) {
                            me = !0;
                            do
                                if (H = oe(H), H === W || (H++, !he)) break; while (ae(H))
                        } else H = Math.min(W, oe(H) + 1);
                        me && (re(pe, H, he), he = !0), U++, de = !0
                    } else {
                        for (me = te(pe = H + 1) === "/"; te(++H) !== `
`;)
                            if (H === W) return null;
                        ++H, me && (re(pe, H - 1, he), he = !0), ++U, de = !0
                    }
                else if ((fe = te(H)) === "*") {
                    pe = H + 1, me = C || te(pe) === "*";
                    do {
                        if (fe === `
` && ++U, ++H === W) throw ee("comment");
                        ve = fe, fe = te(H)
                    } while (ve !== "*" || fe !== "/");
                    ++H, me && (re(pe, H - 2, he), he = !0), de = !0
                } else return "/"
            }
        } while (de);
        var Se = H;
        delimRe.lastIndex = 0;
        var _e = delimRe.test(te(Se++));
        if (!_e)
            for (; Se < W && !delimRe.test(te(Se));) ++Se;
        var be = K.substring(H, H = Se);
        return (be === '"' || be === "'") && (Q = be), be
    }

    function ue(de) {
        Z.push(de)
    }

    function le() {
        if (!Z.length) {
            var de = ie();
            if (de === null) return null;
            ue(de)
        }
        return Z[0]
    }

    function se(de, ve) {
        var fe = le(),
            pe = fe === de;
        if (pe) return ie(), !0;
        if (!ve) throw ee("token '" + fe + "', '" + de + "' expected");
        return !1
    }

    function ce(de) {
        var ve = null,
            fe;
        return de === void 0 ? (fe = X[U - 1], delete X[U - 1], fe && (C || fe.type === "*" || fe.lineEmpty) && (ve =
            fe.leading ? fe.text : null)) : (G < de && le(), fe = X[de], delete X[de], fe && !fe.lineEmpty && (C ||
            fe.type === "/") && (ve = fe.leading ? null : fe.text)), ve
    }
    return Object.defineProperty({
        next: ie,
        peek: le,
        push: ue,
        skip: se,
        cmnt: ce
    }, "line", {
        get: function () {
            return U
        }
    })
}
var parse_1 = parse;
parse.filename = null;
parse.defaults = {
    keepCase: !1
};
var tokenize = tokenize_1,
    Root = requireRoot(),
    Type = requireType(),
    Field = requireField(),
    MapField = requireMapfield(),
    OneOf = requireOneof(),
    Enum = require_enum(),
    Service = requireService(),
    Method = requireMethod(),
    types = requireTypes(),
    util = requireUtil(),
    base10Re = /^[1-9][0-9]*$/,
    base10NegRe = /^-?[1-9][0-9]*$/,
    base16Re = /^0[x][0-9a-fA-F]+$/,
    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,
    base8Re = /^0[0-7]+$/,
    base8NegRe = /^-?0[0-7]+$/,
    numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
    nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
    typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,
    fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;

function parse(K, C, H) {
    C instanceof Root || (H = C, C = new Root), H || (H = parse.defaults);
    var W = H.preferTrailingComment || !1,
        U = tokenize(K, H.alternateCommentMode || !1),
        G = U.next,
        X = U.push,
        Z = U.peek,
        Q = U.skip,
        ee = U.cmnt,
        ne = !0,
        te, re, ae, oe, ie = !1,
        ue = C,
        le = H.keepCase ? function (je) {
            return je
        } : util.camelCase;

    function se(je, Fe, Le) {
        var Ie = parse.filename;
        return Le || (parse.filename = null), Error("illegal " + (Fe || "token") + " '" + je + "' (" + (Ie ? Ie + ", " :
            "") + "line " + U.line + ")")
    }

    function ce() {
        var je = [],
            Fe;
        do {
            if ((Fe = G()) !== '"' && Fe !== "'") throw se(Fe);
            je.push(G()), Q(Fe), Fe = Z()
        } while (Fe === '"' || Fe === "'");
        return je.join("")
    }

    function de(je) {
        var Fe = G();
        switch (Fe) {
            case "'":
            case '"':
                return X(Fe), ce();
            case "true":
            case "TRUE":
                return !0;
            case "false":
            case "FALSE":
                return !1
        }
        try {
            return fe(Fe, !0)
        } catch {
            if (je && typeRefRe.test(Fe)) return Fe;
            throw se(Fe, "value")
        }
    }

    function ve(je, Fe) {
        var Le, Ie;
        do Fe && ((Le = Z()) === '"' || Le === "'") ? je.push(ce()) : je.push([Ie = pe(G()), Q("to", !0) ? pe(G()) : Ie]); while (
            Q(",", !0));
        Q(";")
    }

    function fe(je, Fe) {
        var Le = 1;
        switch (je.charAt(0) === "-" && (Le = -1, je = je.substring(1)), je) {
            case "inf":
            case "INF":
            case "Inf":
                return Le * (1 / 0);
            case "nan":
            case "NAN":
            case "Nan":
            case "NaN":
                return NaN;
            case "0":
                return 0
        }
        if (base10Re.test(je)) return Le * parseInt(je, 10);
        if (base16Re.test(je)) return Le * parseInt(je, 16);
        if (base8Re.test(je)) return Le * parseInt(je, 8);
        if (numberRe.test(je)) return Le * parseFloat(je);
        throw se(je, "number", Fe)
    }

    function pe(je, Fe) {
        switch (je) {
            case "max":
            case "MAX":
            case "Max":
                return 536870911;
            case "0":
                return 0
        }
        if (!Fe && je.charAt(0) === "-") throw se(je, "id");
        if (base10NegRe.test(je)) return parseInt(je, 10);
        if (base16NegRe.test(je)) return parseInt(je, 16);
        if (base8NegRe.test(je)) return parseInt(je, 8);
        throw se(je, "id")
    }

    function me() {
        if (te !== void 0) throw se("package");
        if (te = G(), !typeRefRe.test(te)) throw se(te, "name");
        ue = ue.define(te), Q(";")
    }

    function he() {
        var je = Z(),
            Fe;
        switch (je) {
            case "weak":
                Fe = ae || (ae = []), G();
                break;
            case "public":
                G();
            default:
                Fe = re || (re = []);
                break
        }
        je = ce(), Q(";"), Fe.push(je)
    }

    function Se() {
        if (Q("="), oe = ce(), ie = oe === "proto3", !ie && oe !== "proto2") throw se(oe, "syntax");
        Q(";")
    }

    function _e(je, Fe) {
        switch (Fe) {
            case "option":
                return Oe(je, Fe), Q(";"), !0;
            case "message":
                return ge(je, Fe), !0;
            case "enum":
                return Ce(je, Fe), !0;
            case "service":
                return Ee(je, Fe), !0;
            case "extend":
                return Re(je, Fe), !0
        }
        return !1
    }

    function be(je, Fe, Le) {
        var Ie = U.line;
        if (je && (typeof je.comment != "string" && (je.comment = ee()), je.filename = parse.filename), Q("{", !0)) {
            for (var Te;
                (Te = G()) !== "}";) Fe(Te);
            Q(";", !0)
        } else Le && Le(), Q(";"), je && (typeof je.comment != "string" || W) && (je.comment = ee(Ie) || je.comment)
    }

    function ge(je, Fe) {
        if (!nameRe.test(Fe = G())) throw se(Fe, "type name");
        var Le = new Type(Fe);
        be(Le, function (Te) {
            if (!_e(Le, Te)) switch (Te) {
                case "map":
                    $e(Le);
                    break;
                case "required":
                case "repeated":
                    xe(Le, Te);
                    break;
                case "optional":
                    ie ? xe(Le, "proto3_optional") : xe(Le, "optional");
                    break;
                case "oneof":
                    ye(Le, Te);
                    break;
                case "extensions":
                    ve(Le.extensions || (Le.extensions = []));
                    break;
                case "reserved":
                    ve(Le.reserved || (Le.reserved = []), !0);
                    break;
                default:
                    if (!ie || !typeRefRe.test(Te)) throw se(Te);
                    X(Te), xe(Le, "optional");
                    break
            }
        }), je.add(Le)
    }

    function xe(je, Fe, Le) {
        var Ie = G();
        if (Ie === "group") {
            Pe(je, Fe);
            return
        }
        for (; Ie.endsWith(".") || Z().startsWith(".");) Ie += G();
        if (!typeRefRe.test(Ie)) throw se(Ie, "type");
        var Te = G();
        if (!nameRe.test(Te)) throw se(Te, "name");
        Te = le(Te), Q("=");
        var De = new Field(Te, pe(G()), Ie, Fe, Le);
        if (be(De, function (Ue) {
                if (Ue === "option") Oe(De, Ue), Q(";");
                else throw se(Ue)
            }, function () {
                ke(De)
            }), Fe === "proto3_optional") {
            var Ke = new OneOf("_" + Te);
            De.setOption("proto3_optional", !0), Ke.add(De), je.add(Ke)
        } else je.add(De);
        !ie && De.repeated && (types.packed[Ie] !== void 0 || types.basic[Ie] === void 0) && De.setOption("packed", !1,
            !0)
    }

    function Pe(je, Fe) {
        var Le = G();
        if (!nameRe.test(Le)) throw se(Le, "name");
        var Ie = util.lcFirst(Le);
        Le === Ie && (Le = util.ucFirst(Le)), Q("=");
        var Te = pe(G()),
            De = new Type(Le);
        De.group = !0;
        var Ke = new Field(Ie, Te, Le, Fe);
        Ke.filename = parse.filename, be(De, function (Ue) {
            switch (Ue) {
                case "option":
                    Oe(De, Ue), Q(";");
                    break;
                case "required":
                case "repeated":
                    xe(De, Ue);
                    break;
                case "optional":
                    ie ? xe(De, "proto3_optional") : xe(De, "optional");
                    break;
                case "message":
                    ge(De, Ue);
                    break;
                case "enum":
                    Ce(De, Ue);
                    break;
                default:
                    throw se(Ue)
            }
        }), je.add(De).add(Ke)
    }

    function $e(je) {
        Q("<");
        var Fe = G();
        if (types.mapKey[Fe] === void 0) throw se(Fe, "type");
        Q(",");
        var Le = G();
        if (!typeRefRe.test(Le)) throw se(Le, "type");
        Q(">");
        var Ie = G();
        if (!nameRe.test(Ie)) throw se(Ie, "name");
        Q("=");
        var Te = new MapField(le(Ie), pe(G()), Fe, Le);
        be(Te, function (Ke) {
            if (Ke === "option") Oe(Te, Ke), Q(";");
            else throw se(Ke)
        }, function () {
            ke(Te)
        }), je.add(Te)
    }

    function ye(je, Fe) {
        if (!nameRe.test(Fe = G())) throw se(Fe, "name");
        var Le = new OneOf(le(Fe));
        be(Le, function (Te) {
            Te === "option" ? (Oe(Le, Te), Q(";")) : (X(Te), xe(Le, "optional"))
        }), je.add(Le)
    }

    function Ce(je, Fe) {
        if (!nameRe.test(Fe = G())) throw se(Fe, "name");
        var Le = new Enum(Fe);
        be(Le, function (Te) {
            switch (Te) {
                case "option":
                    Oe(Le, Te), Q(";");
                    break;
                case "reserved":
                    ve(Le.reserved || (Le.reserved = []), !0);
                    break;
                default:
                    we(Le, Te)
            }
        }), je.add(Le)
    }

    function we(je, Fe) {
        if (!nameRe.test(Fe)) throw se(Fe, "name");
        Q("=");
        var Le = pe(G(), !0),
            Ie = {
                options: void 0
            };
        Ie.setOption = function (Te, De) {
            this.options === void 0 && (this.options = {}), this.options[Te] = De
        }, be(Ie, function (De) {
            if (De === "option") Oe(Ie, De), Q(";");
            else throw se(De)
        }, function () {
            ke(Ie)
        }), je.add(Fe, Le, Ie.comment, Ie.options)
    }

    function Oe(je, Fe) {
        var Le = Q("(", !0);
        if (!typeRefRe.test(Fe = G())) throw se(Fe, "name");
        var Ie = Fe,
            Te = Ie,
            De;
        Le && (Q(")"), Ie = "(" + Ie + ")", Te = Ie, Fe = Z(), fqTypeRefRe.test(Fe) && (De = Fe.slice(1), Ie += Fe, G())),
            Q("=");
        var Ke = Ne(je, Ie);
        Ve(je, Te, Ke, De)
    }

    function Ne(je, Fe) {
        if (Q("{", !0)) {
            for (var Le = {}; !Q("}", !0);) {
                if (!nameRe.test(He = G())) throw se(He, "name");
                var Ie, Te = He;
                if (Q(":", !0), Z() === "{") Ie = Ne(je, Fe + "." + He);
                else if (Z() === "[") {
                    Ie = [];
                    var De;
                    if (Q("[", !0)) {
                        do De = de(!0), Ie.push(De); while (Q(",", !0));
                        Q("]"), typeof De < "u" && Me(je, Fe + "." + He, De)
                    }
                } else Ie = de(!0), Me(je, Fe + "." + He, Ie);
                var Ke = Le[Te];
                Ke && (Ie = [].concat(Ke).concat(Ie)), Le[Te] = Ie, Q(",", !0), Q(";", !0)
            }
            return Le
        }
        var We = de(!0);
        return Me(je, Fe, We), We
    }

    function Me(je, Fe, Le) {
        je.setOption && je.setOption(Fe, Le)
    }

    function Ve(je, Fe, Le, Ie) {
        je.setParsedOption && je.setParsedOption(Fe, Le, Ie)
    }

    function ke(je) {
        if (Q("[", !0)) {
            do Oe(je, "option"); while (Q(",", !0));
            Q("]")
        }
        return je
    }

    function Ee(je, Fe) {
        if (!nameRe.test(Fe = G())) throw se(Fe, "service name");
        var Le = new Service(Fe);
        be(Le, function (Te) {
            if (!_e(Le, Te))
                if (Te === "rpc") Ae(Le, Te);
                else throw se(Te)
        }), je.add(Le)
    }

    function Ae(je, Fe) {
        var Le = ee(),
            Ie = Fe;
        if (!nameRe.test(Fe = G())) throw se(Fe, "name");
        var Te = Fe,
            De, Ke, We, Ue;
        if (Q("("), Q("stream", !0) && (Ke = !0), !typeRefRe.test(Fe = G()) || (De = Fe, Q(")"), Q("returns"), Q("("),
                Q("stream", !0) && (Ue = !0), !typeRefRe.test(Fe = G()))) throw se(Fe);
        We = Fe, Q(")");
        var et = new Method(Te, Ie, De, We, Ke, Ue);
        et.comment = Le, be(et, function (ze) {
            if (ze === "option") Oe(et, ze), Q(";");
            else throw se(ze)
        }), je.add(et)
    }

    function Re(je, Fe) {
        if (!typeRefRe.test(Fe = G())) throw se(Fe, "reference");
        var Le = Fe;
        be(null, function (Te) {
            switch (Te) {
                case "required":
                case "repeated":
                    xe(je, Te, Le);
                    break;
                case "optional":
                    ie ? xe(je, "proto3_optional", Le) : xe(je, "optional", Le);
                    break;
                default:
                    if (!ie || !typeRefRe.test(Te)) throw se(Te);
                    X(Te), xe(je, "optional", Le);
                    break
            }
        })
    }
    for (var He;
        (He = G()) !== null;) switch (He) {
        case "package":
            if (!ne) throw se(He);
            me();
            break;
        case "import":
            if (!ne) throw se(He);
            he();
            break;
        case "syntax":
            if (!ne) throw se(He);
            Se();
            break;
        case "option":
            Oe(ue, He), Q(";");
            break;
        default:
            if (_e(ue, He)) {
                ne = !1;
                continue
            }
            throw se(He)
    }
    return parse.filename = null, {
        package: te,
        imports: re,
        weakImports: ae,
        syntax: oe,
        root: C
    }
}
var common_1 = common,
    commonRe = /\/|\./;

function common(K, C) {
    commonRe.test(K) || (K = "google/protobuf/" + K + ".proto", C = {
        nested: {
            google: {
                nested: {
                    protobuf: {
                        nested: C
                    }
                }
            }
        }
    }), common[K] = C
}
common("any", {
    Any: {
        fields: {
            type_url: {
                type: "string",
                id: 1
            },
            value: {
                type: "bytes",
                id: 2
            }
        }
    }
});
var timeType;
common("duration", {
    Duration: timeType = {
        fields: {
            seconds: {
                type: "int64",
                id: 1
            },
            nanos: {
                type: "int32",
                id: 2
            }
        }
    }
});
common("timestamp", {
    Timestamp: timeType
});
common("empty", {
    Empty: {
        fields: {}
    }
});
common("struct", {
    Struct: {
        fields: {
            fields: {
                keyType: "string",
                type: "Value",
                id: 1
            }
        }
    },
    Value: {
        oneofs: {
            kind: {
                oneof: ["nullValue", "numberValue", "stringValue", "boolValue", "structValue", "listValue"]
            }
        },
        fields: {
            nullValue: {
                type: "NullValue",
                id: 1
            },
            numberValue: {
                type: "double",
                id: 2
            },
            stringValue: {
                type: "string",
                id: 3
            },
            boolValue: {
                type: "bool",
                id: 4
            },
            structValue: {
                type: "Struct",
                id: 5
            },
            listValue: {
                type: "ListValue",
                id: 6
            }
        }
    },
    NullValue: {
        values: {
            NULL_VALUE: 0
        }
    },
    ListValue: {
        fields: {
            values: {
                rule: "repeated",
                type: "Value",
                id: 1
            }
        }
    }
});
common("wrappers", {
    DoubleValue: {
        fields: {
            value: {
                type: "double",
                id: 1
            }
        }
    },
    FloatValue: {
        fields: {
            value: {
                type: "float",
                id: 1
            }
        }
    },
    Int64Value: {
        fields: {
            value: {
                type: "int64",
                id: 1
            }
        }
    },
    UInt64Value: {
        fields: {
            value: {
                type: "uint64",
                id: 1
            }
        }
    },
    Int32Value: {
        fields: {
            value: {
                type: "int32",
                id: 1
            }
        }
    },
    UInt32Value: {
        fields: {
            value: {
                type: "uint32",
                id: 1
            }
        }
    },
    BoolValue: {
        fields: {
            value: {
                type: "bool",
                id: 1
            }
        }
    },
    StringValue: {
        fields: {
            value: {
                type: "string",
                id: 1
            }
        }
    },
    BytesValue: {
        fields: {
            value: {
                type: "bytes",
                id: 1
            }
        }
    }
});
common("field_mask", {
    FieldMask: {
        fields: {
            paths: {
                rule: "repeated",
                type: "string",
                id: 1
            }
        }
    }
});
common.get = function K(C) {
    return common[C] || null
};
(function (K) {
    var C = K.exports = indexLightExports;
    C.build = "full", C.tokenize = tokenize_1, C.parse = parse_1, C.common = common_1, C.Root._configure(C.Type, C.parse,
        C.common)
})(src);
(function (K) {
    K.exports = srcExports
})(protobufjs);
const protobuf = getDefaultExportFromCjs(protobufjsExports),
    antd = "";
// export {
//     withDirectives as A, vShow as B, resolveDynamicComponent as C, EditOutlined$1 as D, Empty$1 as E, Fragment as F,
//     DeleteOutlined$1 as G, DownOutlined$1 as H, isRef as I, hooks as J, InfoCircleOutlined$1 as K, Long as L,
//     minimalExports as M, protobuf as N, onUnmounted as O, PlusOutlined$1 as P, QuestionCircleOutlined$1 as Q, createApp as R,
//     Antd as S, toRaw as T, Upload as U, reactive as a, resolveComponent as b, openBlock as c, createElementBlock as d,
//     createVNode as e, withCtx as f, renderList as g, createBaseVNode as h, normalizeStyle as i, createTextVNode as j,
//     createCommentVNode as k, normalizeClass as l, popScopeId as m, nextTick as n, onMounted as o, pushScopeId as p,
//     message$1 as q, ref as r, computed as s, toDisplayString as t, unref as u, v4 as v, watch as w, shallowReactive as x,
//     markRaw as y, createBlock as z
// };

module.exports = {
  M:minimalExports
};